var Y3 = Object.defineProperty;
var X3 = (s, e, t) => e in s ? Y3(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var rt = (s, e, t) => X3(s, typeof e != "symbol" ? e + "" : e, t);
function Q3(s) {
  return new Worker(
    "/assets/editor.worker-BKD3YLiN.js",
    {
      name: s == null ? void 0 : s.name
    }
  );
}
function WP() {
  return globalThis._VSCODE_NLS_MESSAGES;
}
function eE() {
  return globalThis._VSCODE_NLS_LANGUAGE;
}
const J3 = eE() === "pseudo" || typeof document < "u" && document.location && document.location.hash.indexOf("pseudo=true") >= 0;
function Tb(s, e) {
  let t;
  return e.length === 0 ? t = s : t = s.replace(/\{(\d+)\}/g, (i, n) => {
    const o = n[0], r = e[o];
    let a = i;
    return typeof r == "string" ? a = r : (typeof r == "number" || typeof r == "boolean" || r === void 0 || r === null) && (a = String(r)), a;
  }), J3 && (t = "［" + t.replace(/[aouei]/g, "$&$&") + "］"), t;
}
function m(s, e, ...t) {
  return Tb(typeof s == "number" ? HP(s, e) : e, t);
}
function HP(s, e) {
  var i;
  const t = (i = WP()) == null ? void 0 : i[s];
  if (typeof t != "string") {
    if (typeof e == "string")
      return e;
    throw new Error(`!!! NLS MISSING: ${s} !!!`);
  }
  return t;
}
function oi(s, e, ...t) {
  let i;
  typeof s == "number" ? i = HP(s, e) : i = e;
  const n = Tb(i, t);
  return {
    value: n,
    original: e === i ? n : Tb(e, t)
  };
}
const VP = "editor.action.showHover", e9 = "editor.action.showDefinitionPreviewHover", t9 = "editor.action.scrollUpHover", i9 = "editor.action.scrollDownHover", n9 = "editor.action.scrollLeftHover", s9 = "editor.action.scrollRightHover", o9 = "editor.action.pageUpHover", r9 = "editor.action.pageDownHover", a9 = "editor.action.goToTopHover", l9 = "editor.action.goToBottomHover", Fv = "editor.action.increaseHoverVerbosityLevel", c9 = m({ key: "increaseHoverVerbosityLevel", comment: ["Label for action that will increase the hover verbosity level."] }, "Increase Hover Verbosity Level"), Bv = "editor.action.decreaseHoverVerbosityLevel", h9 = m({ key: "decreaseHoverVerbosityLevel", comment: ["Label for action that will decrease the hover verbosity level."] }, "Decrease Hover Verbosity Level");
class tE {
  constructor() {
    this._keyCodeToStr = [], this._strToKeyCode = /* @__PURE__ */ Object.create(null);
  }
  define(e, t) {
    this._keyCodeToStr[e] = t, this._strToKeyCode[t.toLowerCase()] = e;
  }
  keyCodeToStr(e) {
    return this._keyCodeToStr[e];
  }
  strToKeyCode(e) {
    return this._strToKeyCode[e.toLowerCase()] || 0;
  }
}
const X_ = new tE(), Ty = new tE(), My = new tE(), zP = new Array(230), d9 = /* @__PURE__ */ Object.create(null), u9 = /* @__PURE__ */ Object.create(null), iE = [];
for (let s = 0; s <= 193; s++)
  iE[s] = -1;
(function() {
  const s = "", e = [
    // immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel
    [1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", s, s],
    [1, 1, "Hyper", 0, s, 0, s, s, s],
    [1, 2, "Super", 0, s, 0, s, s, s],
    [1, 3, "Fn", 0, s, 0, s, s, s],
    [1, 4, "FnLock", 0, s, 0, s, s, s],
    [1, 5, "Suspend", 0, s, 0, s, s, s],
    [1, 6, "Resume", 0, s, 0, s, s, s],
    [1, 7, "Turbo", 0, s, 0, s, s, s],
    [1, 8, "Sleep", 0, s, 0, "VK_SLEEP", s, s],
    [1, 9, "WakeUp", 0, s, 0, s, s, s],
    [0, 10, "KeyA", 31, "A", 65, "VK_A", s, s],
    [0, 11, "KeyB", 32, "B", 66, "VK_B", s, s],
    [0, 12, "KeyC", 33, "C", 67, "VK_C", s, s],
    [0, 13, "KeyD", 34, "D", 68, "VK_D", s, s],
    [0, 14, "KeyE", 35, "E", 69, "VK_E", s, s],
    [0, 15, "KeyF", 36, "F", 70, "VK_F", s, s],
    [0, 16, "KeyG", 37, "G", 71, "VK_G", s, s],
    [0, 17, "KeyH", 38, "H", 72, "VK_H", s, s],
    [0, 18, "KeyI", 39, "I", 73, "VK_I", s, s],
    [0, 19, "KeyJ", 40, "J", 74, "VK_J", s, s],
    [0, 20, "KeyK", 41, "K", 75, "VK_K", s, s],
    [0, 21, "KeyL", 42, "L", 76, "VK_L", s, s],
    [0, 22, "KeyM", 43, "M", 77, "VK_M", s, s],
    [0, 23, "KeyN", 44, "N", 78, "VK_N", s, s],
    [0, 24, "KeyO", 45, "O", 79, "VK_O", s, s],
    [0, 25, "KeyP", 46, "P", 80, "VK_P", s, s],
    [0, 26, "KeyQ", 47, "Q", 81, "VK_Q", s, s],
    [0, 27, "KeyR", 48, "R", 82, "VK_R", s, s],
    [0, 28, "KeyS", 49, "S", 83, "VK_S", s, s],
    [0, 29, "KeyT", 50, "T", 84, "VK_T", s, s],
    [0, 30, "KeyU", 51, "U", 85, "VK_U", s, s],
    [0, 31, "KeyV", 52, "V", 86, "VK_V", s, s],
    [0, 32, "KeyW", 53, "W", 87, "VK_W", s, s],
    [0, 33, "KeyX", 54, "X", 88, "VK_X", s, s],
    [0, 34, "KeyY", 55, "Y", 89, "VK_Y", s, s],
    [0, 35, "KeyZ", 56, "Z", 90, "VK_Z", s, s],
    [0, 36, "Digit1", 22, "1", 49, "VK_1", s, s],
    [0, 37, "Digit2", 23, "2", 50, "VK_2", s, s],
    [0, 38, "Digit3", 24, "3", 51, "VK_3", s, s],
    [0, 39, "Digit4", 25, "4", 52, "VK_4", s, s],
    [0, 40, "Digit5", 26, "5", 53, "VK_5", s, s],
    [0, 41, "Digit6", 27, "6", 54, "VK_6", s, s],
    [0, 42, "Digit7", 28, "7", 55, "VK_7", s, s],
    [0, 43, "Digit8", 29, "8", 56, "VK_8", s, s],
    [0, 44, "Digit9", 30, "9", 57, "VK_9", s, s],
    [0, 45, "Digit0", 21, "0", 48, "VK_0", s, s],
    [1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", s, s],
    [1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", s, s],
    [1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", s, s],
    [1, 49, "Tab", 2, "Tab", 9, "VK_TAB", s, s],
    [1, 50, "Space", 10, "Space", 32, "VK_SPACE", s, s],
    [0, 51, "Minus", 88, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
    [0, 52, "Equal", 86, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
    [0, 53, "BracketLeft", 92, "[", 219, "VK_OEM_4", "[", "OEM_4"],
    [0, 54, "BracketRight", 94, "]", 221, "VK_OEM_6", "]", "OEM_6"],
    [0, 55, "Backslash", 93, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
    [0, 56, "IntlHash", 0, s, 0, s, s, s],
    // has been dropped from the w3c spec
    [0, 57, "Semicolon", 85, ";", 186, "VK_OEM_1", ";", "OEM_1"],
    [0, 58, "Quote", 95, "'", 222, "VK_OEM_7", "'", "OEM_7"],
    [0, 59, "Backquote", 91, "`", 192, "VK_OEM_3", "`", "OEM_3"],
    [0, 60, "Comma", 87, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
    [0, 61, "Period", 89, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
    [0, 62, "Slash", 90, "/", 191, "VK_OEM_2", "/", "OEM_2"],
    [1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", s, s],
    [1, 64, "F1", 59, "F1", 112, "VK_F1", s, s],
    [1, 65, "F2", 60, "F2", 113, "VK_F2", s, s],
    [1, 66, "F3", 61, "F3", 114, "VK_F3", s, s],
    [1, 67, "F4", 62, "F4", 115, "VK_F4", s, s],
    [1, 68, "F5", 63, "F5", 116, "VK_F5", s, s],
    [1, 69, "F6", 64, "F6", 117, "VK_F6", s, s],
    [1, 70, "F7", 65, "F7", 118, "VK_F7", s, s],
    [1, 71, "F8", 66, "F8", 119, "VK_F8", s, s],
    [1, 72, "F9", 67, "F9", 120, "VK_F9", s, s],
    [1, 73, "F10", 68, "F10", 121, "VK_F10", s, s],
    [1, 74, "F11", 69, "F11", 122, "VK_F11", s, s],
    [1, 75, "F12", 70, "F12", 123, "VK_F12", s, s],
    [1, 76, "PrintScreen", 0, s, 0, s, s, s],
    [1, 77, "ScrollLock", 84, "ScrollLock", 145, "VK_SCROLL", s, s],
    [1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", s, s],
    [1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", s, s],
    [1, 80, "Home", 14, "Home", 36, "VK_HOME", s, s],
    [1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", s, s],
    [1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", s, s],
    [1, 83, "End", 13, "End", 35, "VK_END", s, s],
    [1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", s, s],
    [1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", s],
    [1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", s],
    [1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", s],
    [1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", s],
    [1, 89, "NumLock", 83, "NumLock", 144, "VK_NUMLOCK", s, s],
    [1, 90, "NumpadDivide", 113, "NumPad_Divide", 111, "VK_DIVIDE", s, s],
    [1, 91, "NumpadMultiply", 108, "NumPad_Multiply", 106, "VK_MULTIPLY", s, s],
    [1, 92, "NumpadSubtract", 111, "NumPad_Subtract", 109, "VK_SUBTRACT", s, s],
    [1, 93, "NumpadAdd", 109, "NumPad_Add", 107, "VK_ADD", s, s],
    [1, 94, "NumpadEnter", 3, s, 0, s, s, s],
    [1, 95, "Numpad1", 99, "NumPad1", 97, "VK_NUMPAD1", s, s],
    [1, 96, "Numpad2", 100, "NumPad2", 98, "VK_NUMPAD2", s, s],
    [1, 97, "Numpad3", 101, "NumPad3", 99, "VK_NUMPAD3", s, s],
    [1, 98, "Numpad4", 102, "NumPad4", 100, "VK_NUMPAD4", s, s],
    [1, 99, "Numpad5", 103, "NumPad5", 101, "VK_NUMPAD5", s, s],
    [1, 100, "Numpad6", 104, "NumPad6", 102, "VK_NUMPAD6", s, s],
    [1, 101, "Numpad7", 105, "NumPad7", 103, "VK_NUMPAD7", s, s],
    [1, 102, "Numpad8", 106, "NumPad8", 104, "VK_NUMPAD8", s, s],
    [1, 103, "Numpad9", 107, "NumPad9", 105, "VK_NUMPAD9", s, s],
    [1, 104, "Numpad0", 98, "NumPad0", 96, "VK_NUMPAD0", s, s],
    [1, 105, "NumpadDecimal", 112, "NumPad_Decimal", 110, "VK_DECIMAL", s, s],
    [0, 106, "IntlBackslash", 97, "OEM_102", 226, "VK_OEM_102", s, s],
    [1, 107, "ContextMenu", 58, "ContextMenu", 93, s, s, s],
    [1, 108, "Power", 0, s, 0, s, s, s],
    [1, 109, "NumpadEqual", 0, s, 0, s, s, s],
    [1, 110, "F13", 71, "F13", 124, "VK_F13", s, s],
    [1, 111, "F14", 72, "F14", 125, "VK_F14", s, s],
    [1, 112, "F15", 73, "F15", 126, "VK_F15", s, s],
    [1, 113, "F16", 74, "F16", 127, "VK_F16", s, s],
    [1, 114, "F17", 75, "F17", 128, "VK_F17", s, s],
    [1, 115, "F18", 76, "F18", 129, "VK_F18", s, s],
    [1, 116, "F19", 77, "F19", 130, "VK_F19", s, s],
    [1, 117, "F20", 78, "F20", 131, "VK_F20", s, s],
    [1, 118, "F21", 79, "F21", 132, "VK_F21", s, s],
    [1, 119, "F22", 80, "F22", 133, "VK_F22", s, s],
    [1, 120, "F23", 81, "F23", 134, "VK_F23", s, s],
    [1, 121, "F24", 82, "F24", 135, "VK_F24", s, s],
    [1, 122, "Open", 0, s, 0, s, s, s],
    [1, 123, "Help", 0, s, 0, s, s, s],
    [1, 124, "Select", 0, s, 0, s, s, s],
    [1, 125, "Again", 0, s, 0, s, s, s],
    [1, 126, "Undo", 0, s, 0, s, s, s],
    [1, 127, "Cut", 0, s, 0, s, s, s],
    [1, 128, "Copy", 0, s, 0, s, s, s],
    [1, 129, "Paste", 0, s, 0, s, s, s],
    [1, 130, "Find", 0, s, 0, s, s, s],
    [1, 131, "AudioVolumeMute", 117, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", s, s],
    [1, 132, "AudioVolumeUp", 118, "AudioVolumeUp", 175, "VK_VOLUME_UP", s, s],
    [1, 133, "AudioVolumeDown", 119, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", s, s],
    [1, 134, "NumpadComma", 110, "NumPad_Separator", 108, "VK_SEPARATOR", s, s],
    [0, 135, "IntlRo", 115, "ABNT_C1", 193, "VK_ABNT_C1", s, s],
    [1, 136, "KanaMode", 0, s, 0, s, s, s],
    [0, 137, "IntlYen", 0, s, 0, s, s, s],
    [1, 138, "Convert", 0, s, 0, s, s, s],
    [1, 139, "NonConvert", 0, s, 0, s, s, s],
    [1, 140, "Lang1", 0, s, 0, s, s, s],
    [1, 141, "Lang2", 0, s, 0, s, s, s],
    [1, 142, "Lang3", 0, s, 0, s, s, s],
    [1, 143, "Lang4", 0, s, 0, s, s, s],
    [1, 144, "Lang5", 0, s, 0, s, s, s],
    [1, 145, "Abort", 0, s, 0, s, s, s],
    [1, 146, "Props", 0, s, 0, s, s, s],
    [1, 147, "NumpadParenLeft", 0, s, 0, s, s, s],
    [1, 148, "NumpadParenRight", 0, s, 0, s, s, s],
    [1, 149, "NumpadBackspace", 0, s, 0, s, s, s],
    [1, 150, "NumpadMemoryStore", 0, s, 0, s, s, s],
    [1, 151, "NumpadMemoryRecall", 0, s, 0, s, s, s],
    [1, 152, "NumpadMemoryClear", 0, s, 0, s, s, s],
    [1, 153, "NumpadMemoryAdd", 0, s, 0, s, s, s],
    [1, 154, "NumpadMemorySubtract", 0, s, 0, s, s, s],
    [1, 155, "NumpadClear", 131, "Clear", 12, "VK_CLEAR", s, s],
    [1, 156, "NumpadClearEntry", 0, s, 0, s, s, s],
    [1, 0, s, 5, "Ctrl", 17, "VK_CONTROL", s, s],
    [1, 0, s, 4, "Shift", 16, "VK_SHIFT", s, s],
    [1, 0, s, 6, "Alt", 18, "VK_MENU", s, s],
    [1, 0, s, 57, "Meta", 91, "VK_COMMAND", s, s],
    [1, 157, "ControlLeft", 5, s, 0, "VK_LCONTROL", s, s],
    [1, 158, "ShiftLeft", 4, s, 0, "VK_LSHIFT", s, s],
    [1, 159, "AltLeft", 6, s, 0, "VK_LMENU", s, s],
    [1, 160, "MetaLeft", 57, s, 0, "VK_LWIN", s, s],
    [1, 161, "ControlRight", 5, s, 0, "VK_RCONTROL", s, s],
    [1, 162, "ShiftRight", 4, s, 0, "VK_RSHIFT", s, s],
    [1, 163, "AltRight", 6, s, 0, "VK_RMENU", s, s],
    [1, 164, "MetaRight", 57, s, 0, "VK_RWIN", s, s],
    [1, 165, "BrightnessUp", 0, s, 0, s, s, s],
    [1, 166, "BrightnessDown", 0, s, 0, s, s, s],
    [1, 167, "MediaPlay", 0, s, 0, s, s, s],
    [1, 168, "MediaRecord", 0, s, 0, s, s, s],
    [1, 169, "MediaFastForward", 0, s, 0, s, s, s],
    [1, 170, "MediaRewind", 0, s, 0, s, s, s],
    [1, 171, "MediaTrackNext", 124, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", s, s],
    [1, 172, "MediaTrackPrevious", 125, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", s, s],
    [1, 173, "MediaStop", 126, "MediaStop", 178, "VK_MEDIA_STOP", s, s],
    [1, 174, "Eject", 0, s, 0, s, s, s],
    [1, 175, "MediaPlayPause", 127, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", s, s],
    [1, 176, "MediaSelect", 128, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", s, s],
    [1, 177, "LaunchMail", 129, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", s, s],
    [1, 178, "LaunchApp2", 130, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", s, s],
    [1, 179, "LaunchApp1", 0, s, 0, "VK_MEDIA_LAUNCH_APP1", s, s],
    [1, 180, "SelectTask", 0, s, 0, s, s, s],
    [1, 181, "LaunchScreenSaver", 0, s, 0, s, s, s],
    [1, 182, "BrowserSearch", 120, "BrowserSearch", 170, "VK_BROWSER_SEARCH", s, s],
    [1, 183, "BrowserHome", 121, "BrowserHome", 172, "VK_BROWSER_HOME", s, s],
    [1, 184, "BrowserBack", 122, "BrowserBack", 166, "VK_BROWSER_BACK", s, s],
    [1, 185, "BrowserForward", 123, "BrowserForward", 167, "VK_BROWSER_FORWARD", s, s],
    [1, 186, "BrowserStop", 0, s, 0, "VK_BROWSER_STOP", s, s],
    [1, 187, "BrowserRefresh", 0, s, 0, "VK_BROWSER_REFRESH", s, s],
    [1, 188, "BrowserFavorites", 0, s, 0, "VK_BROWSER_FAVORITES", s, s],
    [1, 189, "ZoomToggle", 0, s, 0, s, s, s],
    [1, 190, "MailReply", 0, s, 0, s, s, s],
    [1, 191, "MailForward", 0, s, 0, s, s, s],
    [1, 192, "MailSend", 0, s, 0, s, s, s],
    // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
    // If an Input Method Editor is processing key input and the event is keydown, return 229.
    [1, 0, s, 114, "KeyInComposition", 229, s, s, s],
    [1, 0, s, 116, "ABNT_C2", 194, "VK_ABNT_C2", s, s],
    [1, 0, s, 96, "OEM_8", 223, "VK_OEM_8", s, s],
    [1, 0, s, 0, s, 0, "VK_KANA", s, s],
    [1, 0, s, 0, s, 0, "VK_HANGUL", s, s],
    [1, 0, s, 0, s, 0, "VK_JUNJA", s, s],
    [1, 0, s, 0, s, 0, "VK_FINAL", s, s],
    [1, 0, s, 0, s, 0, "VK_HANJA", s, s],
    [1, 0, s, 0, s, 0, "VK_KANJI", s, s],
    [1, 0, s, 0, s, 0, "VK_CONVERT", s, s],
    [1, 0, s, 0, s, 0, "VK_NONCONVERT", s, s],
    [1, 0, s, 0, s, 0, "VK_ACCEPT", s, s],
    [1, 0, s, 0, s, 0, "VK_MODECHANGE", s, s],
    [1, 0, s, 0, s, 0, "VK_SELECT", s, s],
    [1, 0, s, 0, s, 0, "VK_PRINT", s, s],
    [1, 0, s, 0, s, 0, "VK_EXECUTE", s, s],
    [1, 0, s, 0, s, 0, "VK_SNAPSHOT", s, s],
    [1, 0, s, 0, s, 0, "VK_HELP", s, s],
    [1, 0, s, 0, s, 0, "VK_APPS", s, s],
    [1, 0, s, 0, s, 0, "VK_PROCESSKEY", s, s],
    [1, 0, s, 0, s, 0, "VK_PACKET", s, s],
    [1, 0, s, 0, s, 0, "VK_DBE_SBCSCHAR", s, s],
    [1, 0, s, 0, s, 0, "VK_DBE_DBCSCHAR", s, s],
    [1, 0, s, 0, s, 0, "VK_ATTN", s, s],
    [1, 0, s, 0, s, 0, "VK_CRSEL", s, s],
    [1, 0, s, 0, s, 0, "VK_EXSEL", s, s],
    [1, 0, s, 0, s, 0, "VK_EREOF", s, s],
    [1, 0, s, 0, s, 0, "VK_PLAY", s, s],
    [1, 0, s, 0, s, 0, "VK_ZOOM", s, s],
    [1, 0, s, 0, s, 0, "VK_NONAME", s, s],
    [1, 0, s, 0, s, 0, "VK_PA1", s, s],
    [1, 0, s, 0, s, 0, "VK_OEM_CLEAR", s, s]
  ], t = [], i = [];
  for (const n of e) {
    const [o, r, a, l, c, h, d, u, f] = n;
    if (i[r] || (i[r] = !0, d9[a] = r, u9[a.toLowerCase()] = r, o && (iE[r] = l)), !t[l]) {
      if (t[l] = !0, !c)
        throw new Error(`String representation missing for key code ${l} around scan code ${a}`);
      X_.define(l, c), Ty.define(l, u || c), My.define(l, f || u || c);
    }
    h && (zP[h] = l);
  }
})();
var Ca;
(function(s) {
  function e(a) {
    return X_.keyCodeToStr(a);
  }
  s.toString = e;
  function t(a) {
    return X_.strToKeyCode(a);
  }
  s.fromString = t;
  function i(a) {
    return Ty.keyCodeToStr(a);
  }
  s.toUserSettingsUS = i;
  function n(a) {
    return My.keyCodeToStr(a);
  }
  s.toUserSettingsGeneral = n;
  function o(a) {
    return Ty.strToKeyCode(a) || My.strToKeyCode(a);
  }
  s.fromUserSettings = o;
  function r(a) {
    if (a >= 98 && a <= 113)
      return null;
    switch (a) {
      case 16:
        return "Up";
      case 18:
        return "Down";
      case 15:
        return "Left";
      case 17:
        return "Right";
    }
    return X_.keyCodeToStr(a);
  }
  s.toElectronAccelerator = r;
})(Ca || (Ca = {}));
function ym(s, e) {
  const t = (e & 65535) << 16 >>> 0;
  return (s | t) >>> 0;
}
const qd = "en";
let Mb = !1, Rb = !1, Q_ = !1, UP = !1, nE = !1, sE = !1, $P = !1, t_, e0 = qd, o2 = qd, f9, xo;
const Oa = globalThis;
let fn;
var PP;
typeof Oa.vscode < "u" && typeof Oa.vscode.process < "u" ? fn = Oa.vscode.process : typeof process < "u" && typeof ((PP = process == null ? void 0 : process.versions) == null ? void 0 : PP.node) == "string" && (fn = process);
var OP;
const g9 = typeof ((OP = fn == null ? void 0 : fn.versions) == null ? void 0 : OP.electron) == "string", m9 = g9 && (fn == null ? void 0 : fn.type) === "renderer";
var FP;
if (typeof fn == "object") {
  Mb = fn.platform === "win32", Rb = fn.platform === "darwin", Q_ = fn.platform === "linux", Q_ && fn.env.SNAP && fn.env.SNAP_REVISION, fn.env.CI || fn.env.BUILD_ARTIFACTSTAGINGDIRECTORY, t_ = qd, e0 = qd;
  const s = fn.env.VSCODE_NLS_CONFIG;
  if (s)
    try {
      const e = JSON.parse(s);
      t_ = e.userLocale, o2 = e.osLocale, e0 = e.resolvedLanguage || qd, f9 = (FP = e.languagePack) == null ? void 0 : FP.translationsConfigFile;
    } catch {
    }
  UP = !0;
} else typeof navigator == "object" && !m9 ? (xo = navigator.userAgent, Mb = xo.indexOf("Windows") >= 0, Rb = xo.indexOf("Macintosh") >= 0, sE = (xo.indexOf("Macintosh") >= 0 || xo.indexOf("iPad") >= 0 || xo.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0, Q_ = xo.indexOf("Linux") >= 0, $P = (xo == null ? void 0 : xo.indexOf("Mobi")) >= 0, nE = !0, e0 = eE() || qd, t_ = navigator.language.toLowerCase(), o2 = t_) : console.error("Unable to resolve platform.");
const es = Mb, $e = Rb, Rn = Q_, Ab = UP, Ef = nE, p9 = nE && typeof Oa.importScripts == "function", _9 = p9 ? Oa.origin : void 0, Kl = sE, KP = $P, Or = xo, b9 = typeof Oa.postMessage == "function" && !Oa.importScripts, jP = (() => {
  if (b9) {
    const s = [];
    Oa.addEventListener("message", (t) => {
      if (t.data && t.data.vscodeScheduleAsyncWork)
        for (let i = 0, n = s.length; i < n; i++) {
          const o = s[i];
          if (o.id === t.data.vscodeScheduleAsyncWork) {
            s.splice(i, 1), o.callback();
            return;
          }
        }
    });
    let e = 0;
    return (t) => {
      const i = ++e;
      s.push({
        id: i,
        callback: t
      }), Oa.postMessage({ vscodeScheduleAsyncWork: i }, "*");
    };
  }
  return (s) => setTimeout(s);
})(), bs = Rb || sE ? 2 : Mb ? 1 : 3;
let r2 = !0, a2 = !1;
function C9() {
  if (!a2) {
    a2 = !0;
    const s = new Uint8Array(2);
    s[0] = 1, s[1] = 2, r2 = new Uint16Array(s.buffer)[0] === 513;
  }
  return r2;
}
const qP = !!(Or && Or.indexOf("Chrome") >= 0), v9 = !!(Or && Or.indexOf("Firefox") >= 0), w9 = !!(!qP && Or && Or.indexOf("Safari") >= 0), y9 = !!(Or && Or.indexOf("Edg/") >= 0), S9 = !!(Or && Or.indexOf("Android") >= 0);
let Eu;
const t0 = globalThis.vscode;
var BP;
if (typeof t0 < "u" && typeof t0.process < "u") {
  const s = t0.process;
  Eu = {
    get platform() {
      return s.platform;
    },
    get arch() {
      return s.arch;
    },
    get env() {
      return s.env;
    },
    cwd() {
      return s.cwd();
    }
  };
} else typeof process < "u" && typeof ((BP = process == null ? void 0 : process.versions) == null ? void 0 : BP.node) == "string" ? Eu = {
  get platform() {
    return process.platform;
  },
  get arch() {
    return process.arch;
  },
  get env() {
    return process.env;
  },
  cwd() {
    return process.env.VSCODE_CWD || process.cwd();
  }
} : Eu = {
  // Supported
  get platform() {
    return es ? "win32" : $e ? "darwin" : "linux";
  },
  get arch() {
  },
  // Unsupported
  get env() {
    return {};
  },
  cwd() {
    return "/";
  }
};
const Pb = Eu.cwd, Ry = Eu.env, L9 = Eu.platform, k9 = 65, x9 = 97, D9 = 90, E9 = 122, Nl = 46, en = 47, hs = 92, sl = 58, I9 = 63;
class GP extends Error {
  constructor(e, t, i) {
    let n;
    typeof t == "string" && t.indexOf("not ") === 0 ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
    const o = e.indexOf(".") !== -1 ? "property" : "argument";
    let r = `The "${e}" ${o} ${n} of type ${t}`;
    r += `. Received type ${typeof i}`, super(r), this.code = "ERR_INVALID_ARG_TYPE";
  }
}
function N9(s, e) {
  if (s === null || typeof s != "object")
    throw new GP(e, "Object", s);
}
function wi(s, e) {
  if (typeof s != "string")
    throw new GP(e, "string", s);
}
const qa = L9 === "win32";
function lt(s) {
  return s === en || s === hs;
}
function Ay(s) {
  return s === en;
}
function ol(s) {
  return s >= k9 && s <= D9 || s >= x9 && s <= E9;
}
function Ob(s, e, t, i) {
  let n = "", o = 0, r = -1, a = 0, l = 0;
  for (let c = 0; c <= s.length; ++c) {
    if (c < s.length)
      l = s.charCodeAt(c);
    else {
      if (i(l))
        break;
      l = en;
    }
    if (i(l)) {
      if (!(r === c - 1 || a === 1)) if (a === 2) {
        if (n.length < 2 || o !== 2 || n.charCodeAt(n.length - 1) !== Nl || n.charCodeAt(n.length - 2) !== Nl) {
          if (n.length > 2) {
            const h = n.lastIndexOf(t);
            h === -1 ? (n = "", o = 0) : (n = n.slice(0, h), o = n.length - 1 - n.lastIndexOf(t)), r = c, a = 0;
            continue;
          } else if (n.length !== 0) {
            n = "", o = 0, r = c, a = 0;
            continue;
          }
        }
        e && (n += n.length > 0 ? `${t}..` : "..", o = 2);
      } else
        n.length > 0 ? n += `${t}${s.slice(r + 1, c)}` : n = s.slice(r + 1, c), o = c - r - 1;
      r = c, a = 0;
    } else l === Nl && a !== -1 ? ++a : a = -1;
  }
  return n;
}
function T9(s) {
  return s ? `${s[0] === "." ? "" : "."}${s}` : "";
}
function ZP(s, e) {
  N9(e, "pathObject");
  const t = e.dir || e.root, i = e.base || `${e.name || ""}${T9(e.ext)}`;
  return t ? t === e.root ? `${t}${i}` : `${t}${s}${i}` : i;
}
const Nn = {
  // path.resolve([from ...], to)
  resolve(...s) {
    let e = "", t = "", i = !1;
    for (let n = s.length - 1; n >= -1; n--) {
      let o;
      if (n >= 0) {
        if (o = s[n], wi(o, `paths[${n}]`), o.length === 0)
          continue;
      } else e.length === 0 ? o = Pb() : (o = Ry[`=${e}`] || Pb(), (o === void 0 || o.slice(0, 2).toLowerCase() !== e.toLowerCase() && o.charCodeAt(2) === hs) && (o = `${e}\\`));
      const r = o.length;
      let a = 0, l = "", c = !1;
      const h = o.charCodeAt(0);
      if (r === 1)
        lt(h) && (a = 1, c = !0);
      else if (lt(h))
        if (c = !0, lt(o.charCodeAt(1))) {
          let d = 2, u = d;
          for (; d < r && !lt(o.charCodeAt(d)); )
            d++;
          if (d < r && d !== u) {
            const f = o.slice(u, d);
            for (u = d; d < r && lt(o.charCodeAt(d)); )
              d++;
            if (d < r && d !== u) {
              for (u = d; d < r && !lt(o.charCodeAt(d)); )
                d++;
              (d === r || d !== u) && (l = `\\\\${f}\\${o.slice(u, d)}`, a = d);
            }
          }
        } else
          a = 1;
      else ol(h) && o.charCodeAt(1) === sl && (l = o.slice(0, 2), a = 2, r > 2 && lt(o.charCodeAt(2)) && (c = !0, a = 3));
      if (l.length > 0)
        if (e.length > 0) {
          if (l.toLowerCase() !== e.toLowerCase())
            continue;
        } else
          e = l;
      if (i) {
        if (e.length > 0)
          break;
      } else if (t = `${o.slice(a)}\\${t}`, i = c, c && e.length > 0)
        break;
    }
    return t = Ob(t, !i, "\\", lt), i ? `${e}\\${t}` : `${e}${t}` || ".";
  },
  normalize(s) {
    wi(s, "path");
    const e = s.length;
    if (e === 0)
      return ".";
    let t = 0, i, n = !1;
    const o = s.charCodeAt(0);
    if (e === 1)
      return Ay(o) ? "\\" : s;
    if (lt(o))
      if (n = !0, lt(s.charCodeAt(1))) {
        let a = 2, l = a;
        for (; a < e && !lt(s.charCodeAt(a)); )
          a++;
        if (a < e && a !== l) {
          const c = s.slice(l, a);
          for (l = a; a < e && lt(s.charCodeAt(a)); )
            a++;
          if (a < e && a !== l) {
            for (l = a; a < e && !lt(s.charCodeAt(a)); )
              a++;
            if (a === e)
              return `\\\\${c}\\${s.slice(l)}\\`;
            a !== l && (i = `\\\\${c}\\${s.slice(l, a)}`, t = a);
          }
        }
      } else
        t = 1;
    else ol(o) && s.charCodeAt(1) === sl && (i = s.slice(0, 2), t = 2, e > 2 && lt(s.charCodeAt(2)) && (n = !0, t = 3));
    let r = t < e ? Ob(s.slice(t), !n, "\\", lt) : "";
    return r.length === 0 && !n && (r = "."), r.length > 0 && lt(s.charCodeAt(e - 1)) && (r += "\\"), i === void 0 ? n ? `\\${r}` : r : n ? `${i}\\${r}` : `${i}${r}`;
  },
  isAbsolute(s) {
    wi(s, "path");
    const e = s.length;
    if (e === 0)
      return !1;
    const t = s.charCodeAt(0);
    return lt(t) || // Possible device root
    e > 2 && ol(t) && s.charCodeAt(1) === sl && lt(s.charCodeAt(2));
  },
  join(...s) {
    if (s.length === 0)
      return ".";
    let e, t;
    for (let o = 0; o < s.length; ++o) {
      const r = s[o];
      wi(r, "path"), r.length > 0 && (e === void 0 ? e = t = r : e += `\\${r}`);
    }
    if (e === void 0)
      return ".";
    let i = !0, n = 0;
    if (typeof t == "string" && lt(t.charCodeAt(0))) {
      ++n;
      const o = t.length;
      o > 1 && lt(t.charCodeAt(1)) && (++n, o > 2 && (lt(t.charCodeAt(2)) ? ++n : i = !1));
    }
    if (i) {
      for (; n < e.length && lt(e.charCodeAt(n)); )
        n++;
      n >= 2 && (e = `\\${e.slice(n)}`);
    }
    return Nn.normalize(e);
  },
  // It will solve the relative path from `from` to `to`, for instance:
  //  from = 'C:\\orandea\\test\\aaa'
  //  to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  relative(s, e) {
    if (wi(s, "from"), wi(e, "to"), s === e)
      return "";
    const t = Nn.resolve(s), i = Nn.resolve(e);
    if (t === i || (s = t.toLowerCase(), e = i.toLowerCase(), s === e))
      return "";
    let n = 0;
    for (; n < s.length && s.charCodeAt(n) === hs; )
      n++;
    let o = s.length;
    for (; o - 1 > n && s.charCodeAt(o - 1) === hs; )
      o--;
    const r = o - n;
    let a = 0;
    for (; a < e.length && e.charCodeAt(a) === hs; )
      a++;
    let l = e.length;
    for (; l - 1 > a && e.charCodeAt(l - 1) === hs; )
      l--;
    const c = l - a, h = r < c ? r : c;
    let d = -1, u = 0;
    for (; u < h; u++) {
      const g = s.charCodeAt(n + u);
      if (g !== e.charCodeAt(a + u))
        break;
      g === hs && (d = u);
    }
    if (u !== h) {
      if (d === -1)
        return i;
    } else {
      if (c > h) {
        if (e.charCodeAt(a + u) === hs)
          return i.slice(a + u + 1);
        if (u === 2)
          return i.slice(a + u);
      }
      r > h && (s.charCodeAt(n + u) === hs ? d = u : u === 2 && (d = 3)), d === -1 && (d = 0);
    }
    let f = "";
    for (u = n + d + 1; u <= o; ++u)
      (u === o || s.charCodeAt(u) === hs) && (f += f.length === 0 ? ".." : "\\..");
    return a += d, f.length > 0 ? `${f}${i.slice(a, l)}` : (i.charCodeAt(a) === hs && ++a, i.slice(a, l));
  },
  toNamespacedPath(s) {
    if (typeof s != "string" || s.length === 0)
      return s;
    const e = Nn.resolve(s);
    if (e.length <= 2)
      return s;
    if (e.charCodeAt(0) === hs) {
      if (e.charCodeAt(1) === hs) {
        const t = e.charCodeAt(2);
        if (t !== I9 && t !== Nl)
          return `\\\\?\\UNC\\${e.slice(2)}`;
      }
    } else if (ol(e.charCodeAt(0)) && e.charCodeAt(1) === sl && e.charCodeAt(2) === hs)
      return `\\\\?\\${e}`;
    return s;
  },
  dirname(s) {
    wi(s, "path");
    const e = s.length;
    if (e === 0)
      return ".";
    let t = -1, i = 0;
    const n = s.charCodeAt(0);
    if (e === 1)
      return lt(n) ? s : ".";
    if (lt(n)) {
      if (t = i = 1, lt(s.charCodeAt(1))) {
        let a = 2, l = a;
        for (; a < e && !lt(s.charCodeAt(a)); )
          a++;
        if (a < e && a !== l) {
          for (l = a; a < e && lt(s.charCodeAt(a)); )
            a++;
          if (a < e && a !== l) {
            for (l = a; a < e && !lt(s.charCodeAt(a)); )
              a++;
            if (a === e)
              return s;
            a !== l && (t = i = a + 1);
          }
        }
      }
    } else ol(n) && s.charCodeAt(1) === sl && (t = e > 2 && lt(s.charCodeAt(2)) ? 3 : 2, i = t);
    let o = -1, r = !0;
    for (let a = e - 1; a >= i; --a)
      if (lt(s.charCodeAt(a))) {
        if (!r) {
          o = a;
          break;
        }
      } else
        r = !1;
    if (o === -1) {
      if (t === -1)
        return ".";
      o = t;
    }
    return s.slice(0, o);
  },
  basename(s, e) {
    e !== void 0 && wi(e, "suffix"), wi(s, "path");
    let t = 0, i = -1, n = !0, o;
    if (s.length >= 2 && ol(s.charCodeAt(0)) && s.charCodeAt(1) === sl && (t = 2), e !== void 0 && e.length > 0 && e.length <= s.length) {
      if (e === s)
        return "";
      let r = e.length - 1, a = -1;
      for (o = s.length - 1; o >= t; --o) {
        const l = s.charCodeAt(o);
        if (lt(l)) {
          if (!n) {
            t = o + 1;
            break;
          }
        } else
          a === -1 && (n = !1, a = o + 1), r >= 0 && (l === e.charCodeAt(r) ? --r === -1 && (i = o) : (r = -1, i = a));
      }
      return t === i ? i = a : i === -1 && (i = s.length), s.slice(t, i);
    }
    for (o = s.length - 1; o >= t; --o)
      if (lt(s.charCodeAt(o))) {
        if (!n) {
          t = o + 1;
          break;
        }
      } else i === -1 && (n = !1, i = o + 1);
    return i === -1 ? "" : s.slice(t, i);
  },
  extname(s) {
    wi(s, "path");
    let e = 0, t = -1, i = 0, n = -1, o = !0, r = 0;
    s.length >= 2 && s.charCodeAt(1) === sl && ol(s.charCodeAt(0)) && (e = i = 2);
    for (let a = s.length - 1; a >= e; --a) {
      const l = s.charCodeAt(a);
      if (lt(l)) {
        if (!o) {
          i = a + 1;
          break;
        }
        continue;
      }
      n === -1 && (o = !1, n = a + 1), l === Nl ? t === -1 ? t = a : r !== 1 && (r = 1) : t !== -1 && (r = -1);
    }
    return t === -1 || n === -1 || // We saw a non-dot character immediately before the dot
    r === 0 || // The (right-most) trimmed path component is exactly '..'
    r === 1 && t === n - 1 && t === i + 1 ? "" : s.slice(t, n);
  },
  format: ZP.bind(null, "\\"),
  parse(s) {
    wi(s, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (s.length === 0)
      return e;
    const t = s.length;
    let i = 0, n = s.charCodeAt(0);
    if (t === 1)
      return lt(n) ? (e.root = e.dir = s, e) : (e.base = e.name = s, e);
    if (lt(n)) {
      if (i = 1, lt(s.charCodeAt(1))) {
        let d = 2, u = d;
        for (; d < t && !lt(s.charCodeAt(d)); )
          d++;
        if (d < t && d !== u) {
          for (u = d; d < t && lt(s.charCodeAt(d)); )
            d++;
          if (d < t && d !== u) {
            for (u = d; d < t && !lt(s.charCodeAt(d)); )
              d++;
            d === t ? i = d : d !== u && (i = d + 1);
          }
        }
      }
    } else if (ol(n) && s.charCodeAt(1) === sl) {
      if (t <= 2)
        return e.root = e.dir = s, e;
      if (i = 2, lt(s.charCodeAt(2))) {
        if (t === 3)
          return e.root = e.dir = s, e;
        i = 3;
      }
    }
    i > 0 && (e.root = s.slice(0, i));
    let o = -1, r = i, a = -1, l = !0, c = s.length - 1, h = 0;
    for (; c >= i; --c) {
      if (n = s.charCodeAt(c), lt(n)) {
        if (!l) {
          r = c + 1;
          break;
        }
        continue;
      }
      a === -1 && (l = !1, a = c + 1), n === Nl ? o === -1 ? o = c : h !== 1 && (h = 1) : o !== -1 && (h = -1);
    }
    return a !== -1 && (o === -1 || // We saw a non-dot character immediately before the dot
    h === 0 || // The (right-most) trimmed path component is exactly '..'
    h === 1 && o === a - 1 && o === r + 1 ? e.base = e.name = s.slice(r, a) : (e.name = s.slice(r, o), e.base = s.slice(r, a), e.ext = s.slice(o, a))), r > 0 && r !== i ? e.dir = s.slice(0, r - 1) : e.dir = e.root, e;
  },
  sep: "\\",
  delimiter: ";",
  win32: null,
  posix: null
}, M9 = (() => {
  if (qa) {
    const s = /\\/g;
    return () => {
      const e = Pb().replace(s, "/");
      return e.slice(e.indexOf("/"));
    };
  }
  return () => Pb();
})(), ni = {
  // path.resolve([from ...], to)
  resolve(...s) {
    let e = "", t = !1;
    for (let i = s.length - 1; i >= -1 && !t; i--) {
      const n = i >= 0 ? s[i] : M9();
      wi(n, `paths[${i}]`), n.length !== 0 && (e = `${n}/${e}`, t = n.charCodeAt(0) === en);
    }
    return e = Ob(e, !t, "/", Ay), t ? `/${e}` : e.length > 0 ? e : ".";
  },
  normalize(s) {
    if (wi(s, "path"), s.length === 0)
      return ".";
    const e = s.charCodeAt(0) === en, t = s.charCodeAt(s.length - 1) === en;
    return s = Ob(s, !e, "/", Ay), s.length === 0 ? e ? "/" : t ? "./" : "." : (t && (s += "/"), e ? `/${s}` : s);
  },
  isAbsolute(s) {
    return wi(s, "path"), s.length > 0 && s.charCodeAt(0) === en;
  },
  join(...s) {
    if (s.length === 0)
      return ".";
    let e;
    for (let t = 0; t < s.length; ++t) {
      const i = s[t];
      wi(i, "path"), i.length > 0 && (e === void 0 ? e = i : e += `/${i}`);
    }
    return e === void 0 ? "." : ni.normalize(e);
  },
  relative(s, e) {
    if (wi(s, "from"), wi(e, "to"), s === e || (s = ni.resolve(s), e = ni.resolve(e), s === e))
      return "";
    const t = 1, i = s.length, n = i - t, o = 1, r = e.length - o, a = n < r ? n : r;
    let l = -1, c = 0;
    for (; c < a; c++) {
      const d = s.charCodeAt(t + c);
      if (d !== e.charCodeAt(o + c))
        break;
      d === en && (l = c);
    }
    if (c === a)
      if (r > a) {
        if (e.charCodeAt(o + c) === en)
          return e.slice(o + c + 1);
        if (c === 0)
          return e.slice(o + c);
      } else n > a && (s.charCodeAt(t + c) === en ? l = c : c === 0 && (l = 0));
    let h = "";
    for (c = t + l + 1; c <= i; ++c)
      (c === i || s.charCodeAt(c) === en) && (h += h.length === 0 ? ".." : "/..");
    return `${h}${e.slice(o + l)}`;
  },
  toNamespacedPath(s) {
    return s;
  },
  dirname(s) {
    if (wi(s, "path"), s.length === 0)
      return ".";
    const e = s.charCodeAt(0) === en;
    let t = -1, i = !0;
    for (let n = s.length - 1; n >= 1; --n)
      if (s.charCodeAt(n) === en) {
        if (!i) {
          t = n;
          break;
        }
      } else
        i = !1;
    return t === -1 ? e ? "/" : "." : e && t === 1 ? "//" : s.slice(0, t);
  },
  basename(s, e) {
    e !== void 0 && wi(e, "ext"), wi(s, "path");
    let t = 0, i = -1, n = !0, o;
    if (e !== void 0 && e.length > 0 && e.length <= s.length) {
      if (e === s)
        return "";
      let r = e.length - 1, a = -1;
      for (o = s.length - 1; o >= 0; --o) {
        const l = s.charCodeAt(o);
        if (l === en) {
          if (!n) {
            t = o + 1;
            break;
          }
        } else
          a === -1 && (n = !1, a = o + 1), r >= 0 && (l === e.charCodeAt(r) ? --r === -1 && (i = o) : (r = -1, i = a));
      }
      return t === i ? i = a : i === -1 && (i = s.length), s.slice(t, i);
    }
    for (o = s.length - 1; o >= 0; --o)
      if (s.charCodeAt(o) === en) {
        if (!n) {
          t = o + 1;
          break;
        }
      } else i === -1 && (n = !1, i = o + 1);
    return i === -1 ? "" : s.slice(t, i);
  },
  extname(s) {
    wi(s, "path");
    let e = -1, t = 0, i = -1, n = !0, o = 0;
    for (let r = s.length - 1; r >= 0; --r) {
      const a = s.charCodeAt(r);
      if (a === en) {
        if (!n) {
          t = r + 1;
          break;
        }
        continue;
      }
      i === -1 && (n = !1, i = r + 1), a === Nl ? e === -1 ? e = r : o !== 1 && (o = 1) : e !== -1 && (o = -1);
    }
    return e === -1 || i === -1 || // We saw a non-dot character immediately before the dot
    o === 0 || // The (right-most) trimmed path component is exactly '..'
    o === 1 && e === i - 1 && e === t + 1 ? "" : s.slice(e, i);
  },
  format: ZP.bind(null, "/"),
  parse(s) {
    wi(s, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (s.length === 0)
      return e;
    const t = s.charCodeAt(0) === en;
    let i;
    t ? (e.root = "/", i = 1) : i = 0;
    let n = -1, o = 0, r = -1, a = !0, l = s.length - 1, c = 0;
    for (; l >= i; --l) {
      const h = s.charCodeAt(l);
      if (h === en) {
        if (!a) {
          o = l + 1;
          break;
        }
        continue;
      }
      r === -1 && (a = !1, r = l + 1), h === Nl ? n === -1 ? n = l : c !== 1 && (c = 1) : n !== -1 && (c = -1);
    }
    if (r !== -1) {
      const h = o === 0 && t ? 1 : o;
      n === -1 || // We saw a non-dot character immediately before the dot
      c === 0 || // The (right-most) trimmed path component is exactly '..'
      c === 1 && n === r - 1 && n === o + 1 ? e.base = e.name = s.slice(h, r) : (e.name = s.slice(h, n), e.base = s.slice(h, r), e.ext = s.slice(n, r));
    }
    return o > 0 ? e.dir = s.slice(0, o - 1) : t && (e.dir = "/"), e;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
ni.win32 = Nn.win32 = Nn;
ni.posix = Nn.posix = ni;
const YP = qa ? Nn.normalize : ni.normalize, R9 = qa ? Nn.join : ni.join, A9 = qa ? Nn.resolve : ni.resolve, P9 = qa ? Nn.relative : ni.relative, O9 = qa ? Nn.dirname : ni.dirname, XP = qa ? Nn.basename : ni.basename, F9 = qa ? Nn.extname : ni.extname, Tl = qa ? Nn.sep : ni.sep, B9 = /^\w[\w\d+.-]*$/, W9 = /^\//, H9 = /^\/\//;
function V9(s, e) {
  if (!s.scheme && e)
    throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${s.authority}", path: "${s.path}", query: "${s.query}", fragment: "${s.fragment}"}`);
  if (s.scheme && !B9.test(s.scheme))
    throw new Error("[UriError]: Scheme contains illegal characters.");
  if (s.path) {
    if (s.authority) {
      if (!W9.test(s.path))
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
    } else if (H9.test(s.path))
      throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
  }
}
function z9(s, e) {
  return !s && !e ? "file" : s;
}
function U9(s, e) {
  switch (s) {
    case "https":
    case "http":
    case "file":
      e ? e[0] !== Po && (e = Po + e) : e = Po;
      break;
  }
  return e;
}
const Qt = "", Po = "/", $9 = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
class we {
  static isUri(e) {
    return e instanceof we ? !0 : e ? typeof e.authority == "string" && typeof e.fragment == "string" && typeof e.path == "string" && typeof e.query == "string" && typeof e.scheme == "string" && typeof e.fsPath == "string" && typeof e.with == "function" && typeof e.toString == "function" : !1;
  }
  /**
   * @internal
   */
  constructor(e, t, i, n, o, r = !1) {
    typeof e == "object" ? (this.scheme = e.scheme || Qt, this.authority = e.authority || Qt, this.path = e.path || Qt, this.query = e.query || Qt, this.fragment = e.fragment || Qt) : (this.scheme = z9(e, r), this.authority = t || Qt, this.path = U9(this.scheme, i || Qt), this.query = n || Qt, this.fragment = o || Qt, V9(this, r));
  }
  // ---- filesystem path -----------------------
  /**
   * Returns a string representing the corresponding file system path of this URI.
   * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
   * platform specific path separator.
   *
   * * Will *not* validate the path for invalid characters and semantics.
   * * Will *not* look at the scheme of this URI.
   * * The result shall *not* be used for display purposes but for accessing a file on disk.
   *
   *
   * The *difference* to `URI#path` is the use of the platform specific separator and the handling
   * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
   *
   * ```ts
      const u = URI.parse('file://server/c$/folder/file.txt')
      u.authority === 'server'
      u.path === '/shares/c$/file.txt'
      u.fsPath === '\\server\c$\folder\file.txt'
  ```
   *
   * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
   * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
   * with URIs that represent files on disk (`file` scheme).
   */
  get fsPath() {
    return Fb(this, !1);
  }
  // ---- modify to new -------------------------
  with(e) {
    if (!e)
      return this;
    let { scheme: t, authority: i, path: n, query: o, fragment: r } = e;
    return t === void 0 ? t = this.scheme : t === null && (t = Qt), i === void 0 ? i = this.authority : i === null && (i = Qt), n === void 0 ? n = this.path : n === null && (n = Qt), o === void 0 ? o = this.query : o === null && (o = Qt), r === void 0 ? r = this.fragment : r === null && (r = Qt), t === this.scheme && i === this.authority && n === this.path && o === this.query && r === this.fragment ? this : new Dd(t, i, n, o, r);
  }
  // ---- parse & validate ------------------------
  /**
   * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
   * `file:///usr/home`, or `scheme:with/path`.
   *
   * @param value A string which represents an URI (see `URI#toString`).
   */
  static parse(e, t = !1) {
    const i = $9.exec(e);
    return i ? new Dd(i[2] || Qt, i_(i[4] || Qt), i_(i[5] || Qt), i_(i[7] || Qt), i_(i[9] || Qt), t) : new Dd(Qt, Qt, Qt, Qt, Qt);
  }
  /**
   * Creates a new URI from a file system path, e.g. `c:\my\files`,
   * `/usr/home`, or `\\server\share\some\path`.
   *
   * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
   * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
   * `URI.parse('file://' + path)` because the path might contain characters that are
   * interpreted (# and ?). See the following sample:
   * ```ts
  const good = URI.file('/coding/c#/project1');
  good.scheme === 'file';
  good.path === '/coding/c#/project1';
  good.fragment === '';
  const bad = URI.parse('file://' + '/coding/c#/project1');
  bad.scheme === 'file';
  bad.path === '/coding/c'; // path is now broken
  bad.fragment === '/project1';
  ```
   *
   * @param path A file system path (see `URI#fsPath`)
   */
  static file(e) {
    let t = Qt;
    if (es && (e = e.replace(/\\/g, Po)), e[0] === Po && e[1] === Po) {
      const i = e.indexOf(Po, 2);
      i === -1 ? (t = e.substring(2), e = Po) : (t = e.substring(2, i), e = e.substring(i) || Po);
    }
    return new Dd("file", t, e, Qt, Qt);
  }
  /**
   * Creates new URI from uri components.
   *
   * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
   * validation and should be used for untrusted uri components retrieved from storage,
   * user input, command arguments etc
   */
  static from(e, t) {
    return new Dd(e.scheme, e.authority, e.path, e.query, e.fragment, t);
  }
  /**
   * Join a URI path with path fragments and normalizes the resulting path.
   *
   * @param uri The input URI.
   * @param pathFragment The path fragment to add to the URI path.
   * @returns The resulting URI.
   */
  static joinPath(e, ...t) {
    if (!e.path)
      throw new Error("[UriError]: cannot call joinPath on URI without path");
    let i;
    return es && e.scheme === "file" ? i = we.file(Nn.join(Fb(e, !0), ...t)).path : i = ni.join(e.path, ...t), e.with({ path: i });
  }
  // ---- printing/externalize ---------------------------
  /**
   * Creates a string representation for this URI. It's guaranteed that calling
   * `URI.parse` with the result of this function creates an URI which is equal
   * to this URI.
   *
   * * The result shall *not* be used for display purposes but for externalization or transport.
   * * The result will be encoded using the percentage encoding and encoding happens mostly
   * ignore the scheme-specific encoding rules.
   *
   * @param skipEncoding Do not encode the result, default is `false`
   */
  toString(e = !1) {
    return Py(this, e);
  }
  toJSON() {
    return this;
  }
  static revive(e) {
    if (e) {
      if (e instanceof we)
        return e;
      {
        const t = new Dd(e);
        return t._formatted = e.external ?? null, t._fsPath = e._sep === QP ? e.fsPath ?? null : null, t;
      }
    } else return e;
  }
}
const QP = es ? 1 : void 0;
class Dd extends we {
  constructor() {
    super(...arguments), this._formatted = null, this._fsPath = null;
  }
  get fsPath() {
    return this._fsPath || (this._fsPath = Fb(this, !1)), this._fsPath;
  }
  toString(e = !1) {
    return e ? Py(this, !0) : (this._formatted || (this._formatted = Py(this, !1)), this._formatted);
  }
  toJSON() {
    const e = {
      $mid: 1
      /* MarshalledId.Uri */
    };
    return this._fsPath && (e.fsPath = this._fsPath, e._sep = QP), this._formatted && (e.external = this._formatted), this.path && (e.path = this.path), this.scheme && (e.scheme = this.scheme), this.authority && (e.authority = this.authority), this.query && (e.query = this.query), this.fragment && (e.fragment = this.fragment), e;
  }
}
const JP = {
  58: "%3A",
  // gen-delims
  47: "%2F",
  63: "%3F",
  35: "%23",
  91: "%5B",
  93: "%5D",
  64: "%40",
  33: "%21",
  // sub-delims
  36: "%24",
  38: "%26",
  39: "%27",
  40: "%28",
  41: "%29",
  42: "%2A",
  43: "%2B",
  44: "%2C",
  59: "%3B",
  61: "%3D",
  32: "%20"
};
function l2(s, e, t) {
  let i, n = -1;
  for (let o = 0; o < s.length; o++) {
    const r = s.charCodeAt(o);
    if (r >= 97 && r <= 122 || r >= 65 && r <= 90 || r >= 48 && r <= 57 || r === 45 || r === 46 || r === 95 || r === 126 || e && r === 47 || t && r === 91 || t && r === 93 || t && r === 58)
      n !== -1 && (i += encodeURIComponent(s.substring(n, o)), n = -1), i !== void 0 && (i += s.charAt(o));
    else {
      i === void 0 && (i = s.substr(0, o));
      const a = JP[r];
      a !== void 0 ? (n !== -1 && (i += encodeURIComponent(s.substring(n, o)), n = -1), i += a) : n === -1 && (n = o);
    }
  }
  return n !== -1 && (i += encodeURIComponent(s.substring(n))), i !== void 0 ? i : s;
}
function K9(s) {
  let e;
  for (let t = 0; t < s.length; t++) {
    const i = s.charCodeAt(t);
    i === 35 || i === 63 ? (e === void 0 && (e = s.substr(0, t)), e += JP[i]) : e !== void 0 && (e += s[t]);
  }
  return e !== void 0 ? e : s;
}
function Fb(s, e) {
  let t;
  return s.authority && s.path.length > 1 && s.scheme === "file" ? t = `//${s.authority}${s.path}` : s.path.charCodeAt(0) === 47 && (s.path.charCodeAt(1) >= 65 && s.path.charCodeAt(1) <= 90 || s.path.charCodeAt(1) >= 97 && s.path.charCodeAt(1) <= 122) && s.path.charCodeAt(2) === 58 ? e ? t = s.path.substr(1) : t = s.path[1].toLowerCase() + s.path.substr(2) : t = s.path, es && (t = t.replace(/\//g, "\\")), t;
}
function Py(s, e) {
  const t = e ? K9 : l2;
  let i = "", { scheme: n, authority: o, path: r, query: a, fragment: l } = s;
  if (n && (i += n, i += ":"), (o || n === "file") && (i += Po, i += Po), o) {
    let c = o.indexOf("@");
    if (c !== -1) {
      const h = o.substr(0, c);
      o = o.substr(c + 1), c = h.lastIndexOf(":"), c === -1 ? i += t(h, !1, !1) : (i += t(h.substr(0, c), !1, !1), i += ":", i += t(h.substr(c + 1), !1, !0)), i += "@";
    }
    o = o.toLowerCase(), c = o.lastIndexOf(":"), c === -1 ? i += t(o, !1, !0) : (i += t(o.substr(0, c), !1, !0), i += o.substr(c));
  }
  if (r) {
    if (r.length >= 3 && r.charCodeAt(0) === 47 && r.charCodeAt(2) === 58) {
      const c = r.charCodeAt(1);
      c >= 65 && c <= 90 && (r = `/${String.fromCharCode(c + 32)}:${r.substr(3)}`);
    } else if (r.length >= 2 && r.charCodeAt(1) === 58) {
      const c = r.charCodeAt(0);
      c >= 65 && c <= 90 && (r = `${String.fromCharCode(c + 32)}:${r.substr(2)}`);
    }
    i += t(r, !0, !1);
  }
  return a && (i += "?", i += t(a, !1, !1)), l && (i += "#", i += e ? l : l2(l, !1, !1)), i;
}
function e4(s) {
  try {
    return decodeURIComponent(s);
  } catch {
    return s.length > 3 ? s.substr(0, 3) + e4(s.substr(3)) : s;
  }
}
const c2 = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function i_(s) {
  return s.match(c2) ? s.replace(c2, (e) => e4(e)) : s;
}
var zo;
(function(s) {
  s.serviceIds = /* @__PURE__ */ new Map(), s.DI_TARGET = "$di$target", s.DI_DEPENDENCIES = "$di$dependencies";
  function e(t) {
    return t[s.DI_DEPENDENCIES] || [];
  }
  s.getServiceDependencies = e;
})(zo || (zo = {}));
const Pe = Be("instantiationService");
function j9(s, e, t) {
  e[zo.DI_TARGET] === e ? e[zo.DI_DEPENDENCIES].push({ id: s, index: t }) : (e[zo.DI_DEPENDENCIES] = [{ id: s, index: t }], e[zo.DI_TARGET] = e);
}
function Be(s) {
  if (zo.serviceIds.has(s))
    return zo.serviceIds.get(s);
  const e = function(t, i, n) {
    if (arguments.length !== 3)
      throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
    j9(e, t, n);
  };
  return e.toString = () => s, zo.serviceIds.set(s, e), e;
}
const Tt = Be("codeEditorService");
class F {
  constructor(e, t) {
    this.lineNumber = e, this.column = t;
  }
  /**
   * Create a new position from this position.
   *
   * @param newLineNumber new line number
   * @param newColumn new column
   */
  with(e = this.lineNumber, t = this.column) {
    return e === this.lineNumber && t === this.column ? this : new F(e, t);
  }
  /**
   * Derive a new position from this position.
   *
   * @param deltaLineNumber line number delta
   * @param deltaColumn column delta
   */
  delta(e = 0, t = 0) {
    return this.with(this.lineNumber + e, this.column + t);
  }
  /**
   * Test if this position equals other position
   */
  equals(e) {
    return F.equals(this, e);
  }
  /**
   * Test if position `a` equals position `b`
   */
  static equals(e, t) {
    return !e && !t ? !0 : !!e && !!t && e.lineNumber === t.lineNumber && e.column === t.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be false.
   */
  isBefore(e) {
    return F.isBefore(this, e);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be false.
   */
  static isBefore(e, t) {
    return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column < t.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be true.
   */
  isBeforeOrEqual(e) {
    return F.isBeforeOrEqual(this, e);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be true.
   */
  static isBeforeOrEqual(e, t) {
    return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column <= t.column;
  }
  /**
   * A function that compares positions, useful for sorting
   */
  static compare(e, t) {
    const i = e.lineNumber | 0, n = t.lineNumber | 0;
    if (i === n) {
      const o = e.column | 0, r = t.column | 0;
      return o - r;
    }
    return i - n;
  }
  /**
   * Clone this position.
   */
  clone() {
    return new F(this.lineNumber, this.column);
  }
  /**
   * Convert to a human-readable representation.
   */
  toString() {
    return "(" + this.lineNumber + "," + this.column + ")";
  }
  // ---
  /**
   * Create a `Position` from an `IPosition`.
   */
  static lift(e) {
    return new F(e.lineNumber, e.column);
  }
  /**
   * Test if `obj` is an `IPosition`.
   */
  static isIPosition(e) {
    return e && typeof e.lineNumber == "number" && typeof e.column == "number";
  }
  toJSON() {
    return {
      lineNumber: this.lineNumber,
      column: this.column
    };
  }
}
const Ui = Be("modelService"), bo = Be("textModelService");
class q9 {
  constructor() {
    this.listeners = [], this.unexpectedErrorHandler = function(e) {
      setTimeout(() => {
        throw e.stack ? ef.isErrorNoTelemetry(e) ? new ef(e.message + `

` + e.stack) : new Error(e.message + `

` + e.stack) : e;
      }, 0);
    };
  }
  emit(e) {
    this.listeners.forEach((t) => {
      t(e);
    });
  }
  onUnexpectedError(e) {
    this.unexpectedErrorHandler(e), this.emit(e);
  }
  // For external errors, we don't want the listeners to be called
  onUnexpectedExternalError(e) {
    this.unexpectedErrorHandler(e);
  }
}
const t4 = new q9();
function Je(s) {
  Jh(s) || t4.onUnexpectedError(s);
}
function Qo(s) {
  Jh(s) || t4.onUnexpectedExternalError(s);
}
function h2(s) {
  if (s instanceof Error) {
    const { name: e, message: t } = s, i = s.stacktrace || s.stack;
    return {
      $isError: !0,
      name: e,
      message: t,
      stack: i,
      noTelemetry: ef.isErrorNoTelemetry(s)
    };
  }
  return s;
}
const Bb = "Canceled";
function Jh(s) {
  return s instanceof ed ? !0 : s instanceof Error && s.name === Bb && s.message === Bb;
}
class ed extends Error {
  constructor() {
    super(Bb), this.name = this.message;
  }
}
function G9() {
  const s = new Error(Bb);
  return s.name = s.message, s;
}
function Tr(s) {
  return s ? new Error(`Illegal argument: ${s}`) : new Error("Illegal argument");
}
function oE(s) {
  return s ? new Error(`Illegal state: ${s}`) : new Error("Illegal state");
}
class Z9 extends Error {
  constructor(e) {
    super("NotSupported"), e && (this.message = e);
  }
}
class ef extends Error {
  constructor(e) {
    super(e), this.name = "CodeExpectedError";
  }
  static fromError(e) {
    if (e instanceof ef)
      return e;
    const t = new ef();
    return t.message = e.message, t.stack = e.stack, t;
  }
  static isErrorNoTelemetry(e) {
    return e.name === "CodeExpectedError";
  }
}
class at extends Error {
  constructor(e) {
    super(e || "An unexpected bug occurred."), Object.setPrototypeOf(this, at.prototype);
  }
}
function tf(s, e) {
  const t = this;
  let i = !1, n;
  return function() {
    return i || (i = !0, n = s.apply(t, arguments)), n;
  };
}
var nt;
(function(s) {
  function e(v) {
    return v && typeof v == "object" && typeof v[Symbol.iterator] == "function";
  }
  s.is = e;
  const t = Object.freeze([]);
  function i() {
    return t;
  }
  s.empty = i;
  function* n(v) {
    yield v;
  }
  s.single = n;
  function o(v) {
    return e(v) ? v : n(v);
  }
  s.wrap = o;
  function r(v) {
    return v || t;
  }
  s.from = r;
  function* a(v) {
    for (let S = v.length - 1; S >= 0; S--)
      yield v[S];
  }
  s.reverse = a;
  function l(v) {
    return !v || v[Symbol.iterator]().next().done === !0;
  }
  s.isEmpty = l;
  function c(v) {
    return v[Symbol.iterator]().next().value;
  }
  s.first = c;
  function h(v, S) {
    let L = 0;
    for (const k of v)
      if (S(k, L++))
        return !0;
    return !1;
  }
  s.some = h;
  function d(v, S) {
    for (const L of v)
      if (S(L))
        return L;
  }
  s.find = d;
  function* u(v, S) {
    for (const L of v)
      S(L) && (yield L);
  }
  s.filter = u;
  function* f(v, S) {
    let L = 0;
    for (const k of v)
      yield S(k, L++);
  }
  s.map = f;
  function* g(v, S) {
    let L = 0;
    for (const k of v)
      yield* S(k, L++);
  }
  s.flatMap = g;
  function* p(...v) {
    for (const S of v)
      yield* S;
  }
  s.concat = p;
  function _(v, S, L) {
    let k = L;
    for (const x of v)
      k = S(k, x);
    return k;
  }
  s.reduce = _;
  function* b(v, S, L = v.length) {
    for (S < 0 && (S += v.length), L < 0 ? L += v.length : L > v.length && (L = v.length); S < L; S++)
      yield v[S];
  }
  s.slice = b;
  function C(v, S = Number.POSITIVE_INFINITY) {
    const L = [];
    if (S === 0)
      return [L, v];
    const k = v[Symbol.iterator]();
    for (let x = 0; x < S; x++) {
      const I = k.next();
      if (I.done)
        return [L, s.empty()];
      L.push(I.value);
    }
    return [L, { [Symbol.iterator]() {
      return k;
    } }];
  }
  s.consume = C;
  async function w(v) {
    const S = [];
    for await (const L of v)
      S.push(L);
    return Promise.resolve(S);
  }
  s.asyncToArray = w;
})(nt || (nt = {}));
function i4(s) {
  return typeof s == "object" && s !== null && typeof s.dispose == "function" && s.dispose.length === 0;
}
function Ft(s) {
  if (nt.is(s)) {
    const e = [];
    for (const t of s)
      if (t)
        try {
          t.dispose();
        } catch (i) {
          e.push(i);
        }
    if (e.length === 1)
      throw e[0];
    if (e.length > 1)
      throw new AggregateError(e, "Encountered errors while disposing of store");
    return Array.isArray(s) ? [] : s;
  } else if (s)
    return s.dispose(), s;
}
function ao(...s) {
  return _e(() => Ft(s));
}
function _e(s) {
  return {
    dispose: tf(() => {
      s();
    })
  };
}
const HC = class HC {
  constructor() {
    this._toDispose = /* @__PURE__ */ new Set(), this._isDisposed = !1;
  }
  /**
   * Dispose of all registered disposables and mark this object as disposed.
   *
   * Any future disposables added to this object will be disposed of on `add`.
   */
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this.clear());
  }
  /**
   * @return `true` if this object has been disposed of.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of all registered disposables but do not mark this object as disposed.
   */
  clear() {
    if (this._toDispose.size !== 0)
      try {
        Ft(this._toDispose);
      } finally {
        this._toDispose.clear();
      }
  }
  /**
   * Add a new {@link IDisposable disposable} to the collection.
   */
  add(e) {
    if (!e)
      return e;
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._isDisposed ? HC.DISABLE_DISPOSED_WARNING || console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack) : this._toDispose.add(e), e;
  }
  /**
   * Deletes the value from the store, but does not dispose it.
   */
  deleteAndLeak(e) {
    e && this._toDispose.has(e) && this._toDispose.delete(e);
  }
};
HC.DISABLE_DISPOSED_WARNING = !1;
let ne = HC;
const JN = class JN {
  constructor() {
    this._store = new ne(), this._store;
  }
  dispose() {
    this._store.dispose();
  }
  /**
   * Adds `o` to the collection of disposables managed by this object.
   */
  _register(e) {
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._store.add(e);
  }
};
JN.None = Object.freeze({ dispose() {
} });
let U = JN;
class Hs {
  constructor() {
    this._isDisposed = !1;
  }
  get value() {
    return this._isDisposed ? void 0 : this._value;
  }
  set value(e) {
    var t;
    this._isDisposed || e === this._value || ((t = this._value) == null || t.dispose(), this._value = e);
  }
  /**
   * Resets the stored value and disposed of the previously stored value.
   */
  clear() {
    this.value = void 0;
  }
  dispose() {
    var e;
    this._isDisposed = !0, (e = this._value) == null || e.dispose(), this._value = void 0;
  }
}
class Y9 {
  constructor(e) {
    this.object = e;
  }
  dispose() {
  }
}
class rE {
  constructor() {
    this._store = /* @__PURE__ */ new Map(), this._isDisposed = !1;
  }
  /**
   * Disposes of all stored values and mark this object as disposed.
   *
   * Trying to use this object after it has been disposed of is an error.
   */
  dispose() {
    this._isDisposed = !0, this.clearAndDisposeAll();
  }
  /**
   * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.
   */
  clearAndDisposeAll() {
    if (this._store.size)
      try {
        Ft(this._store.values());
      } finally {
        this._store.clear();
      }
  }
  get(e) {
    return this._store.get(e);
  }
  set(e, t, i = !1) {
    var n;
    this._isDisposed && console.warn(new Error("Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!").stack), i || (n = this._store.get(e)) == null || n.dispose(), this._store.set(e, t);
  }
  /**
   * Delete the value stored for `key` from this map and also dispose of it.
   */
  deleteAndDispose(e) {
    var t;
    (t = this._store.get(e)) == null || t.dispose(), this._store.delete(e);
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]();
  }
}
var Ma;
let gi = (Ma = class {
  constructor(e) {
    this.element = e, this.next = Ma.Undefined, this.prev = Ma.Undefined;
  }
}, Ma.Undefined = new Ma(void 0), Ma);
class Tn {
  constructor() {
    this._first = gi.Undefined, this._last = gi.Undefined, this._size = 0;
  }
  get size() {
    return this._size;
  }
  isEmpty() {
    return this._first === gi.Undefined;
  }
  clear() {
    let e = this._first;
    for (; e !== gi.Undefined; ) {
      const t = e.next;
      e.prev = gi.Undefined, e.next = gi.Undefined, e = t;
    }
    this._first = gi.Undefined, this._last = gi.Undefined, this._size = 0;
  }
  unshift(e) {
    return this._insert(e, !1);
  }
  push(e) {
    return this._insert(e, !0);
  }
  _insert(e, t) {
    const i = new gi(e);
    if (this._first === gi.Undefined)
      this._first = i, this._last = i;
    else if (t) {
      const o = this._last;
      this._last = i, i.prev = o, o.next = i;
    } else {
      const o = this._first;
      this._first = i, i.next = o, o.prev = i;
    }
    this._size += 1;
    let n = !1;
    return () => {
      n || (n = !0, this._remove(i));
    };
  }
  shift() {
    if (this._first !== gi.Undefined) {
      const e = this._first.element;
      return this._remove(this._first), e;
    }
  }
  pop() {
    if (this._last !== gi.Undefined) {
      const e = this._last.element;
      return this._remove(this._last), e;
    }
  }
  _remove(e) {
    if (e.prev !== gi.Undefined && e.next !== gi.Undefined) {
      const t = e.prev;
      t.next = e.next, e.next.prev = t;
    } else e.prev === gi.Undefined && e.next === gi.Undefined ? (this._first = gi.Undefined, this._last = gi.Undefined) : e.next === gi.Undefined ? (this._last = this._last.prev, this._last.next = gi.Undefined) : e.prev === gi.Undefined && (this._first = this._first.next, this._first.prev = gi.Undefined);
    this._size -= 1;
  }
  *[Symbol.iterator]() {
    let e = this._first;
    for (; e !== gi.Undefined; )
      yield e.element, e = e.next;
  }
}
const X9 = globalThis.performance && typeof globalThis.performance.now == "function";
class Ga {
  static create(e) {
    return new Ga(e);
  }
  constructor(e) {
    this._now = X9 && e === !1 ? Date.now : globalThis.performance.now.bind(globalThis.performance), this._startTime = this._now(), this._stopTime = -1;
  }
  stop() {
    this._stopTime = this._now();
  }
  reset() {
    this._startTime = this._now(), this._stopTime = -1;
  }
  elapsed() {
    return this._stopTime !== -1 ? this._stopTime - this._startTime : this._now() - this._startTime;
  }
}
var ee;
(function(s) {
  s.None = () => U.None;
  function e(H, P) {
    return u(H, () => {
    }, 0, void 0, !0, void 0, P);
  }
  s.defer = e;
  function t(H) {
    return (P, q = null, J) => {
      let oe = !1, ae;
      return ae = H((re) => {
        if (!oe)
          return ae ? ae.dispose() : oe = !0, P.call(q, re);
      }, null, J), oe && ae.dispose(), ae;
    };
  }
  s.once = t;
  function i(H, P) {
    return s.once(s.filter(H, P));
  }
  s.onceIf = i;
  function n(H, P, q) {
    return h((J, oe = null, ae) => H((re) => J.call(oe, P(re)), null, ae), q);
  }
  s.map = n;
  function o(H, P, q) {
    return h((J, oe = null, ae) => H((re) => {
      P(re), J.call(oe, re);
    }, null, ae), q);
  }
  s.forEach = o;
  function r(H, P, q) {
    return h((J, oe = null, ae) => H((re) => P(re) && J.call(oe, re), null, ae), q);
  }
  s.filter = r;
  function a(H) {
    return H;
  }
  s.signal = a;
  function l(...H) {
    return (P, q = null, J) => {
      const oe = ao(...H.map((ae) => ae((re) => P.call(q, re))));
      return d(oe, J);
    };
  }
  s.any = l;
  function c(H, P, q, J) {
    let oe = q;
    return n(H, (ae) => (oe = P(oe, ae), oe), J);
  }
  s.reduce = c;
  function h(H, P) {
    let q;
    const J = {
      onWillAddFirstListener() {
        q = H(oe.fire, oe);
      },
      onDidRemoveLastListener() {
        q == null || q.dispose();
      }
    }, oe = new A(J);
    return P == null || P.add(oe), oe.event;
  }
  function d(H, P) {
    return P instanceof Array ? P.push(H) : P && P.add(H), H;
  }
  function u(H, P, q = 100, J = !1, oe = !1, ae, re) {
    let be, Ce, At, ye = 0, ct;
    const ot = {
      leakWarningThreshold: ae,
      onWillAddFirstListener() {
        be = H((hn) => {
          ye++, Ce = P(Ce, hn), J && !At && (Xt.fire(Ce), Ce = void 0), ct = () => {
            const Sn = Ce;
            Ce = void 0, At = void 0, (!J || ye > 1) && Xt.fire(Sn), ye = 0;
          }, typeof q == "number" ? (clearTimeout(At), At = setTimeout(ct, q)) : At === void 0 && (At = 0, queueMicrotask(ct));
        });
      },
      onWillRemoveListener() {
        oe && ye > 0 && (ct == null || ct());
      },
      onDidRemoveLastListener() {
        ct = void 0, be.dispose();
      }
    }, Xt = new A(ot);
    return re == null || re.add(Xt), Xt.event;
  }
  s.debounce = u;
  function f(H, P = 0, q) {
    return s.debounce(H, (J, oe) => J ? (J.push(oe), J) : [oe], P, void 0, !0, void 0, q);
  }
  s.accumulate = f;
  function g(H, P = (J, oe) => J === oe, q) {
    let J = !0, oe;
    return r(H, (ae) => {
      const re = J || !P(ae, oe);
      return J = !1, oe = ae, re;
    }, q);
  }
  s.latch = g;
  function p(H, P, q) {
    return [
      s.filter(H, P, q),
      s.filter(H, (J) => !P(J), q)
    ];
  }
  s.split = p;
  function _(H, P = !1, q = [], J) {
    let oe = q.slice(), ae = H((Ce) => {
      oe ? oe.push(Ce) : be.fire(Ce);
    });
    J && J.add(ae);
    const re = () => {
      oe == null || oe.forEach((Ce) => be.fire(Ce)), oe = null;
    }, be = new A({
      onWillAddFirstListener() {
        ae || (ae = H((Ce) => be.fire(Ce)), J && J.add(ae));
      },
      onDidAddFirstListener() {
        oe && (P ? setTimeout(re) : re());
      },
      onDidRemoveLastListener() {
        ae && ae.dispose(), ae = null;
      }
    });
    return J && J.add(be), be.event;
  }
  s.buffer = _;
  function b(H, P) {
    return (J, oe, ae) => {
      const re = P(new w());
      return H(function(be) {
        const Ce = re.evaluate(be);
        Ce !== C && J.call(oe, Ce);
      }, void 0, ae);
    };
  }
  s.chain = b;
  const C = Symbol("HaltChainable");
  class w {
    constructor() {
      this.steps = [];
    }
    map(P) {
      return this.steps.push(P), this;
    }
    forEach(P) {
      return this.steps.push((q) => (P(q), q)), this;
    }
    filter(P) {
      return this.steps.push((q) => P(q) ? q : C), this;
    }
    reduce(P, q) {
      let J = q;
      return this.steps.push((oe) => (J = P(J, oe), J)), this;
    }
    latch(P = (q, J) => q === J) {
      let q = !0, J;
      return this.steps.push((oe) => {
        const ae = q || !P(oe, J);
        return q = !1, J = oe, ae ? oe : C;
      }), this;
    }
    evaluate(P) {
      for (const q of this.steps)
        if (P = q(P), P === C)
          break;
      return P;
    }
  }
  function v(H, P, q = (J) => J) {
    const J = (...be) => re.fire(q(...be)), oe = () => H.on(P, J), ae = () => H.removeListener(P, J), re = new A({ onWillAddFirstListener: oe, onDidRemoveLastListener: ae });
    return re.event;
  }
  s.fromNodeEventEmitter = v;
  function S(H, P, q = (J) => J) {
    const J = (...be) => re.fire(q(...be)), oe = () => H.addEventListener(P, J), ae = () => H.removeEventListener(P, J), re = new A({ onWillAddFirstListener: oe, onDidRemoveLastListener: ae });
    return re.event;
  }
  s.fromDOMEventEmitter = S;
  function L(H) {
    return new Promise((P) => t(H)(P));
  }
  s.toPromise = L;
  function k(H) {
    const P = new A();
    return H.then((q) => {
      P.fire(q);
    }, () => {
      P.fire(void 0);
    }).finally(() => {
      P.dispose();
    }), P.event;
  }
  s.fromPromise = k;
  function x(H, P) {
    return H((q) => P.fire(q));
  }
  s.forward = x;
  function I(H, P, q) {
    return P(q), H((J) => P(J));
  }
  s.runAndSubscribe = I;
  class K {
    constructor(P, q) {
      this._observable = P, this._counter = 0, this._hasChanged = !1;
      const J = {
        onWillAddFirstListener: () => {
          P.addObserver(this), this._observable.reportChanges();
        },
        onDidRemoveLastListener: () => {
          P.removeObserver(this);
        }
      };
      this.emitter = new A(J), q && q.add(this.emitter);
    }
    beginUpdate(P) {
      this._counter++;
    }
    handlePossibleChange(P) {
    }
    handleChange(P, q) {
      this._hasChanged = !0;
    }
    endUpdate(P) {
      this._counter--, this._counter === 0 && (this._observable.reportChanges(), this._hasChanged && (this._hasChanged = !1, this.emitter.fire(this._observable.get())));
    }
  }
  function B(H, P) {
    return new K(H, P).emitter.event;
  }
  s.fromObservable = B;
  function W(H) {
    return (P, q, J) => {
      let oe = 0, ae = !1;
      const re = {
        beginUpdate() {
          oe++;
        },
        endUpdate() {
          oe--, oe === 0 && (H.reportChanges(), ae && (ae = !1, P.call(q)));
        },
        handlePossibleChange() {
        },
        handleChange() {
          ae = !0;
        }
      };
      H.addObserver(re), H.reportChanges();
      const be = {
        dispose() {
          H.removeObserver(re);
        }
      };
      return J instanceof ne ? J.add(be) : Array.isArray(J) && J.push(be), be;
    };
  }
  s.fromObservableLight = W;
})(ee || (ee = {}));
const gu = class gu {
  constructor(e) {
    this.listenerCount = 0, this.invocationCount = 0, this.elapsedOverall = 0, this.durations = [], this.name = `${e}_${gu._idPool++}`, gu.all.add(this);
  }
  start(e) {
    this._stopWatch = new Ga(), this.listenerCount = e;
  }
  stop() {
    if (this._stopWatch) {
      const e = this._stopWatch.elapsed();
      this.durations.push(e), this.elapsedOverall += e, this.invocationCount += 1, this._stopWatch = void 0;
    }
  }
};
gu.all = /* @__PURE__ */ new Set(), gu._idPool = 0;
let Oy = gu, Q9 = -1;
const VC = class VC {
  constructor(e, t, i = (VC._idPool++).toString(16).padStart(3, "0")) {
    this._errorHandler = e, this.threshold = t, this.name = i, this._warnCountdown = 0;
  }
  dispose() {
    var e;
    (e = this._stacks) == null || e.clear();
  }
  check(e, t) {
    const i = this.threshold;
    if (i <= 0 || t < i)
      return;
    this._stacks || (this._stacks = /* @__PURE__ */ new Map());
    const n = this._stacks.get(e.value) || 0;
    if (this._stacks.set(e.value, n + 1), this._warnCountdown -= 1, this._warnCountdown <= 0) {
      this._warnCountdown = i * 0.5;
      const [o, r] = this.getMostFrequentStack(), a = `[${this.name}] potential listener LEAK detected, having ${t} listeners already. MOST frequent listener (${r}):`;
      console.warn(a), console.warn(o);
      const l = new J9(a, o);
      this._errorHandler(l);
    }
    return () => {
      const o = this._stacks.get(e.value) || 0;
      this._stacks.set(e.value, o - 1);
    };
  }
  getMostFrequentStack() {
    if (!this._stacks)
      return;
    let e, t = 0;
    for (const [i, n] of this._stacks)
      (!e || t < n) && (e = [i, n], t = n);
    return e;
  }
};
VC._idPool = 1;
let Fy = VC;
class aE {
  static create() {
    const e = new Error();
    return new aE(e.stack ?? "");
  }
  constructor(e) {
    this.value = e;
  }
  print() {
    console.warn(this.value.split(`
`).slice(2).join(`
`));
  }
}
class J9 extends Error {
  constructor(e, t) {
    super(e), this.name = "ListenerLeakError", this.stack = t;
  }
}
class e8 extends Error {
  constructor(e, t) {
    super(e), this.name = "ListenerRefusalError", this.stack = t;
  }
}
class i0 {
  constructor(e) {
    this.value = e;
  }
}
const t8 = 2;
class A {
  constructor(e) {
    var t, i, n, o;
    this._size = 0, this._options = e, this._leakageMon = (t = this._options) != null && t.leakWarningThreshold ? new Fy((e == null ? void 0 : e.onListenerError) ?? Je, ((i = this._options) == null ? void 0 : i.leakWarningThreshold) ?? Q9) : void 0, this._perfMon = (n = this._options) != null && n._profName ? new Oy(this._options._profName) : void 0, this._deliveryQueue = (o = this._options) == null ? void 0 : o.deliveryQueue;
  }
  dispose() {
    var e, t, i, n;
    this._disposed || (this._disposed = !0, ((e = this._deliveryQueue) == null ? void 0 : e.current) === this && this._deliveryQueue.reset(), this._listeners && (this._listeners = void 0, this._size = 0), (i = (t = this._options) == null ? void 0 : t.onDidRemoveLastListener) == null || i.call(t), (n = this._leakageMon) == null || n.dispose());
  }
  /**
   * For the public to allow to subscribe
   * to events from this Emitter
   */
  get event() {
    return this._event ?? (this._event = (e, t, i) => {
      var a, l, c, h, d;
      if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {
        const u = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;
        console.warn(u);
        const f = this._leakageMon.getMostFrequentStack() ?? ["UNKNOWN stack", -1], g = new e8(`${u}. HINT: Stack shows most frequent listener (${f[1]}-times)`, f[0]);
        return (((a = this._options) == null ? void 0 : a.onListenerError) || Je)(g), U.None;
      }
      if (this._disposed)
        return U.None;
      t && (e = e.bind(t));
      const n = new i0(e);
      let o;
      this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2) && (n.stack = aE.create(), o = this._leakageMon.check(n.stack, this._size + 1)), this._listeners ? this._listeners instanceof i0 ? (this._deliveryQueue ?? (this._deliveryQueue = new n4()), this._listeners = [this._listeners, n]) : this._listeners.push(n) : ((c = (l = this._options) == null ? void 0 : l.onWillAddFirstListener) == null || c.call(l, this), this._listeners = n, (d = (h = this._options) == null ? void 0 : h.onDidAddFirstListener) == null || d.call(h, this)), this._size++;
      const r = _e(() => {
        o == null || o(), this._removeListener(n);
      });
      return i instanceof ne ? i.add(r) : Array.isArray(i) && i.push(r), r;
    }), this._event;
  }
  _removeListener(e) {
    var o, r, a, l;
    if ((r = (o = this._options) == null ? void 0 : o.onWillRemoveListener) == null || r.call(o, this), !this._listeners)
      return;
    if (this._size === 1) {
      this._listeners = void 0, (l = (a = this._options) == null ? void 0 : a.onDidRemoveLastListener) == null || l.call(a, this), this._size = 0;
      return;
    }
    const t = this._listeners, i = t.indexOf(e);
    if (i === -1)
      throw console.log("disposed?", this._disposed), console.log("size?", this._size), console.log("arr?", JSON.stringify(this._listeners)), new Error("Attempted to dispose unknown listener");
    this._size--, t[i] = void 0;
    const n = this._deliveryQueue.current === this;
    if (this._size * t8 <= t.length) {
      let c = 0;
      for (let h = 0; h < t.length; h++)
        t[h] ? t[c++] = t[h] : n && (this._deliveryQueue.end--, c < this._deliveryQueue.i && this._deliveryQueue.i--);
      t.length = c;
    }
  }
  _deliver(e, t) {
    var n;
    if (!e)
      return;
    const i = ((n = this._options) == null ? void 0 : n.onListenerError) || Je;
    if (!i) {
      e.value(t);
      return;
    }
    try {
      e.value(t);
    } catch (o) {
      i(o);
    }
  }
  /** Delivers items in the queue. Assumes the queue is ready to go. */
  _deliverQueue(e) {
    const t = e.current._listeners;
    for (; e.i < e.end; )
      this._deliver(t[e.i++], e.value);
    e.reset();
  }
  /**
   * To be kept private to fire an event to
   * subscribers
   */
  fire(e) {
    var t, i, n, o;
    if ((t = this._deliveryQueue) != null && t.current && (this._deliverQueue(this._deliveryQueue), (i = this._perfMon) == null || i.stop()), (n = this._perfMon) == null || n.start(this._size), this._listeners) if (this._listeners instanceof i0)
      this._deliver(this._listeners, e);
    else {
      const r = this._deliveryQueue;
      r.enqueue(this, e, this._listeners.length), this._deliverQueue(r);
    }
    (o = this._perfMon) == null || o.stop();
  }
  hasListeners() {
    return this._size > 0;
  }
}
const i8 = () => new n4();
class n4 {
  constructor() {
    this.i = -1, this.end = 0;
  }
  enqueue(e, t, i) {
    this.i = 0, this.end = i, this.current = e, this.value = t;
  }
  reset() {
    this.i = this.end, this.current = void 0, this.value = void 0;
  }
}
class Sm extends A {
  constructor(e) {
    super(e), this._isPaused = 0, this._eventQueue = new Tn(), this._mergeFn = e == null ? void 0 : e.merge;
  }
  pause() {
    this._isPaused++;
  }
  resume() {
    if (this._isPaused !== 0 && --this._isPaused === 0)
      if (this._mergeFn) {
        if (this._eventQueue.size > 0) {
          const e = Array.from(this._eventQueue);
          this._eventQueue.clear(), super.fire(this._mergeFn(e));
        }
      } else
        for (; !this._isPaused && this._eventQueue.size !== 0; )
          super.fire(this._eventQueue.shift());
  }
  fire(e) {
    this._size && (this._isPaused !== 0 ? this._eventQueue.push(e) : super.fire(e));
  }
}
class s4 extends Sm {
  constructor(e) {
    super(e), this._delay = e.delay ?? 100;
  }
  fire(e) {
    this._handle || (this.pause(), this._handle = setTimeout(() => {
      this._handle = void 0, this.resume();
    }, this._delay)), super.fire(e);
  }
}
class n8 extends A {
  constructor(e) {
    super(e), this._queuedEvents = [], this._mergeFn = e == null ? void 0 : e.merge;
  }
  fire(e) {
    this.hasListeners() && (this._queuedEvents.push(e), this._queuedEvents.length === 1 && queueMicrotask(() => {
      this._mergeFn ? super.fire(this._mergeFn(this._queuedEvents)) : this._queuedEvents.forEach((t) => super.fire(t)), this._queuedEvents = [];
    }));
  }
}
class s8 {
  constructor() {
    this.hasListeners = !1, this.events = [], this.emitter = new A({
      onWillAddFirstListener: () => this.onFirstListenerAdd(),
      onDidRemoveLastListener: () => this.onLastListenerRemove()
    });
  }
  get event() {
    return this.emitter.event;
  }
  add(e) {
    const t = { event: e, listener: null };
    return this.events.push(t), this.hasListeners && this.hook(t), _e(tf(() => {
      this.hasListeners && this.unhook(t);
      const n = this.events.indexOf(t);
      this.events.splice(n, 1);
    }));
  }
  onFirstListenerAdd() {
    this.hasListeners = !0, this.events.forEach((e) => this.hook(e));
  }
  onLastListenerRemove() {
    this.hasListeners = !1, this.events.forEach((e) => this.unhook(e));
  }
  hook(e) {
    e.listener = e.event((t) => this.emitter.fire(t));
  }
  unhook(e) {
    var t;
    (t = e.listener) == null || t.dispose(), e.listener = null;
  }
  dispose() {
    var e;
    this.emitter.dispose();
    for (const t of this.events)
      (e = t.listener) == null || e.dispose();
    this.events = [];
  }
}
class xp {
  constructor() {
    this.data = [];
  }
  wrapEvent(e, t, i) {
    return (n, o, r) => e((a) => {
      const l = this.data[this.data.length - 1];
      if (!t) {
        l ? l.buffers.push(() => n.call(o, a)) : n.call(o, a);
        return;
      }
      const c = l;
      if (!c) {
        n.call(o, t(i, a));
        return;
      }
      c.items ?? (c.items = []), c.items.push(a), c.buffers.length === 0 && l.buffers.push(() => {
        c.reducedResult ?? (c.reducedResult = i ? c.items.reduce(t, i) : c.items.reduce(t)), n.call(o, c.reducedResult);
      });
    }, void 0, r);
  }
  bufferEvents(e) {
    const t = { buffers: new Array() };
    this.data.push(t);
    const i = e();
    return this.data.pop(), t.buffers.forEach((n) => n()), i;
  }
}
class d2 {
  constructor() {
    this.listening = !1, this.inputEvent = ee.None, this.inputEventListener = U.None, this.emitter = new A({
      onDidAddFirstListener: () => {
        this.listening = !0, this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
      },
      onDidRemoveLastListener: () => {
        this.listening = !1, this.inputEventListener.dispose();
      }
    }), this.event = this.emitter.event;
  }
  set input(e) {
    this.inputEvent = e, this.listening && (this.inputEventListener.dispose(), this.inputEventListener = e(this.emitter.fire, this.emitter));
  }
  dispose() {
    this.inputEventListener.dispose(), this.emitter.dispose();
  }
}
class ys extends U {
  constructor(e, t = "", i = "", n = !0, o) {
    super(), this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, this._enabled = !0, this._id = e, this._label = t, this._cssClass = i, this._enabled = n, this._actionCallback = o;
  }
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  set label(e) {
    this._setLabel(e);
  }
  _setLabel(e) {
    this._label !== e && (this._label = e, this._onDidChange.fire({ label: e }));
  }
  get tooltip() {
    return this._tooltip || "";
  }
  set tooltip(e) {
    this._setTooltip(e);
  }
  _setTooltip(e) {
    this._tooltip !== e && (this._tooltip = e, this._onDidChange.fire({ tooltip: e }));
  }
  get class() {
    return this._cssClass;
  }
  set class(e) {
    this._setClass(e);
  }
  _setClass(e) {
    this._cssClass !== e && (this._cssClass = e, this._onDidChange.fire({ class: e }));
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._setEnabled(e);
  }
  _setEnabled(e) {
    this._enabled !== e && (this._enabled = e, this._onDidChange.fire({ enabled: e }));
  }
  get checked() {
    return this._checked;
  }
  set checked(e) {
    this._setChecked(e);
  }
  _setChecked(e) {
    this._checked !== e && (this._checked = e, this._onDidChange.fire({ checked: e }));
  }
  async run(e, t) {
    this._actionCallback && await this._actionCallback(e);
  }
}
class Fh extends U {
  constructor() {
    super(...arguments), this._onWillRun = this._register(new A()), this.onWillRun = this._onWillRun.event, this._onDidRun = this._register(new A()), this.onDidRun = this._onDidRun.event;
  }
  async run(e, t) {
    if (!e.enabled)
      return;
    this._onWillRun.fire({ action: e });
    let i;
    try {
      await this.runAction(e, t);
    } catch (n) {
      i = n;
    }
    this._onDidRun.fire({ action: e, error: i });
  }
  async runAction(e, t) {
    await e.run(t);
  }
}
const lm = class lm {
  constructor() {
    this.id = lm.ID, this.label = "", this.tooltip = "", this.class = "separator", this.enabled = !1, this.checked = !1;
  }
  /**
   * Joins all non-empty lists of actions with separators.
   */
  static join(...e) {
    let t = [];
    for (const i of e)
      i.length && (t.length ? t = [...t, new lm(), ...i] : t = i);
    return t;
  }
  async run() {
  }
};
lm.ID = "vs.actions.separator";
let Vi = lm;
class Wv {
  get actions() {
    return this._actions;
  }
  constructor(e, t, i, n) {
    this.tooltip = "", this.enabled = !0, this.checked = void 0, this.id = e, this.label = t, this.class = n, this._actions = i;
  }
  async run() {
  }
}
const zC = class zC extends ys {
  constructor() {
    super(zC.ID, m("submenu.empty", "(empty)"), void 0, !1);
  }
};
zC.ID = "vs.actions.empty";
let By = zC;
function Iu(s) {
  return {
    id: s.id,
    label: s.label,
    tooltip: s.tooltip ?? s.label,
    class: s.class,
    enabled: s.enabled ?? !0,
    checked: s.checked,
    run: async (...e) => s.run(...e)
  };
}
function Ss(s) {
  return typeof s == "string";
}
function Wi(s) {
  return typeof s == "object" && s !== null && !Array.isArray(s) && !(s instanceof RegExp) && !(s instanceof Date);
}
function o8(s) {
  const e = Object.getPrototypeOf(Uint8Array);
  return typeof s == "object" && s instanceof e;
}
function If(s) {
  return typeof s == "number" && !isNaN(s);
}
function u2(s) {
  return !!s && typeof s[Symbol.iterator] == "function";
}
function o4(s) {
  return s === !0 || s === !1;
}
function As(s) {
  return typeof s > "u";
}
function nf(s) {
  return !ms(s);
}
function ms(s) {
  return As(s) || s === null;
}
function qi(s, e) {
  if (!s)
    throw new Error("Unexpected type");
}
function r4(s) {
  if (ms(s))
    throw new Error("Assertion Failed: argument is undefined or null");
  return s;
}
function Wb(s) {
  return typeof s == "function";
}
function r8(s, e) {
  const t = Math.min(s.length, e.length);
  for (let i = 0; i < t; i++)
    a8(s[i], e[i]);
}
function a8(s, e) {
  if (Ss(e)) {
    if (typeof s !== e)
      throw new Error(`argument does not match constraint: typeof ${e}`);
  } else if (Wb(e)) {
    try {
      if (s instanceof e)
        return;
    } catch {
    }
    if (!ms(s) && s.constructor === e || e.length === 1 && e.call(void 0, s) === !0)
      return;
    throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
  }
}
const Wy = /* @__PURE__ */ Object.create(null);
function y(s, e) {
  if (Ss(e)) {
    const t = Wy[e];
    if (t === void 0)
      throw new Error(`${s} references an unknown codicon: ${e}`);
    e = t;
  }
  return Wy[s] = e, { id: s };
}
function a4() {
  return Wy;
}
const l8 = {
  add: y("add", 6e4),
  plus: y("plus", 6e4),
  gistNew: y("gist-new", 6e4),
  repoCreate: y("repo-create", 6e4),
  lightbulb: y("lightbulb", 60001),
  lightBulb: y("light-bulb", 60001),
  repo: y("repo", 60002),
  repoDelete: y("repo-delete", 60002),
  gistFork: y("gist-fork", 60003),
  repoForked: y("repo-forked", 60003),
  gitPullRequest: y("git-pull-request", 60004),
  gitPullRequestAbandoned: y("git-pull-request-abandoned", 60004),
  recordKeys: y("record-keys", 60005),
  keyboard: y("keyboard", 60005),
  tag: y("tag", 60006),
  gitPullRequestLabel: y("git-pull-request-label", 60006),
  tagAdd: y("tag-add", 60006),
  tagRemove: y("tag-remove", 60006),
  person: y("person", 60007),
  personFollow: y("person-follow", 60007),
  personOutline: y("person-outline", 60007),
  personFilled: y("person-filled", 60007),
  gitBranch: y("git-branch", 60008),
  gitBranchCreate: y("git-branch-create", 60008),
  gitBranchDelete: y("git-branch-delete", 60008),
  sourceControl: y("source-control", 60008),
  mirror: y("mirror", 60009),
  mirrorPublic: y("mirror-public", 60009),
  star: y("star", 60010),
  starAdd: y("star-add", 60010),
  starDelete: y("star-delete", 60010),
  starEmpty: y("star-empty", 60010),
  comment: y("comment", 60011),
  commentAdd: y("comment-add", 60011),
  alert: y("alert", 60012),
  warning: y("warning", 60012),
  search: y("search", 60013),
  searchSave: y("search-save", 60013),
  logOut: y("log-out", 60014),
  signOut: y("sign-out", 60014),
  logIn: y("log-in", 60015),
  signIn: y("sign-in", 60015),
  eye: y("eye", 60016),
  eyeUnwatch: y("eye-unwatch", 60016),
  eyeWatch: y("eye-watch", 60016),
  circleFilled: y("circle-filled", 60017),
  primitiveDot: y("primitive-dot", 60017),
  closeDirty: y("close-dirty", 60017),
  debugBreakpoint: y("debug-breakpoint", 60017),
  debugBreakpointDisabled: y("debug-breakpoint-disabled", 60017),
  debugHint: y("debug-hint", 60017),
  terminalDecorationSuccess: y("terminal-decoration-success", 60017),
  primitiveSquare: y("primitive-square", 60018),
  edit: y("edit", 60019),
  pencil: y("pencil", 60019),
  info: y("info", 60020),
  issueOpened: y("issue-opened", 60020),
  gistPrivate: y("gist-private", 60021),
  gitForkPrivate: y("git-fork-private", 60021),
  lock: y("lock", 60021),
  mirrorPrivate: y("mirror-private", 60021),
  close: y("close", 60022),
  removeClose: y("remove-close", 60022),
  x: y("x", 60022),
  repoSync: y("repo-sync", 60023),
  sync: y("sync", 60023),
  clone: y("clone", 60024),
  desktopDownload: y("desktop-download", 60024),
  beaker: y("beaker", 60025),
  microscope: y("microscope", 60025),
  vm: y("vm", 60026),
  deviceDesktop: y("device-desktop", 60026),
  file: y("file", 60027),
  fileText: y("file-text", 60027),
  more: y("more", 60028),
  ellipsis: y("ellipsis", 60028),
  kebabHorizontal: y("kebab-horizontal", 60028),
  mailReply: y("mail-reply", 60029),
  reply: y("reply", 60029),
  organization: y("organization", 60030),
  organizationFilled: y("organization-filled", 60030),
  organizationOutline: y("organization-outline", 60030),
  newFile: y("new-file", 60031),
  fileAdd: y("file-add", 60031),
  newFolder: y("new-folder", 60032),
  fileDirectoryCreate: y("file-directory-create", 60032),
  trash: y("trash", 60033),
  trashcan: y("trashcan", 60033),
  history: y("history", 60034),
  clock: y("clock", 60034),
  folder: y("folder", 60035),
  fileDirectory: y("file-directory", 60035),
  symbolFolder: y("symbol-folder", 60035),
  logoGithub: y("logo-github", 60036),
  markGithub: y("mark-github", 60036),
  github: y("github", 60036),
  terminal: y("terminal", 60037),
  console: y("console", 60037),
  repl: y("repl", 60037),
  zap: y("zap", 60038),
  symbolEvent: y("symbol-event", 60038),
  error: y("error", 60039),
  stop: y("stop", 60039),
  variable: y("variable", 60040),
  symbolVariable: y("symbol-variable", 60040),
  array: y("array", 60042),
  symbolArray: y("symbol-array", 60042),
  symbolModule: y("symbol-module", 60043),
  symbolPackage: y("symbol-package", 60043),
  symbolNamespace: y("symbol-namespace", 60043),
  symbolObject: y("symbol-object", 60043),
  symbolMethod: y("symbol-method", 60044),
  symbolFunction: y("symbol-function", 60044),
  symbolConstructor: y("symbol-constructor", 60044),
  symbolBoolean: y("symbol-boolean", 60047),
  symbolNull: y("symbol-null", 60047),
  symbolNumeric: y("symbol-numeric", 60048),
  symbolNumber: y("symbol-number", 60048),
  symbolStructure: y("symbol-structure", 60049),
  symbolStruct: y("symbol-struct", 60049),
  symbolParameter: y("symbol-parameter", 60050),
  symbolTypeParameter: y("symbol-type-parameter", 60050),
  symbolKey: y("symbol-key", 60051),
  symbolText: y("symbol-text", 60051),
  symbolReference: y("symbol-reference", 60052),
  goToFile: y("go-to-file", 60052),
  symbolEnum: y("symbol-enum", 60053),
  symbolValue: y("symbol-value", 60053),
  symbolRuler: y("symbol-ruler", 60054),
  symbolUnit: y("symbol-unit", 60054),
  activateBreakpoints: y("activate-breakpoints", 60055),
  archive: y("archive", 60056),
  arrowBoth: y("arrow-both", 60057),
  arrowDown: y("arrow-down", 60058),
  arrowLeft: y("arrow-left", 60059),
  arrowRight: y("arrow-right", 60060),
  arrowSmallDown: y("arrow-small-down", 60061),
  arrowSmallLeft: y("arrow-small-left", 60062),
  arrowSmallRight: y("arrow-small-right", 60063),
  arrowSmallUp: y("arrow-small-up", 60064),
  arrowUp: y("arrow-up", 60065),
  bell: y("bell", 60066),
  bold: y("bold", 60067),
  book: y("book", 60068),
  bookmark: y("bookmark", 60069),
  debugBreakpointConditionalUnverified: y("debug-breakpoint-conditional-unverified", 60070),
  debugBreakpointConditional: y("debug-breakpoint-conditional", 60071),
  debugBreakpointConditionalDisabled: y("debug-breakpoint-conditional-disabled", 60071),
  debugBreakpointDataUnverified: y("debug-breakpoint-data-unverified", 60072),
  debugBreakpointData: y("debug-breakpoint-data", 60073),
  debugBreakpointDataDisabled: y("debug-breakpoint-data-disabled", 60073),
  debugBreakpointLogUnverified: y("debug-breakpoint-log-unverified", 60074),
  debugBreakpointLog: y("debug-breakpoint-log", 60075),
  debugBreakpointLogDisabled: y("debug-breakpoint-log-disabled", 60075),
  briefcase: y("briefcase", 60076),
  broadcast: y("broadcast", 60077),
  browser: y("browser", 60078),
  bug: y("bug", 60079),
  calendar: y("calendar", 60080),
  caseSensitive: y("case-sensitive", 60081),
  check: y("check", 60082),
  checklist: y("checklist", 60083),
  chevronDown: y("chevron-down", 60084),
  chevronLeft: y("chevron-left", 60085),
  chevronRight: y("chevron-right", 60086),
  chevronUp: y("chevron-up", 60087),
  chromeClose: y("chrome-close", 60088),
  chromeMaximize: y("chrome-maximize", 60089),
  chromeMinimize: y("chrome-minimize", 60090),
  chromeRestore: y("chrome-restore", 60091),
  circleOutline: y("circle-outline", 60092),
  circle: y("circle", 60092),
  debugBreakpointUnverified: y("debug-breakpoint-unverified", 60092),
  terminalDecorationIncomplete: y("terminal-decoration-incomplete", 60092),
  circleSlash: y("circle-slash", 60093),
  circuitBoard: y("circuit-board", 60094),
  clearAll: y("clear-all", 60095),
  clippy: y("clippy", 60096),
  closeAll: y("close-all", 60097),
  cloudDownload: y("cloud-download", 60098),
  cloudUpload: y("cloud-upload", 60099),
  code: y("code", 60100),
  collapseAll: y("collapse-all", 60101),
  colorMode: y("color-mode", 60102),
  commentDiscussion: y("comment-discussion", 60103),
  creditCard: y("credit-card", 60105),
  dash: y("dash", 60108),
  dashboard: y("dashboard", 60109),
  database: y("database", 60110),
  debugContinue: y("debug-continue", 60111),
  debugDisconnect: y("debug-disconnect", 60112),
  debugPause: y("debug-pause", 60113),
  debugRestart: y("debug-restart", 60114),
  debugStart: y("debug-start", 60115),
  debugStepInto: y("debug-step-into", 60116),
  debugStepOut: y("debug-step-out", 60117),
  debugStepOver: y("debug-step-over", 60118),
  debugStop: y("debug-stop", 60119),
  debug: y("debug", 60120),
  deviceCameraVideo: y("device-camera-video", 60121),
  deviceCamera: y("device-camera", 60122),
  deviceMobile: y("device-mobile", 60123),
  diffAdded: y("diff-added", 60124),
  diffIgnored: y("diff-ignored", 60125),
  diffModified: y("diff-modified", 60126),
  diffRemoved: y("diff-removed", 60127),
  diffRenamed: y("diff-renamed", 60128),
  diff: y("diff", 60129),
  diffSidebyside: y("diff-sidebyside", 60129),
  discard: y("discard", 60130),
  editorLayout: y("editor-layout", 60131),
  emptyWindow: y("empty-window", 60132),
  exclude: y("exclude", 60133),
  extensions: y("extensions", 60134),
  eyeClosed: y("eye-closed", 60135),
  fileBinary: y("file-binary", 60136),
  fileCode: y("file-code", 60137),
  fileMedia: y("file-media", 60138),
  filePdf: y("file-pdf", 60139),
  fileSubmodule: y("file-submodule", 60140),
  fileSymlinkDirectory: y("file-symlink-directory", 60141),
  fileSymlinkFile: y("file-symlink-file", 60142),
  fileZip: y("file-zip", 60143),
  files: y("files", 60144),
  filter: y("filter", 60145),
  flame: y("flame", 60146),
  foldDown: y("fold-down", 60147),
  foldUp: y("fold-up", 60148),
  fold: y("fold", 60149),
  folderActive: y("folder-active", 60150),
  folderOpened: y("folder-opened", 60151),
  gear: y("gear", 60152),
  gift: y("gift", 60153),
  gistSecret: y("gist-secret", 60154),
  gist: y("gist", 60155),
  gitCommit: y("git-commit", 60156),
  gitCompare: y("git-compare", 60157),
  compareChanges: y("compare-changes", 60157),
  gitMerge: y("git-merge", 60158),
  githubAction: y("github-action", 60159),
  githubAlt: y("github-alt", 60160),
  globe: y("globe", 60161),
  grabber: y("grabber", 60162),
  graph: y("graph", 60163),
  gripper: y("gripper", 60164),
  heart: y("heart", 60165),
  home: y("home", 60166),
  horizontalRule: y("horizontal-rule", 60167),
  hubot: y("hubot", 60168),
  inbox: y("inbox", 60169),
  issueReopened: y("issue-reopened", 60171),
  issues: y("issues", 60172),
  italic: y("italic", 60173),
  jersey: y("jersey", 60174),
  json: y("json", 60175),
  kebabVertical: y("kebab-vertical", 60176),
  key: y("key", 60177),
  law: y("law", 60178),
  lightbulbAutofix: y("lightbulb-autofix", 60179),
  linkExternal: y("link-external", 60180),
  link: y("link", 60181),
  listOrdered: y("list-ordered", 60182),
  listUnordered: y("list-unordered", 60183),
  liveShare: y("live-share", 60184),
  loading: y("loading", 60185),
  location: y("location", 60186),
  mailRead: y("mail-read", 60187),
  mail: y("mail", 60188),
  markdown: y("markdown", 60189),
  megaphone: y("megaphone", 60190),
  mention: y("mention", 60191),
  milestone: y("milestone", 60192),
  gitPullRequestMilestone: y("git-pull-request-milestone", 60192),
  mortarBoard: y("mortar-board", 60193),
  move: y("move", 60194),
  multipleWindows: y("multiple-windows", 60195),
  mute: y("mute", 60196),
  noNewline: y("no-newline", 60197),
  note: y("note", 60198),
  octoface: y("octoface", 60199),
  openPreview: y("open-preview", 60200),
  package: y("package", 60201),
  paintcan: y("paintcan", 60202),
  pin: y("pin", 60203),
  play: y("play", 60204),
  run: y("run", 60204),
  plug: y("plug", 60205),
  preserveCase: y("preserve-case", 60206),
  preview: y("preview", 60207),
  project: y("project", 60208),
  pulse: y("pulse", 60209),
  question: y("question", 60210),
  quote: y("quote", 60211),
  radioTower: y("radio-tower", 60212),
  reactions: y("reactions", 60213),
  references: y("references", 60214),
  refresh: y("refresh", 60215),
  regex: y("regex", 60216),
  remoteExplorer: y("remote-explorer", 60217),
  remote: y("remote", 60218),
  remove: y("remove", 60219),
  replaceAll: y("replace-all", 60220),
  replace: y("replace", 60221),
  repoClone: y("repo-clone", 60222),
  repoForcePush: y("repo-force-push", 60223),
  repoPull: y("repo-pull", 60224),
  repoPush: y("repo-push", 60225),
  report: y("report", 60226),
  requestChanges: y("request-changes", 60227),
  rocket: y("rocket", 60228),
  rootFolderOpened: y("root-folder-opened", 60229),
  rootFolder: y("root-folder", 60230),
  rss: y("rss", 60231),
  ruby: y("ruby", 60232),
  saveAll: y("save-all", 60233),
  saveAs: y("save-as", 60234),
  save: y("save", 60235),
  screenFull: y("screen-full", 60236),
  screenNormal: y("screen-normal", 60237),
  searchStop: y("search-stop", 60238),
  server: y("server", 60240),
  settingsGear: y("settings-gear", 60241),
  settings: y("settings", 60242),
  shield: y("shield", 60243),
  smiley: y("smiley", 60244),
  sortPrecedence: y("sort-precedence", 60245),
  splitHorizontal: y("split-horizontal", 60246),
  splitVertical: y("split-vertical", 60247),
  squirrel: y("squirrel", 60248),
  starFull: y("star-full", 60249),
  starHalf: y("star-half", 60250),
  symbolClass: y("symbol-class", 60251),
  symbolColor: y("symbol-color", 60252),
  symbolConstant: y("symbol-constant", 60253),
  symbolEnumMember: y("symbol-enum-member", 60254),
  symbolField: y("symbol-field", 60255),
  symbolFile: y("symbol-file", 60256),
  symbolInterface: y("symbol-interface", 60257),
  symbolKeyword: y("symbol-keyword", 60258),
  symbolMisc: y("symbol-misc", 60259),
  symbolOperator: y("symbol-operator", 60260),
  symbolProperty: y("symbol-property", 60261),
  wrench: y("wrench", 60261),
  wrenchSubaction: y("wrench-subaction", 60261),
  symbolSnippet: y("symbol-snippet", 60262),
  tasklist: y("tasklist", 60263),
  telescope: y("telescope", 60264),
  textSize: y("text-size", 60265),
  threeBars: y("three-bars", 60266),
  thumbsdown: y("thumbsdown", 60267),
  thumbsup: y("thumbsup", 60268),
  tools: y("tools", 60269),
  triangleDown: y("triangle-down", 60270),
  triangleLeft: y("triangle-left", 60271),
  triangleRight: y("triangle-right", 60272),
  triangleUp: y("triangle-up", 60273),
  twitter: y("twitter", 60274),
  unfold: y("unfold", 60275),
  unlock: y("unlock", 60276),
  unmute: y("unmute", 60277),
  unverified: y("unverified", 60278),
  verified: y("verified", 60279),
  versions: y("versions", 60280),
  vmActive: y("vm-active", 60281),
  vmOutline: y("vm-outline", 60282),
  vmRunning: y("vm-running", 60283),
  watch: y("watch", 60284),
  whitespace: y("whitespace", 60285),
  wholeWord: y("whole-word", 60286),
  window: y("window", 60287),
  wordWrap: y("word-wrap", 60288),
  zoomIn: y("zoom-in", 60289),
  zoomOut: y("zoom-out", 60290),
  listFilter: y("list-filter", 60291),
  listFlat: y("list-flat", 60292),
  listSelection: y("list-selection", 60293),
  selection: y("selection", 60293),
  listTree: y("list-tree", 60294),
  debugBreakpointFunctionUnverified: y("debug-breakpoint-function-unverified", 60295),
  debugBreakpointFunction: y("debug-breakpoint-function", 60296),
  debugBreakpointFunctionDisabled: y("debug-breakpoint-function-disabled", 60296),
  debugStackframeActive: y("debug-stackframe-active", 60297),
  circleSmallFilled: y("circle-small-filled", 60298),
  debugStackframeDot: y("debug-stackframe-dot", 60298),
  terminalDecorationMark: y("terminal-decoration-mark", 60298),
  debugStackframe: y("debug-stackframe", 60299),
  debugStackframeFocused: y("debug-stackframe-focused", 60299),
  debugBreakpointUnsupported: y("debug-breakpoint-unsupported", 60300),
  symbolString: y("symbol-string", 60301),
  debugReverseContinue: y("debug-reverse-continue", 60302),
  debugStepBack: y("debug-step-back", 60303),
  debugRestartFrame: y("debug-restart-frame", 60304),
  debugAlt: y("debug-alt", 60305),
  callIncoming: y("call-incoming", 60306),
  callOutgoing: y("call-outgoing", 60307),
  menu: y("menu", 60308),
  expandAll: y("expand-all", 60309),
  feedback: y("feedback", 60310),
  gitPullRequestReviewer: y("git-pull-request-reviewer", 60310),
  groupByRefType: y("group-by-ref-type", 60311),
  ungroupByRefType: y("ungroup-by-ref-type", 60312),
  account: y("account", 60313),
  gitPullRequestAssignee: y("git-pull-request-assignee", 60313),
  bellDot: y("bell-dot", 60314),
  debugConsole: y("debug-console", 60315),
  library: y("library", 60316),
  output: y("output", 60317),
  runAll: y("run-all", 60318),
  syncIgnored: y("sync-ignored", 60319),
  pinned: y("pinned", 60320),
  githubInverted: y("github-inverted", 60321),
  serverProcess: y("server-process", 60322),
  serverEnvironment: y("server-environment", 60323),
  pass: y("pass", 60324),
  issueClosed: y("issue-closed", 60324),
  stopCircle: y("stop-circle", 60325),
  playCircle: y("play-circle", 60326),
  record: y("record", 60327),
  debugAltSmall: y("debug-alt-small", 60328),
  vmConnect: y("vm-connect", 60329),
  cloud: y("cloud", 60330),
  merge: y("merge", 60331),
  export: y("export", 60332),
  graphLeft: y("graph-left", 60333),
  magnet: y("magnet", 60334),
  notebook: y("notebook", 60335),
  redo: y("redo", 60336),
  checkAll: y("check-all", 60337),
  pinnedDirty: y("pinned-dirty", 60338),
  passFilled: y("pass-filled", 60339),
  circleLargeFilled: y("circle-large-filled", 60340),
  circleLarge: y("circle-large", 60341),
  circleLargeOutline: y("circle-large-outline", 60341),
  combine: y("combine", 60342),
  gather: y("gather", 60342),
  table: y("table", 60343),
  variableGroup: y("variable-group", 60344),
  typeHierarchy: y("type-hierarchy", 60345),
  typeHierarchySub: y("type-hierarchy-sub", 60346),
  typeHierarchySuper: y("type-hierarchy-super", 60347),
  gitPullRequestCreate: y("git-pull-request-create", 60348),
  runAbove: y("run-above", 60349),
  runBelow: y("run-below", 60350),
  notebookTemplate: y("notebook-template", 60351),
  debugRerun: y("debug-rerun", 60352),
  workspaceTrusted: y("workspace-trusted", 60353),
  workspaceUntrusted: y("workspace-untrusted", 60354),
  workspaceUnknown: y("workspace-unknown", 60355),
  terminalCmd: y("terminal-cmd", 60356),
  terminalDebian: y("terminal-debian", 60357),
  terminalLinux: y("terminal-linux", 60358),
  terminalPowershell: y("terminal-powershell", 60359),
  terminalTmux: y("terminal-tmux", 60360),
  terminalUbuntu: y("terminal-ubuntu", 60361),
  terminalBash: y("terminal-bash", 60362),
  arrowSwap: y("arrow-swap", 60363),
  copy: y("copy", 60364),
  personAdd: y("person-add", 60365),
  filterFilled: y("filter-filled", 60366),
  wand: y("wand", 60367),
  debugLineByLine: y("debug-line-by-line", 60368),
  inspect: y("inspect", 60369),
  layers: y("layers", 60370),
  layersDot: y("layers-dot", 60371),
  layersActive: y("layers-active", 60372),
  compass: y("compass", 60373),
  compassDot: y("compass-dot", 60374),
  compassActive: y("compass-active", 60375),
  azure: y("azure", 60376),
  issueDraft: y("issue-draft", 60377),
  gitPullRequestClosed: y("git-pull-request-closed", 60378),
  gitPullRequestDraft: y("git-pull-request-draft", 60379),
  debugAll: y("debug-all", 60380),
  debugCoverage: y("debug-coverage", 60381),
  runErrors: y("run-errors", 60382),
  folderLibrary: y("folder-library", 60383),
  debugContinueSmall: y("debug-continue-small", 60384),
  beakerStop: y("beaker-stop", 60385),
  graphLine: y("graph-line", 60386),
  graphScatter: y("graph-scatter", 60387),
  pieChart: y("pie-chart", 60388),
  bracket: y("bracket", 60175),
  bracketDot: y("bracket-dot", 60389),
  bracketError: y("bracket-error", 60390),
  lockSmall: y("lock-small", 60391),
  azureDevops: y("azure-devops", 60392),
  verifiedFilled: y("verified-filled", 60393),
  newline: y("newline", 60394),
  layout: y("layout", 60395),
  layoutActivitybarLeft: y("layout-activitybar-left", 60396),
  layoutActivitybarRight: y("layout-activitybar-right", 60397),
  layoutPanelLeft: y("layout-panel-left", 60398),
  layoutPanelCenter: y("layout-panel-center", 60399),
  layoutPanelJustify: y("layout-panel-justify", 60400),
  layoutPanelRight: y("layout-panel-right", 60401),
  layoutPanel: y("layout-panel", 60402),
  layoutSidebarLeft: y("layout-sidebar-left", 60403),
  layoutSidebarRight: y("layout-sidebar-right", 60404),
  layoutStatusbar: y("layout-statusbar", 60405),
  layoutMenubar: y("layout-menubar", 60406),
  layoutCentered: y("layout-centered", 60407),
  target: y("target", 60408),
  indent: y("indent", 60409),
  recordSmall: y("record-small", 60410),
  errorSmall: y("error-small", 60411),
  terminalDecorationError: y("terminal-decoration-error", 60411),
  arrowCircleDown: y("arrow-circle-down", 60412),
  arrowCircleLeft: y("arrow-circle-left", 60413),
  arrowCircleRight: y("arrow-circle-right", 60414),
  arrowCircleUp: y("arrow-circle-up", 60415),
  layoutSidebarRightOff: y("layout-sidebar-right-off", 60416),
  layoutPanelOff: y("layout-panel-off", 60417),
  layoutSidebarLeftOff: y("layout-sidebar-left-off", 60418),
  blank: y("blank", 60419),
  heartFilled: y("heart-filled", 60420),
  map: y("map", 60421),
  mapHorizontal: y("map-horizontal", 60421),
  foldHorizontal: y("fold-horizontal", 60421),
  mapFilled: y("map-filled", 60422),
  mapHorizontalFilled: y("map-horizontal-filled", 60422),
  foldHorizontalFilled: y("fold-horizontal-filled", 60422),
  circleSmall: y("circle-small", 60423),
  bellSlash: y("bell-slash", 60424),
  bellSlashDot: y("bell-slash-dot", 60425),
  commentUnresolved: y("comment-unresolved", 60426),
  gitPullRequestGoToChanges: y("git-pull-request-go-to-changes", 60427),
  gitPullRequestNewChanges: y("git-pull-request-new-changes", 60428),
  searchFuzzy: y("search-fuzzy", 60429),
  commentDraft: y("comment-draft", 60430),
  send: y("send", 60431),
  sparkle: y("sparkle", 60432),
  insert: y("insert", 60433),
  mic: y("mic", 60434),
  thumbsdownFilled: y("thumbsdown-filled", 60435),
  thumbsupFilled: y("thumbsup-filled", 60436),
  coffee: y("coffee", 60437),
  snake: y("snake", 60438),
  game: y("game", 60439),
  vr: y("vr", 60440),
  chip: y("chip", 60441),
  piano: y("piano", 60442),
  music: y("music", 60443),
  micFilled: y("mic-filled", 60444),
  repoFetch: y("repo-fetch", 60445),
  copilot: y("copilot", 60446),
  lightbulbSparkle: y("lightbulb-sparkle", 60447),
  robot: y("robot", 60448),
  sparkleFilled: y("sparkle-filled", 60449),
  diffSingle: y("diff-single", 60450),
  diffMultiple: y("diff-multiple", 60451),
  surroundWith: y("surround-with", 60452),
  share: y("share", 60453),
  gitStash: y("git-stash", 60454),
  gitStashApply: y("git-stash-apply", 60455),
  gitStashPop: y("git-stash-pop", 60456),
  vscode: y("vscode", 60457),
  vscodeInsiders: y("vscode-insiders", 60458),
  codeOss: y("code-oss", 60459),
  runCoverage: y("run-coverage", 60460),
  runAllCoverage: y("run-all-coverage", 60461),
  coverage: y("coverage", 60462),
  githubProject: y("github-project", 60463),
  mapVertical: y("map-vertical", 60464),
  foldVertical: y("fold-vertical", 60464),
  mapVerticalFilled: y("map-vertical-filled", 60465),
  foldVerticalFilled: y("fold-vertical-filled", 60465),
  goToSearch: y("go-to-search", 60466),
  percentage: y("percentage", 60467),
  sortPercentage: y("sort-percentage", 60467),
  attach: y("attach", 60468)
}, c8 = {
  dialogError: y("dialog-error", "error"),
  dialogWarning: y("dialog-warning", "warning"),
  dialogInfo: y("dialog-info", "info"),
  dialogClose: y("dialog-close", "close"),
  treeItemExpanded: y("tree-item-expanded", "chevron-down"),
  // collapsed is done with rotation
  treeFilterOnTypeOn: y("tree-filter-on-type-on", "list-filter"),
  treeFilterOnTypeOff: y("tree-filter-on-type-off", "list-selection"),
  treeFilterClear: y("tree-filter-clear", "close"),
  treeItemLoading: y("tree-item-loading", "loading"),
  menuSelection: y("menu-selection", "check"),
  menuSubmenu: y("menu-submenu", "chevron-right"),
  menuBarMore: y("menubar-more", "more"),
  scrollbarButtonLeft: y("scrollbar-button-left", "triangle-left"),
  scrollbarButtonRight: y("scrollbar-button-right", "triangle-right"),
  scrollbarButtonUp: y("scrollbar-button-up", "triangle-up"),
  scrollbarButtonDown: y("scrollbar-button-down", "triangle-down"),
  toolBarMore: y("toolbar-more", "more"),
  quickInputBack: y("quick-input-back", "arrow-left"),
  dropDownButton: y("drop-down-button", 60084),
  symbolCustomColor: y("symbol-customcolor", 60252),
  exportIcon: y("export", 60332),
  workspaceUnspecified: y("workspace-unspecified", 60355),
  newLine: y("newline", 60394),
  thumbsDownFilled: y("thumbsdown-filled", 60435),
  thumbsUpFilled: y("thumbsup-filled", 60436),
  gitFetch: y("git-fetch", 60445),
  lightbulbSparkleAutofix: y("lightbulb-sparkle-autofix", 60447),
  debugBreakpointPending: y("debug-breakpoint-pending", 60377)
}, ie = {
  ...l8,
  ...c8
};
var Hy;
(function(s) {
  function e(t) {
    return t && typeof t == "object" && typeof t.id == "string";
  }
  s.isThemeColor = e;
})(Hy || (Hy = {}));
var Te;
(function(s) {
  s.iconNameSegment = "[A-Za-z0-9]+", s.iconNameExpression = "[A-Za-z0-9-]+", s.iconModifierExpression = "~[A-Za-z]+", s.iconNameCharacter = "[A-Za-z0-9~-]";
  const e = new RegExp(`^(${s.iconNameExpression})(${s.iconModifierExpression})?$`);
  function t(u) {
    const f = e.exec(u.id);
    if (!f)
      return t(ie.error);
    const [, g, p] = f, _ = ["codicon", "codicon-" + g];
    return p && _.push("codicon-modifier-" + p.substring(1)), _;
  }
  s.asClassNameArray = t;
  function i(u) {
    return t(u).join(" ");
  }
  s.asClassName = i;
  function n(u) {
    return "." + t(u).join(".");
  }
  s.asCSSSelector = n;
  function o(u) {
    return u && typeof u == "object" && typeof u.id == "string" && (typeof u.color > "u" || Hy.isThemeColor(u.color));
  }
  s.isThemeIcon = o;
  const r = new RegExp(`^\\$\\((${s.iconNameExpression}(?:${s.iconModifierExpression})?)\\)$`);
  function a(u) {
    const f = r.exec(u);
    if (!f)
      return;
    const [, g] = f;
    return { id: g };
  }
  s.fromString = a;
  function l(u) {
    return { id: u };
  }
  s.fromId = l;
  function c(u, f) {
    let g = u.id;
    const p = g.lastIndexOf("~");
    return p !== -1 && (g = g.substring(0, p)), f && (g = `${g}~${f}`), { id: g };
  }
  s.modify = c;
  function h(u) {
    const f = u.id.lastIndexOf("~");
    if (f !== -1)
      return u.id.substring(f + 1);
  }
  s.getModifier = h;
  function d(u, f) {
    var g, p;
    return u.id === f.id && ((g = u.color) == null ? void 0 : g.id) === ((p = f.color) == null ? void 0 : p.id);
  }
  s.isEqual = d;
})(Te || (Te = {}));
const fi = Be("commandService"), St = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._onDidRegisterCommand = new A(), this.onDidRegisterCommand = this._onDidRegisterCommand.event;
  }
  registerCommand(s, e) {
    if (!s)
      throw new Error("invalid command");
    if (typeof s == "string") {
      if (!e)
        throw new Error("invalid command");
      return this.registerCommand({ id: s, handler: e });
    }
    if (s.metadata && Array.isArray(s.metadata.args)) {
      const r = [];
      for (const l of s.metadata.args)
        r.push(l.constraint);
      const a = s.handler;
      s.handler = function(l, ...c) {
        return r8(c, r), a(l, ...c);
      };
    }
    const { id: t } = s;
    let i = this._commands.get(t);
    i || (i = new Tn(), this._commands.set(t, i));
    const n = i.unshift(s), o = _e(() => {
      n();
      const r = this._commands.get(t);
      r != null && r.isEmpty() && this._commands.delete(t);
    });
    return this._onDidRegisterCommand.fire(t), o;
  }
  registerCommandAlias(s, e) {
    return St.registerCommand(s, (t, ...i) => t.get(fi).executeCommand(e, ...i));
  }
  getCommand(s) {
    const e = this._commands.get(s);
    if (!(!e || e.isEmpty()))
      return nt.first(e);
  }
  getCommands() {
    const s = /* @__PURE__ */ new Map();
    for (const e of this._commands.keys()) {
      const t = this.getCommand(e);
      t && s.set(e, t);
    }
    return s;
  }
}();
St.registerCommand("noop", () => {
});
function l4(s) {
  return s;
}
class h8 {
  constructor(e, t) {
    this.lastCache = void 0, this.lastArgKey = void 0, typeof e == "function" ? (this._fn = e, this._computeKey = l4) : (this._fn = t, this._computeKey = e.getCacheKey);
  }
  get(e) {
    const t = this._computeKey(e);
    return this.lastArgKey !== t && (this.lastArgKey = t, this.lastCache = this._fn(e)), this.lastCache;
  }
}
class f2 {
  get cachedValues() {
    return this._map;
  }
  constructor(e, t) {
    this._map = /* @__PURE__ */ new Map(), this._map2 = /* @__PURE__ */ new Map(), typeof e == "function" ? (this._fn = e, this._computeKey = l4) : (this._fn = t, this._computeKey = e.getCacheKey);
  }
  get(e) {
    const t = this._computeKey(e);
    if (this._map2.has(t))
      return this._map2.get(t);
    const i = this._fn(e);
    return this._map.set(e, i), this._map2.set(t, i), i;
  }
}
class Fr {
  constructor(e) {
    this.executor = e, this._didRun = !1;
  }
  /**
   * Get the wrapped value.
   *
   * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
   * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
   */
  get value() {
    if (!this._didRun)
      try {
        this._value = this.executor();
      } catch (e) {
        this._error = e;
      } finally {
        this._didRun = !0;
      }
    if (this._error)
      throw this._error;
    return this._value;
  }
  /**
   * Get the wrapped value without forcing evaluation.
   */
  get rawValue() {
    return this._value;
  }
}
function d8(s) {
  return !s || typeof s != "string" ? !0 : s.trim().length === 0;
}
const u8 = /{(\d+)}/g;
function Hb(s, ...e) {
  return e.length === 0 ? s : s.replace(u8, function(t, i) {
    const n = parseInt(i, 10);
    return isNaN(n) || n < 0 || n >= e.length ? t : e[n];
  });
}
function f8(s) {
  return s.replace(/[<>"'&]/g, (e) => {
    switch (e) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case '"':
        return "&quot;";
      case "'":
        return "&apos;";
      case "&":
        return "&amp;";
    }
    return e;
  });
}
function Ng(s) {
  return s.replace(/[<>&]/g, function(e) {
    switch (e) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case "&":
        return "&amp;";
      default:
        return e;
    }
  });
}
function za(s) {
  return s.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function Hv(s, e) {
  if (!s || !e)
    return s;
  const t = e.length;
  if (t === 0 || s.length === 0)
    return s;
  let i = 0;
  for (; s.indexOf(e, i) === i; )
    i = i + t;
  return s.substring(i);
}
function g8(s, e) {
  if (!s)
    return s;
  const t = e.length, i = s.length;
  if (t === 0 || i === 0)
    return s;
  let n = i, o = -1;
  for (; o = s.lastIndexOf(e, n - 1), !(o === -1 || o + t !== n); ) {
    if (o === 0)
      return "";
    n = o;
  }
  return s.substring(0, n);
}
function m8(s) {
  return s.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&").replace(/[\*]/g, ".*");
}
function c4(s, e, t = {}) {
  if (!s)
    throw new Error("Cannot create regex from empty string");
  e || (s = za(s)), t.wholeWord && (/\B/.test(s.charAt(0)) || (s = "\\b" + s), /\B/.test(s.charAt(s.length - 1)) || (s = s + "\\b"));
  let i = "";
  return t.global && (i += "g"), t.matchCase || (i += "i"), t.multiline && (i += "m"), t.unicode && (i += "u"), new RegExp(s, i);
}
function p8(s) {
  return s.source === "^" || s.source === "^$" || s.source === "$" || s.source === "^\\s*$" ? !1 : !!(s.exec("") && s.lastIndex === 0);
}
function td(s) {
  return s.split(/\r\n|\r|\n/);
}
function Zn(s) {
  for (let e = 0, t = s.length; e < t; e++) {
    const i = s.charCodeAt(e);
    if (i !== 32 && i !== 9)
      return e;
  }
  return -1;
}
function gn(s, e = 0, t = s.length) {
  for (let i = e; i < t; i++) {
    const n = s.charCodeAt(i);
    if (n !== 32 && n !== 9)
      return s.substring(e, i);
  }
  return s.substring(e, t);
}
function id(s, e = s.length - 1) {
  for (let t = e; t >= 0; t--) {
    const i = s.charCodeAt(t);
    if (i !== 32 && i !== 9)
      return t;
  }
  return -1;
}
function Lm(s, e) {
  return s < e ? -1 : s > e ? 1 : 0;
}
function lE(s, e, t = 0, i = s.length, n = 0, o = e.length) {
  for (; t < i && n < o; t++, n++) {
    const l = s.charCodeAt(t), c = e.charCodeAt(n);
    if (l < c)
      return -1;
    if (l > c)
      return 1;
  }
  const r = i - t, a = o - n;
  return r < a ? -1 : r > a ? 1 : 0;
}
function g2(s, e) {
  return Dp(s, e, 0, s.length, 0, e.length);
}
function Dp(s, e, t = 0, i = s.length, n = 0, o = e.length) {
  for (; t < i && n < o; t++, n++) {
    let l = s.charCodeAt(t), c = e.charCodeAt(n);
    if (l === c)
      continue;
    if (l >= 128 || c >= 128)
      return lE(s.toLowerCase(), e.toLowerCase(), t, i, n, o);
    Gd(l) && (l -= 32), Gd(c) && (c -= 32);
    const h = l - c;
    if (h !== 0)
      return h;
  }
  const r = i - t, a = o - n;
  return r < a ? -1 : r > a ? 1 : 0;
}
function n_(s) {
  return s >= 48 && s <= 57;
}
function Gd(s) {
  return s >= 97 && s <= 122;
}
function dl(s) {
  return s >= 65 && s <= 90;
}
function Zd(s, e) {
  return s.length === e.length && Dp(s, e) === 0;
}
function cE(s, e) {
  const t = e.length;
  return e.length > s.length ? !1 : Dp(s, e, 0, t) === 0;
}
function Vb(s, e) {
  const t = Math.min(s.length, e.length);
  let i;
  for (i = 0; i < t; i++)
    if (s.charCodeAt(i) !== e.charCodeAt(i))
      return i;
  return t;
}
function Vy(s, e) {
  const t = Math.min(s.length, e.length);
  let i;
  const n = s.length - 1, o = e.length - 1;
  for (i = 0; i < t; i++)
    if (s.charCodeAt(n - i) !== e.charCodeAt(o - i))
      return i;
  return t;
}
function Si(s) {
  return 55296 <= s && s <= 56319;
}
function sf(s) {
  return 56320 <= s && s <= 57343;
}
function hE(s, e) {
  return (s - 55296 << 10) + (e - 56320) + 65536;
}
function zb(s, e, t) {
  const i = s.charCodeAt(t);
  if (Si(i) && t + 1 < e) {
    const n = s.charCodeAt(t + 1);
    if (sf(n))
      return hE(i, n);
  }
  return i;
}
function _8(s, e) {
  const t = s.charCodeAt(e - 1);
  if (sf(t) && e > 1) {
    const i = s.charCodeAt(e - 2);
    if (Si(i))
      return hE(i, t);
  }
  return t;
}
class dE {
  get offset() {
    return this._offset;
  }
  constructor(e, t = 0) {
    this._str = e, this._len = e.length, this._offset = t;
  }
  setOffset(e) {
    this._offset = e;
  }
  prevCodePoint() {
    const e = _8(this._str, this._offset);
    return this._offset -= e >= 65536 ? 2 : 1, e;
  }
  nextCodePoint() {
    const e = zb(this._str, this._len, this._offset);
    return this._offset += e >= 65536 ? 2 : 1, e;
  }
  eol() {
    return this._offset >= this._len;
  }
}
class Ub {
  get offset() {
    return this._iterator.offset;
  }
  constructor(e, t = 0) {
    this._iterator = new dE(e, t);
  }
  nextGraphemeLength() {
    const e = $b.getInstance(), t = this._iterator, i = t.offset;
    let n = e.getGraphemeBreakType(t.nextCodePoint());
    for (; !t.eol(); ) {
      const o = t.offset, r = e.getGraphemeBreakType(t.nextCodePoint());
      if (m2(n, r)) {
        t.setOffset(o);
        break;
      }
      n = r;
    }
    return t.offset - i;
  }
  prevGraphemeLength() {
    const e = $b.getInstance(), t = this._iterator, i = t.offset;
    let n = e.getGraphemeBreakType(t.prevCodePoint());
    for (; t.offset > 0; ) {
      const o = t.offset, r = e.getGraphemeBreakType(t.prevCodePoint());
      if (m2(r, n)) {
        t.setOffset(o);
        break;
      }
      n = r;
    }
    return i - t.offset;
  }
  eol() {
    return this._iterator.eol();
  }
}
function uE(s, e) {
  return new Ub(s, e).nextGraphemeLength();
}
function h4(s, e) {
  return new Ub(s, e).prevGraphemeLength();
}
function b8(s, e) {
  e > 0 && sf(s.charCodeAt(e)) && e--;
  const t = e + uE(s, e);
  return [t - h4(s, t), t];
}
let n0;
function C8() {
  return /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
}
function km(s) {
  return n0 || (n0 = C8()), n0.test(s);
}
const v8 = /^[\t\n\r\x20-\x7E]*$/;
function fE(s) {
  return v8.test(s);
}
const d4 = /[\u2028\u2029]/;
function u4(s) {
  return d4.test(s);
}
function jl(s) {
  return s >= 11904 && s <= 55215 || s >= 63744 && s <= 64255 || s >= 65281 && s <= 65374;
}
function gE(s) {
  return s >= 127462 && s <= 127487 || s === 8986 || s === 8987 || s === 9200 || s === 9203 || s >= 9728 && s <= 10175 || s === 11088 || s === 11093 || s >= 127744 && s <= 128591 || s >= 128640 && s <= 128764 || s >= 128992 && s <= 129008 || s >= 129280 && s <= 129535 || s >= 129648 && s <= 129782;
}
const w8 = "\uFEFF";
function mE(s) {
  return !!(s && s.length > 0 && s.charCodeAt(0) === 65279);
}
function f4(s) {
  return s = s % (2 * 26), s < 26 ? String.fromCharCode(97 + s) : String.fromCharCode(65 + s - 26);
}
function m2(s, e) {
  return s === 0 ? e !== 5 && e !== 7 : s === 2 && e === 3 ? !1 : s === 4 || s === 2 || s === 3 || e === 4 || e === 2 || e === 3 ? !0 : !(s === 8 && (e === 8 || e === 9 || e === 11 || e === 12) || (s === 11 || s === 9) && (e === 9 || e === 10) || (s === 12 || s === 10) && e === 10 || e === 5 || e === 13 || e === 7 || s === 1 || s === 13 && e === 14 || s === 6 && e === 6);
}
const Uc = class Uc {
  static getInstance() {
    return Uc._INSTANCE || (Uc._INSTANCE = new Uc()), Uc._INSTANCE;
  }
  constructor() {
    this._data = y8();
  }
  getGraphemeBreakType(e) {
    if (e < 32)
      return e === 10 ? 3 : e === 13 ? 2 : 4;
    if (e < 127)
      return 0;
    const t = this._data, i = t.length / 3;
    let n = 1;
    for (; n <= i; )
      if (e < t[3 * n])
        n = 2 * n;
      else if (e > t[3 * n + 1])
        n = 2 * n + 1;
      else
        return t[3 * n + 2];
    return 0;
  }
};
Uc._INSTANCE = null;
let $b = Uc;
function y8() {
  return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
}
function S8(s, e) {
  if (s === 0)
    return 0;
  const t = L8(s, e);
  if (t !== void 0)
    return t;
  const i = new dE(e, s);
  return i.prevCodePoint(), i.offset;
}
function L8(s, e) {
  const t = new dE(e, s);
  let i = t.prevCodePoint();
  for (; k8(i) || i === 65039 || i === 8419; ) {
    if (t.offset === 0)
      return;
    i = t.prevCodePoint();
  }
  if (!gE(i))
    return;
  let n = t.offset;
  return n > 0 && t.prevCodePoint() === 8205 && (n = t.offset), n;
}
function k8(s) {
  return 127995 <= s && s <= 127999;
}
const x8 = " ", _r = class _r {
  static getInstance(e) {
    return _r.cache.get(Array.from(e));
  }
  static getLocales() {
    return _r._locales.value;
  }
  constructor(e) {
    this.confusableDictionary = e;
  }
  isAmbiguous(e) {
    return this.confusableDictionary.has(e);
  }
  /**
   * Returns the non basic ASCII code point that the given code point can be confused,
   * or undefined if such code point does note exist.
   */
  getPrimaryConfusable(e) {
    return this.confusableDictionary.get(e);
  }
  getConfusableCodePoints() {
    return new Set(this.confusableDictionary.keys());
  }
};
_r.ambiguousCharacterData = new Fr(() => JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}')), _r.cache = new h8({ getCacheKey: JSON.stringify }, (e) => {
  function t(h) {
    const d = /* @__PURE__ */ new Map();
    for (let u = 0; u < h.length; u += 2)
      d.set(h[u], h[u + 1]);
    return d;
  }
  function i(h, d) {
    const u = new Map(h);
    for (const [f, g] of d)
      u.set(f, g);
    return u;
  }
  function n(h, d) {
    if (!h)
      return d;
    const u = /* @__PURE__ */ new Map();
    for (const [f, g] of h)
      d.has(f) && u.set(f, g);
    return u;
  }
  const o = _r.ambiguousCharacterData.value;
  let r = e.filter((h) => !h.startsWith("_") && h in o);
  r.length === 0 && (r = ["_default"]);
  let a;
  for (const h of r) {
    const d = t(o[h]);
    a = n(a, d);
  }
  const l = t(o._common), c = i(l, a);
  return new _r(c);
}), _r._locales = new Fr(() => Object.keys(_r.ambiguousCharacterData.value).filter((e) => !e.startsWith("_")));
let xm = _r;
const mu = class mu {
  static getRawData() {
    return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
  }
  static getData() {
    return this._data || (this._data = new Set(mu.getRawData())), this._data;
  }
  static isInvisibleCharacter(e) {
    return mu.getData().has(e);
  }
  static get codePoints() {
    return mu.getData();
  }
};
mu._data = void 0;
let Tg = mu;
function s0(...s) {
  switch (s.length) {
    case 1:
      return m("contextkey.scanner.hint.didYouMean1", "Did you mean {0}?", s[0]);
    case 2:
      return m("contextkey.scanner.hint.didYouMean2", "Did you mean {0} or {1}?", s[0], s[1]);
    case 3:
      return m("contextkey.scanner.hint.didYouMean3", "Did you mean {0}, {1} or {2}?", s[0], s[1], s[2]);
    default:
      return;
  }
}
const D8 = m("contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote", "Did you forget to open or close the quote?"), E8 = m("contextkey.scanner.hint.didYouForgetToEscapeSlash", "Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\/'."), pu = class pu {
  constructor() {
    this._input = "", this._start = 0, this._current = 0, this._tokens = [], this._errors = [], this.stringRe = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy;
  }
  static getLexeme(e) {
    switch (e.type) {
      case 0:
        return "(";
      case 1:
        return ")";
      case 2:
        return "!";
      case 3:
        return e.isTripleEq ? "===" : "==";
      case 4:
        return e.isTripleEq ? "!==" : "!=";
      case 5:
        return "<";
      case 6:
        return "<=";
      case 7:
        return ">=";
      case 8:
        return ">=";
      case 9:
        return "=~";
      case 10:
        return e.lexeme;
      case 11:
        return "true";
      case 12:
        return "false";
      case 13:
        return "in";
      case 14:
        return "not";
      case 15:
        return "&&";
      case 16:
        return "||";
      case 17:
        return e.lexeme;
      case 18:
        return e.lexeme;
      case 19:
        return e.lexeme;
      case 20:
        return "EOF";
      default:
        throw oE(`unhandled token type: ${JSON.stringify(e)}; have you forgotten to add a case?`);
    }
  }
  reset(e) {
    return this._input = e, this._start = 0, this._current = 0, this._tokens = [], this._errors = [], this;
  }
  scan() {
    for (; !this._isAtEnd(); )
      switch (this._start = this._current, this._advance()) {
        case 40:
          this._addToken(
            0
            /* TokenType.LParen */
          );
          break;
        case 41:
          this._addToken(
            1
            /* TokenType.RParen */
          );
          break;
        case 33:
          if (this._match(
            61
            /* CharCode.Equals */
          )) {
            const t = this._match(
              61
              /* CharCode.Equals */
            );
            this._tokens.push({ type: 4, offset: this._start, isTripleEq: t });
          } else
            this._addToken(
              2
              /* TokenType.Neg */
            );
          break;
        case 39:
          this._quotedString();
          break;
        case 47:
          this._regex();
          break;
        case 61:
          if (this._match(
            61
            /* CharCode.Equals */
          )) {
            const t = this._match(
              61
              /* CharCode.Equals */
            );
            this._tokens.push({ type: 3, offset: this._start, isTripleEq: t });
          } else this._match(
            126
            /* CharCode.Tilde */
          ) ? this._addToken(
            9
            /* TokenType.RegexOp */
          ) : this._error(s0("==", "=~"));
          break;
        case 60:
          this._addToken(
            this._match(
              61
              /* CharCode.Equals */
            ) ? 6 : 5
            /* TokenType.Lt */
          );
          break;
        case 62:
          this._addToken(
            this._match(
              61
              /* CharCode.Equals */
            ) ? 8 : 7
            /* TokenType.Gt */
          );
          break;
        case 38:
          this._match(
            38
            /* CharCode.Ampersand */
          ) ? this._addToken(
            15
            /* TokenType.And */
          ) : this._error(s0("&&"));
          break;
        case 124:
          this._match(
            124
            /* CharCode.Pipe */
          ) ? this._addToken(
            16
            /* TokenType.Or */
          ) : this._error(s0("||"));
          break;
        // TODO@ulugbekna: 1) rewrite using a regex 2) reconsider what characters are considered whitespace, including unicode, nbsp, etc.
        case 32:
        case 13:
        case 9:
        case 10:
        case 160:
          break;
        default:
          this._string();
      }
    return this._start = this._current, this._addToken(
      20
      /* TokenType.EOF */
    ), Array.from(this._tokens);
  }
  _match(e) {
    return this._isAtEnd() || this._input.charCodeAt(this._current) !== e ? !1 : (this._current++, !0);
  }
  _advance() {
    return this._input.charCodeAt(this._current++);
  }
  _peek() {
    return this._isAtEnd() ? 0 : this._input.charCodeAt(this._current);
  }
  _addToken(e) {
    this._tokens.push({ type: e, offset: this._start });
  }
  _error(e) {
    const t = this._start, i = this._input.substring(this._start, this._current), n = { type: 19, offset: this._start, lexeme: i };
    this._errors.push({ offset: t, lexeme: i, additionalInfo: e }), this._tokens.push(n);
  }
  _string() {
    this.stringRe.lastIndex = this._start;
    const e = this.stringRe.exec(this._input);
    if (e) {
      this._current = this._start + e[0].length;
      const t = this._input.substring(this._start, this._current), i = pu._keywords.get(t);
      i ? this._addToken(i) : this._tokens.push({ type: 17, lexeme: t, offset: this._start });
    }
  }
  // captures the lexeme without the leading and trailing '
  _quotedString() {
    for (; this._peek() !== 39 && !this._isAtEnd(); )
      this._advance();
    if (this._isAtEnd()) {
      this._error(D8);
      return;
    }
    this._advance(), this._tokens.push({ type: 18, lexeme: this._input.substring(this._start + 1, this._current - 1), offset: this._start + 1 });
  }
  /*
   * Lexing a regex expression: /.../[igsmyu]*
   * Based on https://github.com/microsoft/TypeScript/blob/9247ef115e617805983740ba795d7a8164babf89/src/compiler/scanner.ts#L2129-L2181
   *
   * Note that we want slashes within a regex to be escaped, e.g., /file:\\/\\/\\// should match `file:///`
   */
  _regex() {
    let e = this._current, t = !1, i = !1;
    for (; ; ) {
      if (e >= this._input.length) {
        this._current = e, this._error(E8);
        return;
      }
      const o = this._input.charCodeAt(e);
      if (t)
        t = !1;
      else if (o === 47 && !i) {
        e++;
        break;
      } else o === 91 ? i = !0 : o === 92 ? t = !0 : o === 93 && (i = !1);
      e++;
    }
    for (; e < this._input.length && pu._regexFlags.has(this._input.charCodeAt(e)); )
      e++;
    this._current = e;
    const n = this._input.substring(this._start, this._current);
    this._tokens.push({ type: 10, lexeme: n, offset: this._start });
  }
  _isAtEnd() {
    return this._current >= this._input.length;
  }
};
pu._regexFlags = new Set(["i", "g", "s", "m", "y", "u"].map((e) => e.charCodeAt(0))), pu._keywords = /* @__PURE__ */ new Map([
  [
    "not",
    14
    /* TokenType.Not */
  ],
  [
    "in",
    13
    /* TokenType.In */
  ],
  [
    "false",
    12
    /* TokenType.False */
  ],
  [
    "true",
    11
    /* TokenType.True */
  ]
]);
let Dc = pu;
const Yi = /* @__PURE__ */ new Map();
Yi.set("false", !1);
Yi.set("true", !0);
Yi.set("isMac", $e);
Yi.set("isLinux", Rn);
Yi.set("isWindows", es);
Yi.set("isWeb", Ef);
Yi.set("isMacNative", $e && !Ef);
Yi.set("isEdge", y9);
Yi.set("isFirefox", v9);
Yi.set("isChrome", qP);
Yi.set("isSafari", w9);
const I8 = Object.prototype.hasOwnProperty, N8 = {
  regexParsingWithErrorRecovery: !0
}, T8 = m("contextkey.parser.error.emptyString", "Empty context key expression"), M8 = m("contextkey.parser.error.emptyString.hint", "Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively."), R8 = m("contextkey.parser.error.noInAfterNot", "'in' after 'not'."), p2 = m("contextkey.parser.error.closingParenthesis", "closing parenthesis ')'"), A8 = m("contextkey.parser.error.unexpectedToken", "Unexpected token"), P8 = m("contextkey.parser.error.unexpectedToken.hint", "Did you forget to put && or || before the token?"), O8 = m("contextkey.parser.error.unexpectedEOF", "Unexpected end of expression"), F8 = m("contextkey.parser.error.unexpectedEOF.hint", "Did you forget to put a context key?");
var Er;
let B8 = (Er = class {
  constructor(e = N8) {
    this._config = e, this._scanner = new Dc(), this._tokens = [], this._current = 0, this._parsingErrors = [], this._flagsGYRe = /g|y/g;
  }
  /**
   * Parse a context key expression.
   *
   * @param input the expression to parse
   * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors
   */
  parse(e) {
    if (e === "") {
      this._parsingErrors.push({ message: T8, offset: 0, lexeme: "", additionalInfo: M8 });
      return;
    }
    this._tokens = this._scanner.reset(e).scan(), this._current = 0, this._parsingErrors = [];
    try {
      const t = this._expr();
      if (!this._isAtEnd()) {
        const i = this._peek(), n = i.type === 17 ? P8 : void 0;
        throw this._parsingErrors.push({ message: A8, offset: i.offset, lexeme: Dc.getLexeme(i), additionalInfo: n }), Er._parseError;
      }
      return t;
    } catch (t) {
      if (t !== Er._parseError)
        throw t;
      return;
    }
  }
  _expr() {
    return this._or();
  }
  _or() {
    const e = [this._and()];
    for (; this._matchOne(
      16
      /* TokenType.Or */
    ); ) {
      const t = this._and();
      e.push(t);
    }
    return e.length === 1 ? e[0] : ve.or(...e);
  }
  _and() {
    const e = [this._term()];
    for (; this._matchOne(
      15
      /* TokenType.And */
    ); ) {
      const t = this._term();
      e.push(t);
    }
    return e.length === 1 ? e[0] : ve.and(...e);
  }
  _term() {
    if (this._matchOne(
      2
      /* TokenType.Neg */
    )) {
      const e = this._peek();
      switch (e.type) {
        case 11:
          return this._advance(), bn.INSTANCE;
        case 12:
          return this._advance(), An.INSTANCE;
        case 0: {
          this._advance();
          const t = this._expr();
          return this._consume(1, p2), t == null ? void 0 : t.negate();
        }
        case 17:
          return this._advance(), sd.create(e.lexeme);
        default:
          throw this._errExpectedButGot("KEY | true | false | '(' expression ')'", e);
      }
    }
    return this._primary();
  }
  _primary() {
    const e = this._peek();
    switch (e.type) {
      case 11:
        return this._advance(), ve.true();
      case 12:
        return this._advance(), ve.false();
      case 0: {
        this._advance();
        const t = this._expr();
        return this._consume(1, p2), t;
      }
      case 17: {
        const t = e.lexeme;
        if (this._advance(), this._matchOne(
          9
          /* TokenType.RegexOp */
        )) {
          const n = this._peek();
          if (!this._config.regexParsingWithErrorRecovery) {
            if (this._advance(), n.type !== 10)
              throw this._errExpectedButGot("REGEX", n);
            const o = n.lexeme, r = o.lastIndexOf("/"), a = r === o.length - 1 ? void 0 : this._removeFlagsGY(o.substring(r + 1));
            let l;
            try {
              l = new RegExp(o.substring(1, r), a);
            } catch {
              throw this._errExpectedButGot("REGEX", n);
            }
            return Dm.create(t, l);
          }
          switch (n.type) {
            case 10:
            case 19: {
              const o = [n.lexeme];
              this._advance();
              let r = this._peek(), a = 0;
              for (let u = 0; u < n.lexeme.length; u++)
                n.lexeme.charCodeAt(u) === 40 ? a++ : n.lexeme.charCodeAt(u) === 41 && a--;
              for (; !this._isAtEnd() && r.type !== 15 && r.type !== 16; ) {
                switch (r.type) {
                  case 0:
                    a++;
                    break;
                  case 1:
                    a--;
                    break;
                  case 10:
                  case 18:
                    for (let u = 0; u < r.lexeme.length; u++)
                      r.lexeme.charCodeAt(u) === 40 ? a++ : n.lexeme.charCodeAt(u) === 41 && a--;
                }
                if (a < 0)
                  break;
                o.push(Dc.getLexeme(r)), this._advance(), r = this._peek();
              }
              const l = o.join(""), c = l.lastIndexOf("/"), h = c === l.length - 1 ? void 0 : this._removeFlagsGY(l.substring(c + 1));
              let d;
              try {
                d = new RegExp(l.substring(1, c), h);
              } catch {
                throw this._errExpectedButGot("REGEX", n);
              }
              return ve.regex(t, d);
            }
            case 18: {
              const o = n.lexeme;
              this._advance();
              let r = null;
              if (!d8(o)) {
                const a = o.indexOf("/"), l = o.lastIndexOf("/");
                if (a !== l && a >= 0) {
                  const c = o.slice(a + 1, l), h = o[l + 1] === "i" ? "i" : "";
                  try {
                    r = new RegExp(c, h);
                  } catch {
                    throw this._errExpectedButGot("REGEX", n);
                  }
                }
              }
              if (r === null)
                throw this._errExpectedButGot("REGEX", n);
              return Dm.create(t, r);
            }
            default:
              throw this._errExpectedButGot("REGEX", this._peek());
          }
        }
        if (this._matchOne(
          14
          /* TokenType.Not */
        )) {
          this._consume(13, R8);
          const n = this._value();
          return ve.notIn(t, n);
        }
        switch (this._peek().type) {
          case 3: {
            this._advance();
            const n = this._value();
            if (this._previous().type === 18)
              return ve.equals(t, n);
            switch (n) {
              case "true":
                return ve.has(t);
              case "false":
                return ve.not(t);
              default:
                return ve.equals(t, n);
            }
          }
          case 4: {
            this._advance();
            const n = this._value();
            if (this._previous().type === 18)
              return ve.notEquals(t, n);
            switch (n) {
              case "true":
                return ve.not(t);
              case "false":
                return ve.has(t);
              default:
                return ve.notEquals(t, n);
            }
          }
          // TODO: ContextKeyExpr.smaller(key, right) accepts only `number` as `right` AND during eval of this node, we just eval to `false` if `right` is not a number
          // consequently, package.json linter should _warn_ the user if they're passing undesired things to ops
          case 5:
            return this._advance(), qv.create(t, this._value());
          case 6:
            return this._advance(), Gv.create(t, this._value());
          case 7:
            return this._advance(), Kv.create(t, this._value());
          case 8:
            return this._advance(), jv.create(t, this._value());
          case 13:
            return this._advance(), ve.in(t, this._value());
          default:
            return ve.has(t);
        }
      }
      case 20:
        throw this._parsingErrors.push({ message: O8, offset: e.offset, lexeme: "", additionalInfo: F8 }), Er._parseError;
      default:
        throw this._errExpectedButGot(`true | false | KEY 
	| KEY '=~' REGEX 
	| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());
    }
  }
  _value() {
    const e = this._peek();
    switch (e.type) {
      case 17:
      case 18:
        return this._advance(), e.lexeme;
      case 11:
        return this._advance(), "true";
      case 12:
        return this._advance(), "false";
      case 13:
        return this._advance(), "in";
      default:
        return "";
    }
  }
  _removeFlagsGY(e) {
    return e.replaceAll(this._flagsGYRe, "");
  }
  // careful: this can throw if current token is the initial one (ie index = 0)
  _previous() {
    return this._tokens[this._current - 1];
  }
  _matchOne(e) {
    return this._check(e) ? (this._advance(), !0) : !1;
  }
  _advance() {
    return this._isAtEnd() || this._current++, this._previous();
  }
  _consume(e, t) {
    if (this._check(e))
      return this._advance();
    throw this._errExpectedButGot(t, this._peek());
  }
  _errExpectedButGot(e, t, i) {
    const n = m("contextkey.parser.error.expectedButGot", `Expected: {0}
Received: '{1}'.`, e, Dc.getLexeme(t)), o = t.offset, r = Dc.getLexeme(t);
    return this._parsingErrors.push({ message: n, offset: o, lexeme: r, additionalInfo: i }), Er._parseError;
  }
  _check(e) {
    return this._peek().type === e;
  }
  _peek() {
    return this._tokens[this._current];
  }
  _isAtEnd() {
    return this._peek().type === 20;
  }
}, Er._parseError = new Error(), Er);
const e2 = class e2 {
  static false() {
    return bn.INSTANCE;
  }
  static true() {
    return An.INSTANCE;
  }
  static has(e) {
    return nd.create(e);
  }
  static equals(e, t) {
    return Ep.create(e, t);
  }
  static notEquals(e, t) {
    return Uv.create(e, t);
  }
  static regex(e, t) {
    return Dm.create(e, t);
  }
  static in(e, t) {
    return Vv.create(e, t);
  }
  static notIn(e, t) {
    return zv.create(e, t);
  }
  static not(e) {
    return sd.create(e);
  }
  static and(...e) {
    return Yc.create(e, null, !0);
  }
  static or(...e) {
    return va.create(e, null, !0);
  }
  static deserialize(e) {
    return e == null ? void 0 : this._parser.parse(e);
  }
};
e2._parser = new B8({ regexParsingWithErrorRecovery: !1 });
let ve = e2;
function W8(s, e) {
  const t = s ? s.substituteConstants() : void 0, i = e ? e.substituteConstants() : void 0;
  return !t && !i ? !0 : !t || !i ? !1 : t.equals(i);
}
function Mg(s, e) {
  return s.cmp(e);
}
const UC = class UC {
  constructor() {
    this.type = 0;
  }
  cmp(e) {
    return this.type - e.type;
  }
  equals(e) {
    return e.type === this.type;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !1;
  }
  serialize() {
    return "false";
  }
  keys() {
    return [];
  }
  negate() {
    return An.INSTANCE;
  }
};
UC.INSTANCE = new UC();
let bn = UC;
const $C = class $C {
  constructor() {
    this.type = 1;
  }
  cmp(e) {
    return this.type - e.type;
  }
  equals(e) {
    return e.type === this.type;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !0;
  }
  serialize() {
    return "true";
  }
  keys() {
    return [];
  }
  negate() {
    return bn.INSTANCE;
  }
};
$C.INSTANCE = new $C();
let An = $C;
class nd {
  static create(e, t = null) {
    const i = Yi.get(e);
    return typeof i == "boolean" ? i ? An.INSTANCE : bn.INSTANCE : new nd(e, t);
  }
  constructor(e, t) {
    this.key = e, this.negated = t, this.type = 2;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : m4(this.key, e.key);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key : !1;
  }
  substituteConstants() {
    const e = Yi.get(this.key);
    return typeof e == "boolean" ? e ? An.INSTANCE : bn.INSTANCE : this;
  }
  evaluate(e) {
    return !!e.getValue(this.key);
  }
  serialize() {
    return this.key;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = sd.create(this.key, this)), this.negated;
  }
}
class Ep {
  static create(e, t, i = null) {
    if (typeof t == "boolean")
      return t ? nd.create(e, i) : sd.create(e, i);
    const n = Yi.get(e);
    return typeof n == "boolean" ? t === (n ? "true" : "false") ? An.INSTANCE : bn.INSTANCE : new Ep(e, t, i);
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 4;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : od(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    const e = Yi.get(this.key);
    if (typeof e == "boolean") {
      const t = e ? "true" : "false";
      return this.value === t ? An.INSTANCE : bn.INSTANCE;
    }
    return this;
  }
  evaluate(e) {
    return e.getValue(this.key) == this.value;
  }
  serialize() {
    return `${this.key} == '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Uv.create(this.key, this.value, this)), this.negated;
  }
}
class Vv {
  static create(e, t) {
    return new Vv(e, t);
  }
  constructor(e, t) {
    this.key = e, this.valueKey = t, this.type = 10, this.negated = null;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : od(this.key, this.valueKey, e.key, e.valueKey);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.valueKey === e.valueKey : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    const t = e.getValue(this.valueKey), i = e.getValue(this.key);
    return Array.isArray(t) ? t.includes(i) : typeof i == "string" && typeof t == "object" && t !== null ? I8.call(t, i) : !1;
  }
  serialize() {
    return `${this.key} in '${this.valueKey}'`;
  }
  keys() {
    return [this.key, this.valueKey];
  }
  negate() {
    return this.negated || (this.negated = zv.create(this.key, this.valueKey)), this.negated;
  }
}
class zv {
  static create(e, t) {
    return new zv(e, t);
  }
  constructor(e, t) {
    this.key = e, this.valueKey = t, this.type = 11, this._negated = Vv.create(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : this._negated.cmp(e._negated);
  }
  equals(e) {
    return e.type === this.type ? this._negated.equals(e._negated) : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !this._negated.evaluate(e);
  }
  serialize() {
    return `${this.key} not in '${this.valueKey}'`;
  }
  keys() {
    return this._negated.keys();
  }
  negate() {
    return this._negated;
  }
}
class Uv {
  static create(e, t, i = null) {
    if (typeof t == "boolean")
      return t ? sd.create(e, i) : nd.create(e, i);
    const n = Yi.get(e);
    return typeof n == "boolean" ? t === (n ? "true" : "false") ? bn.INSTANCE : An.INSTANCE : new Uv(e, t, i);
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 5;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : od(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    const e = Yi.get(this.key);
    if (typeof e == "boolean") {
      const t = e ? "true" : "false";
      return this.value === t ? bn.INSTANCE : An.INSTANCE;
    }
    return this;
  }
  evaluate(e) {
    return e.getValue(this.key) != this.value;
  }
  serialize() {
    return `${this.key} != '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Ep.create(this.key, this.value, this)), this.negated;
  }
}
class sd {
  static create(e, t = null) {
    const i = Yi.get(e);
    return typeof i == "boolean" ? i ? bn.INSTANCE : An.INSTANCE : new sd(e, t);
  }
  constructor(e, t) {
    this.key = e, this.negated = t, this.type = 3;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : m4(this.key, e.key);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key : !1;
  }
  substituteConstants() {
    const e = Yi.get(this.key);
    return typeof e == "boolean" ? e ? bn.INSTANCE : An.INSTANCE : this;
  }
  evaluate(e) {
    return !e.getValue(this.key);
  }
  serialize() {
    return `!${this.key}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = nd.create(this.key, this)), this.negated;
  }
}
function $v(s, e) {
  if (typeof s == "string") {
    const t = parseFloat(s);
    isNaN(t) || (s = t);
  }
  return typeof s == "string" || typeof s == "number" ? e(s) : bn.INSTANCE;
}
class Kv {
  static create(e, t, i = null) {
    return $v(t, (n) => new Kv(e, n, i));
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 12;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : od(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) > this.value;
  }
  serialize() {
    return `${this.key} > ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Gv.create(this.key, this.value, this)), this.negated;
  }
}
class jv {
  static create(e, t, i = null) {
    return $v(t, (n) => new jv(e, n, i));
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 13;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : od(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) >= this.value;
  }
  serialize() {
    return `${this.key} >= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = qv.create(this.key, this.value, this)), this.negated;
  }
}
class qv {
  static create(e, t, i = null) {
    return $v(t, (n) => new qv(e, n, i));
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 14;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : od(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) < this.value;
  }
  serialize() {
    return `${this.key} < ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = jv.create(this.key, this.value, this)), this.negated;
  }
}
class Gv {
  static create(e, t, i = null) {
    return $v(t, (n) => new Gv(e, n, i));
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 15;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : od(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) <= this.value;
  }
  serialize() {
    return `${this.key} <= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Kv.create(this.key, this.value, this)), this.negated;
  }
}
class Dm {
  static create(e, t) {
    return new Dm(e, t);
  }
  constructor(e, t) {
    this.key = e, this.regexp = t, this.type = 7, this.negated = null;
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.key < e.key)
      return -1;
    if (this.key > e.key)
      return 1;
    const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
    return t < i ? -1 : t > i ? 1 : 0;
  }
  equals(e) {
    if (e.type === this.type) {
      const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
      return this.key === e.key && t === i;
    }
    return !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    const t = e.getValue(this.key);
    return this.regexp ? this.regexp.test(t) : !1;
  }
  serialize() {
    const e = this.regexp ? `/${this.regexp.source}/${this.regexp.flags}` : "/invalid/";
    return `${this.key} =~ ${e}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = pE.create(this)), this.negated;
  }
}
class pE {
  static create(e) {
    return new pE(e);
  }
  constructor(e) {
    this._actual = e, this.type = 8;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : this._actual.cmp(e._actual);
  }
  equals(e) {
    return e.type === this.type ? this._actual.equals(e._actual) : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !this._actual.evaluate(e);
  }
  serialize() {
    return `!(${this._actual.serialize()})`;
  }
  keys() {
    return this._actual.keys();
  }
  negate() {
    return this._actual;
  }
}
function g4(s) {
  let e = null;
  for (let t = 0, i = s.length; t < i; t++) {
    const n = s[t].substituteConstants();
    if (s[t] !== n && e === null) {
      e = [];
      for (let o = 0; o < t; o++)
        e[o] = s[o];
    }
    e !== null && (e[t] = n);
  }
  return e === null ? s : e;
}
class Yc {
  static create(e, t, i) {
    return Yc._normalizeArr(e, t, i);
  }
  constructor(e, t) {
    this.expr = e, this.negated = t, this.type = 6;
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.expr.length < e.expr.length)
      return -1;
    if (this.expr.length > e.expr.length)
      return 1;
    for (let t = 0, i = this.expr.length; t < i; t++) {
      const n = Mg(this.expr[t], e.expr[t]);
      if (n !== 0)
        return n;
    }
    return 0;
  }
  equals(e) {
    if (e.type === this.type) {
      if (this.expr.length !== e.expr.length)
        return !1;
      for (let t = 0, i = this.expr.length; t < i; t++)
        if (!this.expr[t].equals(e.expr[t]))
          return !1;
      return !0;
    }
    return !1;
  }
  substituteConstants() {
    const e = g4(this.expr);
    return e === this.expr ? this : Yc.create(e, this.negated, !1);
  }
  evaluate(e) {
    for (let t = 0, i = this.expr.length; t < i; t++)
      if (!this.expr[t].evaluate(e))
        return !1;
    return !0;
  }
  static _normalizeArr(e, t, i) {
    const n = [];
    let o = !1;
    for (const r of e)
      if (r) {
        if (r.type === 1) {
          o = !0;
          continue;
        }
        if (r.type === 0)
          return bn.INSTANCE;
        if (r.type === 6) {
          n.push(...r.expr);
          continue;
        }
        n.push(r);
      }
    if (n.length === 0 && o)
      return An.INSTANCE;
    if (n.length !== 0) {
      if (n.length === 1)
        return n[0];
      n.sort(Mg);
      for (let r = 1; r < n.length; r++)
        n[r - 1].equals(n[r]) && (n.splice(r, 1), r--);
      if (n.length === 1)
        return n[0];
      for (; n.length > 1; ) {
        const r = n[n.length - 1];
        if (r.type !== 9)
          break;
        n.pop();
        const a = n.pop(), l = n.length === 0, c = va.create(r.expr.map((h) => Yc.create([h, a], null, i)), null, l);
        c && (n.push(c), n.sort(Mg));
      }
      if (n.length === 1)
        return n[0];
      if (i) {
        for (let r = 0; r < n.length; r++)
          for (let a = r + 1; a < n.length; a++)
            if (n[r].negate().equals(n[a]))
              return bn.INSTANCE;
        if (n.length === 1)
          return n[0];
      }
      return new Yc(n, t);
    }
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" && ");
  }
  keys() {
    const e = [];
    for (const t of this.expr)
      e.push(...t.keys());
    return e;
  }
  negate() {
    if (!this.negated) {
      const e = [];
      for (const t of this.expr)
        e.push(t.negate());
      this.negated = va.create(e, this, !0);
    }
    return this.negated;
  }
}
class va {
  static create(e, t, i) {
    return va._normalizeArr(e, t, i);
  }
  constructor(e, t) {
    this.expr = e, this.negated = t, this.type = 9;
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.expr.length < e.expr.length)
      return -1;
    if (this.expr.length > e.expr.length)
      return 1;
    for (let t = 0, i = this.expr.length; t < i; t++) {
      const n = Mg(this.expr[t], e.expr[t]);
      if (n !== 0)
        return n;
    }
    return 0;
  }
  equals(e) {
    if (e.type === this.type) {
      if (this.expr.length !== e.expr.length)
        return !1;
      for (let t = 0, i = this.expr.length; t < i; t++)
        if (!this.expr[t].equals(e.expr[t]))
          return !1;
      return !0;
    }
    return !1;
  }
  substituteConstants() {
    const e = g4(this.expr);
    return e === this.expr ? this : va.create(e, this.negated, !1);
  }
  evaluate(e) {
    for (let t = 0, i = this.expr.length; t < i; t++)
      if (this.expr[t].evaluate(e))
        return !0;
    return !1;
  }
  static _normalizeArr(e, t, i) {
    let n = [], o = !1;
    if (e) {
      for (let r = 0, a = e.length; r < a; r++) {
        const l = e[r];
        if (l) {
          if (l.type === 0) {
            o = !0;
            continue;
          }
          if (l.type === 1)
            return An.INSTANCE;
          if (l.type === 9) {
            n = n.concat(l.expr);
            continue;
          }
          n.push(l);
        }
      }
      if (n.length === 0 && o)
        return bn.INSTANCE;
      n.sort(Mg);
    }
    if (n.length !== 0) {
      if (n.length === 1)
        return n[0];
      for (let r = 1; r < n.length; r++)
        n[r - 1].equals(n[r]) && (n.splice(r, 1), r--);
      if (n.length === 1)
        return n[0];
      if (i) {
        for (let r = 0; r < n.length; r++)
          for (let a = r + 1; a < n.length; a++)
            if (n[r].negate().equals(n[a]))
              return An.INSTANCE;
        if (n.length === 1)
          return n[0];
      }
      return new va(n, t);
    }
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" || ");
  }
  keys() {
    const e = [];
    for (const t of this.expr)
      e.push(...t.keys());
    return e;
  }
  negate() {
    if (!this.negated) {
      const e = [];
      for (const t of this.expr)
        e.push(t.negate());
      for (; e.length > 1; ) {
        const t = e.shift(), i = e.shift(), n = [];
        for (const o of b2(t))
          for (const r of b2(i))
            n.push(Yc.create([o, r], null, !1));
        e.unshift(va.create(n, null, !1));
      }
      this.negated = va.create(e, this, !0);
    }
    return this.negated;
  }
}
const _u = class _u extends nd {
  static all() {
    return _u._info.values();
  }
  constructor(e, t, i) {
    super(e, null), this._defaultValue = t, typeof i == "object" ? _u._info.push({ ...i, key: e }) : i !== !0 && _u._info.push({ key: e, description: i, type: t != null ? typeof t : void 0 });
  }
  bindTo(e) {
    return e.createKey(this.key, this._defaultValue);
  }
  getValue(e) {
    return e.getContextKeyValue(this.key);
  }
  toNegated() {
    return this.negate();
  }
  isEqualTo(e) {
    return Ep.create(this.key, e);
  }
};
_u._info = [];
let ce = _u;
const Fe = Be("contextKeyService");
function m4(s, e) {
  return s < e ? -1 : s > e ? 1 : 0;
}
function od(s, e, t, i) {
  return s < t ? -1 : s > t ? 1 : e < i ? -1 : e > i ? 1 : 0;
}
function zy(s, e) {
  if (s.type === 0 || e.type === 1)
    return !0;
  if (s.type === 9)
    return e.type === 9 ? _2(s.expr, e.expr) : !1;
  if (e.type === 9) {
    for (const t of e.expr)
      if (zy(s, t))
        return !0;
    return !1;
  }
  if (s.type === 6) {
    if (e.type === 6)
      return _2(e.expr, s.expr);
    for (const t of s.expr)
      if (zy(t, e))
        return !0;
    return !1;
  }
  return s.equals(e);
}
function _2(s, e) {
  let t = 0, i = 0;
  for (; t < s.length && i < e.length; ) {
    const n = s[t].cmp(e[i]);
    if (n < 0)
      return !1;
    n === 0 && t++, i++;
  }
  return t === s.length;
}
function b2(s) {
  return s.type === 9 ? s.expr : [s];
}
function Uy(s, e) {
  if (typeof s == "number") {
    if (s === 0)
      return null;
    const t = (s & 65535) >>> 0, i = (s & 4294901760) >>> 16;
    return i !== 0 ? new o0([
      s_(t, e),
      s_(i, e)
    ]) : new o0([s_(t, e)]);
  } else {
    const t = [];
    for (let i = 0; i < s.length; i++)
      t.push(s_(s[i], e));
    return new o0(t);
  }
}
function s_(s, e) {
  const t = !!(s & 2048), i = !!(s & 256), n = e === 2 ? i : t, o = !!(s & 1024), r = !!(s & 512), a = e === 2 ? t : i, l = s & 255;
  return new Bh(n, o, r, a, l);
}
class Bh {
  constructor(e, t, i, n, o) {
    this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = n, this.keyCode = o;
  }
  equals(e) {
    return e instanceof Bh && this.ctrlKey === e.ctrlKey && this.shiftKey === e.shiftKey && this.altKey === e.altKey && this.metaKey === e.metaKey && this.keyCode === e.keyCode;
  }
  isModifierKey() {
    return this.keyCode === 0 || this.keyCode === 5 || this.keyCode === 57 || this.keyCode === 6 || this.keyCode === 4;
  }
  /**
   * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
   */
  isDuplicateModifierCase() {
    return this.ctrlKey && this.keyCode === 5 || this.shiftKey && this.keyCode === 4 || this.altKey && this.keyCode === 6 || this.metaKey && this.keyCode === 57;
  }
}
class o0 {
  constructor(e) {
    if (e.length === 0)
      throw Tr("chords");
    this.chords = e;
  }
}
class H8 {
  constructor(e, t, i, n, o, r) {
    this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = n, this.keyLabel = o, this.keyAriaLabel = r;
  }
}
class V8 {
}
function r0(s, e) {
  if (!s)
    throw new Error(e ? `Assertion failed (${e})` : "Assertion Failed");
}
function _E(s, e = "Unreachable") {
  throw new Error(e);
}
function C2(s) {
  s || Je(new at("Soft Assertion Failed"));
}
function Wh(s) {
  if (!s()) {
    debugger;
    s(), Je(new at("Assertion Failed"));
  }
}
function bE(s, e) {
  let t = 0;
  for (; t < s.length - 1; ) {
    const i = s[t], n = s[t + 1];
    if (!e(i, n))
      return !1;
    t++;
  }
  return !0;
}
class z8 {
  constructor() {
    this.data = /* @__PURE__ */ new Map();
  }
  add(e, t) {
    r0(Ss(e)), r0(Wi(t)), r0(!this.data.has(e), "There is already an extension with this id"), this.data.set(e, t);
  }
  as(e) {
    return this.data.get(e) || null;
  }
}
const Mi = new z8();
class CE {
  constructor() {
    this._coreKeybindings = new Tn(), this._extensionKeybindings = [], this._cachedMergedKeybindings = null;
  }
  /**
   * Take current platform into account and reduce to primary & secondary.
   */
  static bindToCurrentPlatform(e) {
    if (bs === 1) {
      if (e && e.win)
        return e.win;
    } else if (bs === 2) {
      if (e && e.mac)
        return e.mac;
    } else if (e && e.linux)
      return e.linux;
    return e;
  }
  registerKeybindingRule(e) {
    const t = CE.bindToCurrentPlatform(e), i = new ne();
    if (t && t.primary) {
      const n = Uy(t.primary, bs);
      n && i.add(this._registerDefaultKeybinding(n, e.id, e.args, e.weight, 0, e.when));
    }
    if (t && Array.isArray(t.secondary))
      for (let n = 0, o = t.secondary.length; n < o; n++) {
        const r = t.secondary[n], a = Uy(r, bs);
        a && i.add(this._registerDefaultKeybinding(a, e.id, e.args, e.weight, -n - 1, e.when));
      }
    return i;
  }
  registerCommandAndKeybindingRule(e) {
    return ao(this.registerKeybindingRule(e), St.registerCommand(e));
  }
  _registerDefaultKeybinding(e, t, i, n, o, r) {
    const a = this._coreKeybindings.push({
      keybinding: e,
      command: t,
      commandArgs: i,
      when: r,
      weight1: n,
      weight2: o,
      extensionId: null,
      isBuiltinExtension: !1
    });
    return this._cachedMergedKeybindings = null, _e(() => {
      a(), this._cachedMergedKeybindings = null;
    });
  }
  getDefaultKeybindings() {
    return this._cachedMergedKeybindings || (this._cachedMergedKeybindings = Array.from(this._coreKeybindings).concat(this._extensionKeybindings), this._cachedMergedKeybindings.sort($8)), this._cachedMergedKeybindings.slice(0);
  }
}
const ts = new CE(), U8 = {
  EditorModes: "platform.keybindingsRegistry"
};
Mi.add(U8.EditorModes, ts);
function $8(s, e) {
  if (s.weight1 !== e.weight1)
    return s.weight1 - e.weight1;
  if (s.command && e.command) {
    if (s.command < e.command)
      return -1;
    if (s.command > e.command)
      return 1;
  }
  return s.weight2 - e.weight2;
}
var K8 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, v2 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, J_;
function Nu(s) {
  return s.command !== void 0;
}
function j8(s) {
  return s.submenu !== void 0;
}
const D = class D {
  /**
   * Create a new `MenuId` with the unique identifier. Will throw if a menu
   * with the identifier already exists, use `MenuId.for(ident)` or a unique
   * identifier
   */
  constructor(e) {
    if (D._instances.has(e))
      throw new TypeError(`MenuId with identifier '${e}' already exists. Use MenuId.for(ident) or a unique identifier`);
    D._instances.set(e, this), this.id = e;
  }
};
D._instances = /* @__PURE__ */ new Map(), D.CommandPalette = new D("CommandPalette"), D.DebugBreakpointsContext = new D("DebugBreakpointsContext"), D.DebugCallStackContext = new D("DebugCallStackContext"), D.DebugConsoleContext = new D("DebugConsoleContext"), D.DebugVariablesContext = new D("DebugVariablesContext"), D.NotebookVariablesContext = new D("NotebookVariablesContext"), D.DebugHoverContext = new D("DebugHoverContext"), D.DebugWatchContext = new D("DebugWatchContext"), D.DebugToolBar = new D("DebugToolBar"), D.DebugToolBarStop = new D("DebugToolBarStop"), D.DebugCallStackToolbar = new D("DebugCallStackToolbar"), D.DebugCreateConfiguration = new D("DebugCreateConfiguration"), D.EditorContext = new D("EditorContext"), D.SimpleEditorContext = new D("SimpleEditorContext"), D.EditorContent = new D("EditorContent"), D.EditorLineNumberContext = new D("EditorLineNumberContext"), D.EditorContextCopy = new D("EditorContextCopy"), D.EditorContextPeek = new D("EditorContextPeek"), D.EditorContextShare = new D("EditorContextShare"), D.EditorTitle = new D("EditorTitle"), D.EditorTitleRun = new D("EditorTitleRun"), D.EditorTitleContext = new D("EditorTitleContext"), D.EditorTitleContextShare = new D("EditorTitleContextShare"), D.EmptyEditorGroup = new D("EmptyEditorGroup"), D.EmptyEditorGroupContext = new D("EmptyEditorGroupContext"), D.EditorTabsBarContext = new D("EditorTabsBarContext"), D.EditorTabsBarShowTabsSubmenu = new D("EditorTabsBarShowTabsSubmenu"), D.EditorTabsBarShowTabsZenModeSubmenu = new D("EditorTabsBarShowTabsZenModeSubmenu"), D.EditorActionsPositionSubmenu = new D("EditorActionsPositionSubmenu"), D.ExplorerContext = new D("ExplorerContext"), D.ExplorerContextShare = new D("ExplorerContextShare"), D.ExtensionContext = new D("ExtensionContext"), D.GlobalActivity = new D("GlobalActivity"), D.CommandCenter = new D("CommandCenter"), D.CommandCenterCenter = new D("CommandCenterCenter"), D.LayoutControlMenuSubmenu = new D("LayoutControlMenuSubmenu"), D.LayoutControlMenu = new D("LayoutControlMenu"), D.MenubarMainMenu = new D("MenubarMainMenu"), D.MenubarAppearanceMenu = new D("MenubarAppearanceMenu"), D.MenubarDebugMenu = new D("MenubarDebugMenu"), D.MenubarEditMenu = new D("MenubarEditMenu"), D.MenubarCopy = new D("MenubarCopy"), D.MenubarFileMenu = new D("MenubarFileMenu"), D.MenubarGoMenu = new D("MenubarGoMenu"), D.MenubarHelpMenu = new D("MenubarHelpMenu"), D.MenubarLayoutMenu = new D("MenubarLayoutMenu"), D.MenubarNewBreakpointMenu = new D("MenubarNewBreakpointMenu"), D.PanelAlignmentMenu = new D("PanelAlignmentMenu"), D.PanelPositionMenu = new D("PanelPositionMenu"), D.ActivityBarPositionMenu = new D("ActivityBarPositionMenu"), D.MenubarPreferencesMenu = new D("MenubarPreferencesMenu"), D.MenubarRecentMenu = new D("MenubarRecentMenu"), D.MenubarSelectionMenu = new D("MenubarSelectionMenu"), D.MenubarShare = new D("MenubarShare"), D.MenubarSwitchEditorMenu = new D("MenubarSwitchEditorMenu"), D.MenubarSwitchGroupMenu = new D("MenubarSwitchGroupMenu"), D.MenubarTerminalMenu = new D("MenubarTerminalMenu"), D.MenubarViewMenu = new D("MenubarViewMenu"), D.MenubarHomeMenu = new D("MenubarHomeMenu"), D.OpenEditorsContext = new D("OpenEditorsContext"), D.OpenEditorsContextShare = new D("OpenEditorsContextShare"), D.ProblemsPanelContext = new D("ProblemsPanelContext"), D.SCMInputBox = new D("SCMInputBox"), D.SCMChangesSeparator = new D("SCMChangesSeparator"), D.SCMChangesContext = new D("SCMChangesContext"), D.SCMIncomingChanges = new D("SCMIncomingChanges"), D.SCMIncomingChangesContext = new D("SCMIncomingChangesContext"), D.SCMIncomingChangesSetting = new D("SCMIncomingChangesSetting"), D.SCMOutgoingChanges = new D("SCMOutgoingChanges"), D.SCMOutgoingChangesContext = new D("SCMOutgoingChangesContext"), D.SCMOutgoingChangesSetting = new D("SCMOutgoingChangesSetting"), D.SCMIncomingChangesAllChangesContext = new D("SCMIncomingChangesAllChangesContext"), D.SCMIncomingChangesHistoryItemContext = new D("SCMIncomingChangesHistoryItemContext"), D.SCMOutgoingChangesAllChangesContext = new D("SCMOutgoingChangesAllChangesContext"), D.SCMOutgoingChangesHistoryItemContext = new D("SCMOutgoingChangesHistoryItemContext"), D.SCMChangeContext = new D("SCMChangeContext"), D.SCMResourceContext = new D("SCMResourceContext"), D.SCMResourceContextShare = new D("SCMResourceContextShare"), D.SCMResourceFolderContext = new D("SCMResourceFolderContext"), D.SCMResourceGroupContext = new D("SCMResourceGroupContext"), D.SCMSourceControl = new D("SCMSourceControl"), D.SCMSourceControlInline = new D("SCMSourceControlInline"), D.SCMSourceControlTitle = new D("SCMSourceControlTitle"), D.SCMHistoryTitle = new D("SCMHistoryTitle"), D.SCMTitle = new D("SCMTitle"), D.SearchContext = new D("SearchContext"), D.SearchActionMenu = new D("SearchActionContext"), D.StatusBarWindowIndicatorMenu = new D("StatusBarWindowIndicatorMenu"), D.StatusBarRemoteIndicatorMenu = new D("StatusBarRemoteIndicatorMenu"), D.StickyScrollContext = new D("StickyScrollContext"), D.TestItem = new D("TestItem"), D.TestItemGutter = new D("TestItemGutter"), D.TestProfilesContext = new D("TestProfilesContext"), D.TestMessageContext = new D("TestMessageContext"), D.TestMessageContent = new D("TestMessageContent"), D.TestPeekElement = new D("TestPeekElement"), D.TestPeekTitle = new D("TestPeekTitle"), D.TestCallStack = new D("TestCallStack"), D.TouchBarContext = new D("TouchBarContext"), D.TitleBarContext = new D("TitleBarContext"), D.TitleBarTitleContext = new D("TitleBarTitleContext"), D.TunnelContext = new D("TunnelContext"), D.TunnelPrivacy = new D("TunnelPrivacy"), D.TunnelProtocol = new D("TunnelProtocol"), D.TunnelPortInline = new D("TunnelInline"), D.TunnelTitle = new D("TunnelTitle"), D.TunnelLocalAddressInline = new D("TunnelLocalAddressInline"), D.TunnelOriginInline = new D("TunnelOriginInline"), D.ViewItemContext = new D("ViewItemContext"), D.ViewContainerTitle = new D("ViewContainerTitle"), D.ViewContainerTitleContext = new D("ViewContainerTitleContext"), D.ViewTitle = new D("ViewTitle"), D.ViewTitleContext = new D("ViewTitleContext"), D.CommentEditorActions = new D("CommentEditorActions"), D.CommentThreadTitle = new D("CommentThreadTitle"), D.CommentThreadActions = new D("CommentThreadActions"), D.CommentThreadAdditionalActions = new D("CommentThreadAdditionalActions"), D.CommentThreadTitleContext = new D("CommentThreadTitleContext"), D.CommentThreadCommentContext = new D("CommentThreadCommentContext"), D.CommentTitle = new D("CommentTitle"), D.CommentActions = new D("CommentActions"), D.CommentsViewThreadActions = new D("CommentsViewThreadActions"), D.InteractiveToolbar = new D("InteractiveToolbar"), D.InteractiveCellTitle = new D("InteractiveCellTitle"), D.InteractiveCellDelete = new D("InteractiveCellDelete"), D.InteractiveCellExecute = new D("InteractiveCellExecute"), D.InteractiveInputExecute = new D("InteractiveInputExecute"), D.InteractiveInputConfig = new D("InteractiveInputConfig"), D.ReplInputExecute = new D("ReplInputExecute"), D.IssueReporter = new D("IssueReporter"), D.NotebookToolbar = new D("NotebookToolbar"), D.NotebookStickyScrollContext = new D("NotebookStickyScrollContext"), D.NotebookCellTitle = new D("NotebookCellTitle"), D.NotebookCellDelete = new D("NotebookCellDelete"), D.NotebookCellInsert = new D("NotebookCellInsert"), D.NotebookCellBetween = new D("NotebookCellBetween"), D.NotebookCellListTop = new D("NotebookCellTop"), D.NotebookCellExecute = new D("NotebookCellExecute"), D.NotebookCellExecuteGoTo = new D("NotebookCellExecuteGoTo"), D.NotebookCellExecutePrimary = new D("NotebookCellExecutePrimary"), D.NotebookDiffCellInputTitle = new D("NotebookDiffCellInputTitle"), D.NotebookDiffCellMetadataTitle = new D("NotebookDiffCellMetadataTitle"), D.NotebookDiffCellOutputsTitle = new D("NotebookDiffCellOutputsTitle"), D.NotebookOutputToolbar = new D("NotebookOutputToolbar"), D.NotebookOutlineFilter = new D("NotebookOutlineFilter"), D.NotebookOutlineActionMenu = new D("NotebookOutlineActionMenu"), D.NotebookEditorLayoutConfigure = new D("NotebookEditorLayoutConfigure"), D.NotebookKernelSource = new D("NotebookKernelSource"), D.BulkEditTitle = new D("BulkEditTitle"), D.BulkEditContext = new D("BulkEditContext"), D.TimelineItemContext = new D("TimelineItemContext"), D.TimelineTitle = new D("TimelineTitle"), D.TimelineTitleContext = new D("TimelineTitleContext"), D.TimelineFilterSubMenu = new D("TimelineFilterSubMenu"), D.AccountsContext = new D("AccountsContext"), D.SidebarTitle = new D("SidebarTitle"), D.PanelTitle = new D("PanelTitle"), D.AuxiliaryBarTitle = new D("AuxiliaryBarTitle"), D.AuxiliaryBarHeader = new D("AuxiliaryBarHeader"), D.TerminalInstanceContext = new D("TerminalInstanceContext"), D.TerminalEditorInstanceContext = new D("TerminalEditorInstanceContext"), D.TerminalNewDropdownContext = new D("TerminalNewDropdownContext"), D.TerminalTabContext = new D("TerminalTabContext"), D.TerminalTabEmptyAreaContext = new D("TerminalTabEmptyAreaContext"), D.TerminalStickyScrollContext = new D("TerminalStickyScrollContext"), D.WebviewContext = new D("WebviewContext"), D.InlineCompletionsActions = new D("InlineCompletionsActions"), D.InlineEditsActions = new D("InlineEditsActions"), D.InlineEditActions = new D("InlineEditActions"), D.NewFile = new D("NewFile"), D.MergeInput1Toolbar = new D("MergeToolbar1Toolbar"), D.MergeInput2Toolbar = new D("MergeToolbar2Toolbar"), D.MergeBaseToolbar = new D("MergeBaseToolbar"), D.MergeInputResultToolbar = new D("MergeToolbarResultToolbar"), D.InlineSuggestionToolbar = new D("InlineSuggestionToolbar"), D.InlineEditToolbar = new D("InlineEditToolbar"), D.ChatContext = new D("ChatContext"), D.ChatCodeBlock = new D("ChatCodeblock"), D.ChatCompareBlock = new D("ChatCompareBlock"), D.ChatMessageTitle = new D("ChatMessageTitle"), D.ChatExecute = new D("ChatExecute"), D.ChatExecuteSecondary = new D("ChatExecuteSecondary"), D.ChatInputSide = new D("ChatInputSide"), D.AccessibleView = new D("AccessibleView"), D.MultiDiffEditorFileToolbar = new D("MultiDiffEditorFileToolbar"), D.DiffEditorHunkToolbar = new D("DiffEditorHunkToolbar"), D.DiffEditorSelectionToolbar = new D("DiffEditorSelectionToolbar");
let et = D;
const $r = Be("menuService"), cm = class cm {
  static for(e) {
    let t = this._all.get(e);
    return t || (t = new cm(e), this._all.set(e, t)), t;
  }
  static merge(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of e)
      i instanceof cm && t.add(i.id);
    return t;
  }
  constructor(e) {
    this.id = e, this.has = (t) => t === e;
  }
};
cm._all = /* @__PURE__ */ new Map();
let Ec = cm;
const so = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._menuItems = /* @__PURE__ */ new Map(), this._onDidChangeMenu = new n8({
      merge: Ec.merge
    }), this.onDidChangeMenu = this._onDidChangeMenu.event;
  }
  addCommand(s) {
    return this._commands.set(s.id, s), this._onDidChangeMenu.fire(Ec.for(et.CommandPalette)), _e(() => {
      this._commands.delete(s.id) && this._onDidChangeMenu.fire(Ec.for(et.CommandPalette));
    });
  }
  getCommand(s) {
    return this._commands.get(s);
  }
  getCommands() {
    const s = /* @__PURE__ */ new Map();
    return this._commands.forEach((e, t) => s.set(t, e)), s;
  }
  appendMenuItem(s, e) {
    let t = this._menuItems.get(s);
    t || (t = new Tn(), this._menuItems.set(s, t));
    const i = t.push(e);
    return this._onDidChangeMenu.fire(Ec.for(s)), _e(() => {
      i(), this._onDidChangeMenu.fire(Ec.for(s));
    });
  }
  appendMenuItems(s) {
    const e = new ne();
    for (const { id: t, item: i } of s)
      e.add(this.appendMenuItem(t, i));
    return e;
  }
  getMenuItems(s) {
    let e;
    return this._menuItems.has(s) ? e = [...this._menuItems.get(s)] : e = [], s === et.CommandPalette && this._appendImplicitItems(e), e;
  }
  _appendImplicitItems(s) {
    const e = /* @__PURE__ */ new Set();
    for (const t of s)
      Nu(t) && (e.add(t.command.id), t.alt && e.add(t.alt.id));
    this._commands.forEach((t, i) => {
      e.has(i) || s.push({ command: t });
    });
  }
}();
class Rg extends Wv {
  constructor(e, t, i) {
    super(`submenuitem.${e.submenu.id}`, typeof e.title == "string" ? e.title : e.title.value, i, "submenu"), this.item = e, this.hideActions = t;
  }
}
let lo = J_ = class {
  static label(e, t) {
    return t != null && t.renderShortTitle && e.shortTitle ? typeof e.shortTitle == "string" ? e.shortTitle : e.shortTitle.value : typeof e.title == "string" ? e.title : e.title.value;
  }
  constructor(e, t, i, n, o, r, a) {
    var c;
    this.hideActions = n, this.menuKeybinding = o, this._commandService = a, this.id = e.id, this.label = J_.label(e, i), this.tooltip = (typeof e.tooltip == "string" ? e.tooltip : (c = e.tooltip) == null ? void 0 : c.value) ?? "", this.enabled = !e.precondition || r.contextMatchesRules(e.precondition), this.checked = void 0;
    let l;
    if (e.toggled) {
      const h = e.toggled.condition ? e.toggled : { condition: e.toggled };
      this.checked = r.contextMatchesRules(h.condition), this.checked && h.tooltip && (this.tooltip = typeof h.tooltip == "string" ? h.tooltip : h.tooltip.value), this.checked && Te.isThemeIcon(h.icon) && (l = h.icon), this.checked && h.title && (this.label = typeof h.title == "string" ? h.title : h.title.value);
    }
    l || (l = Te.isThemeIcon(e.icon) ? e.icon : void 0), this.item = e, this.alt = t ? new J_(t, void 0, i, n, void 0, r, a) : void 0, this._options = i, this.class = l && Te.asClassName(l);
  }
  run(...e) {
    var i, n;
    let t = [];
    return (i = this._options) != null && i.arg && (t = [...t, this._options.arg]), (n = this._options) != null && n.shouldForwardArgs && (t = [...t, ...e]), this._commandService.executeCommand(this.id, ...t);
  }
};
lo = J_ = K8([
  v2(5, Fe),
  v2(6, fi)
], lo);
class Nf {
  constructor(e) {
    this.desc = e;
  }
}
function Fn(s) {
  const e = [], t = new s(), { f1: i, menu: n, keybinding: o, ...r } = t.desc;
  if (St.getCommand(r.id))
    throw new Error(`Cannot register two commands with the same id: ${r.id}`);
  if (e.push(St.registerCommand({
    id: r.id,
    handler: (a, ...l) => t.run(a, ...l),
    metadata: r.metadata
  })), Array.isArray(n))
    for (const a of n)
      e.push(so.appendMenuItem(a.id, { command: { ...r, precondition: a.precondition === null ? void 0 : r.precondition }, ...a }));
  else n && e.push(so.appendMenuItem(n.id, { command: { ...r, precondition: n.precondition === null ? void 0 : r.precondition }, ...n }));
  if (i && (e.push(so.appendMenuItem(et.CommandPalette, { command: r, when: r.precondition })), e.push(so.addCommand(r))), Array.isArray(o))
    for (const a of o)
      e.push(ts.registerKeybindingRule({
        ...a,
        id: r.id,
        when: r.precondition ? ve.and(r.precondition, a.when) : a.when
      }));
  else o && e.push(ts.registerKeybindingRule({
    ...o,
    id: r.id,
    when: r.precondition ? ve.and(r.precondition, o.when) : o.when
  }));
  return {
    dispose() {
      Ft(e);
    }
  };
}
const Jo = Be("telemetryService"), Co = Be("logService");
var En;
(function(s) {
  s[s.Off = 0] = "Off", s[s.Trace = 1] = "Trace", s[s.Debug = 2] = "Debug", s[s.Info = 3] = "Info", s[s.Warning = 4] = "Warning", s[s.Error = 5] = "Error";
})(En || (En = {}));
const p4 = En.Info;
class _4 extends U {
  constructor() {
    super(...arguments), this.level = p4, this._onDidChangeLogLevel = this._register(new A()), this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;
  }
  setLevel(e) {
    this.level !== e && (this.level = e, this._onDidChangeLogLevel.fire(this.level));
  }
  getLevel() {
    return this.level;
  }
  checkLogLevel(e) {
    return this.level !== En.Off && this.level <= e;
  }
}
class q8 extends _4 {
  constructor(e = p4, t = !0) {
    super(), this.useColors = t, this.setLevel(e);
  }
  trace(e, ...t) {
    this.checkLogLevel(En.Trace) && (this.useColors ? console.log("%cTRACE", "color: #888", e, ...t) : console.log(e, ...t));
  }
  debug(e, ...t) {
    this.checkLogLevel(En.Debug) && (this.useColors ? console.log("%cDEBUG", "background: #eee; color: #888", e, ...t) : console.log(e, ...t));
  }
  info(e, ...t) {
    this.checkLogLevel(En.Info) && (this.useColors ? console.log("%c INFO", "color: #33f", e, ...t) : console.log(e, ...t));
  }
  warn(e, ...t) {
    this.checkLogLevel(En.Warning) && (this.useColors ? console.log("%c WARN", "color: #993", e, ...t) : console.log(e, ...t));
  }
  error(e, ...t) {
    this.checkLogLevel(En.Error) && (this.useColors ? console.log("%c  ERR", "color: #f33", e, ...t) : console.error(e, ...t));
  }
}
class G8 extends _4 {
  constructor(e) {
    super(), this.loggers = e, e.length && this.setLevel(e[0].getLevel());
  }
  setLevel(e) {
    for (const t of this.loggers)
      t.setLevel(e);
    super.setLevel(e);
  }
  trace(e, ...t) {
    for (const i of this.loggers)
      i.trace(e, ...t);
  }
  debug(e, ...t) {
    for (const i of this.loggers)
      i.debug(e, ...t);
  }
  info(e, ...t) {
    for (const i of this.loggers)
      i.info(e, ...t);
  }
  warn(e, ...t) {
    for (const i of this.loggers)
      i.warn(e, ...t);
  }
  error(e, ...t) {
    for (const i of this.loggers)
      i.error(e, ...t);
  }
  dispose() {
    for (const e of this.loggers)
      e.dispose();
    super.dispose();
  }
}
function Z8(s) {
  switch (s) {
    case En.Trace:
      return "trace";
    case En.Debug:
      return "debug";
    case En.Info:
      return "info";
    case En.Warning:
      return "warn";
    case En.Error:
      return "error";
    case En.Off:
      return "off";
  }
}
new ce("logLevel", Z8(En.Info));
function Y8(s, e) {
  const t = s;
  typeof t.vscodeWindowId != "number" && Object.defineProperty(t, "vscodeWindowId", {
    get: () => e
  });
}
const pt = window, KC = class KC {
  constructor() {
    this.mapWindowIdToZoomFactor = /* @__PURE__ */ new Map();
  }
  getZoomFactor(e) {
    return this.mapWindowIdToZoomFactor.get(this.getWindowId(e)) ?? 1;
  }
  getWindowId(e) {
    return e.vscodeWindowId;
  }
};
KC.INSTANCE = new KC();
let $y = KC;
function b4(s, e, t) {
  typeof e == "string" && (e = s.matchMedia(e)), e.addEventListener("change", t);
}
function X8(s) {
  return $y.INSTANCE.getZoomFactor(s);
}
const Tf = navigator.userAgent, uo = Tf.indexOf("Firefox") >= 0, Zv = Tf.indexOf("AppleWebKit") >= 0, Ip = Tf.indexOf("Chrome") >= 0, ql = !Ip && Tf.indexOf("Safari") >= 0, C4 = !Ip && !ql && Zv;
Tf.indexOf("Electron/") >= 0;
const w2 = Tf.indexOf("Android") >= 0;
let a0 = !1;
if (typeof pt.matchMedia == "function") {
  const s = pt.matchMedia("(display-mode: standalone) or (display-mode: window-controls-overlay)"), e = pt.matchMedia("(display-mode: fullscreen)");
  a0 = s.matches, b4(pt, s, ({ matches: t }) => {
    a0 && e.matches || (a0 = t);
  });
}
const vE = {
  clipboard: {
    writeText: Ab || document.queryCommandSupported && document.queryCommandSupported("copy") || !!(navigator && navigator.clipboard && navigator.clipboard.writeText),
    readText: Ab || !!(navigator && navigator.clipboard && navigator.clipboard.readText)
  },
  pointerEvents: pt.PointerEvent && ("ontouchstart" in pt || navigator.maxTouchPoints > 0)
};
function Q8(s) {
  if (s.charCode) {
    const t = String.fromCharCode(s.charCode).toUpperCase();
    return Ca.fromString(t);
  }
  const e = s.keyCode;
  if (e === 3)
    return 7;
  if (uo)
    switch (e) {
      case 59:
        return 85;
      case 60:
        if (Rn)
          return 97;
        break;
      case 61:
        return 86;
      // based on: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#numpad_keys
      case 107:
        return 109;
      case 109:
        return 111;
      case 173:
        return 88;
      case 224:
        if ($e)
          return 57;
        break;
    }
  else if (Zv) {
    if ($e && e === 93)
      return 57;
    if (!$e && e === 92)
      return 57;
  }
  return zP[e] || 0;
}
const J8 = $e ? 256 : 2048, e6 = 512, t6 = 1024, i6 = $e ? 2048 : 256;
class Dt {
  constructor(e) {
    var i;
    this._standardKeyboardEventBrand = !0;
    const t = e;
    this.browserEvent = t, this.target = t.target, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.altKey = t.altKey, this.metaKey = t.metaKey, this.altGraphKey = (i = t.getModifierState) == null ? void 0 : i.call(t, "AltGraph"), this.keyCode = Q8(t), this.code = t.code, this.ctrlKey = this.ctrlKey || this.keyCode === 5, this.altKey = this.altKey || this.keyCode === 6, this.shiftKey = this.shiftKey || this.keyCode === 4, this.metaKey = this.metaKey || this.keyCode === 57, this._asKeybinding = this._computeKeybinding(), this._asKeyCodeChord = this._computeKeyCodeChord();
  }
  preventDefault() {
    this.browserEvent && this.browserEvent.preventDefault && this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent && this.browserEvent.stopPropagation && this.browserEvent.stopPropagation();
  }
  toKeyCodeChord() {
    return this._asKeyCodeChord;
  }
  equals(e) {
    return this._asKeybinding === e;
  }
  _computeKeybinding() {
    let e = 0;
    this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode);
    let t = 0;
    return this.ctrlKey && (t |= J8), this.altKey && (t |= e6), this.shiftKey && (t |= t6), this.metaKey && (t |= i6), t |= e, t;
  }
  _computeKeyCodeChord() {
    let e = 0;
    return this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode), new Bh(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, e);
  }
}
const y2 = /* @__PURE__ */ new WeakMap();
function n6(s) {
  if (!s.parent || s.parent === s)
    return null;
  try {
    const e = s.location, t = s.parent.location;
    if (e.origin !== "null" && t.origin !== "null" && e.origin !== t.origin)
      return null;
  } catch {
    return null;
  }
  return s.parent;
}
class s6 {
  /**
   * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).
   * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.
   */
  static getSameOriginWindowChain(e) {
    let t = y2.get(e);
    if (!t) {
      t = [], y2.set(e, t);
      let i = e, n;
      do
        n = n6(i), n ? t.push({
          window: new WeakRef(i),
          iframeElement: i.frameElement || null
        }) : t.push({
          window: new WeakRef(i),
          iframeElement: null
        }), i = n;
      while (i);
    }
    return t.slice(0);
  }
  /**
   * Returns the position of `childWindow` relative to `ancestorWindow`
   */
  static getPositionOfChildWindowRelativeToAncestorWindow(e, t) {
    if (!t || e === t)
      return {
        top: 0,
        left: 0
      };
    let i = 0, n = 0;
    const o = this.getSameOriginWindowChain(e);
    for (const r of o) {
      const a = r.window.deref();
      if (i += (a == null ? void 0 : a.scrollY) ?? 0, n += (a == null ? void 0 : a.scrollX) ?? 0, a === t || !r.iframeElement)
        break;
      const l = r.iframeElement.getBoundingClientRect();
      i += l.top, n += l.left;
    }
    return {
      top: i,
      left: n
    };
  }
}
class Uo {
  constructor(e, t) {
    this.timestamp = Date.now(), this.browserEvent = t, this.leftButton = t.button === 0, this.middleButton = t.button === 1, this.rightButton = t.button === 2, this.buttons = t.buttons, this.target = t.target, this.detail = t.detail || 1, t.type === "dblclick" && (this.detail = 2), this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.altKey = t.altKey, this.metaKey = t.metaKey, typeof t.pageX == "number" ? (this.posx = t.pageX, this.posy = t.pageY) : (this.posx = t.clientX + this.target.ownerDocument.body.scrollLeft + this.target.ownerDocument.documentElement.scrollLeft, this.posy = t.clientY + this.target.ownerDocument.body.scrollTop + this.target.ownerDocument.documentElement.scrollTop);
    const i = s6.getPositionOfChildWindowRelativeToAncestorWindow(e, t.view);
    this.posx -= i.left, this.posy -= i.top;
  }
  preventDefault() {
    this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent.stopPropagation();
  }
}
class Hh {
  constructor(e, t = 0, i = 0) {
    var o;
    this.browserEvent = e || null, this.target = e ? e.target || e.targetNode || e.srcElement : null, this.deltaY = i, this.deltaX = t;
    let n = !1;
    if (Ip) {
      const r = navigator.userAgent.match(/Chrome\/(\d+)/);
      n = (r ? parseInt(r[1]) : 123) <= 122;
    }
    if (e) {
      const r = e, a = e, l = ((o = e.view) == null ? void 0 : o.devicePixelRatio) || 1;
      if (typeof r.wheelDeltaY < "u")
        n ? this.deltaY = r.wheelDeltaY / (120 * l) : this.deltaY = r.wheelDeltaY / 120;
      else if (typeof a.VERTICAL_AXIS < "u" && a.axis === a.VERTICAL_AXIS)
        this.deltaY = -a.detail / 3;
      else if (e.type === "wheel") {
        const c = e;
        c.deltaMode === c.DOM_DELTA_LINE ? uo && !$e ? this.deltaY = -e.deltaY / 3 : this.deltaY = -e.deltaY : this.deltaY = -e.deltaY / 40;
      }
      if (typeof r.wheelDeltaX < "u")
        ql && es ? this.deltaX = -(r.wheelDeltaX / 120) : n ? this.deltaX = r.wheelDeltaX / (120 * l) : this.deltaX = r.wheelDeltaX / 120;
      else if (typeof a.HORIZONTAL_AXIS < "u" && a.axis === a.HORIZONTAL_AXIS)
        this.deltaX = -e.detail / 3;
      else if (e.type === "wheel") {
        const c = e;
        c.deltaMode === c.DOM_DELTA_LINE ? uo && !$e ? this.deltaX = -e.deltaX / 3 : this.deltaX = -e.deltaX : this.deltaX = -e.deltaX / 40;
      }
      this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta && (n ? this.deltaY = e.wheelDelta / (120 * l) : this.deltaY = e.wheelDelta / 120);
    }
  }
  preventDefault() {
    var e;
    (e = this.browserEvent) == null || e.preventDefault();
  }
  stopPropagation() {
    var e;
    (e = this.browserEvent) == null || e.stopPropagation();
  }
}
const v4 = Object.freeze(function(s, e) {
  const t = setTimeout(s.bind(e), 0);
  return { dispose() {
    clearTimeout(t);
  } };
});
var _t;
(function(s) {
  function e(t) {
    return t === s.None || t === s.Cancelled || t instanceof eb ? !0 : !t || typeof t != "object" ? !1 : typeof t.isCancellationRequested == "boolean" && typeof t.onCancellationRequested == "function";
  }
  s.isCancellationToken = e, s.None = Object.freeze({
    isCancellationRequested: !1,
    onCancellationRequested: ee.None
  }), s.Cancelled = Object.freeze({
    isCancellationRequested: !0,
    onCancellationRequested: v4
  });
})(_t || (_t = {}));
class eb {
  constructor() {
    this._isCancelled = !1, this._emitter = null;
  }
  cancel() {
    this._isCancelled || (this._isCancelled = !0, this._emitter && (this._emitter.fire(void 0), this.dispose()));
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    return this._isCancelled ? v4 : (this._emitter || (this._emitter = new A()), this._emitter.event);
  }
  dispose() {
    this._emitter && (this._emitter.dispose(), this._emitter = null);
  }
}
class Vs {
  constructor(e) {
    this._token = void 0, this._parentListener = void 0, this._parentListener = e && e.onCancellationRequested(this.cancel, this);
  }
  get token() {
    return this._token || (this._token = new eb()), this._token;
  }
  cancel() {
    this._token ? this._token instanceof eb && this._token.cancel() : this._token = _t.Cancelled;
  }
  dispose(e = !1) {
    var t;
    e && this.cancel(), (t = this._parentListener) == null || t.dispose(), this._token ? this._token instanceof eb && this._token.dispose() : this._token = _t.None;
  }
}
const w4 = Symbol("MicrotaskDelay");
function Ky(s) {
  return !!s && typeof s.then == "function";
}
function Za(s) {
  const e = new Vs(), t = s(e.token), i = new Promise((n, o) => {
    const r = e.token.onCancellationRequested(() => {
      r.dispose(), o(new ed());
    });
    Promise.resolve(t).then((a) => {
      r.dispose(), e.dispose(), n(a);
    }, (a) => {
      r.dispose(), e.dispose(), o(a);
    });
  });
  return new class {
    cancel() {
      e.cancel(), e.dispose();
    }
    then(n, o) {
      return i.then(n, o);
    }
    catch(n) {
      return this.then(void 0, n);
    }
    finally(n) {
      return i.finally(n);
    }
  }();
}
function o6(s, e, t) {
  return new Promise((i, n) => {
    const o = e.onCancellationRequested(() => {
      o.dispose(), i(t);
    });
    s.then(i, n).finally(() => o.dispose());
  });
}
class r6 {
  constructor() {
    this.isDisposed = !1, this.activePromise = null, this.queuedPromise = null, this.queuedPromiseFactory = null;
  }
  queue(e) {
    if (this.isDisposed)
      return Promise.reject(new Error("Throttler is disposed"));
    if (this.activePromise) {
      if (this.queuedPromiseFactory = e, !this.queuedPromise) {
        const t = () => {
          if (this.queuedPromise = null, this.isDisposed)
            return;
          const i = this.queue(this.queuedPromiseFactory);
          return this.queuedPromiseFactory = null, i;
        };
        this.queuedPromise = new Promise((i) => {
          this.activePromise.then(t, t).then(i);
        });
      }
      return new Promise((t, i) => {
        this.queuedPromise.then(t, i);
      });
    }
    return this.activePromise = e(), new Promise((t, i) => {
      this.activePromise.then((n) => {
        this.activePromise = null, t(n);
      }, (n) => {
        this.activePromise = null, i(n);
      });
    });
  }
  dispose() {
    this.isDisposed = !0;
  }
}
const a6 = (s, e) => {
  let t = !0;
  const i = setTimeout(() => {
    t = !1, e();
  }, s);
  return {
    isTriggered: () => t,
    dispose: () => {
      clearTimeout(i), t = !1;
    }
  };
}, l6 = (s) => {
  let e = !0;
  return queueMicrotask(() => {
    e && (e = !1, s());
  }), {
    isTriggered: () => e,
    dispose: () => {
      e = !1;
    }
  };
};
class Np {
  constructor(e) {
    this.defaultDelay = e, this.deferred = null, this.completionPromise = null, this.doResolve = null, this.doReject = null, this.task = null;
  }
  trigger(e, t = this.defaultDelay) {
    this.task = e, this.cancelTimeout(), this.completionPromise || (this.completionPromise = new Promise((n, o) => {
      this.doResolve = n, this.doReject = o;
    }).then(() => {
      if (this.completionPromise = null, this.doResolve = null, this.task) {
        const n = this.task;
        return this.task = null, n();
      }
    }));
    const i = () => {
      var n;
      this.deferred = null, (n = this.doResolve) == null || n.call(this, null);
    };
    return this.deferred = t === w4 ? l6(i) : a6(t, i), this.completionPromise;
  }
  isTriggered() {
    var e;
    return !!((e = this.deferred) != null && e.isTriggered());
  }
  cancel() {
    var e;
    this.cancelTimeout(), this.completionPromise && ((e = this.doReject) == null || e.call(this, new ed()), this.completionPromise = null);
  }
  cancelTimeout() {
    var e;
    (e = this.deferred) == null || e.dispose(), this.deferred = null;
  }
  dispose() {
    this.cancel();
  }
}
class y4 {
  constructor(e) {
    this.delayer = new Np(e), this.throttler = new r6();
  }
  trigger(e, t) {
    return this.delayer.trigger(() => this.throttler.queue(e), t);
  }
  cancel() {
    this.delayer.cancel();
  }
  dispose() {
    this.delayer.dispose(), this.throttler.dispose();
  }
}
function Em(s, e) {
  return e ? new Promise((t, i) => {
    const n = setTimeout(() => {
      o.dispose(), t();
    }, s), o = e.onCancellationRequested(() => {
      clearTimeout(n), o.dispose(), i(new ed());
    });
  }) : Za((t) => Em(s, t));
}
function Kb(s, e = 0, t) {
  const i = setTimeout(() => {
    s(), t && n.dispose();
  }, e), n = _e(() => {
    clearTimeout(i), t == null || t.deleteAndLeak(n);
  });
  return t == null || t.add(n), n;
}
class Ya {
  constructor(e, t) {
    this._isDisposed = !1, this._token = -1, typeof e == "function" && typeof t == "number" && this.setIfNotSet(e, t);
  }
  dispose() {
    this.cancel(), this._isDisposed = !0;
  }
  cancel() {
    this._token !== -1 && (clearTimeout(this._token), this._token = -1);
  }
  cancelAndSet(e, t) {
    if (this._isDisposed)
      throw new at("Calling 'cancelAndSet' on a disposed TimeoutTimer");
    this.cancel(), this._token = setTimeout(() => {
      this._token = -1, e();
    }, t);
  }
  setIfNotSet(e, t) {
    if (this._isDisposed)
      throw new at("Calling 'setIfNotSet' on a disposed TimeoutTimer");
    this._token === -1 && (this._token = setTimeout(() => {
      this._token = -1, e();
    }, t));
  }
}
class wE {
  constructor() {
    this.disposable = void 0, this.isDisposed = !1;
  }
  cancel() {
    var e;
    (e = this.disposable) == null || e.dispose(), this.disposable = void 0;
  }
  cancelAndSet(e, t, i = globalThis) {
    if (this.isDisposed)
      throw new at("Calling 'cancelAndSet' on a disposed IntervalTimer");
    this.cancel();
    const n = i.setInterval(() => {
      e();
    }, t);
    this.disposable = _e(() => {
      i.clearInterval(n), this.disposable = void 0;
    });
  }
  dispose() {
    this.cancel(), this.isDisposed = !0;
  }
}
class ai {
  constructor(e, t) {
    this.timeoutToken = -1, this.runner = e, this.timeout = t, this.timeoutHandler = this.onTimeout.bind(this);
  }
  /**
   * Dispose RunOnceScheduler
   */
  dispose() {
    this.cancel(), this.runner = null;
  }
  /**
   * Cancel current scheduled runner (if any).
   */
  cancel() {
    this.isScheduled() && (clearTimeout(this.timeoutToken), this.timeoutToken = -1);
  }
  /**
   * Cancel previous runner (if any) & schedule a new runner.
   */
  schedule(e = this.timeout) {
    this.cancel(), this.timeoutToken = setTimeout(this.timeoutHandler, e);
  }
  get delay() {
    return this.timeout;
  }
  set delay(e) {
    this.timeout = e;
  }
  /**
   * Returns true if scheduled.
   */
  isScheduled() {
    return this.timeoutToken !== -1;
  }
  onTimeout() {
    this.timeoutToken = -1, this.runner && this.doRun();
  }
  doRun() {
    var e;
    (e = this.runner) == null || e.call(this);
  }
}
let S4, Ag;
(function() {
  typeof globalThis.requestIdleCallback != "function" || typeof globalThis.cancelIdleCallback != "function" ? Ag = (s, e) => {
    jP(() => {
      if (t)
        return;
      const i = Date.now() + 15;
      e(Object.freeze({
        didTimeout: !0,
        timeRemaining() {
          return Math.max(0, i - Date.now());
        }
      }));
    });
    let t = !1;
    return {
      dispose() {
        t || (t = !0);
      }
    };
  } : Ag = (s, e, t) => {
    const i = s.requestIdleCallback(e, typeof t == "number" ? { timeout: t } : void 0);
    let n = !1;
    return {
      dispose() {
        n || (n = !0, s.cancelIdleCallback(i));
      }
    };
  }, S4 = (s) => Ag(globalThis, s);
})();
class c6 {
  constructor(e, t) {
    this._didRun = !1, this._executor = () => {
      try {
        this._value = t();
      } catch (i) {
        this._error = i;
      } finally {
        this._didRun = !0;
      }
    }, this._handle = Ag(e, () => this._executor());
  }
  dispose() {
    this._handle.dispose();
  }
  get value() {
    if (this._didRun || (this._handle.dispose(), this._executor()), this._error)
      throw this._error;
    return this._value;
  }
  get isInitialized() {
    return this._didRun;
  }
}
class h6 extends c6 {
  constructor(e) {
    super(globalThis, e);
  }
}
class L4 {
  get isRejected() {
    var e;
    return ((e = this.outcome) == null ? void 0 : e.outcome) === 1;
  }
  get isSettled() {
    return !!this.outcome;
  }
  constructor() {
    this.p = new Promise((e, t) => {
      this.completeCallback = e, this.errorCallback = t;
    });
  }
  complete(e) {
    return new Promise((t) => {
      this.completeCallback(e), this.outcome = { outcome: 0, value: e }, t();
    });
  }
  error(e) {
    return new Promise((t) => {
      this.errorCallback(e), this.outcome = { outcome: 1, value: e }, t();
    });
  }
  cancel() {
    return this.error(new ed());
  }
}
var jy;
(function(s) {
  async function e(i) {
    let n;
    const o = await Promise.all(i.map((r) => r.then((a) => a, (a) => {
      n || (n = a);
    })));
    if (typeof n < "u")
      throw n;
    return o;
  }
  s.settled = e;
  function t(i) {
    return new Promise(async (n, o) => {
      try {
        await i(n, o);
      } catch (r) {
        o(r);
      }
    });
  }
  s.withAsyncBody = t;
})(jy || (jy = {}));
const $n = class $n {
  static fromArray(e) {
    return new $n((t) => {
      t.emitMany(e);
    });
  }
  static fromPromise(e) {
    return new $n(async (t) => {
      t.emitMany(await e);
    });
  }
  static fromPromises(e) {
    return new $n(async (t) => {
      await Promise.all(e.map(async (i) => t.emitOne(await i)));
    });
  }
  static merge(e) {
    return new $n(async (t) => {
      await Promise.all(e.map(async (i) => {
        for await (const n of i)
          t.emitOne(n);
      }));
    });
  }
  constructor(e, t) {
    this._state = 0, this._results = [], this._error = null, this._onReturn = t, this._onStateChanged = new A(), queueMicrotask(async () => {
      const i = {
        emitOne: (n) => this.emitOne(n),
        emitMany: (n) => this.emitMany(n),
        reject: (n) => this.reject(n)
      };
      try {
        await Promise.resolve(e(i)), this.resolve();
      } catch (n) {
        this.reject(n);
      } finally {
        i.emitOne = void 0, i.emitMany = void 0, i.reject = void 0;
      }
    });
  }
  [Symbol.asyncIterator]() {
    let e = 0;
    return {
      next: async () => {
        do {
          if (this._state === 2)
            throw this._error;
          if (e < this._results.length)
            return { done: !1, value: this._results[e++] };
          if (this._state === 1)
            return { done: !0, value: void 0 };
          await ee.toPromise(this._onStateChanged.event);
        } while (!0);
      },
      return: async () => {
        var t;
        return (t = this._onReturn) == null || t.call(this), { done: !0, value: void 0 };
      }
    };
  }
  static map(e, t) {
    return new $n(async (i) => {
      for await (const n of e)
        i.emitOne(t(n));
    });
  }
  map(e) {
    return $n.map(this, e);
  }
  static filter(e, t) {
    return new $n(async (i) => {
      for await (const n of e)
        t(n) && i.emitOne(n);
    });
  }
  filter(e) {
    return $n.filter(this, e);
  }
  static coalesce(e) {
    return $n.filter(e, (t) => !!t);
  }
  coalesce() {
    return $n.coalesce(this);
  }
  static async toPromise(e) {
    const t = [];
    for await (const i of e)
      t.push(i);
    return t;
  }
  toPromise() {
    return $n.toPromise(this);
  }
  /**
   * The value will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitOne(e) {
    this._state === 0 && (this._results.push(e), this._onStateChanged.fire());
  }
  /**
   * The values will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitMany(e) {
    this._state === 0 && (this._results = this._results.concat(e), this._onStateChanged.fire());
  }
  /**
   * Calling `resolve()` will mark the result array as complete.
   *
   * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  resolve() {
    this._state === 0 && (this._state = 1, this._onStateChanged.fire());
  }
  /**
   * Writing an error will permanently invalidate this iterable.
   * The current users will receive an error thrown, as will all future users.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  reject(e) {
    this._state === 0 && (this._state = 2, this._error = e, this._onStateChanged.fire());
  }
};
$n.EMPTY = $n.fromArray([]);
let Cs = $n;
class d6 extends Cs {
  constructor(e, t) {
    super(t), this._source = e;
  }
  cancel() {
    this._source.cancel();
  }
}
function u6(s) {
  const e = new Vs(), t = s(e.token);
  return new d6(e, async (i) => {
    const n = e.token.onCancellationRequested(() => {
      n.dispose(), e.dispose(), i.reject(new ed());
    });
    try {
      for await (const o of t) {
        if (e.token.isCancellationRequested)
          return;
        i.emitOne(o);
      }
      n.dispose(), e.dispose();
    } catch (o) {
      n.dispose(), e.dispose(), i.reject(o);
    }
  });
}
/*! @license DOMPurify 3.1.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.7/LICENSE */
const {
  entries: k4,
  setPrototypeOf: S2,
  isFrozen: f6,
  getPrototypeOf: g6,
  getOwnPropertyDescriptor: m6
} = Object;
let {
  freeze: is,
  seal: fo,
  create: x4
} = Object, {
  apply: qy,
  construct: Gy
} = typeof Reflect < "u" && Reflect;
is || (is = function(e) {
  return e;
});
fo || (fo = function(e) {
  return e;
});
qy || (qy = function(e, t, i) {
  return e.apply(t, i);
});
Gy || (Gy = function(e, t) {
  return new e(...t);
});
const o_ = zs(Array.prototype.forEach), L2 = zs(Array.prototype.pop), qf = zs(Array.prototype.push), tb = zs(String.prototype.toLowerCase), l0 = zs(String.prototype.toString), k2 = zs(String.prototype.match), Gf = zs(String.prototype.replace), p6 = zs(String.prototype.indexOf), _6 = zs(String.prototype.trim), No = zs(Object.prototype.hasOwnProperty), Vn = zs(RegExp.prototype.test), Zf = b6(TypeError);
function zs(s) {
  return function(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
      i[n - 1] = arguments[n];
    return qy(s, e, i);
  };
}
function b6(s) {
  return function() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return Gy(s, t);
  };
}
function ut(s, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : tb;
  S2 && S2(s, null);
  let i = e.length;
  for (; i--; ) {
    let n = e[i];
    if (typeof n == "string") {
      const o = t(n);
      o !== n && (f6(e) || (e[i] = o), n = o);
    }
    s[n] = !0;
  }
  return s;
}
function C6(s) {
  for (let e = 0; e < s.length; e++)
    No(s, e) || (s[e] = null);
  return s;
}
function vc(s) {
  const e = x4(null);
  for (const [t, i] of k4(s))
    No(s, t) && (Array.isArray(i) ? e[t] = C6(i) : i && typeof i == "object" && i.constructor === Object ? e[t] = vc(i) : e[t] = i);
  return e;
}
function Yf(s, e) {
  for (; s !== null; ) {
    const i = m6(s, e);
    if (i) {
      if (i.get)
        return zs(i.get);
      if (typeof i.value == "function")
        return zs(i.value);
    }
    s = g6(s);
  }
  function t() {
    return null;
  }
  return t;
}
const x2 = is(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), c0 = is(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), h0 = is(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), v6 = is(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), d0 = is(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), w6 = is(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), D2 = is(["#text"]), E2 = is(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), u0 = is(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), I2 = is(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), r_ = is(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), y6 = fo(/\{\{[\w\W]*|[\w\W]*\}\}/gm), S6 = fo(/<%[\w\W]*|[\w\W]*%>/gm), L6 = fo(/\${[\w\W]*}/gm), k6 = fo(/^data-[\-\w.\u00B7-\uFFFF]/), x6 = fo(/^aria-[\-\w]+$/), D4 = fo(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), D6 = fo(/^(?:\w+script|data):/i), E6 = fo(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), E4 = fo(/^html$/i), I6 = fo(/^[a-z][.\w]*(-[.\w]+)+$/i);
var N2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR: y6,
  ERB_EXPR: S6,
  TMPLIT_EXPR: L6,
  DATA_ATTR: k6,
  ARIA_ATTR: x6,
  IS_ALLOWED_URI: D4,
  IS_SCRIPT_OR_DATA: D6,
  ATTR_WHITESPACE: E6,
  DOCTYPE_NAME: E4,
  CUSTOM_ELEMENT: I6
});
const Xf = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, N6 = function() {
  return typeof window > "u" ? null : window;
}, T6 = function(e, t) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let i = null;
  const n = "data-tt-policy-suffix";
  t && t.hasAttribute(n) && (i = t.getAttribute(n));
  const o = "dompurify" + (i ? "#" + i : "");
  try {
    return e.createPolicy(o, {
      createHTML(r) {
        return r;
      },
      createScriptURL(r) {
        return r;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + o + " could not be created."), null;
  }
};
function I4() {
  let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : N6();
  const e = (Re) => I4(Re);
  if (e.version = "3.1.7", e.removed = [], !s || !s.document || s.document.nodeType !== Xf.document)
    return e.isSupported = !1, e;
  let {
    document: t
  } = s;
  const i = t, n = i.currentScript, {
    DocumentFragment: o,
    HTMLTemplateElement: r,
    Node: a,
    Element: l,
    NodeFilter: c,
    NamedNodeMap: h = s.NamedNodeMap || s.MozNamedAttrMap,
    HTMLFormElement: d,
    DOMParser: u,
    trustedTypes: f
  } = s, g = l.prototype, p = Yf(g, "cloneNode"), _ = Yf(g, "remove"), b = Yf(g, "nextSibling"), C = Yf(g, "childNodes"), w = Yf(g, "parentNode");
  if (typeof r == "function") {
    const Re = t.createElement("template");
    Re.content && Re.content.ownerDocument && (t = Re.content.ownerDocument);
  }
  let v, S = "";
  const {
    implementation: L,
    createNodeIterator: k,
    createDocumentFragment: x,
    getElementsByTagName: I
  } = t, {
    importNode: K
  } = i;
  let B = {};
  e.isSupported = typeof k4 == "function" && typeof w == "function" && L && L.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: W,
    ERB_EXPR: H,
    TMPLIT_EXPR: P,
    DATA_ATTR: q,
    ARIA_ATTR: J,
    IS_SCRIPT_OR_DATA: oe,
    ATTR_WHITESPACE: ae,
    CUSTOM_ELEMENT: re
  } = N2;
  let {
    IS_ALLOWED_URI: be
  } = N2, Ce = null;
  const At = ut({}, [...x2, ...c0, ...h0, ...d0, ...D2]);
  let ye = null;
  const ct = ut({}, [...E2, ...u0, ...I2, ...r_]);
  let ot = Object.seal(x4(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Xt = null, hn = null, Sn = !0, qs = !0, as = !1, rc = !0, di = !1, Gs = !0, Xr = !1, zf = !1, Uf = !1, tl = !1, yd = !1, Sd = !1, ac = !0, Xp = !1;
  const Qp = "user-content-";
  let Ld = !0, lc = !1, or = {}, il = null;
  const kd = ut({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let Jp = null;
  const cc = ut({}, ["audio", "video", "img", "source", "image", "track"]);
  let Qr = null;
  const ls = ut({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), rr = "http://www.w3.org/1998/Math/MathML", Jr = "http://www.w3.org/2000/svg", xi = "http://www.w3.org/1999/xhtml";
  let Ds = xi, xd = !1, So = null;
  const Mt = ut({}, [rr, Jr, xi], l0);
  let hc = null;
  const Xw = ["application/xhtml+xml", "text/html"], Qw = "text/html";
  let Ri = null, nl = null;
  const Jw = t.createElement("form"), e_ = function($) {
    return $ instanceof RegExp || $ instanceof Function;
  }, $f = function() {
    let $ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(nl && nl === $)) {
      if ((!$ || typeof $ != "object") && ($ = {}), $ = vc($), hc = // eslint-disable-next-line unicorn/prefer-includes
      Xw.indexOf($.PARSER_MEDIA_TYPE) === -1 ? Qw : $.PARSER_MEDIA_TYPE, Ri = hc === "application/xhtml+xml" ? l0 : tb, Ce = No($, "ALLOWED_TAGS") ? ut({}, $.ALLOWED_TAGS, Ri) : At, ye = No($, "ALLOWED_ATTR") ? ut({}, $.ALLOWED_ATTR, Ri) : ct, So = No($, "ALLOWED_NAMESPACES") ? ut({}, $.ALLOWED_NAMESPACES, l0) : Mt, Qr = No($, "ADD_URI_SAFE_ATTR") ? ut(
        vc(ls),
        // eslint-disable-line indent
        $.ADD_URI_SAFE_ATTR,
        // eslint-disable-line indent
        Ri
        // eslint-disable-line indent
      ) : ls, Jp = No($, "ADD_DATA_URI_TAGS") ? ut(
        vc(cc),
        // eslint-disable-line indent
        $.ADD_DATA_URI_TAGS,
        // eslint-disable-line indent
        Ri
        // eslint-disable-line indent
      ) : cc, il = No($, "FORBID_CONTENTS") ? ut({}, $.FORBID_CONTENTS, Ri) : kd, Xt = No($, "FORBID_TAGS") ? ut({}, $.FORBID_TAGS, Ri) : {}, hn = No($, "FORBID_ATTR") ? ut({}, $.FORBID_ATTR, Ri) : {}, or = No($, "USE_PROFILES") ? $.USE_PROFILES : !1, Sn = $.ALLOW_ARIA_ATTR !== !1, qs = $.ALLOW_DATA_ATTR !== !1, as = $.ALLOW_UNKNOWN_PROTOCOLS || !1, rc = $.ALLOW_SELF_CLOSE_IN_ATTR !== !1, di = $.SAFE_FOR_TEMPLATES || !1, Gs = $.SAFE_FOR_XML !== !1, Xr = $.WHOLE_DOCUMENT || !1, tl = $.RETURN_DOM || !1, yd = $.RETURN_DOM_FRAGMENT || !1, Sd = $.RETURN_TRUSTED_TYPE || !1, Uf = $.FORCE_BODY || !1, ac = $.SANITIZE_DOM !== !1, Xp = $.SANITIZE_NAMED_PROPS || !1, Ld = $.KEEP_CONTENT !== !1, lc = $.IN_PLACE || !1, be = $.ALLOWED_URI_REGEXP || D4, Ds = $.NAMESPACE || xi, ot = $.CUSTOM_ELEMENT_HANDLING || {}, $.CUSTOM_ELEMENT_HANDLING && e_($.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (ot.tagNameCheck = $.CUSTOM_ELEMENT_HANDLING.tagNameCheck), $.CUSTOM_ELEMENT_HANDLING && e_($.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (ot.attributeNameCheck = $.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), $.CUSTOM_ELEMENT_HANDLING && typeof $.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (ot.allowCustomizedBuiltInElements = $.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), di && (qs = !1), yd && (tl = !0), or && (Ce = ut({}, D2), ye = [], or.html === !0 && (ut(Ce, x2), ut(ye, E2)), or.svg === !0 && (ut(Ce, c0), ut(ye, u0), ut(ye, r_)), or.svgFilters === !0 && (ut(Ce, h0), ut(ye, u0), ut(ye, r_)), or.mathMl === !0 && (ut(Ce, d0), ut(ye, I2), ut(ye, r_))), $.ADD_TAGS && (Ce === At && (Ce = vc(Ce)), ut(Ce, $.ADD_TAGS, Ri)), $.ADD_ATTR && (ye === ct && (ye = vc(ye)), ut(ye, $.ADD_ATTR, Ri)), $.ADD_URI_SAFE_ATTR && ut(Qr, $.ADD_URI_SAFE_ATTR, Ri), $.FORBID_CONTENTS && (il === kd && (il = vc(il)), ut(il, $.FORBID_CONTENTS, Ri)), Ld && (Ce["#text"] = !0), Xr && ut(Ce, ["html", "head", "body"]), Ce.table && (ut(Ce, ["tbody"]), delete Xt.tbody), $.TRUSTED_TYPES_POLICY) {
        if (typeof $.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Zf('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof $.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Zf('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        v = $.TRUSTED_TYPES_POLICY, S = v.createHTML("");
      } else
        v === void 0 && (v = T6(f, n)), v !== null && typeof S == "string" && (S = v.createHTML(""));
      is && is($), nl = $;
    }
  }, je = ut({}, ["mi", "mo", "mn", "ms", "mtext"]), N = ut({}, ["annotation-xml"]), M = ut({}, ["title", "style", "font", "a", "script"]), R = ut({}, [...c0, ...h0, ...v6]), O = ut({}, [...d0, ...w6]), V = function($) {
    let de = w($);
    (!de || !de.tagName) && (de = {
      namespaceURI: Ds,
      tagName: "template"
    });
    const ke = tb($.tagName), ri = tb(de.tagName);
    return So[$.namespaceURI] ? $.namespaceURI === Jr ? de.namespaceURI === xi ? ke === "svg" : de.namespaceURI === rr ? ke === "svg" && (ri === "annotation-xml" || je[ri]) : !!R[ke] : $.namespaceURI === rr ? de.namespaceURI === xi ? ke === "math" : de.namespaceURI === Jr ? ke === "math" && N[ri] : !!O[ke] : $.namespaceURI === xi ? de.namespaceURI === Jr && !N[ri] || de.namespaceURI === rr && !je[ri] ? !1 : !O[ke] && (M[ke] || !R[ke]) : !!(hc === "application/xhtml+xml" && So[$.namespaceURI]) : !1;
  }, G = function($) {
    qf(e.removed, {
      element: $
    });
    try {
      w($).removeChild($);
    } catch {
      _($);
    }
  }, Q = function($, de) {
    try {
      qf(e.removed, {
        attribute: de.getAttributeNode($),
        from: de
      });
    } catch {
      qf(e.removed, {
        attribute: null,
        from: de
      });
    }
    if (de.removeAttribute($), $ === "is" && !ye[$])
      if (tl || yd)
        try {
          G(de);
        } catch {
        }
      else
        try {
          de.setAttribute($, "");
        } catch {
        }
  }, ue = function($) {
    let de = null, ke = null;
    if (Uf)
      $ = "<remove></remove>" + $;
    else {
      const dn = k2($, /^[\r\n\t ]+/);
      ke = dn && dn[0];
    }
    hc === "application/xhtml+xml" && Ds === xi && ($ = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + $ + "</body></html>");
    const ri = v ? v.createHTML($) : $;
    if (Ds === xi)
      try {
        de = new u().parseFromString(ri, hc);
      } catch {
      }
    if (!de || !de.documentElement) {
      de = L.createDocument(Ds, "template", null);
      try {
        de.documentElement.innerHTML = xd ? S : ri;
      } catch {
      }
    }
    const Ln = de.body || de.documentElement;
    return $ && ke && Ln.insertBefore(t.createTextNode(ke), Ln.childNodes[0] || null), Ds === xi ? I.call(de, Xr ? "html" : "body")[0] : Xr ? de.documentElement : Ln;
  }, me = function($) {
    return k.call(
      $.ownerDocument || $,
      $,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,
      null
    );
  }, We = function($) {
    return $ instanceof d && (typeof $.nodeName != "string" || typeof $.textContent != "string" || typeof $.removeChild != "function" || !($.attributes instanceof h) || typeof $.removeAttribute != "function" || typeof $.setAttribute != "function" || typeof $.namespaceURI != "string" || typeof $.insertBefore != "function" || typeof $.hasChildNodes != "function");
  }, dt = function($) {
    return typeof a == "function" && $ instanceof a;
  }, mt = function($, de, ke) {
    B[$] && o_(B[$], (ri) => {
      ri.call(e, de, ke, nl);
    });
  }, $t = function($) {
    let de = null;
    if (mt("beforeSanitizeElements", $, null), We($))
      return G($), !0;
    const ke = Ri($.nodeName);
    if (mt("uponSanitizeElement", $, {
      tagName: ke,
      allowedTags: Ce
    }), $.hasChildNodes() && !dt($.firstElementChild) && Vn(/<[/\w]/g, $.innerHTML) && Vn(/<[/\w]/g, $.textContent) || $.nodeType === Xf.progressingInstruction || Gs && $.nodeType === Xf.comment && Vn(/<[/\w]/g, $.data))
      return G($), !0;
    if (!Ce[ke] || Xt[ke]) {
      if (!Xt[ke] && Wn(ke) && (ot.tagNameCheck instanceof RegExp && Vn(ot.tagNameCheck, ke) || ot.tagNameCheck instanceof Function && ot.tagNameCheck(ke)))
        return !1;
      if (Ld && !il[ke]) {
        const ri = w($) || $.parentNode, Ln = C($) || $.childNodes;
        if (Ln && ri) {
          const dn = Ln.length;
          for (let cs = dn - 1; cs >= 0; --cs) {
            const ar = p(Ln[cs], !0);
            ar.__removalCount = ($.__removalCount || 0) + 1, ri.insertBefore(ar, b($));
          }
        }
      }
      return G($), !0;
    }
    return $ instanceof l && !V($) || (ke === "noscript" || ke === "noembed" || ke === "noframes") && Vn(/<\/no(script|embed|frames)/i, $.innerHTML) ? (G($), !0) : (di && $.nodeType === Xf.text && (de = $.textContent, o_([W, H, P], (ri) => {
      de = Gf(de, ri, " ");
    }), $.textContent !== de && (qf(e.removed, {
      element: $.cloneNode()
    }), $.textContent = de)), mt("afterSanitizeElements", $, null), !1);
  }, Kt = function($, de, ke) {
    if (ac && (de === "id" || de === "name") && (ke in t || ke in Jw))
      return !1;
    if (!(qs && !hn[de] && Vn(q, de))) {
      if (!(Sn && Vn(J, de))) {
        if (!ye[de] || hn[de]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(Wn($) && (ot.tagNameCheck instanceof RegExp && Vn(ot.tagNameCheck, $) || ot.tagNameCheck instanceof Function && ot.tagNameCheck($)) && (ot.attributeNameCheck instanceof RegExp && Vn(ot.attributeNameCheck, de) || ot.attributeNameCheck instanceof Function && ot.attributeNameCheck(de)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            de === "is" && ot.allowCustomizedBuiltInElements && (ot.tagNameCheck instanceof RegExp && Vn(ot.tagNameCheck, ke) || ot.tagNameCheck instanceof Function && ot.tagNameCheck(ke)))
          ) return !1;
        } else if (!Qr[de]) {
          if (!Vn(be, Gf(ke, ae, ""))) {
            if (!((de === "src" || de === "xlink:href" || de === "href") && $ !== "script" && p6(ke, "data:") === 0 && Jp[$])) {
              if (!(as && !Vn(oe, Gf(ke, ae, "")))) {
                if (ke)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Wn = function($) {
    return $ !== "annotation-xml" && k2($, re);
  }, Es = function($) {
    mt("beforeSanitizeAttributes", $, null);
    const {
      attributes: de
    } = $;
    if (!de)
      return;
    const ke = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: ye
    };
    let ri = de.length;
    for (; ri--; ) {
      const Ln = de[ri], {
        name: dn,
        namespaceURI: cs,
        value: ar
      } = Ln, jf = Ri(dn);
      let Hn = dn === "value" ? ar : _6(ar);
      if (ke.attrName = jf, ke.attrValue = Hn, ke.keepAttr = !0, ke.forceKeepAttr = void 0, mt("uponSanitizeAttribute", $, ke), Hn = ke.attrValue, ke.forceKeepAttr || (Q(dn, $), !ke.keepAttr))
        continue;
      if (!rc && Vn(/\/>/i, Hn)) {
        Q(dn, $);
        continue;
      }
      di && o_([W, H, P], (s2) => {
        Hn = Gf(Hn, s2, " ");
      });
      const n2 = Ri($.nodeName);
      if (Kt(n2, jf, Hn)) {
        if (Xp && (jf === "id" || jf === "name") && (Q(dn, $), Hn = Qp + Hn), Gs && Vn(/((--!?|])>)|<\/(style|title)/i, Hn)) {
          Q(dn, $);
          continue;
        }
        if (v && typeof f == "object" && typeof f.getAttributeType == "function" && !cs)
          switch (f.getAttributeType(n2, jf)) {
            case "TrustedHTML": {
              Hn = v.createHTML(Hn);
              break;
            }
            case "TrustedScriptURL": {
              Hn = v.createScriptURL(Hn);
              break;
            }
          }
        try {
          cs ? $.setAttributeNS(cs, dn, Hn) : $.setAttribute(dn, Hn), We($) ? G($) : L2(e.removed);
        } catch {
        }
      }
    }
    mt("afterSanitizeAttributes", $, null);
  }, Kf = function Re($) {
    let de = null;
    const ke = me($);
    for (mt("beforeSanitizeShadowDOM", $, null); de = ke.nextNode(); )
      mt("uponSanitizeShadowNode", de, null), !$t(de) && (de.content instanceof o && Re(de.content), Es(de));
    mt("afterSanitizeShadowDOM", $, null);
  };
  return e.sanitize = function(Re) {
    let $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, de = null, ke = null, ri = null, Ln = null;
    if (xd = !Re, xd && (Re = "<!-->"), typeof Re != "string" && !dt(Re))
      if (typeof Re.toString == "function") {
        if (Re = Re.toString(), typeof Re != "string")
          throw Zf("dirty is not a string, aborting");
      } else
        throw Zf("toString is not a function");
    if (!e.isSupported)
      return Re;
    if (zf || $f($), e.removed = [], typeof Re == "string" && (lc = !1), lc) {
      if (Re.nodeName) {
        const ar = Ri(Re.nodeName);
        if (!Ce[ar] || Xt[ar])
          throw Zf("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Re instanceof a)
      de = ue("<!---->"), ke = de.ownerDocument.importNode(Re, !0), ke.nodeType === Xf.element && ke.nodeName === "BODY" || ke.nodeName === "HTML" ? de = ke : de.appendChild(ke);
    else {
      if (!tl && !di && !Xr && // eslint-disable-next-line unicorn/prefer-includes
      Re.indexOf("<") === -1)
        return v && Sd ? v.createHTML(Re) : Re;
      if (de = ue(Re), !de)
        return tl ? null : Sd ? S : "";
    }
    de && Uf && G(de.firstChild);
    const dn = me(lc ? Re : de);
    for (; ri = dn.nextNode(); )
      $t(ri) || (ri.content instanceof o && Kf(ri.content), Es(ri));
    if (lc)
      return Re;
    if (tl) {
      if (yd)
        for (Ln = x.call(de.ownerDocument); de.firstChild; )
          Ln.appendChild(de.firstChild);
      else
        Ln = de;
      return (ye.shadowroot || ye.shadowrootmode) && (Ln = K.call(i, Ln, !0)), Ln;
    }
    let cs = Xr ? de.outerHTML : de.innerHTML;
    return Xr && Ce["!doctype"] && de.ownerDocument && de.ownerDocument.doctype && de.ownerDocument.doctype.name && Vn(E4, de.ownerDocument.doctype.name) && (cs = "<!DOCTYPE " + de.ownerDocument.doctype.name + `>
` + cs), di && o_([W, H, P], (ar) => {
      cs = Gf(cs, ar, " ");
    }), v && Sd ? v.createHTML(cs) : cs;
  }, e.setConfig = function() {
    let Re = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    $f(Re), zf = !0;
  }, e.clearConfig = function() {
    nl = null, zf = !1;
  }, e.isValidAttribute = function(Re, $, de) {
    nl || $f({});
    const ke = Ri(Re), ri = Ri($);
    return Kt(ke, ri, de);
  }, e.addHook = function(Re, $) {
    typeof $ == "function" && (B[Re] = B[Re] || [], qf(B[Re], $));
  }, e.removeHook = function(Re) {
    if (B[Re])
      return L2(B[Re]);
  }, e.removeHooks = function(Re) {
    B[Re] && (B[Re] = []);
  }, e.removeAllHooks = function() {
    B = {};
  }, e;
}
var Kr = I4();
Kr.version;
Kr.isSupported;
const N4 = Kr.sanitize;
Kr.setConfig;
Kr.clearConfig;
Kr.isValidAttribute;
const T4 = Kr.addHook, M4 = Kr.removeHook;
Kr.removeHooks;
Kr.removeAllHooks;
var Ie;
(function(s) {
  s.inMemory = "inmemory", s.vscode = "vscode", s.internal = "private", s.walkThrough = "walkThrough", s.walkThroughSnippet = "walkThroughSnippet", s.http = "http", s.https = "https", s.file = "file", s.mailto = "mailto", s.untitled = "untitled", s.data = "data", s.command = "command", s.vscodeRemote = "vscode-remote", s.vscodeRemoteResource = "vscode-remote-resource", s.vscodeManagedRemoteResource = "vscode-managed-remote-resource", s.vscodeUserData = "vscode-userdata", s.vscodeCustomEditor = "vscode-custom-editor", s.vscodeNotebookCell = "vscode-notebook-cell", s.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata", s.vscodeNotebookCellMetadataDiff = "vscode-notebook-cell-metadata-diff", s.vscodeNotebookCellOutput = "vscode-notebook-cell-output", s.vscodeNotebookCellOutputDiff = "vscode-notebook-cell-output-diff", s.vscodeNotebookMetadata = "vscode-notebook-metadata", s.vscodeInteractiveInput = "vscode-interactive-input", s.vscodeSettings = "vscode-settings", s.vscodeWorkspaceTrust = "vscode-workspace-trust", s.vscodeTerminal = "vscode-terminal", s.vscodeChatCodeBlock = "vscode-chat-code-block", s.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block", s.vscodeChatSesssion = "vscode-chat-editor", s.webviewPanel = "webview-panel", s.vscodeWebview = "vscode-webview", s.extension = "extension", s.vscodeFileResource = "vscode-file", s.tmp = "tmp", s.vsls = "vsls", s.vscodeSourceControl = "vscode-scm", s.commentsInput = "comment", s.codeSetting = "code-setting", s.outputChannel = "output";
})(Ie || (Ie = {}));
function yE(s, e) {
  return we.isUri(s) ? Zd(s.scheme, e) : cE(s, e + ":");
}
function Zy(s, ...e) {
  return e.some((t) => yE(s, t));
}
const M6 = "tkn";
class R6 {
  constructor() {
    this._hosts = /* @__PURE__ */ Object.create(null), this._ports = /* @__PURE__ */ Object.create(null), this._connectionTokens = /* @__PURE__ */ Object.create(null), this._preferredWebSchema = "http", this._delegate = null, this._serverRootPath = "/";
  }
  setPreferredWebSchema(e) {
    this._preferredWebSchema = e;
  }
  get _remoteResourcesPath() {
    return ni.join(this._serverRootPath, Ie.vscodeRemoteResource);
  }
  rewrite(e) {
    if (this._delegate)
      try {
        return this._delegate(e);
      } catch (a) {
        return Je(a), e;
      }
    const t = e.authority;
    let i = this._hosts[t];
    i && i.indexOf(":") !== -1 && i.indexOf("[") === -1 && (i = `[${i}]`);
    const n = this._ports[t], o = this._connectionTokens[t];
    let r = `path=${encodeURIComponent(e.path)}`;
    return typeof o == "string" && (r += `&${M6}=${encodeURIComponent(o)}`), we.from({
      scheme: Ef ? this._preferredWebSchema : Ie.vscodeRemoteResource,
      authority: `${i}:${n}`,
      path: this._remoteResourcesPath,
      query: r
    });
  }
}
const R4 = new R6(), A6 = "vscode-app", hm = class hm {
  /**
   * Returns a URI to use in contexts where the browser is responsible
   * for loading (e.g. fetch()) or when used within the DOM.
   *
   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
   */
  asBrowserUri(e) {
    const t = this.toUri(e);
    return this.uriToBrowserUri(t);
  }
  /**
   * Returns a URI to use in contexts where the browser is responsible
   * for loading (e.g. fetch()) or when used within the DOM.
   *
   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
   */
  uriToBrowserUri(e) {
    return e.scheme === Ie.vscodeRemote ? R4.rewrite(e) : (
      // ...only ever for `file` resources
      e.scheme === Ie.file && // ...and we run in native environments
      (Ab || // ...or web worker extensions on desktop
      _9 === `${Ie.vscodeFileResource}://${hm.FALLBACK_AUTHORITY}`) ? e.with({
        scheme: Ie.vscodeFileResource,
        // We need to provide an authority here so that it can serve
        // as origin for network and loading matters in chromium.
        // If the URI is not coming with an authority already, we
        // add our own
        authority: e.authority || hm.FALLBACK_AUTHORITY,
        query: null,
        fragment: null
      }) : e
    );
  }
  toUri(e, t) {
    if (we.isUri(e))
      return e;
    if (globalThis._VSCODE_FILE_ROOT) {
      const i = globalThis._VSCODE_FILE_ROOT;
      if (/^\w[\w\d+.-]*:\/\//.test(i))
        return we.joinPath(we.parse(i, !0), e);
      const n = R9(i, e);
      return we.file(n);
    }
    return we.parse(t.toUrl(e));
  }
};
hm.FALLBACK_AUTHORITY = A6;
let Yy = hm;
const Yv = new Yy();
var Xy;
(function(s) {
  const e = /* @__PURE__ */ new Map([
    ["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
    ["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
    ["3", { "Cross-Origin-Opener-Policy": "same-origin", "Cross-Origin-Embedder-Policy": "require-corp" }]
  ]);
  s.CoopAndCoep = Object.freeze(e.get("3"));
  const t = "vscode-coi";
  function i(o) {
    let r;
    typeof o == "string" ? r = new URL(o).searchParams : o instanceof URL ? r = o.searchParams : we.isUri(o) && (r = new URL(o.toString(!0)).searchParams);
    const a = r == null ? void 0 : r.get(t);
    if (a)
      return e.get(a);
  }
  s.getHeadersFromQuery = i;
  function n(o, r, a) {
    if (!globalThis.crossOriginIsolated)
      return;
    const l = r && a ? "3" : a ? "2" : "1";
    o instanceof URLSearchParams ? o.set(t, l) : o[t] = l;
  }
  s.addSearchParam = n;
})(Xy || (Xy = {}));
function A4(s) {
  return Xv(s, 0);
}
function Xv(s, e) {
  switch (typeof s) {
    case "object":
      return s === null ? ka(349, e) : Array.isArray(s) ? O6(s, e) : F6(s, e);
    case "string":
      return SE(s, e);
    case "boolean":
      return P6(s, e);
    case "number":
      return ka(s, e);
    case "undefined":
      return ka(937, e);
    default:
      return ka(617, e);
  }
}
function ka(s, e) {
  return (e << 5) - e + s | 0;
}
function P6(s, e) {
  return ka(s ? 433 : 863, e);
}
function SE(s, e) {
  e = ka(149417, e);
  for (let t = 0, i = s.length; t < i; t++)
    e = ka(s.charCodeAt(t), e);
  return e;
}
function O6(s, e) {
  return e = ka(104579, e), s.reduce((t, i) => Xv(i, t), e);
}
function F6(s, e) {
  return e = ka(181387, e), Object.keys(s).sort().reduce((t, i) => (t = SE(i, t), Xv(s[i], t)), e);
}
function f0(s, e, t = 32) {
  const i = t - e, n = ~((1 << i) - 1);
  return (s << e | (n & s) >>> i) >>> 0;
}
function T2(s, e = 0, t = s.byteLength, i = 0) {
  for (let n = 0; n < t; n++)
    s[e + n] = i;
}
function B6(s, e, t = "0") {
  for (; s.length < e; )
    s = t + s;
  return s;
}
function Qf(s, e = 32) {
  return s instanceof ArrayBuffer ? Array.from(new Uint8Array(s)).map((t) => t.toString(16).padStart(2, "0")).join("") : B6((s >>> 0).toString(16), e / 4);
}
const jC = class jC {
  // 80 * 4 = 320
  constructor() {
    this._h0 = 1732584193, this._h1 = 4023233417, this._h2 = 2562383102, this._h3 = 271733878, this._h4 = 3285377520, this._buff = new Uint8Array(
      67
      /* to fit any utf-8 */
    ), this._buffDV = new DataView(this._buff.buffer), this._buffLen = 0, this._totalLen = 0, this._leftoverHighSurrogate = 0, this._finished = !1;
  }
  update(e) {
    const t = e.length;
    if (t === 0)
      return;
    const i = this._buff;
    let n = this._buffLen, o = this._leftoverHighSurrogate, r, a;
    for (o !== 0 ? (r = o, a = -1, o = 0) : (r = e.charCodeAt(0), a = 0); ; ) {
      let l = r;
      if (Si(r))
        if (a + 1 < t) {
          const c = e.charCodeAt(a + 1);
          sf(c) ? (a++, l = hE(r, c)) : l = 65533;
        } else {
          o = r;
          break;
        }
      else sf(r) && (l = 65533);
      if (n = this._push(i, n, l), a++, a < t)
        r = e.charCodeAt(a);
      else
        break;
    }
    this._buffLen = n, this._leftoverHighSurrogate = o;
  }
  _push(e, t, i) {
    return i < 128 ? e[t++] = i : i < 2048 ? (e[t++] = 192 | (i & 1984) >>> 6, e[t++] = 128 | (i & 63) >>> 0) : i < 65536 ? (e[t++] = 224 | (i & 61440) >>> 12, e[t++] = 128 | (i & 4032) >>> 6, e[t++] = 128 | (i & 63) >>> 0) : (e[t++] = 240 | (i & 1835008) >>> 18, e[t++] = 128 | (i & 258048) >>> 12, e[t++] = 128 | (i & 4032) >>> 6, e[t++] = 128 | (i & 63) >>> 0), t >= 64 && (this._step(), t -= 64, this._totalLen += 64, e[0] = e[64], e[1] = e[65], e[2] = e[66]), t;
  }
  digest() {
    return this._finished || (this._finished = !0, this._leftoverHighSurrogate && (this._leftoverHighSurrogate = 0, this._buffLen = this._push(
      this._buff,
      this._buffLen,
      65533
      /* SHA1Constant.UNICODE_REPLACEMENT */
    )), this._totalLen += this._buffLen, this._wrapUp()), Qf(this._h0) + Qf(this._h1) + Qf(this._h2) + Qf(this._h3) + Qf(this._h4);
  }
  _wrapUp() {
    this._buff[this._buffLen++] = 128, T2(this._buff, this._buffLen), this._buffLen > 56 && (this._step(), T2(this._buff));
    const e = 8 * this._totalLen;
    this._buffDV.setUint32(56, Math.floor(e / 4294967296), !1), this._buffDV.setUint32(60, e % 4294967296, !1), this._step();
  }
  _step() {
    const e = jC._bigBlock32, t = this._buffDV;
    for (let d = 0; d < 64; d += 4)
      e.setUint32(d, t.getUint32(d, !1), !1);
    for (let d = 64; d < 320; d += 4)
      e.setUint32(d, f0(e.getUint32(d - 12, !1) ^ e.getUint32(d - 32, !1) ^ e.getUint32(d - 56, !1) ^ e.getUint32(d - 64, !1), 1), !1);
    let i = this._h0, n = this._h1, o = this._h2, r = this._h3, a = this._h4, l, c, h;
    for (let d = 0; d < 80; d++)
      d < 20 ? (l = n & o | ~n & r, c = 1518500249) : d < 40 ? (l = n ^ o ^ r, c = 1859775393) : d < 60 ? (l = n & o | n & r | o & r, c = 2400959708) : (l = n ^ o ^ r, c = 3395469782), h = f0(i, 5) + l + a + c + e.getUint32(d * 4, !1) & 4294967295, a = r, r = o, o = f0(n, 30), n = i, i = h;
    this._h0 = this._h0 + i & 4294967295, this._h1 = this._h1 + n & 4294967295, this._h2 = this._h2 + o & 4294967295, this._h3 = this._h3 + r & 4294967295, this._h4 = this._h4 + a & 4294967295;
  }
};
jC._bigBlock32 = new DataView(new ArrayBuffer(320));
let Qy = jC;
const { getWindow: fe, getWindows: P4, getWindowsCount: W6, getWindowId: jb, getWindowById: M2, onDidRegisterWindow: Qv, onWillUnregisterWindow: H6, onDidUnregisterWindow: V6 } = function() {
  const s = /* @__PURE__ */ new Map();
  Y8(pt, 1);
  const e = { window: pt, disposables: new ne() };
  s.set(pt.vscodeWindowId, e);
  const t = new A(), i = new A(), n = new A();
  function o(r, a) {
    return (typeof r == "number" ? s.get(r) : void 0) ?? (a ? e : void 0);
  }
  return {
    onDidRegisterWindow: t.event,
    onWillUnregisterWindow: n.event,
    onDidUnregisterWindow: i.event,
    registerWindow(r) {
      if (s.has(r.vscodeWindowId))
        return U.None;
      const a = new ne(), l = {
        window: r,
        disposables: a.add(new ne())
      };
      return s.set(r.vscodeWindowId, l), a.add(_e(() => {
        s.delete(r.vscodeWindowId), i.fire(r);
      })), a.add(z(r, X.BEFORE_UNLOAD, () => {
        n.fire(r);
      })), t.fire(l), a;
    },
    getWindows() {
      return s.values();
    },
    getWindowsCount() {
      return s.size;
    },
    getWindowId(r) {
      return r.vscodeWindowId;
    },
    hasWindow(r) {
      return s.has(r);
    },
    getWindowById: o,
    getWindow(r) {
      var c;
      const a = r;
      if ((c = a == null ? void 0 : a.ownerDocument) != null && c.defaultView)
        return a.ownerDocument.defaultView.window;
      const l = r;
      return l != null && l.view ? l.view.window : pt;
    },
    getDocument(r) {
      return fe(r).document;
    }
  };
}();
function ks(s) {
  for (; s.firstChild; )
    s.firstChild.remove();
}
class z6 {
  constructor(e, t, i, n) {
    this._node = e, this._type = t, this._handler = i, this._options = n || !1, this._node.addEventListener(this._type, this._handler, this._options);
  }
  dispose() {
    this._handler && (this._node.removeEventListener(this._type, this._handler, this._options), this._node = null, this._handler = null);
  }
}
function z(s, e, t, i) {
  return new z6(s, e, t, i);
}
function O4(s, e) {
  return function(t) {
    return e(new Uo(s, t));
  };
}
function U6(s) {
  return function(e) {
    return s(new Dt(e));
  };
}
const Zt = function(e, t, i, n) {
  let o = i;
  return t === "click" || t === "mousedown" || t === "contextmenu" ? o = O4(fe(e), i) : (t === "keydown" || t === "keypress" || t === "keyup") && (o = U6(i)), z(e, t, o, n);
}, $6 = function(e, t, i) {
  const n = O4(fe(e), t);
  return K6(e, n, i);
};
function K6(s, e, t) {
  return z(s, Kl && vE.pointerEvents ? X.POINTER_DOWN : X.MOUSE_DOWN, e, t);
}
function a_(s, e, t) {
  return Ag(s, e, t);
}
let F4, ns;
class LE extends wE {
  /**
   *
   * @param node The optional node from which the target window is determined
   */
  constructor(e) {
    super(), this.defaultTarget = e && fe(e);
  }
  cancelAndSet(e, t, i) {
    return super.cancelAndSet(e, t, i ?? this.defaultTarget);
  }
}
class g0 {
  constructor(e, t = 0) {
    this._runner = e, this.priority = t, this._canceled = !1;
  }
  dispose() {
    this._canceled = !0;
  }
  execute() {
    if (!this._canceled)
      try {
        this._runner();
      } catch (e) {
        Je(e);
      }
  }
  // Sort by priority (largest to lowest)
  static sort(e, t) {
    return t.priority - e.priority;
  }
}
(function() {
  const s = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = (o) => {
    t.set(o, !1);
    const r = s.get(o) ?? [];
    for (e.set(o, r), s.set(o, []), i.set(o, !0); r.length > 0; )
      r.sort(g0.sort), r.shift().execute();
    i.set(o, !1);
  };
  ns = (o, r, a = 0) => {
    const l = jb(o), c = new g0(r, a);
    let h = s.get(l);
    return h || (h = [], s.set(l, h)), h.push(c), t.get(l) || (t.set(l, !0), o.requestAnimationFrame(() => n(l))), c;
  }, F4 = (o, r, a) => {
    const l = jb(o);
    if (i.get(l)) {
      const c = new g0(r, a);
      let h = e.get(l);
      return h || (h = [], e.set(l, h)), h.push(c), c;
    } else
      return ns(o, r, a);
  };
})();
function kE(s) {
  return fe(s).getComputedStyle(s, null);
}
function Im(s, e) {
  const t = fe(s), i = t.document;
  if (s !== i.body)
    return new ti(s.clientWidth, s.clientHeight);
  if (Kl && (t != null && t.visualViewport))
    return new ti(t.visualViewport.width, t.visualViewport.height);
  if (t != null && t.innerWidth && t.innerHeight)
    return new ti(t.innerWidth, t.innerHeight);
  if (i.body && i.body.clientWidth && i.body.clientHeight)
    return new ti(i.body.clientWidth, i.body.clientHeight);
  if (i.documentElement && i.documentElement.clientWidth && i.documentElement.clientHeight)
    return new ti(i.documentElement.clientWidth, i.documentElement.clientHeight);
  throw new Error("Unable to figure out browser width and height");
}
class qt {
  // Adapted from WinJS
  // Converts a CSS positioning string for the specified element to pixels.
  static convertToPixels(e, t) {
    return parseFloat(t) || 0;
  }
  static getDimension(e, t, i) {
    const n = kE(e), o = n ? n.getPropertyValue(t) : "0";
    return qt.convertToPixels(e, o);
  }
  static getBorderLeftWidth(e) {
    return qt.getDimension(e, "border-left-width", "borderLeftWidth");
  }
  static getBorderRightWidth(e) {
    return qt.getDimension(e, "border-right-width", "borderRightWidth");
  }
  static getBorderTopWidth(e) {
    return qt.getDimension(e, "border-top-width", "borderTopWidth");
  }
  static getBorderBottomWidth(e) {
    return qt.getDimension(e, "border-bottom-width", "borderBottomWidth");
  }
  static getPaddingLeft(e) {
    return qt.getDimension(e, "padding-left", "paddingLeft");
  }
  static getPaddingRight(e) {
    return qt.getDimension(e, "padding-right", "paddingRight");
  }
  static getPaddingTop(e) {
    return qt.getDimension(e, "padding-top", "paddingTop");
  }
  static getPaddingBottom(e) {
    return qt.getDimension(e, "padding-bottom", "paddingBottom");
  }
  static getMarginLeft(e) {
    return qt.getDimension(e, "margin-left", "marginLeft");
  }
  static getMarginTop(e) {
    return qt.getDimension(e, "margin-top", "marginTop");
  }
  static getMarginRight(e) {
    return qt.getDimension(e, "margin-right", "marginRight");
  }
  static getMarginBottom(e) {
    return qt.getDimension(e, "margin-bottom", "marginBottom");
  }
}
const $c = class $c {
  constructor(e, t) {
    this.width = e, this.height = t;
  }
  with(e = this.width, t = this.height) {
    return e !== this.width || t !== this.height ? new $c(e, t) : this;
  }
  static is(e) {
    return typeof e == "object" && typeof e.height == "number" && typeof e.width == "number";
  }
  static lift(e) {
    return e instanceof $c ? e : new $c(e.width, e.height);
  }
  static equals(e, t) {
    return e === t ? !0 : !e || !t ? !1 : e.width === t.width && e.height === t.height;
  }
};
$c.None = new $c(0, 0);
let ti = $c;
function j6(s) {
  let e = s.offsetParent, t = s.offsetTop, i = s.offsetLeft;
  for (; (s = s.parentNode) !== null && s !== s.ownerDocument.body && s !== s.ownerDocument.documentElement; ) {
    t -= s.scrollTop;
    const n = W4(s) ? null : kE(s);
    n && (i -= n.direction !== "rtl" ? s.scrollLeft : -s.scrollLeft), s === e && (i += qt.getBorderLeftWidth(s), t += qt.getBorderTopWidth(s), t += s.offsetTop, i += s.offsetLeft, e = s.offsetParent);
  }
  return {
    left: i,
    top: t
  };
}
function ui(s) {
  const e = s.getBoundingClientRect(), t = fe(s);
  return {
    left: e.left + t.scrollX,
    top: e.top + t.scrollY,
    width: e.width,
    height: e.height
  };
}
function B4(s) {
  let e = s, t = 1;
  do {
    const i = kE(e).zoom;
    i != null && i !== "1" && (t *= i), e = e.parentElement;
  } while (e !== null && e !== e.ownerDocument.documentElement);
  return t;
}
function Nm(s) {
  const e = qt.getMarginLeft(s) + qt.getMarginRight(s);
  return s.offsetWidth + e;
}
function m0(s) {
  const e = qt.getBorderLeftWidth(s) + qt.getBorderRightWidth(s), t = qt.getPaddingLeft(s) + qt.getPaddingRight(s);
  return s.offsetWidth - e - t;
}
function q6(s) {
  const e = qt.getBorderTopWidth(s) + qt.getBorderBottomWidth(s), t = qt.getPaddingTop(s) + qt.getPaddingBottom(s);
  return s.offsetHeight - e - t;
}
function Xc(s) {
  const e = qt.getMarginTop(s) + qt.getMarginBottom(s);
  return s.offsetHeight + e;
}
function _i(s, e) {
  return !!(e != null && e.contains(s));
}
function G6(s, e, t) {
  for (; s && s.nodeType === s.ELEMENT_NODE; ) {
    if (s.classList.contains(e))
      return s;
    if (t) {
      if (typeof t == "string") {
        if (s.classList.contains(t))
          return null;
      } else if (s === t)
        return null;
    }
    s = s.parentNode;
  }
  return null;
}
function p0(s, e, t) {
  return !!G6(s, e, t);
}
function W4(s) {
  return s && !!s.host && !!s.mode;
}
function qb(s) {
  return !!of(s);
}
function of(s) {
  var e;
  for (; s.parentNode; ) {
    if (s === ((e = s.ownerDocument) == null ? void 0 : e.body))
      return null;
    s = s.parentNode;
  }
  return W4(s) ? s : null;
}
function Gi() {
  let s = DE().activeElement;
  for (; s != null && s.shadowRoot; )
    s = s.shadowRoot.activeElement;
  return s;
}
function xE(s) {
  return Gi() === s;
}
function H4(s) {
  return _i(Gi(), s);
}
function DE() {
  return W6() <= 1 ? pt.document : Array.from(P4()).map(({ window: e }) => e.document).find((e) => e.hasFocus()) ?? pt.document;
}
function mg() {
  var e;
  return ((e = DE().defaultView) == null ? void 0 : e.window) ?? pt;
}
const EE = /* @__PURE__ */ new Map();
function Us(s = pt.document.head, e, t) {
  const i = document.createElement("style");
  if (i.type = "text/css", i.media = "screen", e == null || e(i), s.appendChild(i), t && t.add(_e(() => i.remove())), s === pt.document.head) {
    const n = /* @__PURE__ */ new Set();
    EE.set(i, n);
    for (const { window: o, disposables: r } of P4()) {
      if (o === pt)
        continue;
      const a = r.add(Z6(i, n, o));
      t == null || t.add(a);
    }
  }
  return i;
}
function Z6(s, e, t) {
  var o, r;
  const i = new ne(), n = s.cloneNode(!0);
  t.document.head.appendChild(n), i.add(_e(() => n.remove()));
  for (const a of z4(s))
    (r = n.sheet) == null || r.insertRule(a.cssText, (o = n.sheet) == null ? void 0 : o.cssRules.length);
  return i.add(Y6.observe(s, i, { childList: !0 })(() => {
    n.textContent = s.textContent;
  })), e.add(n), i.add(_e(() => e.delete(n))), i;
}
const Y6 = new class {
  constructor() {
    this.mutationObservers = /* @__PURE__ */ new Map();
  }
  observe(s, e, t) {
    let i = this.mutationObservers.get(s);
    i || (i = /* @__PURE__ */ new Map(), this.mutationObservers.set(s, i));
    const n = A4(t);
    let o = i.get(n);
    if (o)
      o.users += 1;
    else {
      const r = new A(), a = new MutationObserver((c) => r.fire(c));
      a.observe(s, t);
      const l = o = {
        users: 1,
        observer: a,
        onDidMutate: r.event
      };
      e.add(_e(() => {
        l.users -= 1, l.users === 0 && (r.dispose(), a.disconnect(), i == null || i.delete(n), (i == null ? void 0 : i.size) === 0 && this.mutationObservers.delete(s));
      })), i.set(n, o);
    }
    return o.onDidMutate;
  }
}();
let _0 = null;
function V4() {
  return _0 || (_0 = Us()), _0;
}
function z4(s) {
  var e, t;
  return (e = s == null ? void 0 : s.sheet) != null && e.rules ? s.sheet.rules : (t = s == null ? void 0 : s.sheet) != null && t.cssRules ? s.sheet.cssRules : [];
}
function Gb(s, e, t = V4()) {
  var i;
  if (!(!t || !e)) {
    (i = t.sheet) == null || i.insertRule(`${s} {${e}}`, 0);
    for (const n of EE.get(t) ?? [])
      Gb(s, e, n);
  }
}
function Jy(s, e = V4()) {
  var n;
  if (!e)
    return;
  const t = z4(e), i = [];
  for (let o = 0; o < t.length; o++) {
    const r = t[o];
    X6(r) && r.selectorText.indexOf(s) !== -1 && i.push(o);
  }
  for (let o = i.length - 1; o >= 0; o--)
    (n = e.sheet) == null || n.deleteRule(i[o]);
  for (const o of EE.get(e) ?? [])
    Jy(s, o);
}
function X6(s) {
  return typeof s.selectorText == "string";
}
function ki(s) {
  return s instanceof HTMLElement || s instanceof fe(s).HTMLElement;
}
function R2(s) {
  return s instanceof HTMLAnchorElement || s instanceof fe(s).HTMLAnchorElement;
}
function Q6(s) {
  return s instanceof SVGElement || s instanceof fe(s).SVGElement;
}
function IE(s) {
  return s instanceof MouseEvent || s instanceof fe(s).MouseEvent;
}
function ma(s) {
  return s instanceof KeyboardEvent || s instanceof fe(s).KeyboardEvent;
}
const X = {
  // Mouse
  CLICK: "click",
  AUXCLICK: "auxclick",
  DBLCLICK: "dblclick",
  MOUSE_UP: "mouseup",
  MOUSE_DOWN: "mousedown",
  MOUSE_OVER: "mouseover",
  MOUSE_MOVE: "mousemove",
  MOUSE_OUT: "mouseout",
  MOUSE_ENTER: "mouseenter",
  MOUSE_LEAVE: "mouseleave",
  MOUSE_WHEEL: "wheel",
  POINTER_UP: "pointerup",
  POINTER_DOWN: "pointerdown",
  POINTER_MOVE: "pointermove",
  POINTER_LEAVE: "pointerleave",
  CONTEXT_MENU: "contextmenu",
  // Keyboard
  KEY_DOWN: "keydown",
  KEY_UP: "keyup",
  BEFORE_UNLOAD: "beforeunload",
  CHANGE: "change",
  FOCUS: "focus",
  FOCUS_IN: "focusin",
  FOCUS_OUT: "focusout",
  BLUR: "blur",
  INPUT: "input",
  // Drag
  DRAG_START: "dragstart",
  DRAG: "drag",
  DRAG_ENTER: "dragenter",
  DRAG_LEAVE: "dragleave",
  DRAG_OVER: "dragover",
  DROP: "drop",
  DRAG_END: "dragend"
};
function J6(s) {
  const e = s;
  return !!(e && typeof e.preventDefault == "function" && typeof e.stopPropagation == "function");
}
const Ge = {
  stop: (s, e) => (s.preventDefault(), e && s.stopPropagation(), s)
};
function eB(s) {
  const e = [];
  for (let t = 0; s && s.nodeType === s.ELEMENT_NODE; t++)
    e[t] = s.scrollTop, s = s.parentNode;
  return e;
}
function tB(s, e) {
  for (let t = 0; s && s.nodeType === s.ELEMENT_NODE; t++)
    s.scrollTop !== e[t] && (s.scrollTop = e[t]), s = s.parentNode;
}
class Zb extends U {
  static hasFocusWithin(e) {
    if (ki(e)) {
      const t = of(e), i = t ? t.activeElement : e.ownerDocument.activeElement;
      return _i(i, e);
    } else {
      const t = e;
      return _i(t.document.activeElement, t.document);
    }
  }
  constructor(e) {
    super(), this._onDidFocus = this._register(new A()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new A()), this.onDidBlur = this._onDidBlur.event;
    let t = Zb.hasFocusWithin(e), i = !1;
    const n = () => {
      i = !1, t || (t = !0, this._onDidFocus.fire());
    }, o = () => {
      t && (i = !0, (ki(e) ? fe(e) : e).setTimeout(() => {
        i && (i = !1, t = !1, this._onDidBlur.fire());
      }, 0));
    };
    this._refreshStateHandler = () => {
      Zb.hasFocusWithin(e) !== t && (t ? o() : n());
    }, this._register(z(e, X.FOCUS, n, !0)), this._register(z(e, X.BLUR, o, !0)), ki(e) && (this._register(z(e, X.FOCUS_IN, () => this._refreshStateHandler())), this._register(z(e, X.FOCUS_OUT, () => this._refreshStateHandler())));
  }
}
function Vh(s) {
  return new Zb(s);
}
function iB(s, e) {
  return s.after(e), e;
}
function te(s, ...e) {
  if (s.append(...e), e.length === 1 && typeof e[0] != "string")
    return e[0];
}
function NE(s, e) {
  return s.insertBefore(e, s.firstChild), e;
}
function _n(s, ...e) {
  s.innerText = "", te(s, ...e);
}
const nB = /([\w\-]+)?(#([\w\-]+))?((\.([\w\-]+))*)/;
var Tm;
(function(s) {
  s.HTML = "http://www.w3.org/1999/xhtml", s.SVG = "http://www.w3.org/2000/svg";
})(Tm || (Tm = {}));
function U4(s, e, t, ...i) {
  const n = nB.exec(e);
  if (!n)
    throw new Error("Bad use of emmet");
  const o = n[1] || "div";
  let r;
  return s !== Tm.HTML ? r = document.createElementNS(s, o) : r = document.createElement(o), n[3] && (r.id = n[3]), n[4] && (r.className = n[4].replace(/\./g, " ").trim()), t && Object.entries(t).forEach(([a, l]) => {
    typeof l > "u" || (/^on\w+$/.test(a) ? r[a] = l : a === "selected" ? l && r.setAttribute(a, "true") : r.setAttribute(a, l));
  }), r.append(...i), r;
}
function he(s, e, ...t) {
  return U4(Tm.HTML, s, e, ...t);
}
he.SVG = function(s, e, ...t) {
  return U4(Tm.SVG, s, e, ...t);
};
function sB(s, ...e) {
  s ? oh(...e) : yl(...e);
}
function oh(...s) {
  for (const e of s)
    e.style.display = "", e.removeAttribute("aria-hidden");
}
function yl(...s) {
  for (const e of s)
    e.style.display = "none", e.setAttribute("aria-hidden", "true");
}
function A2(s, e) {
  const t = s.devicePixelRatio * e;
  return Math.max(1, Math.floor(t)) / s.devicePixelRatio;
}
function $4(s) {
  pt.open(s, "_blank", "noopener");
}
function oB(s, e) {
  const t = () => {
    e(), i = ns(s, t);
  };
  let i = ns(s, t);
  return _e(() => i.dispose());
}
R4.setPreferredWebSchema(/^https:/.test(pt.location.href) ? "https" : "http");
function Ua(s) {
  return s ? `url('${Yv.uriToBrowserUri(s).toString(!0).replace(/'/g, "%27")}')` : "url('')";
}
function b0(s) {
  return `'${s.replace(/'/g, "%27")}'`;
}
function Fa(s, e) {
  if (s !== void 0) {
    const t = s.match(/^\s*var\((.+)\)$/);
    if (t) {
      const i = t[1].split(",", 2);
      return i.length === 2 && (e = Fa(i[1].trim(), e)), `var(${i[0]}, ${e})`;
    }
    return s;
  }
  return e;
}
function rB(s, e = !1) {
  const t = document.createElement("a");
  return T4("afterSanitizeAttributes", (i) => {
    for (const n of ["href", "src"])
      if (i.hasAttribute(n)) {
        const o = i.getAttribute(n);
        if (n === "href" && o.startsWith("#"))
          continue;
        if (t.href = o, !s.includes(t.protocol.replace(/:$/, ""))) {
          if (e && n === "src" && t.href.startsWith("data:"))
            continue;
          i.removeAttribute(n);
        }
      }
  }), _e(() => {
    M4("afterSanitizeAttributes");
  });
}
const aB = Object.freeze([
  "a",
  "abbr",
  "b",
  "bdo",
  "blockquote",
  "br",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "i",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "li",
  "mark",
  "ol",
  "p",
  "pre",
  "q",
  "rp",
  "rt",
  "ruby",
  "samp",
  "small",
  "small",
  "source",
  "span",
  "strike",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "tt",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
]);
class xa extends A {
  constructor() {
    super(), this._subscriptions = new ne(), this._keyStatus = {
      altKey: !1,
      shiftKey: !1,
      ctrlKey: !1,
      metaKey: !1
    }, this._subscriptions.add(ee.runAndSubscribe(Qv, ({ window: e, disposables: t }) => this.registerListeners(e, t), { window: pt, disposables: this._subscriptions }));
  }
  registerListeners(e, t) {
    t.add(z(e, "keydown", (i) => {
      if (i.defaultPrevented)
        return;
      const n = new Dt(i);
      if (!(n.keyCode === 6 && i.repeat)) {
        if (i.altKey && !this._keyStatus.altKey)
          this._keyStatus.lastKeyPressed = "alt";
        else if (i.ctrlKey && !this._keyStatus.ctrlKey)
          this._keyStatus.lastKeyPressed = "ctrl";
        else if (i.metaKey && !this._keyStatus.metaKey)
          this._keyStatus.lastKeyPressed = "meta";
        else if (i.shiftKey && !this._keyStatus.shiftKey)
          this._keyStatus.lastKeyPressed = "shift";
        else if (n.keyCode !== 6)
          this._keyStatus.lastKeyPressed = void 0;
        else
          return;
        this._keyStatus.altKey = i.altKey, this._keyStatus.ctrlKey = i.ctrlKey, this._keyStatus.metaKey = i.metaKey, this._keyStatus.shiftKey = i.shiftKey, this._keyStatus.lastKeyPressed && (this._keyStatus.event = i, this.fire(this._keyStatus));
      }
    }, !0)), t.add(z(e, "keyup", (i) => {
      i.defaultPrevented || (!i.altKey && this._keyStatus.altKey ? this._keyStatus.lastKeyReleased = "alt" : !i.ctrlKey && this._keyStatus.ctrlKey ? this._keyStatus.lastKeyReleased = "ctrl" : !i.metaKey && this._keyStatus.metaKey ? this._keyStatus.lastKeyReleased = "meta" : !i.shiftKey && this._keyStatus.shiftKey ? this._keyStatus.lastKeyReleased = "shift" : this._keyStatus.lastKeyReleased = void 0, this._keyStatus.lastKeyPressed !== this._keyStatus.lastKeyReleased && (this._keyStatus.lastKeyPressed = void 0), this._keyStatus.altKey = i.altKey, this._keyStatus.ctrlKey = i.ctrlKey, this._keyStatus.metaKey = i.metaKey, this._keyStatus.shiftKey = i.shiftKey, this._keyStatus.lastKeyReleased && (this._keyStatus.event = i, this.fire(this._keyStatus)));
    }, !0)), t.add(z(e.document.body, "mousedown", () => {
      this._keyStatus.lastKeyPressed = void 0;
    }, !0)), t.add(z(e.document.body, "mouseup", () => {
      this._keyStatus.lastKeyPressed = void 0;
    }, !0)), t.add(z(e.document.body, "mousemove", (i) => {
      i.buttons && (this._keyStatus.lastKeyPressed = void 0);
    }, !0)), t.add(z(e, "blur", () => {
      this.resetKeyStatus();
    }));
  }
  get keyStatus() {
    return this._keyStatus;
  }
  /**
   * Allows to explicitly reset the key status based on more knowledge (#109062)
   */
  resetKeyStatus() {
    this.doResetKeyStatus(), this.fire(this._keyStatus);
  }
  doResetKeyStatus() {
    this._keyStatus = {
      altKey: !1,
      shiftKey: !1,
      ctrlKey: !1,
      metaKey: !1
    };
  }
  static getInstance() {
    return xa.instance || (xa.instance = new xa()), xa.instance;
  }
  dispose() {
    super.dispose(), this._subscriptions.dispose();
  }
}
class lB extends U {
  constructor(e, t) {
    super(), this.element = e, this.callbacks = t, this.counter = 0, this.dragStartTime = 0, this.registerListeners();
  }
  registerListeners() {
    this.callbacks.onDragStart && this._register(z(this.element, X.DRAG_START, (e) => {
      var t, i;
      (i = (t = this.callbacks).onDragStart) == null || i.call(t, e);
    })), this.callbacks.onDrag && this._register(z(this.element, X.DRAG, (e) => {
      var t, i;
      (i = (t = this.callbacks).onDrag) == null || i.call(t, e);
    })), this._register(z(this.element, X.DRAG_ENTER, (e) => {
      var t, i;
      this.counter++, this.dragStartTime = e.timeStamp, (i = (t = this.callbacks).onDragEnter) == null || i.call(t, e);
    })), this._register(z(this.element, X.DRAG_OVER, (e) => {
      var t, i;
      e.preventDefault(), (i = (t = this.callbacks).onDragOver) == null || i.call(t, e, e.timeStamp - this.dragStartTime);
    })), this._register(z(this.element, X.DRAG_LEAVE, (e) => {
      var t, i;
      this.counter--, this.counter === 0 && (this.dragStartTime = 0, (i = (t = this.callbacks).onDragLeave) == null || i.call(t, e));
    })), this._register(z(this.element, X.DRAG_END, (e) => {
      var t, i;
      this.counter = 0, this.dragStartTime = 0, (i = (t = this.callbacks).onDragEnd) == null || i.call(t, e);
    })), this._register(z(this.element, X.DROP, (e) => {
      var t, i;
      this.counter = 0, this.dragStartTime = 0, (i = (t = this.callbacks).onDrop) == null || i.call(t, e);
    }));
  }
}
const cB = /(?<tag>[\w\-]+)?(?:#(?<id>[\w\-]+))?(?<class>(?:\.(?:[\w\-]+))*)(?:@(?<name>(?:[\w\_])+))?/;
function Xe(s, ...e) {
  let t, i;
  Array.isArray(e[0]) ? (t = {}, i = e[0]) : (t = e[0] || {}, i = e[1]);
  const n = cB.exec(s);
  if (!n || !n.groups)
    throw new Error("Bad use of h");
  const o = n.groups.tag || "div", r = document.createElement(o);
  n.groups.id && (r.id = n.groups.id);
  const a = [];
  if (n.groups.class)
    for (const c of n.groups.class.split("."))
      c !== "" && a.push(c);
  if (t.className !== void 0)
    for (const c of t.className.split("."))
      c !== "" && a.push(c);
  a.length > 0 && (r.className = a.join(" "));
  const l = {};
  if (n.groups.name && (l[n.groups.name] = r), i)
    for (const c of i)
      ki(c) ? r.appendChild(c) : typeof c == "string" ? r.append(c) : "root" in c && (Object.assign(l, c), r.appendChild(c.root));
  for (const [c, h] of Object.entries(t))
    if (c !== "className")
      if (c === "style")
        for (const [d, u] of Object.entries(h))
          r.style.setProperty(P2(d), typeof u == "number" ? u + "px" : "" + u);
      else c === "tabIndex" ? r.tabIndex = h : r.setAttribute(P2(c), h.toString());
  return l.root = r, l;
}
function P2(s) {
  return s.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
let Jv = class {
  constructor(e) {
    this.id = e.id, this.precondition = e.precondition, this._kbOpts = e.kbOpts, this._menuOpts = e.menuOpts, this.metadata = e.metadata;
  }
  register() {
    if (Array.isArray(this._menuOpts) ? this._menuOpts.forEach(this._registerMenuItem, this) : this._menuOpts && this._registerMenuItem(this._menuOpts), this._kbOpts) {
      const e = Array.isArray(this._kbOpts) ? this._kbOpts : [this._kbOpts];
      for (const t of e) {
        let i = t.kbExpr;
        this.precondition && (i ? i = ve.and(i, this.precondition) : i = this.precondition);
        const n = {
          id: this.id,
          weight: t.weight,
          args: t.args,
          when: i,
          primary: t.primary,
          secondary: t.secondary,
          win: t.win,
          linux: t.linux,
          mac: t.mac
        };
        ts.registerKeybindingRule(n);
      }
    }
    St.registerCommand({
      id: this.id,
      handler: (e, t) => this.runCommand(e, t),
      metadata: this.metadata
    });
  }
  _registerMenuItem(e) {
    so.appendMenuItem(e.menuId, {
      group: e.group,
      command: {
        id: this.id,
        title: e.title,
        icon: e.icon,
        precondition: this.precondition
      },
      when: e.when,
      order: e.order
    });
  }
};
class TE extends Jv {
  constructor() {
    super(...arguments), this._implementations = [];
  }
  /**
   * A higher priority gets to be looked at first
   */
  addImplementation(e, t, i, n) {
    return this._implementations.push({ priority: e, name: t, implementation: i, when: n }), this._implementations.sort((o, r) => r.priority - o.priority), {
      dispose: () => {
        for (let o = 0; o < this._implementations.length; o++)
          if (this._implementations[o].implementation === i) {
            this._implementations.splice(o, 1);
            return;
          }
      }
    };
  }
  runCommand(e, t) {
    const i = e.get(Co), n = e.get(Fe);
    i.trace(`Executing Command '${this.id}' which has ${this._implementations.length} bound.`);
    for (const o of this._implementations) {
      if (o.when) {
        const a = n.getContext(Gi());
        if (!o.when.evaluate(a))
          continue;
      }
      const r = o.implementation(e, t);
      if (r)
        return i.trace(`Command '${this.id}' was handled by '${o.name}'.`), typeof r == "boolean" ? void 0 : r;
    }
    i.trace(`The Command '${this.id}' was not handled by any implementation.`);
  }
}
class K4 extends Jv {
  constructor(e, t) {
    super(t), this.command = e;
  }
  runCommand(e, t) {
    return this.command.runCommand(e, t);
  }
}
class jo extends Jv {
  /**
   * Create a command class that is bound to a certain editor contribution.
   */
  static bindToContribution(e) {
    return class extends jo {
      constructor(i) {
        super(i), this._callback = i.handler;
      }
      runEditorCommand(i, n, o) {
        const r = e(n);
        r && this._callback(r, o);
      }
    };
  }
  static runEditorCommand(e, t, i, n) {
    const o = e.get(Tt), r = o.getFocusedCodeEditor() || o.getActiveCodeEditor();
    if (r)
      return r.invokeWithinContext((a) => {
        if (a.get(Fe).contextMatchesRules(i ?? void 0))
          return n(a, r, t);
      });
  }
  runCommand(e, t) {
    return jo.runEditorCommand(e, t, this.precondition, (i, n, o) => this.runEditorCommand(i, n, o));
  }
}
class ss extends jo {
  static convertOptions(e) {
    let t;
    Array.isArray(e.menuOpts) ? t = e.menuOpts : e.menuOpts ? t = [e.menuOpts] : t = [];
    function i(n) {
      return n.menuId || (n.menuId = et.EditorContext), n.title || (n.title = e.label), n.when = ve.and(e.precondition, n.when), n;
    }
    return Array.isArray(e.contextMenuOpts) ? t.push(...e.contextMenuOpts.map(i)) : e.contextMenuOpts && t.push(i(e.contextMenuOpts)), e.menuOpts = t, e;
  }
  constructor(e) {
    super(ss.convertOptions(e)), this.label = e.label, this.alias = e.alias;
  }
  runEditorCommand(e, t, i) {
    return this.reportTelemetry(e, t), this.run(e, t, i || {});
  }
  reportTelemetry(e, t) {
    e.get(Jo).publicLog2("editorActionInvoked", { name: this.label, id: this.id });
  }
}
class hB extends Nf {
  run(e, ...t) {
    const i = e.get(Tt), n = i.getFocusedCodeEditor() || i.getActiveCodeEditor();
    if (n)
      return n.invokeWithinContext((o) => {
        var c;
        const r = o.get(Fe), a = o.get(Co);
        if (!r.contextMatchesRules(this.desc.precondition ?? void 0)) {
          a.debug("[EditorAction2] NOT running command because its precondition is FALSE", this.desc.id, (c = this.desc.precondition) == null ? void 0 : c.serialize());
          return;
        }
        return this.runEditorCommand(o, n, ...t);
      });
  }
}
function vo(s, e) {
  St.registerCommand(s, function(t, ...i) {
    const n = t.get(Pe), [o, r] = i;
    qi(we.isUri(o)), qi(F.isIPosition(r));
    const a = t.get(Ui).getModel(o);
    if (a) {
      const l = F.lift(r);
      return n.invokeFunction(e, a, l, ...i.slice(2));
    }
    return t.get(bo).createModelReference(o).then((l) => new Promise((c, h) => {
      try {
        const d = n.invokeFunction(e, l.object.textEditorModel, F.lift(r), i.slice(2));
        c(d);
      } catch (d) {
        h(d);
      }
    }).finally(() => {
      l.dispose();
    }));
  });
}
function Le(s) {
  return Ho.INSTANCE.registerEditorCommand(s), s;
}
function Bn(s) {
  const e = new s();
  return Ho.INSTANCE.registerEditorAction(e), e;
}
function Xa(s, e, t) {
  Ho.INSTANCE.registerEditorContribution(s, e, t);
}
var Tu;
(function(s) {
  function e(r) {
    return Ho.INSTANCE.getEditorCommand(r);
  }
  s.getEditorCommand = e;
  function t() {
    return Ho.INSTANCE.getEditorActions();
  }
  s.getEditorActions = t;
  function i() {
    return Ho.INSTANCE.getEditorContributions();
  }
  s.getEditorContributions = i;
  function n(r) {
    return Ho.INSTANCE.getEditorContributions().filter((a) => r.indexOf(a.id) >= 0);
  }
  s.getSomeEditorContributions = n;
  function o() {
    return Ho.INSTANCE.getDiffEditorContributions();
  }
  s.getDiffEditorContributions = o;
})(Tu || (Tu = {}));
const dB = {
  EditorCommonContributions: "editor.contributions"
}, qC = class qC {
  constructor() {
    this.editorContributions = [], this.diffEditorContributions = [], this.editorActions = [], this.editorCommands = /* @__PURE__ */ Object.create(null);
  }
  registerEditorContribution(e, t, i) {
    this.editorContributions.push({ id: e, ctor: t, instantiation: i });
  }
  getEditorContributions() {
    return this.editorContributions.slice(0);
  }
  getDiffEditorContributions() {
    return this.diffEditorContributions.slice(0);
  }
  registerEditorAction(e) {
    e.register(), this.editorActions.push(e);
  }
  getEditorActions() {
    return this.editorActions;
  }
  registerEditorCommand(e) {
    e.register(), this.editorCommands[e.id] = e;
  }
  getEditorCommand(e) {
    return this.editorCommands[e] || null;
  }
};
qC.INSTANCE = new qC();
let Ho = qC;
Mi.add(dB.EditorCommonContributions, Ho.INSTANCE);
function Tp(s) {
  return s.register(), s;
}
const j4 = Tp(new TE({
  id: "undo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2104
    /* KeyCode.KeyZ */
  },
  menuOpts: [{
    menuId: et.MenubarEditMenu,
    group: "1_do",
    title: m({ key: "miUndo", comment: ["&& denotes a mnemonic"] }, "&&Undo"),
    order: 1
  }, {
    menuId: et.CommandPalette,
    group: "",
    title: m("undo", "Undo"),
    order: 1
  }]
}));
Tp(new K4(j4, { id: "default:undo", precondition: void 0 }));
const q4 = Tp(new TE({
  id: "redo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2103,
    secondary: [
      3128
      /* KeyCode.KeyZ */
    ],
    mac: {
      primary: 3128
      /* KeyCode.KeyZ */
    }
  },
  menuOpts: [{
    menuId: et.MenubarEditMenu,
    group: "1_do",
    title: m({ key: "miRedo", comment: ["&& denotes a mnemonic"] }, "&&Redo"),
    order: 2
  }, {
    menuId: et.CommandPalette,
    group: "",
    title: m("redo", "Redo"),
    order: 1
  }]
}));
Tp(new K4(q4, { id: "default:redo", precondition: void 0 }));
const uB = Tp(new TE({
  id: "editor.action.selectAll",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    kbExpr: null,
    primary: 2079
    /* KeyCode.KeyA */
  },
  menuOpts: [{
    menuId: et.MenubarSelectionMenu,
    group: "1_basic",
    title: m({ key: "miSelectAll", comment: ["&& denotes a mnemonic"] }, "&&Select All"),
    order: 1
  }, {
    menuId: et.CommandPalette,
    group: "",
    title: m("selectAll", "Select All"),
    order: 1
  }]
}));
let T = class Di {
  constructor(e, t, i, n) {
    e > i || e === i && t > n ? (this.startLineNumber = i, this.startColumn = n, this.endLineNumber = e, this.endColumn = t) : (this.startLineNumber = e, this.startColumn = t, this.endLineNumber = i, this.endColumn = n);
  }
  /**
   * Test if this range is empty.
   */
  isEmpty() {
    return Di.isEmpty(this);
  }
  /**
   * Test if `range` is empty.
   */
  static isEmpty(e) {
    return e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn;
  }
  /**
   * Test if position is in this range. If the position is at the edges, will return true.
   */
  containsPosition(e) {
    return Di.containsPosition(this, e);
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return true.
   */
  static containsPosition(e, t) {
    return !(t.lineNumber < e.startLineNumber || t.lineNumber > e.endLineNumber || t.lineNumber === e.startLineNumber && t.column < e.startColumn || t.lineNumber === e.endLineNumber && t.column > e.endColumn);
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return false.
   * @internal
   */
  static strictContainsPosition(e, t) {
    return !(t.lineNumber < e.startLineNumber || t.lineNumber > e.endLineNumber || t.lineNumber === e.startLineNumber && t.column <= e.startColumn || t.lineNumber === e.endLineNumber && t.column >= e.endColumn);
  }
  /**
   * Test if range is in this range. If the range is equal to this range, will return true.
   */
  containsRange(e) {
    return Di.containsRange(this, e);
  }
  /**
   * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
   */
  static containsRange(e, t) {
    return !(t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber || t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber || t.startLineNumber === e.startLineNumber && t.startColumn < e.startColumn || t.endLineNumber === e.endLineNumber && t.endColumn > e.endColumn);
  }
  /**
   * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
   */
  strictContainsRange(e) {
    return Di.strictContainsRange(this, e);
  }
  /**
   * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
   */
  static strictContainsRange(e, t) {
    return !(t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber || t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber || t.startLineNumber === e.startLineNumber && t.startColumn <= e.startColumn || t.endLineNumber === e.endLineNumber && t.endColumn >= e.endColumn);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  plusRange(e) {
    return Di.plusRange(this, e);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  static plusRange(e, t) {
    let i, n, o, r;
    return t.startLineNumber < e.startLineNumber ? (i = t.startLineNumber, n = t.startColumn) : t.startLineNumber === e.startLineNumber ? (i = t.startLineNumber, n = Math.min(t.startColumn, e.startColumn)) : (i = e.startLineNumber, n = e.startColumn), t.endLineNumber > e.endLineNumber ? (o = t.endLineNumber, r = t.endColumn) : t.endLineNumber === e.endLineNumber ? (o = t.endLineNumber, r = Math.max(t.endColumn, e.endColumn)) : (o = e.endLineNumber, r = e.endColumn), new Di(i, n, o, r);
  }
  /**
   * A intersection of the two ranges.
   */
  intersectRanges(e) {
    return Di.intersectRanges(this, e);
  }
  /**
   * A intersection of the two ranges.
   */
  static intersectRanges(e, t) {
    let i = e.startLineNumber, n = e.startColumn, o = e.endLineNumber, r = e.endColumn;
    const a = t.startLineNumber, l = t.startColumn, c = t.endLineNumber, h = t.endColumn;
    return i < a ? (i = a, n = l) : i === a && (n = Math.max(n, l)), o > c ? (o = c, r = h) : o === c && (r = Math.min(r, h)), i > o || i === o && n > r ? null : new Di(i, n, o, r);
  }
  /**
   * Test if this range equals other.
   */
  equalsRange(e) {
    return Di.equalsRange(this, e);
  }
  /**
   * Test if range `a` equals `b`.
   */
  static equalsRange(e, t) {
    return !e && !t ? !0 : !!e && !!t && e.startLineNumber === t.startLineNumber && e.startColumn === t.startColumn && e.endLineNumber === t.endLineNumber && e.endColumn === t.endColumn;
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  getEndPosition() {
    return Di.getEndPosition(this);
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  static getEndPosition(e) {
    return new F(e.endLineNumber, e.endColumn);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  getStartPosition() {
    return Di.getStartPosition(this);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  static getStartPosition(e) {
    return new F(e.startLineNumber, e.startColumn);
  }
  /**
   * Transform to a user presentable string representation.
   */
  toString() {
    return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
  }
  /**
   * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
   */
  setEndPosition(e, t) {
    return new Di(this.startLineNumber, this.startColumn, e, t);
  }
  /**
   * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
   */
  setStartPosition(e, t) {
    return new Di(e, t, this.endLineNumber, this.endColumn);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  collapseToStart() {
    return Di.collapseToStart(this);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  static collapseToStart(e) {
    return new Di(e.startLineNumber, e.startColumn, e.startLineNumber, e.startColumn);
  }
  /**
   * Create a new empty range using this range's end position.
   */
  collapseToEnd() {
    return Di.collapseToEnd(this);
  }
  /**
   * Create a new empty range using this range's end position.
   */
  static collapseToEnd(e) {
    return new Di(e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn);
  }
  /**
   * Moves the range by the given amount of lines.
   */
  delta(e) {
    return new Di(this.startLineNumber + e, this.startColumn, this.endLineNumber + e, this.endColumn);
  }
  // ---
  static fromPositions(e, t = e) {
    return new Di(e.lineNumber, e.column, t.lineNumber, t.column);
  }
  static lift(e) {
    return e ? new Di(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : null;
  }
  /**
   * Test if `obj` is an `IRange`.
   */
  static isIRange(e) {
    return e && typeof e.startLineNumber == "number" && typeof e.startColumn == "number" && typeof e.endLineNumber == "number" && typeof e.endColumn == "number";
  }
  /**
   * Test if the two ranges are touching in any way.
   */
  static areIntersectingOrTouching(e, t) {
    return !(e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn < t.startColumn || t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn < e.startColumn);
  }
  /**
   * Test if the two ranges are intersecting. If the ranges are touching it returns true.
   */
  static areIntersecting(e, t) {
    return !(e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn <= t.startColumn || t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn <= e.startColumn);
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the startPosition and then on the endPosition
   */
  static compareRangesUsingStarts(e, t) {
    if (e && t) {
      const o = e.startLineNumber | 0, r = t.startLineNumber | 0;
      if (o === r) {
        const a = e.startColumn | 0, l = t.startColumn | 0;
        if (a === l) {
          const c = e.endLineNumber | 0, h = t.endLineNumber | 0;
          if (c === h) {
            const d = e.endColumn | 0, u = t.endColumn | 0;
            return d - u;
          }
          return c - h;
        }
        return a - l;
      }
      return o - r;
    }
    return (e ? 1 : 0) - (t ? 1 : 0);
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the endPosition and then on the startPosition
   */
  static compareRangesUsingEnds(e, t) {
    return e.endLineNumber === t.endLineNumber ? e.endColumn === t.endColumn ? e.startLineNumber === t.startLineNumber ? e.startColumn - t.startColumn : e.startLineNumber - t.startLineNumber : e.endColumn - t.endColumn : e.endLineNumber - t.endLineNumber;
  }
  /**
   * Test if the range spans multiple lines.
   */
  static spansMultipleLines(e) {
    return e.endLineNumber > e.startLineNumber;
  }
  toJSON() {
    return this;
  }
};
var Z;
(function(s) {
  s.editorSimpleInput = new ce("editorSimpleInput", !1, !0), s.editorTextFocus = new ce("editorTextFocus", !1, m("editorTextFocus", "Whether the editor text has focus (cursor is blinking)")), s.focus = new ce("editorFocus", !1, m("editorFocus", "Whether the editor or an editor widget has focus (e.g. focus is in the find widget)")), s.textInputFocus = new ce("textInputFocus", !1, m("textInputFocus", "Whether an editor or a rich text input has focus (cursor is blinking)")), s.readOnly = new ce("editorReadonly", !1, m("editorReadonly", "Whether the editor is read-only")), s.inDiffEditor = new ce("inDiffEditor", !1, m("inDiffEditor", "Whether the context is a diff editor")), s.isEmbeddedDiffEditor = new ce("isEmbeddedDiffEditor", !1, m("isEmbeddedDiffEditor", "Whether the context is an embedded diff editor")), s.inMultiDiffEditor = new ce("inMultiDiffEditor", !1, m("inMultiDiffEditor", "Whether the context is a multi diff editor")), s.multiDiffEditorAllCollapsed = new ce("multiDiffEditorAllCollapsed", void 0, m("multiDiffEditorAllCollapsed", "Whether all files in multi diff editor are collapsed")), s.hasChanges = new ce("diffEditorHasChanges", !1, m("diffEditorHasChanges", "Whether the diff editor has changes")), s.comparingMovedCode = new ce("comparingMovedCode", !1, m("comparingMovedCode", "Whether a moved code block is selected for comparison")), s.accessibleDiffViewerVisible = new ce("accessibleDiffViewerVisible", !1, m("accessibleDiffViewerVisible", "Whether the accessible diff viewer is visible")), s.diffEditorRenderSideBySideInlineBreakpointReached = new ce("diffEditorRenderSideBySideInlineBreakpointReached", !1, m("diffEditorRenderSideBySideInlineBreakpointReached", "Whether the diff editor render side by side inline breakpoint is reached")), s.diffEditorInlineMode = new ce("diffEditorInlineMode", !1, m("diffEditorInlineMode", "Whether inline mode is active")), s.diffEditorOriginalWritable = new ce("diffEditorOriginalWritable", !1, m("diffEditorOriginalWritable", "Whether modified is writable in the diff editor")), s.diffEditorModifiedWritable = new ce("diffEditorModifiedWritable", !1, m("diffEditorModifiedWritable", "Whether modified is writable in the diff editor")), s.diffEditorOriginalUri = new ce("diffEditorOriginalUri", "", m("diffEditorOriginalUri", "The uri of the original document")), s.diffEditorModifiedUri = new ce("diffEditorModifiedUri", "", m("diffEditorModifiedUri", "The uri of the modified document")), s.columnSelection = new ce("editorColumnSelection", !1, m("editorColumnSelection", "Whether `editor.columnSelection` is enabled")), s.writable = s.readOnly.toNegated(), s.hasNonEmptySelection = new ce("editorHasSelection", !1, m("editorHasSelection", "Whether the editor has text selected")), s.hasOnlyEmptySelection = s.hasNonEmptySelection.toNegated(), s.hasMultipleSelections = new ce("editorHasMultipleSelections", !1, m("editorHasMultipleSelections", "Whether the editor has multiple selections")), s.hasSingleSelection = s.hasMultipleSelections.toNegated(), s.tabMovesFocus = new ce("editorTabMovesFocus", !1, m("editorTabMovesFocus", "Whether `Tab` will move focus out of the editor")), s.tabDoesNotMoveFocus = s.tabMovesFocus.toNegated(), s.isInEmbeddedEditor = new ce("isInEmbeddedEditor", !1, !0), s.canUndo = new ce("canUndo", !1, !0), s.canRedo = new ce("canRedo", !1, !0), s.hoverVisible = new ce("editorHoverVisible", !1, m("editorHoverVisible", "Whether the editor hover is visible")), s.hoverFocused = new ce("editorHoverFocused", !1, m("editorHoverFocused", "Whether the editor hover is focused")), s.stickyScrollFocused = new ce("stickyScrollFocused", !1, m("stickyScrollFocused", "Whether the sticky scroll is focused")), s.stickyScrollVisible = new ce("stickyScrollVisible", !1, m("stickyScrollVisible", "Whether the sticky scroll is visible")), s.standaloneColorPickerVisible = new ce("standaloneColorPickerVisible", !1, m("standaloneColorPickerVisible", "Whether the standalone color picker is visible")), s.standaloneColorPickerFocused = new ce("standaloneColorPickerFocused", !1, m("standaloneColorPickerFocused", "Whether the standalone color picker is focused")), s.inCompositeEditor = new ce("inCompositeEditor", void 0, m("inCompositeEditor", "Whether the editor is part of a larger editor (e.g. notebooks)")), s.notInCompositeEditor = s.inCompositeEditor.toNegated(), s.languageId = new ce("editorLangId", "", m("editorLangId", "The language identifier of the editor")), s.hasCompletionItemProvider = new ce("editorHasCompletionItemProvider", !1, m("editorHasCompletionItemProvider", "Whether the editor has a completion item provider")), s.hasCodeActionsProvider = new ce("editorHasCodeActionsProvider", !1, m("editorHasCodeActionsProvider", "Whether the editor has a code actions provider")), s.hasCodeLensProvider = new ce("editorHasCodeLensProvider", !1, m("editorHasCodeLensProvider", "Whether the editor has a code lens provider")), s.hasDefinitionProvider = new ce("editorHasDefinitionProvider", !1, m("editorHasDefinitionProvider", "Whether the editor has a definition provider")), s.hasDeclarationProvider = new ce("editorHasDeclarationProvider", !1, m("editorHasDeclarationProvider", "Whether the editor has a declaration provider")), s.hasImplementationProvider = new ce("editorHasImplementationProvider", !1, m("editorHasImplementationProvider", "Whether the editor has an implementation provider")), s.hasTypeDefinitionProvider = new ce("editorHasTypeDefinitionProvider", !1, m("editorHasTypeDefinitionProvider", "Whether the editor has a type definition provider")), s.hasHoverProvider = new ce("editorHasHoverProvider", !1, m("editorHasHoverProvider", "Whether the editor has a hover provider")), s.hasDocumentHighlightProvider = new ce("editorHasDocumentHighlightProvider", !1, m("editorHasDocumentHighlightProvider", "Whether the editor has a document highlight provider")), s.hasDocumentSymbolProvider = new ce("editorHasDocumentSymbolProvider", !1, m("editorHasDocumentSymbolProvider", "Whether the editor has a document symbol provider")), s.hasReferenceProvider = new ce("editorHasReferenceProvider", !1, m("editorHasReferenceProvider", "Whether the editor has a reference provider")), s.hasRenameProvider = new ce("editorHasRenameProvider", !1, m("editorHasRenameProvider", "Whether the editor has a rename provider")), s.hasSignatureHelpProvider = new ce("editorHasSignatureHelpProvider", !1, m("editorHasSignatureHelpProvider", "Whether the editor has a signature help provider")), s.hasInlayHintsProvider = new ce("editorHasInlayHintsProvider", !1, m("editorHasInlayHintsProvider", "Whether the editor has an inline hints provider")), s.hasDocumentFormattingProvider = new ce("editorHasDocumentFormattingProvider", !1, m("editorHasDocumentFormattingProvider", "Whether the editor has a document formatting provider")), s.hasDocumentSelectionFormattingProvider = new ce("editorHasDocumentSelectionFormattingProvider", !1, m("editorHasDocumentSelectionFormattingProvider", "Whether the editor has a document selection formatting provider")), s.hasMultipleDocumentFormattingProvider = new ce("editorHasMultipleDocumentFormattingProvider", !1, m("editorHasMultipleDocumentFormattingProvider", "Whether the editor has multiple document formatting providers")), s.hasMultipleDocumentSelectionFormattingProvider = new ce("editorHasMultipleDocumentSelectionFormattingProvider", !1, m("editorHasMultipleDocumentSelectionFormattingProvider", "Whether the editor has multiple document selection formatting providers"));
})(Z || (Z = {}));
var O2, F2;
class fB {
  constructor(e, t) {
    this.uri = e, this.value = t;
  }
}
function gB(s) {
  return Array.isArray(s);
}
const Kc = class Kc {
  constructor(e, t) {
    if (this[O2] = "ResourceMap", e instanceof Kc)
      this.map = new Map(e.map), this.toKey = t ?? Kc.defaultToKey;
    else if (gB(e)) {
      this.map = /* @__PURE__ */ new Map(), this.toKey = t ?? Kc.defaultToKey;
      for (const [i, n] of e)
        this.set(i, n);
    } else
      this.map = /* @__PURE__ */ new Map(), this.toKey = e ?? Kc.defaultToKey;
  }
  set(e, t) {
    return this.map.set(this.toKey(e), new fB(e, t)), this;
  }
  get(e) {
    var t;
    return (t = this.map.get(this.toKey(e))) == null ? void 0 : t.value;
  }
  has(e) {
    return this.map.has(this.toKey(e));
  }
  get size() {
    return this.map.size;
  }
  clear() {
    this.map.clear();
  }
  delete(e) {
    return this.map.delete(this.toKey(e));
  }
  forEach(e, t) {
    typeof t < "u" && (e = e.bind(t));
    for (const [i, n] of this.map)
      e(n.value, n.uri, this);
  }
  *values() {
    for (const e of this.map.values())
      yield e.value;
  }
  *keys() {
    for (const e of this.map.values())
      yield e.uri;
  }
  *entries() {
    for (const e of this.map.values())
      yield [e.uri, e.value];
  }
  *[(O2 = Symbol.toStringTag, Symbol.iterator)]() {
    for (const [, e] of this.map)
      yield [e.uri, e.value];
  }
};
Kc.defaultToKey = (e) => e.toString();
let Yn = Kc;
class mB {
  constructor() {
    this[F2] = "LinkedMap", this._map = /* @__PURE__ */ new Map(), this._head = void 0, this._tail = void 0, this._size = 0, this._state = 0;
  }
  clear() {
    this._map.clear(), this._head = void 0, this._tail = void 0, this._size = 0, this._state++;
  }
  isEmpty() {
    return !this._head && !this._tail;
  }
  get size() {
    return this._size;
  }
  get first() {
    var e;
    return (e = this._head) == null ? void 0 : e.value;
  }
  get last() {
    var e;
    return (e = this._tail) == null ? void 0 : e.value;
  }
  has(e) {
    return this._map.has(e);
  }
  get(e, t = 0) {
    const i = this._map.get(e);
    if (i)
      return t !== 0 && this.touch(i, t), i.value;
  }
  set(e, t, i = 0) {
    let n = this._map.get(e);
    if (n)
      n.value = t, i !== 0 && this.touch(n, i);
    else {
      switch (n = { key: e, value: t, next: void 0, previous: void 0 }, i) {
        case 0:
          this.addItemLast(n);
          break;
        case 1:
          this.addItemFirst(n);
          break;
        case 2:
          this.addItemLast(n);
          break;
        default:
          this.addItemLast(n);
          break;
      }
      this._map.set(e, n), this._size++;
    }
    return this;
  }
  delete(e) {
    return !!this.remove(e);
  }
  remove(e) {
    const t = this._map.get(e);
    if (t)
      return this._map.delete(e), this.removeItem(t), this._size--, t.value;
  }
  shift() {
    if (!this._head && !this._tail)
      return;
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    const e = this._head;
    return this._map.delete(e.key), this.removeItem(e), this._size--, e.value;
  }
  forEach(e, t) {
    const i = this._state;
    let n = this._head;
    for (; n; ) {
      if (t ? e.bind(t)(n.value, n.key, this) : e(n.value, n.key, this), this._state !== i)
        throw new Error("LinkedMap got modified during iteration.");
      n = n.next;
    }
  }
  keys() {
    const e = this, t = this._state;
    let i = this._head;
    const n = {
      [Symbol.iterator]() {
        return n;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const o = { value: i.key, done: !1 };
          return i = i.next, o;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return n;
  }
  values() {
    const e = this, t = this._state;
    let i = this._head;
    const n = {
      [Symbol.iterator]() {
        return n;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const o = { value: i.value, done: !1 };
          return i = i.next, o;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return n;
  }
  entries() {
    const e = this, t = this._state;
    let i = this._head;
    const n = {
      [Symbol.iterator]() {
        return n;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const o = { value: [i.key, i.value], done: !1 };
          return i = i.next, o;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return n;
  }
  [(F2 = Symbol.toStringTag, Symbol.iterator)]() {
    return this.entries();
  }
  trimOld(e) {
    if (e >= this.size)
      return;
    if (e === 0) {
      this.clear();
      return;
    }
    let t = this._head, i = this.size;
    for (; t && i > e; )
      this._map.delete(t.key), t = t.next, i--;
    this._head = t, this._size = i, t && (t.previous = void 0), this._state++;
  }
  trimNew(e) {
    if (e >= this.size)
      return;
    if (e === 0) {
      this.clear();
      return;
    }
    let t = this._tail, i = this.size;
    for (; t && i > e; )
      this._map.delete(t.key), t = t.previous, i--;
    this._tail = t, this._size = i, t && (t.next = void 0), this._state++;
  }
  addItemFirst(e) {
    if (!this._head && !this._tail)
      this._tail = e;
    else if (this._head)
      e.next = this._head, this._head.previous = e;
    else
      throw new Error("Invalid list");
    this._head = e, this._state++;
  }
  addItemLast(e) {
    if (!this._head && !this._tail)
      this._head = e;
    else if (this._tail)
      e.previous = this._tail, this._tail.next = e;
    else
      throw new Error("Invalid list");
    this._tail = e, this._state++;
  }
  removeItem(e) {
    if (e === this._head && e === this._tail)
      this._head = void 0, this._tail = void 0;
    else if (e === this._head) {
      if (!e.next)
        throw new Error("Invalid list");
      e.next.previous = void 0, this._head = e.next;
    } else if (e === this._tail) {
      if (!e.previous)
        throw new Error("Invalid list");
      e.previous.next = void 0, this._tail = e.previous;
    } else {
      const t = e.next, i = e.previous;
      if (!t || !i)
        throw new Error("Invalid list");
      t.previous = i, i.next = t;
    }
    e.next = void 0, e.previous = void 0, this._state++;
  }
  touch(e, t) {
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    if (!(t !== 1 && t !== 2)) {
      if (t === 1) {
        if (e === this._head)
          return;
        const i = e.next, n = e.previous;
        e === this._tail ? (n.next = void 0, this._tail = n) : (i.previous = n, n.next = i), e.previous = void 0, e.next = this._head, this._head.previous = e, this._head = e, this._state++;
      } else if (t === 2) {
        if (e === this._tail)
          return;
        const i = e.next, n = e.previous;
        e === this._head ? (i.previous = void 0, this._head = i) : (i.previous = n, n.next = i), e.next = void 0, e.previous = this._tail, this._tail.next = e, this._tail = e, this._state++;
      }
    }
  }
  toJSON() {
    const e = [];
    return this.forEach((t, i) => {
      e.push([i, t]);
    }), e;
  }
  fromJSON(e) {
    this.clear();
    for (const [t, i] of e)
      this.set(t, i);
  }
}
class pB extends mB {
  constructor(e, t = 1) {
    super(), this._limit = e, this._ratio = Math.min(Math.max(0, t), 1);
  }
  get limit() {
    return this._limit;
  }
  set limit(e) {
    this._limit = e, this.checkTrim();
  }
  get(e, t = 2) {
    return super.get(e, t);
  }
  peek(e) {
    return super.get(
      e,
      0
      /* Touch.None */
    );
  }
  set(e, t) {
    return super.set(
      e,
      t,
      2
      /* Touch.AsNew */
    ), this;
  }
  checkTrim() {
    this.size > this._limit && this.trim(Math.round(this._limit * this._ratio));
  }
}
class Mf extends pB {
  constructor(e, t = 1) {
    super(e, t);
  }
  trim(e) {
    this.trimOld(e);
  }
  set(e, t) {
    return super.set(e, t), this.checkTrim(), this;
  }
}
class _B {
  constructor(e) {
    if (this._m1 = /* @__PURE__ */ new Map(), this._m2 = /* @__PURE__ */ new Map(), e)
      for (const [t, i] of e)
        this.set(t, i);
  }
  clear() {
    this._m1.clear(), this._m2.clear();
  }
  set(e, t) {
    this._m1.set(e, t), this._m2.set(t, e);
  }
  get(e) {
    return this._m1.get(e);
  }
  getKey(e) {
    return this._m2.get(e);
  }
  delete(e) {
    const t = this._m1.get(e);
    return t === void 0 ? !1 : (this._m1.delete(e), this._m2.delete(t), !0);
  }
  keys() {
    return this._m1.keys();
  }
  values() {
    return this._m1.values();
  }
}
class G4 {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  add(e, t) {
    let i = this.map.get(e);
    i || (i = /* @__PURE__ */ new Set(), this.map.set(e, i)), i.add(t);
  }
  delete(e, t) {
    const i = this.map.get(e);
    i && (i.delete(t), i.size === 0 && this.map.delete(e));
  }
  forEach(e, t) {
    const i = this.map.get(e);
    i && i.forEach(t);
  }
  get(e) {
    const t = this.map.get(e);
    return t || /* @__PURE__ */ new Set();
  }
}
function Z4(...s) {
  return function(e, t) {
    for (let i = 0, n = s.length; i < n; i++) {
      const o = s[i](e, t);
      if (o)
        return o;
    }
    return null;
  };
}
Y4.bind(void 0, !1);
const Yb = Y4.bind(void 0, !0);
function Y4(s, e, t) {
  if (!t || t.length < e.length)
    return null;
  let i;
  return s ? i = cE(t, e) : i = t.indexOf(e) === 0, i ? e.length > 0 ? [{ start: 0, end: e.length }] : [] : null;
}
function bB(s, e) {
  const t = e.toLowerCase().indexOf(s.toLowerCase());
  return t === -1 ? null : [{ start: t, end: t + s.length }];
}
function CB(s, e) {
  return eS(s.toLowerCase(), e.toLowerCase(), 0, 0);
}
function eS(s, e, t, i) {
  if (t === s.length)
    return [];
  if (i === e.length)
    return null;
  if (s[t] === e[i]) {
    let n = null;
    return (n = eS(s, e, t + 1, i + 1)) ? Q4({ start: i, end: i + 1 }, n) : null;
  }
  return eS(s, e, t, i + 1);
}
function ME(s) {
  return 97 <= s && s <= 122;
}
function ew(s) {
  return 65 <= s && s <= 90;
}
function RE(s) {
  return 48 <= s && s <= 57;
}
function vB(s) {
  return s === 32 || s === 9 || s === 10 || s === 13;
}
const wB = /* @__PURE__ */ new Set();
"()[]{}<>`'\"-/;:,.?!".split("").forEach((s) => wB.add(s.charCodeAt(0)));
function X4(s) {
  return ME(s) || ew(s) || RE(s);
}
function Q4(s, e) {
  return e.length === 0 ? e = [s] : s.end === e[0].start ? e[0].start = s.start : e.unshift(s), e;
}
function J4(s, e) {
  for (let t = e; t < s.length; t++) {
    const i = s.charCodeAt(t);
    if (ew(i) || RE(i) || t > 0 && !X4(s.charCodeAt(t - 1)))
      return t;
  }
  return s.length;
}
function tS(s, e, t, i) {
  if (t === s.length)
    return [];
  if (i === e.length)
    return null;
  if (s[t] !== e[i].toLowerCase())
    return null;
  {
    let n = null, o = i + 1;
    for (n = tS(s, e, t + 1, i + 1); !n && (o = J4(e, o)) < e.length; )
      n = tS(s, e, t + 1, o), o++;
    return n === null ? null : Q4({ start: i, end: i + 1 }, n);
  }
}
function yB(s) {
  let e = 0, t = 0, i = 0, n = 0, o = 0;
  for (let h = 0; h < s.length; h++)
    o = s.charCodeAt(h), ew(o) && e++, ME(o) && t++, X4(o) && i++, RE(o) && n++;
  const r = e / s.length, a = t / s.length, l = i / s.length, c = n / s.length;
  return { upperPercent: r, lowerPercent: a, alphaPercent: l, numericPercent: c };
}
function SB(s) {
  const { upperPercent: e, lowerPercent: t } = s;
  return t === 0 && e > 0.6;
}
function LB(s) {
  const { upperPercent: e, lowerPercent: t, alphaPercent: i, numericPercent: n } = s;
  return t > 0.2 && e < 0.8 && i > 0.6 && n < 0.2;
}
function kB(s) {
  let e = 0, t = 0, i = 0, n = 0;
  for (let o = 0; o < s.length; o++)
    i = s.charCodeAt(o), ew(i) && e++, ME(i) && t++, vB(i) && n++;
  return (e === 0 || t === 0) && n === 0 ? s.length <= 30 : e <= 5;
}
function eO(s, e) {
  if (!e || (e = e.trim(), e.length === 0) || !kB(s))
    return null;
  e.length > 60 && (e = e.substring(0, 60));
  const t = yB(e);
  if (!LB(t)) {
    if (!SB(t))
      return null;
    e = e.toLowerCase();
  }
  let i = null, n = 0;
  for (s = s.toLowerCase(); n < e.length && (i = tS(s, e, 0, n)) === null; )
    n = J4(e, n + 1);
  return i;
}
const xB = Z4(Yb, eO, bB), DB = Z4(Yb, eO, CB), B2 = new Mf(1e4);
function W2(s, e, t = !1) {
  if (typeof s != "string" || typeof e != "string")
    return null;
  let i = B2.get(s);
  i || (i = new RegExp(m8(s), "i"), B2.set(s, i));
  const n = i.exec(e);
  return n ? [{ start: n.index, end: n.index + n[0].length }] : t ? DB(s, e) : xB(s, e);
}
function EB(s, e) {
  const t = nO(s, s.toLowerCase(), 0, e, e.toLowerCase(), 0, { firstMatchCanBeWeak: !0, boostFullMatch: !0 });
  return t ? AE(t) : null;
}
function AE(s) {
  if (typeof s > "u")
    return [];
  const e = [], t = s[1];
  for (let i = s.length - 1; i > 1; i--) {
    const n = s[i] + t, o = e[e.length - 1];
    o && o.end === n ? o.end = n + 1 : e.push({ start: n, end: n + 1 });
  }
  return e;
}
const Sl = 128;
function PE() {
  const s = [], e = [];
  for (let t = 0; t <= Sl; t++)
    e[t] = 0;
  for (let t = 0; t <= Sl; t++)
    s.push(e.slice(0));
  return s;
}
function tO(s) {
  const e = [];
  for (let t = 0; t <= s; t++)
    e[t] = 0;
  return e;
}
const iO = tO(2 * Sl), iS = tO(2 * Sl), ea = PE(), dc = PE(), l_ = PE();
function c_(s, e) {
  if (e < 0 || e >= s.length)
    return !1;
  const t = s.codePointAt(e);
  switch (t) {
    case 95:
    case 45:
    case 46:
    case 32:
    case 47:
    case 92:
    case 39:
    case 34:
    case 58:
    case 36:
    case 60:
    case 62:
    case 40:
    case 41:
    case 91:
    case 93:
    case 123:
    case 125:
      return !0;
    case void 0:
      return !1;
    default:
      return !!gE(t);
  }
}
function H2(s, e) {
  if (e < 0 || e >= s.length)
    return !1;
  switch (s.charCodeAt(e)) {
    case 32:
    case 9:
      return !0;
    default:
      return !1;
  }
}
function ib(s, e, t) {
  return e[s] !== t[s];
}
function IB(s, e, t, i, n, o, r = !1) {
  for (; e < t && n < o; )
    s[e] === i[n] && (r && (iO[e] = n), e += 1), n += 1;
  return e === t;
}
var rh;
(function(s) {
  s.Default = [-100, 0];
  function e(t) {
    return !t || t.length === 2 && t[0] === -100 && t[1] === 0;
  }
  s.isDefault = e;
})(rh || (rh = {}));
const t2 = class t2 {
  constructor(e, t) {
    this.firstMatchCanBeWeak = e, this.boostFullMatch = t;
  }
};
t2.default = { boostFullMatch: !0, firstMatchCanBeWeak: !1 };
let nS = t2;
function nO(s, e, t, i, n, o, r = nS.default) {
  const a = s.length > Sl ? Sl : s.length, l = i.length > Sl ? Sl : i.length;
  if (t >= a || o >= l || a - t > l - o || !IB(e, t, a, n, o, l, !0))
    return;
  NB(a, l, t, o, e, n);
  let c = 1, h = 1, d = t, u = o;
  const f = [!1];
  for (c = 1, d = t; d < a; c++, d++) {
    const C = iO[d], w = iS[d], v = d + 1 < a ? iS[d + 1] : l;
    for (h = C - o + 1, u = C; u < v; h++, u++) {
      let S = Number.MIN_SAFE_INTEGER, L = !1;
      u <= w && (S = TB(s, e, d, t, i, n, u, l, o, ea[c - 1][h - 1] === 0, f));
      let k = 0;
      S !== Number.MAX_SAFE_INTEGER && (L = !0, k = S + dc[c - 1][h - 1]);
      const x = u > C, I = x ? dc[c][h - 1] + (ea[c][h - 1] > 0 ? -5 : 0) : 0, K = u > C + 1 && ea[c][h - 1] > 0, B = K ? dc[c][h - 2] + (ea[c][h - 2] > 0 ? -5 : 0) : 0;
      if (K && (!x || B >= I) && (!L || B >= k))
        dc[c][h] = B, l_[c][h] = 3, ea[c][h] = 0;
      else if (x && (!L || I >= k))
        dc[c][h] = I, l_[c][h] = 2, ea[c][h] = 0;
      else if (L)
        dc[c][h] = k, l_[c][h] = 1, ea[c][h] = ea[c - 1][h - 1] + 1;
      else
        throw new Error("not possible");
    }
  }
  if (!f[0] && !r.firstMatchCanBeWeak)
    return;
  c--, h--;
  const g = [dc[c][h], o];
  let p = 0, _ = 0;
  for (; c >= 1; ) {
    let C = h;
    do {
      const w = l_[c][C];
      if (w === 3)
        C = C - 2;
      else if (w === 2)
        C = C - 1;
      else
        break;
    } while (C >= 1);
    p > 1 && e[t + c - 1] === n[o + h - 1] && !ib(C + o - 1, i, n) && p + 1 > ea[c][C] && (C = h), C === h ? p++ : p = 1, _ || (_ = C), c--, h = C - 1, g.push(h);
  }
  l - o === a && r.boostFullMatch && (g[0] += 2);
  const b = _ - a;
  return g[0] -= b, g;
}
function NB(s, e, t, i, n, o) {
  let r = s - 1, a = e - 1;
  for (; r >= t && a >= i; )
    n[r] === o[a] && (iS[r] = a, r--), a--;
}
function TB(s, e, t, i, n, o, r, a, l, c, h) {
  if (e[t] !== o[r])
    return Number.MIN_SAFE_INTEGER;
  let d = 1, u = !1;
  return r === t - i ? d = s[t] === n[r] ? 7 : 5 : ib(r, n, o) && (r === 0 || !ib(r - 1, n, o)) ? (d = s[t] === n[r] ? 7 : 5, u = !0) : c_(o, r) && (r === 0 || !c_(o, r - 1)) ? d = 5 : (c_(o, r - 1) || H2(o, r - 1)) && (d = 5, u = !0), d > 1 && t === i && (h[0] = !0), u || (u = ib(r, n, o) || c_(o, r - 1) || H2(o, r - 1)), t === i ? r > l && (d -= u ? 3 : 5) : c ? d += u ? 2 : 0 : d += u ? 0 : 1, r + 1 === a && (d -= u ? 3 : 5), d;
}
const MB = "$(", OE = new RegExp(`\\$\\(${Te.iconNameExpression}(?:${Te.iconModifierExpression})?\\)`, "g"), RB = new RegExp(`(\\\\)?${OE.source}`, "g");
function AB(s) {
  return s.replace(RB, (e, t) => t ? e : `\\${e}`);
}
const PB = new RegExp(`\\\\${OE.source}`, "g");
function OB(s) {
  return s.replace(PB, (e) => `\\${e}`);
}
const FB = new RegExp(`(\\s)?(\\\\)?${OE.source}(\\s)?`, "g");
function sO(s) {
  return s.indexOf(MB) === -1 ? s : s.replace(FB, (e, t, i, n) => i ? e : t || n || "");
}
function BB(s) {
  return s ? s.replace(/\$\((.*?)\)/g, (e, t) => ` ${t} `).trim() : "";
}
const C0 = new RegExp(`\\$\\(${Te.iconNameCharacter}+\\)`, "g");
function pg(s) {
  C0.lastIndex = 0;
  let e = "";
  const t = [];
  let i = 0;
  for (; ; ) {
    const n = C0.lastIndex, o = C0.exec(s), r = s.substring(n, o == null ? void 0 : o.index);
    if (r.length > 0) {
      e += r;
      for (let a = 0; a < r.length; a++)
        t.push(i);
    }
    if (!o)
      break;
    i += o[0].length;
  }
  return { text: e, iconOffsets: t };
}
function v0(s, e, t = !1) {
  const { text: i, iconOffsets: n } = e;
  if (!n || n.length === 0)
    return W2(s, i, t);
  const o = Hv(i, " "), r = i.length - o.length, a = W2(s, o, t);
  if (a)
    for (const l of a) {
      const c = n[l.start + r] + r;
      l.start += c, l.end += c;
    }
  return a;
}
function rl(s) {
  return s === 47 || s === 92;
}
function oO(s) {
  return s.replace(/[\\/]/g, ni.sep);
}
function WB(s) {
  return s.indexOf("/") === -1 && (s = oO(s)), /^[a-zA-Z]:(\/|$)/.test(s) && (s = "/" + s), s;
}
function V2(s, e = ni.sep) {
  if (!s)
    return "";
  const t = s.length, i = s.charCodeAt(0);
  if (rl(i)) {
    if (rl(s.charCodeAt(1)) && !rl(s.charCodeAt(2))) {
      let o = 3;
      const r = o;
      for (; o < t && !rl(s.charCodeAt(o)); o++)
        ;
      if (r !== o && !rl(s.charCodeAt(o + 1))) {
        for (o += 1; o < t; o++)
          if (rl(s.charCodeAt(o)))
            return s.slice(0, o + 1).replace(/[\\/]/g, e);
      }
    }
    return e;
  } else if (HB(i) && s.charCodeAt(1) === 58)
    return rl(s.charCodeAt(2)) ? s.slice(0, 2) + e : s.slice(0, 2);
  let n = s.indexOf("://");
  if (n !== -1) {
    for (n += 3; n < t; n++)
      if (rl(s.charCodeAt(n)))
        return s.slice(0, n + 1);
  }
  return "";
}
function sS(s, e, t, i = Tl) {
  if (s === e)
    return !0;
  if (!s || !e || e.length > s.length)
    return !1;
  if (t) {
    if (!cE(s, e))
      return !1;
    if (e.length === s.length)
      return !0;
    let o = e.length;
    return e.charAt(e.length - 1) === i && o--, s.charAt(o) === i;
  }
  return e.charAt(e.length - 1) !== i && (e += i), s.indexOf(e) === 0;
}
function HB(s) {
  return s >= 65 && s <= 90 || s >= 97 && s <= 122;
}
function ta(s) {
  return Fb(s, !0);
}
class VB {
  constructor(e) {
    this._ignorePathCasing = e;
  }
  compare(e, t, i = !1) {
    return e === t ? 0 : Lm(this.getComparisonKey(e, i), this.getComparisonKey(t, i));
  }
  isEqual(e, t, i = !1) {
    return e === t ? !0 : !e || !t ? !1 : this.getComparisonKey(e, i) === this.getComparisonKey(t, i);
  }
  getComparisonKey(e, t = !1) {
    return e.with({
      path: this._ignorePathCasing(e) ? e.path.toLowerCase() : void 0,
      fragment: t ? null : void 0
    }).toString();
  }
  isEqualOrParent(e, t, i = !1) {
    if (e.scheme === t.scheme) {
      if (e.scheme === Ie.file)
        return sS(ta(e), ta(t), this._ignorePathCasing(e)) && e.query === t.query && (i || e.fragment === t.fragment);
      if (U2(e.authority, t.authority))
        return sS(e.path, t.path, this._ignorePathCasing(e), "/") && e.query === t.query && (i || e.fragment === t.fragment);
    }
    return !1;
  }
  // --- path math
  joinPath(e, ...t) {
    return we.joinPath(e, ...t);
  }
  basenameOrAuthority(e) {
    return qo(e) || e.authority;
  }
  basename(e) {
    return ni.basename(e.path);
  }
  extname(e) {
    return ni.extname(e.path);
  }
  dirname(e) {
    if (e.path.length === 0)
      return e;
    let t;
    return e.scheme === Ie.file ? t = we.file(O9(ta(e))).path : (t = ni.dirname(e.path), e.authority && t.length && t.charCodeAt(0) !== 47 && (console.error(`dirname("${e.toString})) resulted in a relative path`), t = "/")), e.with({
      path: t
    });
  }
  normalizePath(e) {
    if (!e.path.length)
      return e;
    let t;
    return e.scheme === Ie.file ? t = we.file(YP(ta(e))).path : t = ni.normalize(e.path), e.with({
      path: t
    });
  }
  relativePath(e, t) {
    if (e.scheme !== t.scheme || !U2(e.authority, t.authority))
      return;
    if (e.scheme === Ie.file) {
      const o = P9(ta(e), ta(t));
      return es ? oO(o) : o;
    }
    let i = e.path || "/";
    const n = t.path || "/";
    if (this._ignorePathCasing(e)) {
      let o = 0;
      for (const r = Math.min(i.length, n.length); o < r && !(i.charCodeAt(o) !== n.charCodeAt(o) && i.charAt(o).toLowerCase() !== n.charAt(o).toLowerCase()); o++)
        ;
      i = n.substr(0, o) + i.substr(o);
    }
    return ni.relative(i, n);
  }
  resolvePath(e, t) {
    if (e.scheme === Ie.file) {
      const i = we.file(A9(ta(e), t));
      return e.with({
        authority: i.authority,
        path: i.path
      });
    }
    return t = WB(t), e.with({
      path: ni.resolve(e.path, t)
    });
  }
  // --- misc
  isAbsolutePath(e) {
    return !!e.path && e.path[0] === "/";
  }
  isEqualAuthority(e, t) {
    return e === t || e !== void 0 && t !== void 0 && Zd(e, t);
  }
  hasTrailingPathSeparator(e, t = Tl) {
    if (e.scheme === Ie.file) {
      const i = ta(e);
      return i.length > V2(i).length && i[i.length - 1] === t;
    } else {
      const i = e.path;
      return i.length > 1 && i.charCodeAt(i.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(e.fsPath);
    }
  }
  removeTrailingPathSeparator(e, t = Tl) {
    return $2(e, t) ? e.with({ path: e.path.substr(0, e.path.length - 1) }) : e;
  }
  addTrailingPathSeparator(e, t = Tl) {
    let i = !1;
    if (e.scheme === Ie.file) {
      const n = ta(e);
      i = n !== void 0 && n.length === V2(n).length && n[n.length - 1] === t;
    } else {
      t = "/";
      const n = e.path;
      i = n.length === 1 && n.charCodeAt(n.length - 1) === 47;
    }
    return !i && !$2(e, t) ? e.with({ path: e.path + "/" }) : e;
  }
}
const Et = new VB(() => !1), FE = Et.isEqual.bind(Et);
Et.isEqualOrParent.bind(Et);
Et.getComparisonKey.bind(Et);
const zB = Et.basenameOrAuthority.bind(Et), qo = Et.basename.bind(Et);
Et.extname.bind(Et);
const BE = Et.dirname.bind(Et);
Et.joinPath.bind(Et);
const UB = Et.normalizePath.bind(Et);
Et.relativePath.bind(Et);
const z2 = Et.resolvePath.bind(Et);
Et.isAbsolutePath.bind(Et);
const U2 = Et.isEqualAuthority.bind(Et), $2 = Et.hasTrailingPathSeparator.bind(Et);
Et.removeTrailingPathSeparator.bind(Et);
Et.addTrailingPathSeparator.bind(Et);
var Xb;
(function(s) {
  s.META_DATA_LABEL = "label", s.META_DATA_DESCRIPTION = "description", s.META_DATA_SIZE = "size", s.META_DATA_MIME = "mime";
  function e(t) {
    const i = /* @__PURE__ */ new Map();
    t.path.substring(t.path.indexOf(";") + 1, t.path.lastIndexOf(";")).split(";").forEach((r) => {
      const [a, l] = r.split(":");
      a && l && i.set(a, l);
    });
    const o = t.path.substring(0, t.path.indexOf(";"));
    return o && i.set(s.META_DATA_MIME, o), i;
  }
  s.parseMetaData = e;
})(Xb || (Xb = {}));
class Oo {
  constructor(e = "", t = !1) {
    if (this.value = e, typeof this.value != "string")
      throw Tr("value");
    typeof t == "boolean" ? (this.isTrusted = t, this.supportThemeIcons = !1, this.supportHtml = !1) : (this.isTrusted = t.isTrusted ?? void 0, this.supportThemeIcons = t.supportThemeIcons ?? !1, this.supportHtml = t.supportHtml ?? !1);
  }
  appendText(e, t = 0) {
    return this.value += KB(this.supportThemeIcons ? AB(e) : e).replace(/([ \t]+)/g, (i, n) => "&nbsp;".repeat(n.length)).replace(/\>/gm, "\\>").replace(/\n/g, t === 1 ? `\\
` : `

`), this;
  }
  appendMarkdown(e) {
    return this.value += e, this;
  }
  appendCodeblock(e, t) {
    return this.value += `
${jB(t, e)}
`, this;
  }
  appendLink(e, t, i) {
    return this.value += "[", this.value += this._escape(t, "]"), this.value += "](", this.value += this._escape(String(e), ")"), i && (this.value += ` "${this._escape(this._escape(i, '"'), ")")}"`), this.value += ")", this;
  }
  _escape(e, t) {
    const i = new RegExp(za(t), "g");
    return e.replace(i, (n, o) => e.charAt(o - 1) !== "\\" ? `\\${n}` : n);
  }
}
function rf(s) {
  return Mr(s) ? !s.value : Array.isArray(s) ? s.every(rf) : !0;
}
function Mr(s) {
  return s instanceof Oo ? !0 : s && typeof s == "object" ? typeof s.value == "string" && (typeof s.isTrusted == "boolean" || typeof s.isTrusted == "object" || s.isTrusted === void 0) && (typeof s.supportThemeIcons == "boolean" || s.supportThemeIcons === void 0) : !1;
}
function $B(s, e) {
  return s === e ? !0 : !s || !e ? !1 : s.value === e.value && s.isTrusted === e.isTrusted && s.supportThemeIcons === e.supportThemeIcons && s.supportHtml === e.supportHtml && (s.baseUri === e.baseUri || !!s.baseUri && !!e.baseUri && FE(we.from(s.baseUri), we.from(e.baseUri)));
}
function KB(s) {
  return s.replace(/[\\`*_{}[\]()#+\-!~]/g, "\\$&");
}
function jB(s, e) {
  var n;
  const t = ((n = s.match(/^`+/gm)) == null ? void 0 : n.reduce((o, r) => o.length > r.length ? o : r).length) ?? 0, i = t >= 3 ? t + 1 : 3;
  return [
    `${"`".repeat(i)}${e}`,
    s,
    `${"`".repeat(i)}`
  ].join(`
`);
}
function h_(s) {
  return s.replace(/"/g, "&quot;");
}
function w0(s) {
  return s && s.replace(/\\([\\`*_{}[\]()#+\-.!~])/g, "$1");
}
function qB(s) {
  const e = [], t = s.split("|").map((n) => n.trim());
  s = t[0];
  const i = t[1];
  if (i) {
    const n = /height=(\d+)/.exec(i), o = /width=(\d+)/.exec(i), r = n ? n[1] : "", a = o ? o[1] : "", l = isFinite(parseInt(a)), c = isFinite(parseInt(r));
    l && e.push(`width="${a}"`), c && e.push(`height="${r}"`);
  }
  return { href: s, dimensions: e };
}
class Lr {
  constructor(e, t = [], i = !1) {
    this.ctor = e, this.staticArguments = t, this.supportsDelayedInstantiation = i;
  }
}
const rO = [];
function Ze(s, e, t) {
  e instanceof Lr || (e = new Lr(e, [], !!t)), rO.push([s, e]);
}
function K2() {
  return rO;
}
const WE = Be("IEditorCancelService"), aO = new ce("cancellableOperation", !1, m("cancellableOperation", "Whether the editor runs a cancellable operation, e.g. like 'Peek References'"));
Ze(
  WE,
  class {
    constructor() {
      this._tokens = /* @__PURE__ */ new WeakMap();
    }
    add(s, e) {
      let t = this._tokens.get(s);
      t || (t = s.invokeWithinContext((n) => {
        const o = aO.bindTo(n.get(Fe)), r = new Tn();
        return { key: o, tokens: r };
      }), this._tokens.set(s, t));
      let i;
      return t.key.set(!0), i = t.tokens.push(e), () => {
        i && (i(), t.key.set(!t.tokens.isEmpty()), i = void 0);
      };
    }
    cancel(s) {
      const e = this._tokens.get(s);
      if (!e)
        return;
      const t = e.tokens.pop();
      t && (t.cancel(), e.key.set(!e.tokens.isEmpty()));
    }
  },
  1
  /* InstantiationType.Delayed */
);
class GB extends Vs {
  constructor(e, t) {
    super(t), this.editor = e, this._unregister = e.invokeWithinContext((i) => i.get(WE).add(e, this));
  }
  dispose() {
    this._unregister(), super.dispose();
  }
}
Le(new class extends jo {
  constructor() {
    super({
      id: "editor.cancelOperation",
      kbOpts: {
        weight: 100,
        primary: 9
        /* KeyCode.Escape */
      },
      precondition: aO
    });
  }
  runEditorCommand(s, e) {
    s.get(WE).cancel(e);
  }
}());
let ZB = class oS {
  constructor(e, t) {
    if (this.flags = t, (this.flags & 1) !== 0) {
      const i = e.getModel();
      this.modelVersionId = i ? Hb("{0}#{1}", i.uri.toString(), i.getVersionId()) : null;
    } else
      this.modelVersionId = null;
    (this.flags & 4) !== 0 ? this.position = e.getPosition() : this.position = null, (this.flags & 2) !== 0 ? this.selection = e.getSelection() : this.selection = null, (this.flags & 8) !== 0 ? (this.scrollLeft = e.getScrollLeft(), this.scrollTop = e.getScrollTop()) : (this.scrollLeft = -1, this.scrollTop = -1);
  }
  _equals(e) {
    if (!(e instanceof oS))
      return !1;
    const t = e;
    return !(this.modelVersionId !== t.modelVersionId || this.scrollLeft !== t.scrollLeft || this.scrollTop !== t.scrollTop || !this.position && t.position || this.position && !t.position || this.position && t.position && !this.position.equals(t.position) || !this.selection && t.selection || this.selection && !t.selection || this.selection && t.selection && !this.selection.equalsRange(t.selection));
  }
  validate(e) {
    return this._equals(new oS(e, this.flags));
  }
};
class YB extends GB {
  constructor(e, t, i, n) {
    super(e, n), this._listener = new ne(), t & 4 && this._listener.add(e.onDidChangeCursorPosition((o) => {
      (!i || !T.containsPosition(i, o.position)) && this.cancel();
    })), t & 2 && this._listener.add(e.onDidChangeCursorSelection((o) => {
      (!i || !T.containsRange(i, o.selection)) && this.cancel();
    })), t & 8 && this._listener.add(e.onDidScrollChange((o) => this.cancel())), t & 1 && (this._listener.add(e.onDidChangeModel((o) => this.cancel())), this._listener.add(e.onDidChangeModelContent((o) => this.cancel())));
  }
  dispose() {
    this._listener.dispose(), super.dispose();
  }
}
class XB extends Vs {
  constructor(e, t) {
    super(t), this._listener = e.onDidChangeContent(() => this.cancel());
  }
  dispose() {
    this._listener.dispose(), super.dispose();
  }
}
const ci = Be("languageService");
function rS(s, e) {
  return !!s[e];
}
class y0 {
  constructor(e, t) {
    this.target = e.target, this.isLeftClick = e.event.leftButton, this.isMiddleClick = e.event.middleButton, this.isRightClick = e.event.rightButton, this.hasTriggerModifier = rS(e.event, t.triggerModifier), this.hasSideBySideModifier = rS(e.event, t.triggerSideBySideModifier), this.isNoneOrSingleMouseDown = e.event.detail <= 1;
  }
}
class j2 {
  constructor(e, t) {
    this.keyCodeIsTriggerKey = e.keyCode === t.triggerKey, this.keyCodeIsSideBySideKey = e.keyCode === t.triggerSideBySideKey, this.hasTriggerModifier = rS(e, t.triggerModifier);
  }
}
class d_ {
  constructor(e, t, i, n) {
    this.triggerKey = e, this.triggerModifier = t, this.triggerSideBySideKey = i, this.triggerSideBySideModifier = n;
  }
  equals(e) {
    return this.triggerKey === e.triggerKey && this.triggerModifier === e.triggerModifier && this.triggerSideBySideKey === e.triggerSideBySideKey && this.triggerSideBySideModifier === e.triggerSideBySideModifier;
  }
}
function q2(s) {
  return s === "altKey" ? $e ? new d_(57, "metaKey", 6, "altKey") : new d_(5, "ctrlKey", 6, "altKey") : $e ? new d_(6, "altKey", 57, "metaKey") : new d_(6, "altKey", 5, "ctrlKey");
}
class lO extends U {
  constructor(e, t) {
    super(), this._onMouseMoveOrRelevantKeyDown = this._register(new A()), this.onMouseMoveOrRelevantKeyDown = this._onMouseMoveOrRelevantKeyDown.event, this._onExecute = this._register(new A()), this.onExecute = this._onExecute.event, this._onCancel = this._register(new A()), this.onCancel = this._onCancel.event, this._editor = e, this._extractLineNumberFromMouseEvent = (t == null ? void 0 : t.extractLineNumberFromMouseEvent) ?? ((i) => i.target.position ? i.target.position.lineNumber : 0), this._opts = q2(this._editor.getOption(
      78
      /* EditorOption.multiCursorModifier */
    )), this._lastMouseMoveEvent = null, this._hasTriggerKeyOnMouseDown = !1, this._lineNumberOnMouseDown = 0, this._register(this._editor.onDidChangeConfiguration((i) => {
      if (i.hasChanged(
        78
        /* EditorOption.multiCursorModifier */
      )) {
        const n = q2(this._editor.getOption(
          78
          /* EditorOption.multiCursorModifier */
        ));
        if (this._opts.equals(n))
          return;
        this._opts = n, this._lastMouseMoveEvent = null, this._hasTriggerKeyOnMouseDown = !1, this._lineNumberOnMouseDown = 0, this._onCancel.fire();
      }
    })), this._register(this._editor.onMouseMove((i) => this._onEditorMouseMove(new y0(i, this._opts)))), this._register(this._editor.onMouseDown((i) => this._onEditorMouseDown(new y0(i, this._opts)))), this._register(this._editor.onMouseUp((i) => this._onEditorMouseUp(new y0(i, this._opts)))), this._register(this._editor.onKeyDown((i) => this._onEditorKeyDown(new j2(i, this._opts)))), this._register(this._editor.onKeyUp((i) => this._onEditorKeyUp(new j2(i, this._opts)))), this._register(this._editor.onMouseDrag(() => this._resetHandler())), this._register(this._editor.onDidChangeCursorSelection((i) => this._onDidChangeCursorSelection(i))), this._register(this._editor.onDidChangeModel((i) => this._resetHandler())), this._register(this._editor.onDidChangeModelContent(() => this._resetHandler())), this._register(this._editor.onDidScrollChange((i) => {
      (i.scrollTopChanged || i.scrollLeftChanged) && this._resetHandler();
    }));
  }
  _onDidChangeCursorSelection(e) {
    e.selection && e.selection.startColumn !== e.selection.endColumn && this._resetHandler();
  }
  _onEditorMouseMove(e) {
    this._lastMouseMoveEvent = e, this._onMouseMoveOrRelevantKeyDown.fire([e, null]);
  }
  _onEditorMouseDown(e) {
    this._hasTriggerKeyOnMouseDown = e.hasTriggerModifier, this._lineNumberOnMouseDown = this._extractLineNumberFromMouseEvent(e);
  }
  _onEditorMouseUp(e) {
    const t = this._extractLineNumberFromMouseEvent(e);
    this._hasTriggerKeyOnMouseDown && this._lineNumberOnMouseDown && this._lineNumberOnMouseDown === t && this._onExecute.fire(e);
  }
  _onEditorKeyDown(e) {
    this._lastMouseMoveEvent && (e.keyCodeIsTriggerKey || e.keyCodeIsSideBySideKey && e.hasTriggerModifier) ? this._onMouseMoveOrRelevantKeyDown.fire([this._lastMouseMoveEvent, e]) : e.hasTriggerModifier && this._onCancel.fire();
  }
  _onEditorKeyUp(e) {
    e.keyCodeIsTriggerKey && this._onCancel.fire();
  }
  _resetHandler() {
    this._lastMouseMoveEvent = null, this._hasTriggerKeyOnMouseDown = !1, this._onCancel.fire();
  }
}
const wa = Object.freeze({
  text: "text/plain",
  binary: "application/octet-stream",
  unknown: "application/unknown",
  markdown: "text/markdown",
  latex: "text/latex",
  uriList: "text/uri-list"
}), cO = {
  /**
   * Typically transfer type for copy/paste transfers.
   */
  TEXT: wa.text
};
function Is(s, e = 0) {
  return s[s.length - (1 + e)];
}
function QB(s) {
  if (s.length === 0)
    throw new Error("Invalid tail call");
  return [s.slice(0, s.length - 1), s[s.length - 1]];
}
function li(s, e, t = (i, n) => i === n) {
  if (s === e)
    return !0;
  if (!s || !e || s.length !== e.length)
    return !1;
  for (let i = 0, n = s.length; i < n; i++)
    if (!t(s[i], e[i]))
      return !1;
  return !0;
}
function JB(s, e) {
  const t = s.length - 1;
  e < t && (s[e] = s[t]), s.pop();
}
function hO(s, e, t) {
  return eW(s.length, (i) => t(s[i], e));
}
function eW(s, e) {
  let t = 0, i = s - 1;
  for (; t <= i; ) {
    const n = (t + i) / 2 | 0, o = e(n);
    if (o < 0)
      t = n + 1;
    else if (o > 0)
      i = n - 1;
    else
      return n;
  }
  return -(t + 1);
}
function* HE(s, e) {
  let t, i;
  for (const n of s)
    i !== void 0 && e(i, n) ? t.push(n) : (t && (yield t), t = [n]), i = n;
  t && (yield t);
}
function dO(s, e) {
  for (let t = 0; t <= s.length; t++)
    e(t === 0 ? void 0 : s[t - 1], t === s.length ? void 0 : s[t]);
}
function tW(s, e) {
  for (let t = 0; t < s.length; t++)
    e(t === 0 ? void 0 : s[t - 1], s[t], t + 1 === s.length ? void 0 : s[t + 1]);
}
function Rf(s) {
  return s.filter((e) => !!e);
}
function G2(s) {
  let e = 0;
  for (let t = 0; t < s.length; t++)
    s[t] && (s[e] = s[t], e += 1);
  s.length = e;
}
function iW(s) {
  return !Array.isArray(s) || s.length === 0;
}
function co(s) {
  return Array.isArray(s) && s.length > 0;
}
function zh(s, e = (t) => t) {
  const t = /* @__PURE__ */ new Set();
  return s.filter((i) => {
    const n = e(i);
    return t.has(n) ? !1 : (t.add(n), !0);
  });
}
function VE(s, e) {
  return s.length > 0 ? s[0] : e;
}
function xn(s, e) {
  let t = typeof e == "number" ? s : 0;
  typeof e == "number" ? t = s : (t = 0, e = s);
  const i = [];
  if (t <= e)
    for (let n = t; n < e; n++)
      i.push(n);
  else
    for (let n = t; n > e; n--)
      i.push(n);
  return i;
}
function tw(s, e, t) {
  const i = s.slice(0, e), n = s.slice(e);
  return i.concat(t, n);
}
function S0(s, e) {
  const t = s.indexOf(e);
  t > -1 && (s.splice(t, 1), s.unshift(e));
}
function u_(s, e) {
  const t = s.indexOf(e);
  t > -1 && (s.splice(t, 1), s.push(e));
}
function aS(s, e) {
  for (const t of e)
    s.push(t);
}
function uO(s) {
  return Array.isArray(s) ? s : [s];
}
function nW(s, e, t) {
  const i = fO(s, e), n = s.length, o = t.length;
  s.length = n + o;
  for (let r = n - 1; r >= i; r--)
    s[r + o] = s[r];
  for (let r = 0; r < o; r++)
    s[r + i] = t[r];
}
function Z2(s, e, t, i) {
  const n = fO(s, e);
  let o = s.splice(n, t);
  return o === void 0 && (o = []), nW(s, n, i), o;
}
function fO(s, e) {
  return e < 0 ? Math.max(e + s.length, 0) : Math.min(e, s.length);
}
var Mm;
(function(s) {
  function e(o) {
    return o < 0;
  }
  s.isLessThan = e;
  function t(o) {
    return o <= 0;
  }
  s.isLessThanOrEqual = t;
  function i(o) {
    return o > 0;
  }
  s.isGreaterThan = i;
  function n(o) {
    return o === 0;
  }
  s.isNeitherLessOrGreaterThan = n, s.greaterThan = 1, s.lessThan = -1, s.neitherLessOrGreaterThan = 0;
})(Mm || (Mm = {}));
function Os(s, e) {
  return (t, i) => e(s(t), s(i));
}
function sW(...s) {
  return (e, t) => {
    for (const i of s) {
      const n = i(e, t);
      if (!Mm.isNeitherLessOrGreaterThan(n))
        return n;
    }
    return Mm.neitherLessOrGreaterThan;
  };
}
const Ba = (s, e) => s - e, oW = (s, e) => Ba(s ? 1 : 0, e ? 1 : 0);
function rW(s) {
  return (e, t) => -s(e, t);
}
class $a {
  /**
   * Constructs a queue that is backed by the given array. Runtime is O(1).
  */
  constructor(e) {
    this.items = e, this.firstIdx = 0, this.lastIdx = this.items.length - 1;
  }
  get length() {
    return this.lastIdx - this.firstIdx + 1;
  }
  /**
   * Consumes elements from the beginning of the queue as long as the predicate returns true.
   * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).
  */
  takeWhile(e) {
    let t = this.firstIdx;
    for (; t < this.items.length && e(this.items[t]); )
      t++;
    const i = t === this.firstIdx ? null : this.items.slice(this.firstIdx, t);
    return this.firstIdx = t, i;
  }
  /**
   * Consumes elements from the end of the queue as long as the predicate returns true.
   * If no elements were consumed, `null` is returned.
   * The result has the same order as the underlying array!
  */
  takeFromEndWhile(e) {
    let t = this.lastIdx;
    for (; t >= 0 && e(this.items[t]); )
      t--;
    const i = t === this.lastIdx ? null : this.items.slice(t + 1, this.lastIdx + 1);
    return this.lastIdx = t, i;
  }
  peek() {
    if (this.length !== 0)
      return this.items[this.firstIdx];
  }
  dequeue() {
    const e = this.items[this.firstIdx];
    return this.firstIdx++, e;
  }
  takeCount(e) {
    const t = this.items.slice(this.firstIdx, this.firstIdx + e);
    return this.firstIdx += e, t;
  }
}
const bu = class bu {
  constructor(e) {
    this.iterate = e;
  }
  toArray() {
    const e = [];
    return this.iterate((t) => (e.push(t), !0)), e;
  }
  filter(e) {
    return new bu((t) => this.iterate((i) => e(i) ? t(i) : !0));
  }
  map(e) {
    return new bu((t) => this.iterate((i) => t(e(i))));
  }
  findLast(e) {
    let t;
    return this.iterate((i) => (e(i) && (t = i), !0)), t;
  }
  findLastMaxBy(e) {
    let t, i = !0;
    return this.iterate((n) => ((i || Mm.isGreaterThan(e(n, t))) && (i = !1, t = n), !0)), t;
  }
};
bu.empty = new bu((e) => {
});
let ah = bu;
function Yt(s, e, t) {
  let i = null, n = null;
  if (typeof t.value == "function" ? (i = "value", n = t.value, n.length !== 0 && console.warn("Memoize should only be used in functions with zero parameters")) : typeof t.get == "function" && (i = "get", n = t.get), !n)
    throw new Error("not supported");
  const o = `$memoize$${e}`;
  t[i] = function(...r) {
    return this.hasOwnProperty(o) || Object.defineProperty(this, o, {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: n.apply(this, r)
    }), this[o];
  };
}
var aW = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, vt;
(function(s) {
  s.Tap = "-monaco-gesturetap", s.Change = "-monaco-gesturechange", s.Start = "-monaco-gesturestart", s.End = "-monaco-gesturesend", s.Contextmenu = "-monaco-gesturecontextmenu";
})(vt || (vt = {}));
const Fi = class Fi extends U {
  // ms
  constructor() {
    super(), this.dispatched = !1, this.targets = new Tn(), this.ignoreTargets = new Tn(), this.activeTouches = {}, this.handle = null, this._lastSetTapCountTime = 0, this._register(ee.runAndSubscribe(Qv, ({ window: e, disposables: t }) => {
      t.add(z(e.document, "touchstart", (i) => this.onTouchStart(i), { passive: !1 })), t.add(z(e.document, "touchend", (i) => this.onTouchEnd(e, i))), t.add(z(e.document, "touchmove", (i) => this.onTouchMove(i), { passive: !1 }));
    }, { window: pt, disposables: this._store }));
  }
  static addTarget(e) {
    if (!Fi.isTouchDevice())
      return U.None;
    Fi.INSTANCE || (Fi.INSTANCE = new Fi());
    const t = Fi.INSTANCE.targets.push(e);
    return _e(t);
  }
  static ignoreTarget(e) {
    if (!Fi.isTouchDevice())
      return U.None;
    Fi.INSTANCE || (Fi.INSTANCE = new Fi());
    const t = Fi.INSTANCE.ignoreTargets.push(e);
    return _e(t);
  }
  static isTouchDevice() {
    return "ontouchstart" in pt || navigator.maxTouchPoints > 0;
  }
  dispose() {
    this.handle && (this.handle.dispose(), this.handle = null), super.dispose();
  }
  onTouchStart(e) {
    const t = Date.now();
    this.handle && (this.handle.dispose(), this.handle = null);
    for (let i = 0, n = e.targetTouches.length; i < n; i++) {
      const o = e.targetTouches.item(i);
      this.activeTouches[o.identifier] = {
        id: o.identifier,
        initialTarget: o.target,
        initialTimeStamp: t,
        initialPageX: o.pageX,
        initialPageY: o.pageY,
        rollingTimestamps: [t],
        rollingPageX: [o.pageX],
        rollingPageY: [o.pageY]
      };
      const r = this.newGestureEvent(vt.Start, o.target);
      r.pageX = o.pageX, r.pageY = o.pageY, this.dispatchEvent(r);
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
  onTouchEnd(e, t) {
    const i = Date.now(), n = Object.keys(this.activeTouches).length;
    for (let o = 0, r = t.changedTouches.length; o < r; o++) {
      const a = t.changedTouches.item(o);
      if (!this.activeTouches.hasOwnProperty(String(a.identifier))) {
        console.warn("move of an UNKNOWN touch", a);
        continue;
      }
      const l = this.activeTouches[a.identifier], c = Date.now() - l.initialTimeStamp;
      if (c < Fi.HOLD_DELAY && Math.abs(l.initialPageX - Is(l.rollingPageX)) < 30 && Math.abs(l.initialPageY - Is(l.rollingPageY)) < 30) {
        const h = this.newGestureEvent(vt.Tap, l.initialTarget);
        h.pageX = Is(l.rollingPageX), h.pageY = Is(l.rollingPageY), this.dispatchEvent(h);
      } else if (c >= Fi.HOLD_DELAY && Math.abs(l.initialPageX - Is(l.rollingPageX)) < 30 && Math.abs(l.initialPageY - Is(l.rollingPageY)) < 30) {
        const h = this.newGestureEvent(vt.Contextmenu, l.initialTarget);
        h.pageX = Is(l.rollingPageX), h.pageY = Is(l.rollingPageY), this.dispatchEvent(h);
      } else if (n === 1) {
        const h = Is(l.rollingPageX), d = Is(l.rollingPageY), u = Is(l.rollingTimestamps) - l.rollingTimestamps[0], f = h - l.rollingPageX[0], g = d - l.rollingPageY[0], p = [...this.targets].filter((_) => l.initialTarget instanceof Node && _.contains(l.initialTarget));
        this.inertia(
          e,
          p,
          i,
          // time now
          Math.abs(f) / u,
          // speed
          f > 0 ? 1 : -1,
          // x direction
          h,
          // x now
          Math.abs(g) / u,
          // y speed
          g > 0 ? 1 : -1,
          // y direction
          d
          // y now
        );
      }
      this.dispatchEvent(this.newGestureEvent(vt.End, l.initialTarget)), delete this.activeTouches[a.identifier];
    }
    this.dispatched && (t.preventDefault(), t.stopPropagation(), this.dispatched = !1);
  }
  newGestureEvent(e, t) {
    const i = document.createEvent("CustomEvent");
    return i.initEvent(e, !1, !0), i.initialTarget = t, i.tapCount = 0, i;
  }
  dispatchEvent(e) {
    if (e.type === vt.Tap) {
      const t = (/* @__PURE__ */ new Date()).getTime();
      let i = 0;
      t - this._lastSetTapCountTime > Fi.CLEAR_TAP_COUNT_TIME ? i = 1 : i = 2, this._lastSetTapCountTime = t, e.tapCount = i;
    } else (e.type === vt.Change || e.type === vt.Contextmenu) && (this._lastSetTapCountTime = 0);
    if (e.initialTarget instanceof Node) {
      for (const i of this.ignoreTargets)
        if (i.contains(e.initialTarget))
          return;
      const t = [];
      for (const i of this.targets)
        if (i.contains(e.initialTarget)) {
          let n = 0, o = e.initialTarget;
          for (; o && o !== i; )
            n++, o = o.parentElement;
          t.push([n, i]);
        }
      t.sort((i, n) => i[0] - n[0]);
      for (const [i, n] of t)
        n.dispatchEvent(e), this.dispatched = !0;
    }
  }
  inertia(e, t, i, n, o, r, a, l, c) {
    this.handle = ns(e, () => {
      const h = Date.now(), d = h - i;
      let u = 0, f = 0, g = !0;
      n += Fi.SCROLL_FRICTION * d, a += Fi.SCROLL_FRICTION * d, n > 0 && (g = !1, u = o * n * d), a > 0 && (g = !1, f = l * a * d);
      const p = this.newGestureEvent(vt.Change);
      p.translationX = u, p.translationY = f, t.forEach((_) => _.dispatchEvent(p)), g || this.inertia(e, t, h, n, o, r + u, a, l, c + f);
    });
  }
  onTouchMove(e) {
    const t = Date.now();
    for (let i = 0, n = e.changedTouches.length; i < n; i++) {
      const o = e.changedTouches.item(i);
      if (!this.activeTouches.hasOwnProperty(String(o.identifier))) {
        console.warn("end of an UNKNOWN touch", o);
        continue;
      }
      const r = this.activeTouches[o.identifier], a = this.newGestureEvent(vt.Change, r.initialTarget);
      a.translationX = o.pageX - Is(r.rollingPageX), a.translationY = o.pageY - Is(r.rollingPageY), a.pageX = o.pageX, a.pageY = o.pageY, this.dispatchEvent(a), r.rollingPageX.length > 3 && (r.rollingPageX.shift(), r.rollingPageY.shift(), r.rollingTimestamps.shift()), r.rollingPageX.push(o.pageX), r.rollingPageY.push(o.pageY), r.rollingTimestamps.push(t);
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
};
Fi.SCROLL_FRICTION = -5e-3, Fi.HOLD_DELAY = 700, Fi.CLEAR_TAP_COUNT_TIME = 400;
let ln = Fi;
aW([
  Yt
], ln, "isTouchDevice", null);
const lW = () => ({
  get delay() {
    return -1;
  },
  dispose: () => {
  },
  showHover: () => {
  }
});
let iw = lW;
const cW = new Fr(() => iw("mouse", !1)), hW = new Fr(() => iw("element", !1));
function dW(s) {
  iw = s;
}
function $s(s) {
  return s === "element" ? hW.value : cW.value;
}
function zE() {
  return iw("element", !0);
}
class He {
  get event() {
    return this.emitter.event;
  }
  constructor(e, t, i) {
    const n = (o) => this.emitter.fire(o);
    this.emitter = new A({
      onWillAddFirstListener: () => e.addEventListener(t, n, i),
      onDidRemoveLastListener: () => e.removeEventListener(t, n, i)
    });
  }
  dispose() {
    this.emitter.dispose();
  }
}
function uW(s, e = {}) {
  const t = UE(e);
  return t.textContent = s, t;
}
function fW(s, e = {}) {
  const t = UE(e);
  return gO(t, mW(s, !!e.renderCodeSegments), e.actionHandler, e.renderCodeSegments), t;
}
function UE(s) {
  const e = s.inline ? "span" : "div", t = document.createElement(e);
  return s.className && (t.className = s.className), t;
}
class gW {
  constructor(e) {
    this.source = e, this.index = 0;
  }
  eos() {
    return this.index >= this.source.length;
  }
  next() {
    const e = this.peek();
    return this.advance(), e;
  }
  peek() {
    return this.source[this.index];
  }
  advance() {
    this.index++;
  }
}
function gO(s, e, t, i) {
  let n;
  if (e.type === 2)
    n = document.createTextNode(e.content || "");
  else if (e.type === 3)
    n = document.createElement("b");
  else if (e.type === 4)
    n = document.createElement("i");
  else if (e.type === 7 && i)
    n = document.createElement("code");
  else if (e.type === 5 && t) {
    const o = document.createElement("a");
    t.disposables.add(Zt(o, "click", (r) => {
      t.callback(String(e.index), r);
    })), n = o;
  } else e.type === 8 ? n = document.createElement("br") : e.type === 1 && (n = s);
  n && s !== n && s.appendChild(n), n && Array.isArray(e.children) && e.children.forEach((o) => {
    gO(n, o, t, i);
  });
}
function mW(s, e) {
  const t = {
    type: 1,
    children: []
  };
  let i = 0, n = t;
  const o = [], r = new gW(s);
  for (; !r.eos(); ) {
    let a = r.next();
    const l = a === "\\" && lS(r.peek(), e) !== 0;
    if (l && (a = r.next()), !l && pW(a, e) && a === r.peek()) {
      r.advance(), n.type === 2 && (n = o.pop());
      const c = lS(a, e);
      if (n.type === c || n.type === 5 && c === 6)
        n = o.pop();
      else {
        const h = {
          type: c,
          children: []
        };
        c === 5 && (h.index = i, i++), n.children.push(h), o.push(n), n = h;
      }
    } else if (a === `
`)
      n.type === 2 && (n = o.pop()), n.children.push({
        type: 8
        /* FormatType.NewLine */
      });
    else if (n.type !== 2) {
      const c = {
        type: 2,
        content: a
      };
      n.children.push(c), o.push(n), n = c;
    } else
      n.content += a;
  }
  return n.type === 2 && (n = o.pop()), t;
}
function pW(s, e) {
  return lS(s, e) !== 0;
}
function lS(s, e) {
  switch (s) {
    case "*":
      return 3;
    case "_":
      return 4;
    case "[":
      return 5;
    case "]":
      return 6;
    case "`":
      return e ? 7 : 0;
    default:
      return 0;
  }
}
const _W = new RegExp(`(\\\\)?\\$\\((${Te.iconNameExpression}(?:${Te.iconModifierExpression})?)\\)`, "g");
function lh(s) {
  const e = new Array();
  let t, i = 0, n = 0;
  for (; (t = _W.exec(s)) !== null; ) {
    n = t.index || 0, i < n && e.push(s.substring(i, n)), i = (t.index || 0) + t[0].length;
    const [, o, r] = t;
    e.push(o ? `$(${r})` : Qb({ id: r }));
  }
  return i < s.length && e.push(s.substring(i)), e;
}
function Qb(s) {
  const e = he("span");
  return e.classList.add(...Te.asClassNameArray(s)), e;
}
class $E {
  constructor(e) {
    this._prefix = e, this._lastId = 0;
  }
  nextId() {
    return this._prefix + ++this._lastId;
  }
}
const cS = new $E("id#");
let Xi = {};
(function() {
  function s(e, t) {
    t(Xi);
  }
  s.amd = !0, function(e, t) {
    typeof s == "function" && s.amd ? s(["exports"], t) : typeof exports == "object" && typeof module < "u" ? t(exports) : (e = typeof globalThis < "u" ? globalThis : e || self, t(e.marked = {}));
  }(this, function(e) {
    function t() {
      return {
        async: !1,
        breaks: !1,
        extensions: null,
        gfm: !0,
        hooks: null,
        pedantic: !1,
        renderer: null,
        silent: !1,
        tokenizer: null,
        walkTokens: null
      };
    }
    e.defaults = t();
    function i(je) {
      e.defaults = je;
    }
    const n = /[&<>"']/, o = new RegExp(n.source, "g"), r = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, a = new RegExp(r.source, "g"), l = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, c = (je) => l[je];
    function h(je, N) {
      if (N) {
        if (n.test(je))
          return je.replace(o, c);
      } else if (r.test(je))
        return je.replace(a, c);
      return je;
    }
    const d = /(^|[^\[])\^/g;
    function u(je, N) {
      let M = typeof je == "string" ? je : je.source;
      N = N || "";
      const R = {
        replace: (O, V) => {
          let G = typeof V == "string" ? V : V.source;
          return G = G.replace(d, "$1"), M = M.replace(O, G), R;
        },
        getRegex: () => new RegExp(M, N)
      };
      return R;
    }
    function f(je) {
      try {
        je = encodeURI(je).replace(/%25/g, "%");
      } catch {
        return null;
      }
      return je;
    }
    const g = { exec: () => null };
    function p(je, N) {
      const M = je.replace(/\|/g, (V, G, Q) => {
        let ue = !1, me = G;
        for (; --me >= 0 && Q[me] === "\\"; )
          ue = !ue;
        return ue ? "|" : " |";
      }), R = M.split(/ \|/);
      let O = 0;
      if (R[0].trim() || R.shift(), R.length > 0 && !R[R.length - 1].trim() && R.pop(), N)
        if (R.length > N)
          R.splice(N);
        else
          for (; R.length < N; )
            R.push("");
      for (; O < R.length; O++)
        R[O] = R[O].trim().replace(/\\\|/g, "|");
      return R;
    }
    function _(je, N, M) {
      const R = je.length;
      if (R === 0)
        return "";
      let O = 0;
      for (; O < R && je.charAt(R - O - 1) === N; )
        O++;
      return je.slice(0, R - O);
    }
    function b(je, N) {
      if (je.indexOf(N[1]) === -1)
        return -1;
      let M = 0;
      for (let R = 0; R < je.length; R++)
        if (je[R] === "\\")
          R++;
        else if (je[R] === N[0])
          M++;
        else if (je[R] === N[1] && (M--, M < 0))
          return R;
      return -1;
    }
    function C(je, N, M, R) {
      const O = N.href, V = N.title ? h(N.title) : null, G = je[1].replace(/\\([\[\]])/g, "$1");
      if (je[0].charAt(0) !== "!") {
        R.state.inLink = !0;
        const Q = {
          type: "link",
          raw: M,
          href: O,
          title: V,
          text: G,
          tokens: R.inlineTokens(G)
        };
        return R.state.inLink = !1, Q;
      }
      return {
        type: "image",
        raw: M,
        href: O,
        title: V,
        text: h(G)
      };
    }
    function w(je, N) {
      const M = je.match(/^(\s+)(?:```)/);
      if (M === null)
        return N;
      const R = M[1];
      return N.split(`
`).map((O) => {
        const V = O.match(/^\s+/);
        if (V === null)
          return O;
        const [G] = V;
        return G.length >= R.length ? O.slice(R.length) : O;
      }).join(`
`);
    }
    class v {
      // set by the lexer
      constructor(N) {
        rt(this, "options");
        rt(this, "rules");
        // set by the lexer
        rt(this, "lexer");
        this.options = N || e.defaults;
      }
      space(N) {
        const M = this.rules.block.newline.exec(N);
        if (M && M[0].length > 0)
          return {
            type: "space",
            raw: M[0]
          };
      }
      code(N) {
        const M = this.rules.block.code.exec(N);
        if (M) {
          const R = M[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: M[0],
            codeBlockStyle: "indented",
            text: this.options.pedantic ? R : _(R, `
`)
          };
        }
      }
      fences(N) {
        const M = this.rules.block.fences.exec(N);
        if (M) {
          const R = M[0], O = w(R, M[3] || "");
          return {
            type: "code",
            raw: R,
            lang: M[2] ? M[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : M[2],
            text: O
          };
        }
      }
      heading(N) {
        const M = this.rules.block.heading.exec(N);
        if (M) {
          let R = M[2].trim();
          if (/#$/.test(R)) {
            const O = _(R, "#");
            (this.options.pedantic || !O || / $/.test(O)) && (R = O.trim());
          }
          return {
            type: "heading",
            raw: M[0],
            depth: M[1].length,
            text: R,
            tokens: this.lexer.inline(R)
          };
        }
      }
      hr(N) {
        const M = this.rules.block.hr.exec(N);
        if (M)
          return {
            type: "hr",
            raw: _(M[0], `
`)
          };
      }
      blockquote(N) {
        const M = this.rules.block.blockquote.exec(N);
        if (M) {
          let R = _(M[0], `
`).split(`
`), O = "", V = "";
          const G = [];
          for (; R.length > 0; ) {
            let Q = !1;
            const ue = [];
            let me;
            for (me = 0; me < R.length; me++)
              if (/^ {0,3}>/.test(R[me]))
                ue.push(R[me]), Q = !0;
              else if (!Q)
                ue.push(R[me]);
              else
                break;
            R = R.slice(me);
            const We = ue.join(`
`), dt = We.replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, `
    $1`).replace(/^ {0,3}>[ \t]?/gm, "");
            O = O ? `${O}
${We}` : We, V = V ? `${V}
${dt}` : dt;
            const mt = this.lexer.state.top;
            if (this.lexer.state.top = !0, this.lexer.blockTokens(dt, G, !0), this.lexer.state.top = mt, R.length === 0)
              break;
            const $t = G[G.length - 1];
            if (($t == null ? void 0 : $t.type) === "code")
              break;
            if (($t == null ? void 0 : $t.type) === "blockquote") {
              const Kt = $t, Wn = Kt.raw + `
` + R.join(`
`), Es = this.blockquote(Wn);
              G[G.length - 1] = Es, O = O.substring(0, O.length - Kt.raw.length) + Es.raw, V = V.substring(0, V.length - Kt.text.length) + Es.text;
              break;
            } else if (($t == null ? void 0 : $t.type) === "list") {
              const Kt = $t, Wn = Kt.raw + `
` + R.join(`
`), Es = this.list(Wn);
              G[G.length - 1] = Es, O = O.substring(0, O.length - $t.raw.length) + Es.raw, V = V.substring(0, V.length - Kt.raw.length) + Es.raw, R = Wn.substring(G[G.length - 1].raw.length).split(`
`);
              continue;
            }
          }
          return {
            type: "blockquote",
            raw: O,
            tokens: G,
            text: V
          };
        }
      }
      list(N) {
        let M = this.rules.block.list.exec(N);
        if (M) {
          let R = M[1].trim();
          const O = R.length > 1, V = {
            type: "list",
            raw: "",
            ordered: O,
            start: O ? +R.slice(0, -1) : "",
            loose: !1,
            items: []
          };
          R = O ? `\\d{1,9}\\${R.slice(-1)}` : `\\${R}`, this.options.pedantic && (R = O ? R : "[*+-]");
          const G = new RegExp(`^( {0,3}${R})((?:[	 ][^\\n]*)?(?:\\n|$))`);
          let Q = !1;
          for (; N; ) {
            let ue = !1, me = "", We = "";
            if (!(M = G.exec(N)) || this.rules.block.hr.test(N))
              break;
            me = M[0], N = N.substring(me.length);
            let dt = M[2].split(`
`, 1)[0].replace(/^\t+/, (Kf) => " ".repeat(3 * Kf.length)), mt = N.split(`
`, 1)[0], $t = !dt.trim(), Kt = 0;
            if (this.options.pedantic ? (Kt = 2, We = dt.trimStart()) : $t ? Kt = M[1].length + 1 : (Kt = M[2].search(/[^ ]/), Kt = Kt > 4 ? 1 : Kt, We = dt.slice(Kt), Kt += M[1].length), $t && /^ *$/.test(mt) && (me += mt + `
`, N = N.substring(mt.length + 1), ue = !0), !ue) {
              const Kf = new RegExp(`^ {0,${Math.min(3, Kt - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), Re = new RegExp(`^ {0,${Math.min(3, Kt - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), $ = new RegExp(`^ {0,${Math.min(3, Kt - 1)}}(?:\`\`\`|~~~)`), de = new RegExp(`^ {0,${Math.min(3, Kt - 1)}}#`);
              for (; N; ) {
                const ke = N.split(`
`, 1)[0];
                if (mt = ke, this.options.pedantic && (mt = mt.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), $.test(mt) || de.test(mt) || Kf.test(mt) || Re.test(N))
                  break;
                if (mt.search(/[^ ]/) >= Kt || !mt.trim())
                  We += `
` + mt.slice(Kt);
                else {
                  if ($t || dt.search(/[^ ]/) >= 4 || $.test(dt) || de.test(dt) || Re.test(dt))
                    break;
                  We += `
` + mt;
                }
                !$t && !mt.trim() && ($t = !0), me += ke + `
`, N = N.substring(ke.length + 1), dt = mt.slice(Kt);
              }
            }
            V.loose || (Q ? V.loose = !0 : /\n *\n *$/.test(me) && (Q = !0));
            let Wn = null, Es;
            this.options.gfm && (Wn = /^\[[ xX]\] /.exec(We), Wn && (Es = Wn[0] !== "[ ] ", We = We.replace(/^\[[ xX]\] +/, ""))), V.items.push({
              type: "list_item",
              raw: me,
              task: !!Wn,
              checked: Es,
              loose: !1,
              text: We,
              tokens: []
            }), V.raw += me;
          }
          V.items[V.items.length - 1].raw = V.items[V.items.length - 1].raw.trimEnd(), V.items[V.items.length - 1].text = V.items[V.items.length - 1].text.trimEnd(), V.raw = V.raw.trimEnd();
          for (let ue = 0; ue < V.items.length; ue++)
            if (this.lexer.state.top = !1, V.items[ue].tokens = this.lexer.blockTokens(V.items[ue].text, []), !V.loose) {
              const me = V.items[ue].tokens.filter((dt) => dt.type === "space"), We = me.length > 0 && me.some((dt) => /\n.*\n/.test(dt.raw));
              V.loose = We;
            }
          if (V.loose)
            for (let ue = 0; ue < V.items.length; ue++)
              V.items[ue].loose = !0;
          return V;
        }
      }
      html(N) {
        const M = this.rules.block.html.exec(N);
        if (M)
          return {
            type: "html",
            block: !0,
            raw: M[0],
            pre: M[1] === "pre" || M[1] === "script" || M[1] === "style",
            text: M[0]
          };
      }
      def(N) {
        const M = this.rules.block.def.exec(N);
        if (M) {
          const R = M[1].toLowerCase().replace(/\s+/g, " "), O = M[2] ? M[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", V = M[3] ? M[3].substring(1, M[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : M[3];
          return {
            type: "def",
            tag: R,
            raw: M[0],
            href: O,
            title: V
          };
        }
      }
      table(N) {
        const M = this.rules.block.table.exec(N);
        if (!M || !/[:|]/.test(M[2]))
          return;
        const R = p(M[1]), O = M[2].replace(/^\||\| *$/g, "").split("|"), V = M[3] && M[3].trim() ? M[3].replace(/\n[ \t]*$/, "").split(`
`) : [], G = {
          type: "table",
          raw: M[0],
          header: [],
          align: [],
          rows: []
        };
        if (R.length === O.length) {
          for (const Q of O)
            /^ *-+: *$/.test(Q) ? G.align.push("right") : /^ *:-+: *$/.test(Q) ? G.align.push("center") : /^ *:-+ *$/.test(Q) ? G.align.push("left") : G.align.push(null);
          for (let Q = 0; Q < R.length; Q++)
            G.header.push({
              text: R[Q],
              tokens: this.lexer.inline(R[Q]),
              header: !0,
              align: G.align[Q]
            });
          for (const Q of V)
            G.rows.push(p(Q, G.header.length).map((ue, me) => ({
              text: ue,
              tokens: this.lexer.inline(ue),
              header: !1,
              align: G.align[me]
            })));
          return G;
        }
      }
      lheading(N) {
        const M = this.rules.block.lheading.exec(N);
        if (M)
          return {
            type: "heading",
            raw: M[0],
            depth: M[2].charAt(0) === "=" ? 1 : 2,
            text: M[1],
            tokens: this.lexer.inline(M[1])
          };
      }
      paragraph(N) {
        const M = this.rules.block.paragraph.exec(N);
        if (M) {
          const R = M[1].charAt(M[1].length - 1) === `
` ? M[1].slice(0, -1) : M[1];
          return {
            type: "paragraph",
            raw: M[0],
            text: R,
            tokens: this.lexer.inline(R)
          };
        }
      }
      text(N) {
        const M = this.rules.block.text.exec(N);
        if (M)
          return {
            type: "text",
            raw: M[0],
            text: M[0],
            tokens: this.lexer.inline(M[0])
          };
      }
      escape(N) {
        const M = this.rules.inline.escape.exec(N);
        if (M)
          return {
            type: "escape",
            raw: M[0],
            text: h(M[1])
          };
      }
      tag(N) {
        const M = this.rules.inline.tag.exec(N);
        if (M)
          return !this.lexer.state.inLink && /^<a /i.test(M[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(M[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(M[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(M[0]) && (this.lexer.state.inRawBlock = !1), {
            type: "html",
            raw: M[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            block: !1,
            text: M[0]
          };
      }
      link(N) {
        const M = this.rules.inline.link.exec(N);
        if (M) {
          const R = M[2].trim();
          if (!this.options.pedantic && /^</.test(R)) {
            if (!/>$/.test(R))
              return;
            const G = _(R.slice(0, -1), "\\");
            if ((R.length - G.length) % 2 === 0)
              return;
          } else {
            const G = b(M[2], "()");
            if (G > -1) {
              const ue = (M[0].indexOf("!") === 0 ? 5 : 4) + M[1].length + G;
              M[2] = M[2].substring(0, G), M[0] = M[0].substring(0, ue).trim(), M[3] = "";
            }
          }
          let O = M[2], V = "";
          if (this.options.pedantic) {
            const G = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(O);
            G && (O = G[1], V = G[3]);
          } else
            V = M[3] ? M[3].slice(1, -1) : "";
          return O = O.trim(), /^</.test(O) && (this.options.pedantic && !/>$/.test(R) ? O = O.slice(1) : O = O.slice(1, -1)), C(M, {
            href: O && O.replace(this.rules.inline.anyPunctuation, "$1"),
            title: V && V.replace(this.rules.inline.anyPunctuation, "$1")
          }, M[0], this.lexer);
        }
      }
      reflink(N, M) {
        let R;
        if ((R = this.rules.inline.reflink.exec(N)) || (R = this.rules.inline.nolink.exec(N))) {
          const O = (R[2] || R[1]).replace(/\s+/g, " "), V = M[O.toLowerCase()];
          if (!V) {
            const G = R[0].charAt(0);
            return {
              type: "text",
              raw: G,
              text: G
            };
          }
          return C(R, V, R[0], this.lexer);
        }
      }
      emStrong(N, M, R = "") {
        let O = this.rules.inline.emStrongLDelim.exec(N);
        if (!O || O[3] && R.match(/[\p{L}\p{N}]/u))
          return;
        if (!(O[1] || O[2] || "") || !R || this.rules.inline.punctuation.exec(R)) {
          const G = [...O[0]].length - 1;
          let Q, ue, me = G, We = 0;
          const dt = O[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
          for (dt.lastIndex = 0, M = M.slice(-1 * N.length + G); (O = dt.exec(M)) != null; ) {
            if (Q = O[1] || O[2] || O[3] || O[4] || O[5] || O[6], !Q)
              continue;
            if (ue = [...Q].length, O[3] || O[4]) {
              me += ue;
              continue;
            } else if ((O[5] || O[6]) && G % 3 && !((G + ue) % 3)) {
              We += ue;
              continue;
            }
            if (me -= ue, me > 0)
              continue;
            ue = Math.min(ue, ue + me + We);
            const mt = [...O[0]][0].length, $t = N.slice(0, G + O.index + mt + ue);
            if (Math.min(G, ue) % 2) {
              const Wn = $t.slice(1, -1);
              return {
                type: "em",
                raw: $t,
                text: Wn,
                tokens: this.lexer.inlineTokens(Wn)
              };
            }
            const Kt = $t.slice(2, -2);
            return {
              type: "strong",
              raw: $t,
              text: Kt,
              tokens: this.lexer.inlineTokens(Kt)
            };
          }
        }
      }
      codespan(N) {
        const M = this.rules.inline.code.exec(N);
        if (M) {
          let R = M[2].replace(/\n/g, " ");
          const O = /[^ ]/.test(R), V = /^ /.test(R) && / $/.test(R);
          return O && V && (R = R.substring(1, R.length - 1)), R = h(R, !0), {
            type: "codespan",
            raw: M[0],
            text: R
          };
        }
      }
      br(N) {
        const M = this.rules.inline.br.exec(N);
        if (M)
          return {
            type: "br",
            raw: M[0]
          };
      }
      del(N) {
        const M = this.rules.inline.del.exec(N);
        if (M)
          return {
            type: "del",
            raw: M[0],
            text: M[2],
            tokens: this.lexer.inlineTokens(M[2])
          };
      }
      autolink(N) {
        const M = this.rules.inline.autolink.exec(N);
        if (M) {
          let R, O;
          return M[2] === "@" ? (R = h(M[1]), O = "mailto:" + R) : (R = h(M[1]), O = R), {
            type: "link",
            raw: M[0],
            text: R,
            href: O,
            tokens: [
              {
                type: "text",
                raw: R,
                text: R
              }
            ]
          };
        }
      }
      url(N) {
        var R;
        let M;
        if (M = this.rules.inline.url.exec(N)) {
          let O, V;
          if (M[2] === "@")
            O = h(M[0]), V = "mailto:" + O;
          else {
            let G;
            do
              G = M[0], M[0] = ((R = this.rules.inline._backpedal.exec(M[0])) == null ? void 0 : R[0]) ?? "";
            while (G !== M[0]);
            O = h(M[0]), M[1] === "www." ? V = "http://" + M[0] : V = M[0];
          }
          return {
            type: "link",
            raw: M[0],
            text: O,
            href: V,
            tokens: [
              {
                type: "text",
                raw: O,
                text: O
              }
            ]
          };
        }
      }
      inlineText(N) {
        const M = this.rules.inline.text.exec(N);
        if (M) {
          let R;
          return this.lexer.state.inRawBlock ? R = M[0] : R = h(M[0]), {
            type: "text",
            raw: M[0],
            text: R
          };
        }
      }
    }
    const S = /^(?: *(?:\n|$))+/, L = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, k = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, x = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, I = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, K = /(?:[*+-]|\d{1,9}[.)])/, B = u(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, K).replace(/blockCode/g, / {4}/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).getRegex(), W = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, H = /^[^\n]+/, P = /(?!\s*\])(?:\\.|[^\[\]\\])+/, q = u(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", P).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), J = u(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, K).getRegex(), oe = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", ae = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, re = u("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", ae).replace("tag", oe).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), be = u(W).replace("hr", x).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", oe).getRegex(), At = {
      blockquote: u(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", be).getRegex(),
      code: L,
      def: q,
      fences: k,
      heading: I,
      hr: x,
      html: re,
      lheading: B,
      list: J,
      newline: S,
      paragraph: be,
      table: g,
      text: H
    }, ye = u("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", x).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", oe).getRegex(), ct = {
      ...At,
      table: ye,
      paragraph: u(W).replace("hr", x).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", ye).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", oe).getRegex()
    }, ot = {
      ...At,
      html: u(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", ae).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: g,
      // fences not supported
      lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      paragraph: u(W).replace("hr", x).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", B).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
    }, Xt = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, hn = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, Sn = /^( {2,}|\\)\n(?!\s*$)/, qs = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, as = "\\p{P}\\p{S}", rc = u(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, as).getRegex(), di = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g, Gs = u(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, as).getRegex(), Xr = u("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, as).getRegex(), zf = u("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, as).getRegex(), Uf = u(/\\([punct])/, "gu").replace(/punct/g, as).getRegex(), tl = u(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), yd = u(ae).replace("(?:-->|$)", "-->").getRegex(), Sd = u("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", yd).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), ac = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, Xp = u(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", ac).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), Qp = u(/^!?\[(label)\]\[(ref)\]/).replace("label", ac).replace("ref", P).getRegex(), Ld = u(/^!?\[(ref)\](?:\[\])?/).replace("ref", P).getRegex(), lc = u("reflink|nolink(?!\\()", "g").replace("reflink", Qp).replace("nolink", Ld).getRegex(), or = {
      _backpedal: g,
      // only used for GFM url
      anyPunctuation: Uf,
      autolink: tl,
      blockSkip: di,
      br: Sn,
      code: hn,
      del: g,
      emStrongLDelim: Gs,
      emStrongRDelimAst: Xr,
      emStrongRDelimUnd: zf,
      escape: Xt,
      link: Xp,
      nolink: Ld,
      punctuation: rc,
      reflink: Qp,
      reflinkSearch: lc,
      tag: Sd,
      text: qs,
      url: g
    }, il = {
      ...or,
      link: u(/^!?\[(label)\]\((.*?)\)/).replace("label", ac).getRegex(),
      reflink: u(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", ac).getRegex()
    }, kd = {
      ...or,
      escape: u(Xt).replace("])", "~|])").getRegex(),
      url: u(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
      _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    }, Jp = {
      ...kd,
      br: u(Sn).replace("{2,}", "*").getRegex(),
      text: u(kd.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    }, cc = {
      normal: At,
      gfm: ct,
      pedantic: ot
    }, Qr = {
      normal: or,
      gfm: kd,
      breaks: Jp,
      pedantic: il
    };
    class ls {
      constructor(N) {
        rt(this, "tokens");
        rt(this, "options");
        rt(this, "state");
        rt(this, "tokenizer");
        rt(this, "inlineQueue");
        this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = N || e.defaults, this.options.tokenizer = this.options.tokenizer || new v(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
          inLink: !1,
          inRawBlock: !1,
          top: !0
        };
        const M = {
          block: cc.normal,
          inline: Qr.normal
        };
        this.options.pedantic ? (M.block = cc.pedantic, M.inline = Qr.pedantic) : this.options.gfm && (M.block = cc.gfm, this.options.breaks ? M.inline = Qr.breaks : M.inline = Qr.gfm), this.tokenizer.rules = M;
      }
      /**
       * Expose Rules
       */
      static get rules() {
        return {
          block: cc,
          inline: Qr
        };
      }
      /**
       * Static Lex Method
       */
      static lex(N, M) {
        return new ls(M).lex(N);
      }
      /**
       * Static Lex Inline Method
       */
      static lexInline(N, M) {
        return new ls(M).inlineTokens(N);
      }
      /**
       * Preprocessing
       */
      lex(N) {
        N = N.replace(/\r\n|\r/g, `
`), this.blockTokens(N, this.tokens);
        for (let M = 0; M < this.inlineQueue.length; M++) {
          const R = this.inlineQueue[M];
          this.inlineTokens(R.src, R.tokens);
        }
        return this.inlineQueue = [], this.tokens;
      }
      blockTokens(N, M = [], R = !1) {
        this.options.pedantic ? N = N.replace(/\t/g, "    ").replace(/^ +$/gm, "") : N = N.replace(/^( *)(\t+)/gm, (Q, ue, me) => ue + "    ".repeat(me.length));
        let O, V, G;
        for (; N; )
          if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((Q) => (O = Q.call({ lexer: this }, N, M)) ? (N = N.substring(O.raw.length), M.push(O), !0) : !1))) {
            if (O = this.tokenizer.space(N)) {
              N = N.substring(O.raw.length), O.raw.length === 1 && M.length > 0 ? M[M.length - 1].raw += `
` : M.push(O);
              continue;
            }
            if (O = this.tokenizer.code(N)) {
              N = N.substring(O.raw.length), V = M[M.length - 1], V && (V.type === "paragraph" || V.type === "text") ? (V.raw += `
` + O.raw, V.text += `
` + O.text, this.inlineQueue[this.inlineQueue.length - 1].src = V.text) : M.push(O);
              continue;
            }
            if (O = this.tokenizer.fences(N)) {
              N = N.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.heading(N)) {
              N = N.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.hr(N)) {
              N = N.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.blockquote(N)) {
              N = N.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.list(N)) {
              N = N.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.html(N)) {
              N = N.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.def(N)) {
              N = N.substring(O.raw.length), V = M[M.length - 1], V && (V.type === "paragraph" || V.type === "text") ? (V.raw += `
` + O.raw, V.text += `
` + O.raw, this.inlineQueue[this.inlineQueue.length - 1].src = V.text) : this.tokens.links[O.tag] || (this.tokens.links[O.tag] = {
                href: O.href,
                title: O.title
              });
              continue;
            }
            if (O = this.tokenizer.table(N)) {
              N = N.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.lheading(N)) {
              N = N.substring(O.raw.length), M.push(O);
              continue;
            }
            if (G = N, this.options.extensions && this.options.extensions.startBlock) {
              let Q = 1 / 0;
              const ue = N.slice(1);
              let me;
              this.options.extensions.startBlock.forEach((We) => {
                me = We.call({ lexer: this }, ue), typeof me == "number" && me >= 0 && (Q = Math.min(Q, me));
              }), Q < 1 / 0 && Q >= 0 && (G = N.substring(0, Q + 1));
            }
            if (this.state.top && (O = this.tokenizer.paragraph(G))) {
              V = M[M.length - 1], R && (V == null ? void 0 : V.type) === "paragraph" ? (V.raw += `
` + O.raw, V.text += `
` + O.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = V.text) : M.push(O), R = G.length !== N.length, N = N.substring(O.raw.length);
              continue;
            }
            if (O = this.tokenizer.text(N)) {
              N = N.substring(O.raw.length), V = M[M.length - 1], V && V.type === "text" ? (V.raw += `
` + O.raw, V.text += `
` + O.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = V.text) : M.push(O);
              continue;
            }
            if (N) {
              const Q = "Infinite loop on byte: " + N.charCodeAt(0);
              if (this.options.silent) {
                console.error(Q);
                break;
              } else
                throw new Error(Q);
            }
          }
        return this.state.top = !0, M;
      }
      inline(N, M = []) {
        return this.inlineQueue.push({ src: N, tokens: M }), M;
      }
      /**
       * Lexing/Compiling
       */
      inlineTokens(N, M = []) {
        let R, O, V, G = N, Q, ue, me;
        if (this.tokens.links) {
          const We = Object.keys(this.tokens.links);
          if (We.length > 0)
            for (; (Q = this.tokenizer.rules.inline.reflinkSearch.exec(G)) != null; )
              We.includes(Q[0].slice(Q[0].lastIndexOf("[") + 1, -1)) && (G = G.slice(0, Q.index) + "[" + "a".repeat(Q[0].length - 2) + "]" + G.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
        }
        for (; (Q = this.tokenizer.rules.inline.blockSkip.exec(G)) != null; )
          G = G.slice(0, Q.index) + "[" + "a".repeat(Q[0].length - 2) + "]" + G.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        for (; (Q = this.tokenizer.rules.inline.anyPunctuation.exec(G)) != null; )
          G = G.slice(0, Q.index) + "++" + G.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
        for (; N; )
          if (ue || (me = ""), ue = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((We) => (R = We.call({ lexer: this }, N, M)) ? (N = N.substring(R.raw.length), M.push(R), !0) : !1))) {
            if (R = this.tokenizer.escape(N)) {
              N = N.substring(R.raw.length), M.push(R);
              continue;
            }
            if (R = this.tokenizer.tag(N)) {
              N = N.substring(R.raw.length), O = M[M.length - 1], O && R.type === "text" && O.type === "text" ? (O.raw += R.raw, O.text += R.text) : M.push(R);
              continue;
            }
            if (R = this.tokenizer.link(N)) {
              N = N.substring(R.raw.length), M.push(R);
              continue;
            }
            if (R = this.tokenizer.reflink(N, this.tokens.links)) {
              N = N.substring(R.raw.length), O = M[M.length - 1], O && R.type === "text" && O.type === "text" ? (O.raw += R.raw, O.text += R.text) : M.push(R);
              continue;
            }
            if (R = this.tokenizer.emStrong(N, G, me)) {
              N = N.substring(R.raw.length), M.push(R);
              continue;
            }
            if (R = this.tokenizer.codespan(N)) {
              N = N.substring(R.raw.length), M.push(R);
              continue;
            }
            if (R = this.tokenizer.br(N)) {
              N = N.substring(R.raw.length), M.push(R);
              continue;
            }
            if (R = this.tokenizer.del(N)) {
              N = N.substring(R.raw.length), M.push(R);
              continue;
            }
            if (R = this.tokenizer.autolink(N)) {
              N = N.substring(R.raw.length), M.push(R);
              continue;
            }
            if (!this.state.inLink && (R = this.tokenizer.url(N))) {
              N = N.substring(R.raw.length), M.push(R);
              continue;
            }
            if (V = N, this.options.extensions && this.options.extensions.startInline) {
              let We = 1 / 0;
              const dt = N.slice(1);
              let mt;
              this.options.extensions.startInline.forEach(($t) => {
                mt = $t.call({ lexer: this }, dt), typeof mt == "number" && mt >= 0 && (We = Math.min(We, mt));
              }), We < 1 / 0 && We >= 0 && (V = N.substring(0, We + 1));
            }
            if (R = this.tokenizer.inlineText(V)) {
              N = N.substring(R.raw.length), R.raw.slice(-1) !== "_" && (me = R.raw.slice(-1)), ue = !0, O = M[M.length - 1], O && O.type === "text" ? (O.raw += R.raw, O.text += R.text) : M.push(R);
              continue;
            }
            if (N) {
              const We = "Infinite loop on byte: " + N.charCodeAt(0);
              if (this.options.silent) {
                console.error(We);
                break;
              } else
                throw new Error(We);
            }
          }
        return M;
      }
    }
    class rr {
      // set by the parser
      constructor(N) {
        rt(this, "options");
        rt(this, "parser");
        this.options = N || e.defaults;
      }
      space(N) {
        return "";
      }
      code({ text: N, lang: M, escaped: R }) {
        var G;
        const O = (G = (M || "").match(/^\S*/)) == null ? void 0 : G[0], V = N.replace(/\n$/, "") + `
`;
        return O ? '<pre><code class="language-' + h(O) + '">' + (R ? V : h(V, !0)) + `</code></pre>
` : "<pre><code>" + (R ? V : h(V, !0)) + `</code></pre>
`;
      }
      blockquote({ tokens: N }) {
        return `<blockquote>
${this.parser.parse(N)}</blockquote>
`;
      }
      html({ text: N }) {
        return N;
      }
      heading({ tokens: N, depth: M }) {
        return `<h${M}>${this.parser.parseInline(N)}</h${M}>
`;
      }
      hr(N) {
        return `<hr>
`;
      }
      list(N) {
        const M = N.ordered, R = N.start;
        let O = "";
        for (let Q = 0; Q < N.items.length; Q++) {
          const ue = N.items[Q];
          O += this.listitem(ue);
        }
        const V = M ? "ol" : "ul", G = M && R !== 1 ? ' start="' + R + '"' : "";
        return "<" + V + G + `>
` + O + "</" + V + `>
`;
      }
      listitem(N) {
        let M = "";
        if (N.task) {
          const R = this.checkbox({ checked: !!N.checked });
          N.loose ? N.tokens.length > 0 && N.tokens[0].type === "paragraph" ? (N.tokens[0].text = R + " " + N.tokens[0].text, N.tokens[0].tokens && N.tokens[0].tokens.length > 0 && N.tokens[0].tokens[0].type === "text" && (N.tokens[0].tokens[0].text = R + " " + N.tokens[0].tokens[0].text)) : N.tokens.unshift({
            type: "text",
            raw: R + " ",
            text: R + " "
          }) : M += R + " ";
        }
        return M += this.parser.parse(N.tokens, !!N.loose), `<li>${M}</li>
`;
      }
      checkbox({ checked: N }) {
        return "<input " + (N ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
      }
      paragraph({ tokens: N }) {
        return `<p>${this.parser.parseInline(N)}</p>
`;
      }
      table(N) {
        let M = "", R = "";
        for (let V = 0; V < N.header.length; V++)
          R += this.tablecell(N.header[V]);
        M += this.tablerow({ text: R });
        let O = "";
        for (let V = 0; V < N.rows.length; V++) {
          const G = N.rows[V];
          R = "";
          for (let Q = 0; Q < G.length; Q++)
            R += this.tablecell(G[Q]);
          O += this.tablerow({ text: R });
        }
        return O && (O = `<tbody>${O}</tbody>`), `<table>
<thead>
` + M + `</thead>
` + O + `</table>
`;
      }
      tablerow({ text: N }) {
        return `<tr>
${N}</tr>
`;
      }
      tablecell(N) {
        const M = this.parser.parseInline(N.tokens), R = N.header ? "th" : "td";
        return (N.align ? `<${R} align="${N.align}">` : `<${R}>`) + M + `</${R}>
`;
      }
      /**
       * span level renderer
       */
      strong({ tokens: N }) {
        return `<strong>${this.parser.parseInline(N)}</strong>`;
      }
      em({ tokens: N }) {
        return `<em>${this.parser.parseInline(N)}</em>`;
      }
      codespan({ text: N }) {
        return `<code>${N}</code>`;
      }
      br(N) {
        return "<br>";
      }
      del({ tokens: N }) {
        return `<del>${this.parser.parseInline(N)}</del>`;
      }
      link({ href: N, title: M, tokens: R }) {
        const O = this.parser.parseInline(R), V = f(N);
        if (V === null)
          return O;
        N = V;
        let G = '<a href="' + N + '"';
        return M && (G += ' title="' + M + '"'), G += ">" + O + "</a>", G;
      }
      image({ href: N, title: M, text: R }) {
        const O = f(N);
        if (O === null)
          return R;
        N = O;
        let V = `<img src="${N}" alt="${R}"`;
        return M && (V += ` title="${M}"`), V += ">", V;
      }
      text(N) {
        return "tokens" in N && N.tokens ? this.parser.parseInline(N.tokens) : N.text;
      }
    }
    class Jr {
      // no need for block level renderers
      strong({ text: N }) {
        return N;
      }
      em({ text: N }) {
        return N;
      }
      codespan({ text: N }) {
        return N;
      }
      del({ text: N }) {
        return N;
      }
      html({ text: N }) {
        return N;
      }
      text({ text: N }) {
        return N;
      }
      link({ text: N }) {
        return "" + N;
      }
      image({ text: N }) {
        return "" + N;
      }
      br() {
        return "";
      }
    }
    class xi {
      constructor(N) {
        rt(this, "options");
        rt(this, "renderer");
        rt(this, "textRenderer");
        this.options = N || e.defaults, this.options.renderer = this.options.renderer || new rr(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new Jr();
      }
      /**
       * Static Parse Method
       */
      static parse(N, M) {
        return new xi(M).parse(N);
      }
      /**
       * Static Parse Inline Method
       */
      static parseInline(N, M) {
        return new xi(M).parseInline(N);
      }
      /**
       * Parse Loop
       */
      parse(N, M = !0) {
        let R = "";
        for (let O = 0; O < N.length; O++) {
          const V = N[O];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[V.type]) {
            const Q = V, ue = this.options.extensions.renderers[Q.type].call({ parser: this }, Q);
            if (ue !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(Q.type)) {
              R += ue || "";
              continue;
            }
          }
          const G = V;
          switch (G.type) {
            case "space": {
              R += this.renderer.space(G);
              continue;
            }
            case "hr": {
              R += this.renderer.hr(G);
              continue;
            }
            case "heading": {
              R += this.renderer.heading(G);
              continue;
            }
            case "code": {
              R += this.renderer.code(G);
              continue;
            }
            case "table": {
              R += this.renderer.table(G);
              continue;
            }
            case "blockquote": {
              R += this.renderer.blockquote(G);
              continue;
            }
            case "list": {
              R += this.renderer.list(G);
              continue;
            }
            case "html": {
              R += this.renderer.html(G);
              continue;
            }
            case "paragraph": {
              R += this.renderer.paragraph(G);
              continue;
            }
            case "text": {
              let Q = G, ue = this.renderer.text(Q);
              for (; O + 1 < N.length && N[O + 1].type === "text"; )
                Q = N[++O], ue += `
` + this.renderer.text(Q);
              M ? R += this.renderer.paragraph({
                type: "paragraph",
                raw: ue,
                text: ue,
                tokens: [{ type: "text", raw: ue, text: ue }]
              }) : R += ue;
              continue;
            }
            default: {
              const Q = 'Token with "' + G.type + '" type was not found.';
              if (this.options.silent)
                return console.error(Q), "";
              throw new Error(Q);
            }
          }
        }
        return R;
      }
      /**
       * Parse Inline Tokens
       */
      parseInline(N, M) {
        M = M || this.renderer;
        let R = "";
        for (let O = 0; O < N.length; O++) {
          const V = N[O];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[V.type]) {
            const Q = this.options.extensions.renderers[V.type].call({ parser: this }, V);
            if (Q !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(V.type)) {
              R += Q || "";
              continue;
            }
          }
          const G = V;
          switch (G.type) {
            case "escape": {
              R += M.text(G);
              break;
            }
            case "html": {
              R += M.html(G);
              break;
            }
            case "link": {
              R += M.link(G);
              break;
            }
            case "image": {
              R += M.image(G);
              break;
            }
            case "strong": {
              R += M.strong(G);
              break;
            }
            case "em": {
              R += M.em(G);
              break;
            }
            case "codespan": {
              R += M.codespan(G);
              break;
            }
            case "br": {
              R += M.br(G);
              break;
            }
            case "del": {
              R += M.del(G);
              break;
            }
            case "text": {
              R += M.text(G);
              break;
            }
            default: {
              const Q = 'Token with "' + G.type + '" type was not found.';
              if (this.options.silent)
                return console.error(Q), "";
              throw new Error(Q);
            }
          }
        }
        return R;
      }
    }
    class Ds {
      constructor(N) {
        rt(this, "options");
        this.options = N || e.defaults;
      }
      /**
       * Process markdown before marked
       */
      preprocess(N) {
        return N;
      }
      /**
       * Process HTML after marked is finished
       */
      postprocess(N) {
        return N;
      }
      /**
       * Process all tokens before walk tokens
       */
      processAllTokens(N) {
        return N;
      }
    }
    rt(Ds, "passThroughHooks", /* @__PURE__ */ new Set([
      "preprocess",
      "postprocess",
      "processAllTokens"
    ]));
    class xd {
      constructor(...N) {
        rt(this, "defaults", t());
        rt(this, "options", this.setOptions);
        rt(this, "parse", this.parseMarkdown(ls.lex, xi.parse));
        rt(this, "parseInline", this.parseMarkdown(ls.lexInline, xi.parseInline));
        rt(this, "Parser", xi);
        rt(this, "Renderer", rr);
        rt(this, "TextRenderer", Jr);
        rt(this, "Lexer", ls);
        rt(this, "Tokenizer", v);
        rt(this, "Hooks", Ds);
        this.use(...N);
      }
      /**
       * Run callback for every token
       */
      walkTokens(N, M) {
        var O, V;
        let R = [];
        for (const G of N)
          switch (R = R.concat(M.call(this, G)), G.type) {
            case "table": {
              const Q = G;
              for (const ue of Q.header)
                R = R.concat(this.walkTokens(ue.tokens, M));
              for (const ue of Q.rows)
                for (const me of ue)
                  R = R.concat(this.walkTokens(me.tokens, M));
              break;
            }
            case "list": {
              const Q = G;
              R = R.concat(this.walkTokens(Q.items, M));
              break;
            }
            default: {
              const Q = G;
              (V = (O = this.defaults.extensions) == null ? void 0 : O.childTokens) != null && V[Q.type] ? this.defaults.extensions.childTokens[Q.type].forEach((ue) => {
                const me = Q[ue].flat(1 / 0);
                R = R.concat(this.walkTokens(me, M));
              }) : Q.tokens && (R = R.concat(this.walkTokens(Q.tokens, M)));
            }
          }
        return R;
      }
      use(...N) {
        const M = this.defaults.extensions || { renderers: {}, childTokens: {} };
        return N.forEach((R) => {
          const O = { ...R };
          if (O.async = this.defaults.async || O.async || !1, R.extensions && (R.extensions.forEach((V) => {
            if (!V.name)
              throw new Error("extension name required");
            if ("renderer" in V) {
              const G = M.renderers[V.name];
              G ? M.renderers[V.name] = function(...Q) {
                let ue = V.renderer.apply(this, Q);
                return ue === !1 && (ue = G.apply(this, Q)), ue;
              } : M.renderers[V.name] = V.renderer;
            }
            if ("tokenizer" in V) {
              if (!V.level || V.level !== "block" && V.level !== "inline")
                throw new Error("extension level must be 'block' or 'inline'");
              const G = M[V.level];
              G ? G.unshift(V.tokenizer) : M[V.level] = [V.tokenizer], V.start && (V.level === "block" ? M.startBlock ? M.startBlock.push(V.start) : M.startBlock = [V.start] : V.level === "inline" && (M.startInline ? M.startInline.push(V.start) : M.startInline = [V.start]));
            }
            "childTokens" in V && V.childTokens && (M.childTokens[V.name] = V.childTokens);
          }), O.extensions = M), R.renderer) {
            const V = this.defaults.renderer || new rr(this.defaults);
            for (const G in R.renderer) {
              if (!(G in V))
                throw new Error(`renderer '${G}' does not exist`);
              if (["options", "parser"].includes(G))
                continue;
              const Q = G, ue = R.renderer[Q], me = V[Q];
              V[Q] = (...We) => {
                let dt = ue.apply(V, We);
                return dt === !1 && (dt = me.apply(V, We)), dt || "";
              };
            }
            O.renderer = V;
          }
          if (R.tokenizer) {
            const V = this.defaults.tokenizer || new v(this.defaults);
            for (const G in R.tokenizer) {
              if (!(G in V))
                throw new Error(`tokenizer '${G}' does not exist`);
              if (["options", "rules", "lexer"].includes(G))
                continue;
              const Q = G, ue = R.tokenizer[Q], me = V[Q];
              V[Q] = (...We) => {
                let dt = ue.apply(V, We);
                return dt === !1 && (dt = me.apply(V, We)), dt;
              };
            }
            O.tokenizer = V;
          }
          if (R.hooks) {
            const V = this.defaults.hooks || new Ds();
            for (const G in R.hooks) {
              if (!(G in V))
                throw new Error(`hook '${G}' does not exist`);
              if (G === "options")
                continue;
              const Q = G, ue = R.hooks[Q], me = V[Q];
              Ds.passThroughHooks.has(G) ? V[Q] = (We) => {
                if (this.defaults.async)
                  return Promise.resolve(ue.call(V, We)).then((mt) => me.call(V, mt));
                const dt = ue.call(V, We);
                return me.call(V, dt);
              } : V[Q] = (...We) => {
                let dt = ue.apply(V, We);
                return dt === !1 && (dt = me.apply(V, We)), dt;
              };
            }
            O.hooks = V;
          }
          if (R.walkTokens) {
            const V = this.defaults.walkTokens, G = R.walkTokens;
            O.walkTokens = function(Q) {
              let ue = [];
              return ue.push(G.call(this, Q)), V && (ue = ue.concat(V.call(this, Q))), ue;
            };
          }
          this.defaults = { ...this.defaults, ...O };
        }), this;
      }
      setOptions(N) {
        return this.defaults = { ...this.defaults, ...N }, this;
      }
      lexer(N, M) {
        return ls.lex(N, M ?? this.defaults);
      }
      parser(N, M) {
        return xi.parse(N, M ?? this.defaults);
      }
      parseMarkdown(N, M) {
        return (O, V) => {
          const G = { ...V }, Q = { ...this.defaults, ...G }, ue = this.onError(!!Q.silent, !!Q.async);
          if (this.defaults.async === !0 && G.async === !1)
            return ue(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
          if (typeof O > "u" || O === null)
            return ue(new Error("marked(): input parameter is undefined or null"));
          if (typeof O != "string")
            return ue(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(O) + ", string expected"));
          if (Q.hooks && (Q.hooks.options = Q), Q.async)
            return Promise.resolve(Q.hooks ? Q.hooks.preprocess(O) : O).then((me) => N(me, Q)).then((me) => Q.hooks ? Q.hooks.processAllTokens(me) : me).then((me) => Q.walkTokens ? Promise.all(this.walkTokens(me, Q.walkTokens)).then(() => me) : me).then((me) => M(me, Q)).then((me) => Q.hooks ? Q.hooks.postprocess(me) : me).catch(ue);
          try {
            Q.hooks && (O = Q.hooks.preprocess(O));
            let me = N(O, Q);
            Q.hooks && (me = Q.hooks.processAllTokens(me)), Q.walkTokens && this.walkTokens(me, Q.walkTokens);
            let We = M(me, Q);
            return Q.hooks && (We = Q.hooks.postprocess(We)), We;
          } catch (me) {
            return ue(me);
          }
        };
      }
      onError(N, M) {
        return (R) => {
          if (R.message += `
Please report this to https://github.com/markedjs/marked.`, N) {
            const O = "<p>An error occurred:</p><pre>" + h(R.message + "", !0) + "</pre>";
            return M ? Promise.resolve(O) : O;
          }
          if (M)
            return Promise.reject(R);
          throw R;
        };
      }
    }
    const So = new xd();
    function Mt(je, N) {
      return So.parse(je, N);
    }
    Mt.options = Mt.setOptions = function(je) {
      return So.setOptions(je), Mt.defaults = So.defaults, i(Mt.defaults), Mt;
    }, Mt.getDefaults = t, Mt.defaults = e.defaults, Mt.use = function(...je) {
      return So.use(...je), Mt.defaults = So.defaults, i(Mt.defaults), Mt;
    }, Mt.walkTokens = function(je, N) {
      return So.walkTokens(je, N);
    }, Mt.parseInline = So.parseInline, Mt.Parser = xi, Mt.parser = xi.parse, Mt.Renderer = rr, Mt.TextRenderer = Jr, Mt.Lexer = ls, Mt.lexer = ls.lex, Mt.Tokenizer = v, Mt.Hooks = Ds, Mt.parse = Mt;
    const hc = Mt.options, Xw = Mt.setOptions, Qw = Mt.use, Ri = Mt.walkTokens, nl = Mt.parseInline, Jw = Mt, e_ = xi.parse, $f = ls.lex;
    e.Hooks = Ds, e.Lexer = ls, e.Marked = xd, e.Parser = xi, e.Renderer = rr, e.TextRenderer = Jr, e.Tokenizer = v, e.getDefaults = t, e.lexer = $f, e.marked = Mt, e.options = hc, e.parse = Jw, e.parseInline = nl, e.parser = e_, e.setOptions = Xw, e.use = Qw, e.walkTokens = Ri;
  });
})();
Xi.Hooks || exports.Hooks;
Xi.Lexer || exports.Lexer;
Xi.Marked || exports.Marked;
Xi.Parser || exports.Parser;
var mO = Xi.Renderer || exports.Renderer;
Xi.TextRenderer || exports.TextRenderer;
Xi.Tokenizer || exports.Tokenizer;
var bW = Xi.defaults || exports.defaults;
Xi.getDefaults || exports.getDefaults;
var nw = Xi.lexer || exports.lexer;
Xi.marked || exports.marked;
Xi.options || exports.options;
var pO = Xi.parse || exports.parse;
Xi.parseInline || exports.parseInline;
var CW = Xi.parser || exports.parser;
Xi.setOptions || exports.setOptions;
Xi.use || exports.use;
Xi.walkTokens || exports.walkTokens;
const Y2 = typeof Buffer < "u";
let L0;
class KE {
  /**
   * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
   * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
   * which is not transferrable.
   */
  static wrap(e) {
    return Y2 && !Buffer.isBuffer(e) && (e = Buffer.from(e.buffer, e.byteOffset, e.byteLength)), new KE(e);
  }
  constructor(e) {
    this.buffer = e, this.byteLength = this.buffer.byteLength;
  }
  toString() {
    return Y2 ? this.buffer.toString() : (L0 || (L0 = new TextDecoder()), L0.decode(this.buffer));
  }
}
function vW(s, e) {
  return s[e + 0] << 0 >>> 0 | s[e + 1] << 8 >>> 0;
}
function wW(s, e, t) {
  s[t + 0] = e & 255, e = e >>> 8, s[t + 1] = e & 255;
}
function Ro(s, e) {
  return s[e] * 2 ** 24 + s[e + 1] * 2 ** 16 + s[e + 2] * 2 ** 8 + s[e + 3];
}
function Ao(s, e, t) {
  s[t + 3] = e, e = e >>> 8, s[t + 2] = e, e = e >>> 8, s[t + 1] = e, e = e >>> 8, s[t] = e;
}
function X2(s, e) {
  return s[e];
}
function Q2(s, e, t) {
  s[t] = e;
}
function yW(s) {
  return JSON.stringify(s, SW);
}
function hS(s) {
  let e = JSON.parse(s);
  return e = dS(e), e;
}
function SW(s, e) {
  return e instanceof RegExp ? {
    $mid: 2,
    source: e.source,
    flags: e.flags
  } : e;
}
function dS(s, e = 0) {
  if (!s || e > 200)
    return s;
  if (typeof s == "object") {
    switch (s.$mid) {
      case 1:
        return we.revive(s);
      case 2:
        return new RegExp(s.source, s.flags);
      case 17:
        return new Date(s.source);
    }
    if (s instanceof KE || s instanceof Uint8Array)
      return s;
    if (Array.isArray(s))
      for (let t = 0; t < s.length; ++t)
        s[t] = dS(s[t], e + 1);
    else
      for (const t in s)
        Object.hasOwnProperty.call(s, t) && (s[t] = dS(s[t], e + 1));
  }
  return s;
}
function pa(s) {
  if (!s || typeof s != "object" || s instanceof RegExp)
    return s;
  const e = Array.isArray(s) ? [] : {};
  return Object.entries(s).forEach(([t, i]) => {
    e[t] = i && typeof i == "object" ? pa(i) : i;
  }), e;
}
function LW(s) {
  if (!s || typeof s != "object")
    return s;
  const e = [s];
  for (; e.length > 0; ) {
    const t = e.shift();
    Object.freeze(t);
    for (const i in t)
      if (_O.call(t, i)) {
        const n = t[i];
        typeof n == "object" && !Object.isFrozen(n) && !o8(n) && e.push(n);
      }
  }
  return s;
}
const _O = Object.prototype.hasOwnProperty;
function bO(s, e) {
  return uS(s, e, /* @__PURE__ */ new Set());
}
function uS(s, e, t) {
  if (ms(s))
    return s;
  const i = e(s);
  if (typeof i < "u")
    return i;
  if (Array.isArray(s)) {
    const n = [];
    for (const o of s)
      n.push(uS(o, e, t));
    return n;
  }
  if (Wi(s)) {
    if (t.has(s))
      throw new Error("Cannot clone recursive data-structure");
    t.add(s);
    const n = {};
    for (const o in s)
      _O.call(s, o) && (n[o] = uS(s[o], e, t));
    return t.delete(s), n;
  }
  return s;
}
function sw(s, e, t = !0) {
  return Wi(s) ? (Wi(e) && Object.keys(e).forEach((i) => {
    i in s ? t && (Wi(s[i]) && Wi(e[i]) ? sw(s[i], e[i], t) : s[i] = e[i]) : s[i] = e[i];
  }), s) : e;
}
function Xn(s, e) {
  if (s === e)
    return !0;
  if (s == null || e === null || e === void 0 || typeof s != typeof e || typeof s != "object" || Array.isArray(s) !== Array.isArray(e))
    return !1;
  let t, i;
  if (Array.isArray(s)) {
    if (s.length !== e.length)
      return !1;
    for (t = 0; t < s.length; t++)
      if (!Xn(s[t], e[t]))
        return !1;
  } else {
    const n = [];
    for (i in s)
      n.push(i);
    n.sort();
    const o = [];
    for (i in e)
      o.push(i);
    if (o.sort(), !Xn(n, o))
      return !1;
    for (t = 0; t < n.length; t++)
      if (!Xn(s[n[t]], e[n[t]]))
        return !1;
  }
  return !0;
}
function kW(s) {
  let e = [];
  for (; Object.prototype !== s; )
    e = e.concat(Object.getOwnPropertyNames(s)), s = Object.getPrototypeOf(s);
  return e;
}
function fS(s) {
  const e = [];
  for (const t of kW(s))
    typeof s[t] == "function" && e.push(t);
  return e;
}
function xW(s, e) {
  const t = (n) => function() {
    const o = Array.prototype.slice.call(arguments, 0);
    return e(n, o);
  }, i = {};
  for (const n of s)
    i[n] = t(n);
  return i;
}
const k0 = Object.freeze({
  image: ({ href: s, title: e, text: t }) => {
    let i = [], n = [];
    return s && ({ href: s, dimensions: i } = qB(s), n.push(`src="${h_(s)}"`)), t && n.push(`alt="${h_(t)}"`), e && n.push(`title="${h_(e)}"`), i.length && (n = n.concat(i)), "<img " + n.join(" ") + ">";
  },
  paragraph({ tokens: s }) {
    return `<p>${this.parser.parseInline(s)}</p>`;
  },
  link({ href: s, title: e, tokens: t }) {
    let i = this.parser.parseInline(t);
    return typeof s != "string" ? "" : (s === i && (i = w0(i)), e = typeof e == "string" ? h_(w0(e)) : "", s = w0(s), s = s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;"), `<a href="${s}" title="${e || s}" draggable="false">${i}</a>`);
  }
});
function ow(s, e = {}, t = {}) {
  const i = new ne();
  let n = !1;
  const o = UE(e), r = function(p) {
    let _;
    try {
      _ = hS(decodeURIComponent(p));
    } catch {
    }
    return _ ? (_ = bO(_, (b) => {
      if (s.uris && s.uris[b])
        return we.revive(s.uris[b]);
    }), encodeURIComponent(JSON.stringify(_))) : p;
  }, a = function(p, _) {
    const b = s.uris && s.uris[p];
    let C = we.revive(b);
    return _ ? p.startsWith(Ie.data + ":") ? p : (C || (C = we.parse(p)), Yv.uriToBrowserUri(C).toString(!0)) : !C || we.parse(p).toString() === C.toString() ? p : (C.query && (C = C.with({ query: r(C.query) })), C.toString());
  }, l = new mO();
  l.image = k0.image, l.link = k0.link, l.paragraph = k0.paragraph;
  const c = [], h = [];
  if (e.codeBlockRendererSync ? l.code = ({ text: p, lang: _ }) => {
    const b = cS.nextId(), C = e.codeBlockRendererSync(J2(_), p);
    return h.push([b, C]), `<div class="code" data-code="${b}">${Ng(p)}</div>`;
  } : e.codeBlockRenderer && (l.code = ({ text: p, lang: _ }) => {
    const b = cS.nextId(), C = e.codeBlockRenderer(J2(_), p);
    return c.push(C.then((w) => [b, w])), `<div class="code" data-code="${b}">${Ng(p)}</div>`;
  }), e.actionHandler) {
    const p = function(C) {
      let w = C.target;
      if (!(w.tagName !== "A" && (w = w.parentElement, !w || w.tagName !== "A")))
        try {
          let v = w.dataset.href;
          v && (s.baseUri && (v = x0(we.from(s.baseUri), v)), e.actionHandler.callback(v, C));
        } catch (v) {
          Je(v);
        } finally {
          C.preventDefault();
        }
    }, _ = e.actionHandler.disposables.add(new He(o, "click")), b = e.actionHandler.disposables.add(new He(o, "auxclick"));
    e.actionHandler.disposables.add(ee.any(_.event, b.event)((C) => {
      const w = new Uo(fe(o), C);
      !w.leftButton && !w.middleButton || p(w);
    })), e.actionHandler.disposables.add(z(o, "keydown", (C) => {
      const w = new Dt(C);
      !w.equals(
        10
        /* KeyCode.Space */
      ) && !w.equals(
        3
        /* KeyCode.Enter */
      ) || p(w);
    }));
  }
  s.supportHtml || (l.html = ({ text: p }) => {
    var b;
    return (b = e.sanitizerOptions) != null && b.replaceWithPlaintext ? Ng(p) : (s.isTrusted ? p.match(/^(<span[^>]+>)|(<\/\s*span>)$/) : void 0) ? p : "";
  }), t.renderer = l;
  let d = s.value ?? "";
  d.length > 1e5 && (d = `${d.substr(0, 1e5)}…`), s.supportThemeIcons && (d = OB(d));
  let u;
  if (e.fillInIncompleteTokens) {
    const p = {
      ...bW,
      ...t
    }, _ = nw(d, p), b = WW(_);
    u = CW(b, p);
  } else
    u = pO(d, { ...t, async: !1 });
  s.supportThemeIcons && (u = lh(u).map((_) => typeof _ == "string" ? _ : _.outerHTML).join(""));
  const g = new DOMParser().parseFromString(gS({ isTrusted: s.isTrusted, ...e.sanitizerOptions }, u), "text/html");
  if (g.body.querySelectorAll("img, audio, video, source").forEach((p) => {
    const _ = p.getAttribute("src");
    if (_) {
      let b = _;
      try {
        s.baseUri && (b = x0(we.from(s.baseUri), b));
      } catch {
      }
      if (p.setAttribute("src", a(b, !0)), e.remoteImageIsAllowed) {
        const C = we.parse(b);
        C.scheme !== Ie.file && C.scheme !== Ie.data && !e.remoteImageIsAllowed(C) && p.replaceWith(he("", void 0, p.outerHTML));
      }
    }
  }), g.body.querySelectorAll("a").forEach((p) => {
    const _ = p.getAttribute("href");
    if (p.setAttribute("href", ""), !_ || /^data:|javascript:/i.test(_) || /^command:/i.test(_) && !s.isTrusted || /^command:(\/\/\/)?_workbench\.downloadResource/i.test(_))
      p.replaceWith(...p.childNodes);
    else {
      let b = a(_, !1);
      s.baseUri && (b = x0(we.from(s.baseUri), _)), p.dataset.href = b;
    }
  }), o.innerHTML = gS({ isTrusted: s.isTrusted, ...e.sanitizerOptions }, g.body.innerHTML), c.length > 0)
    Promise.all(c).then((p) => {
      var C;
      if (n)
        return;
      const _ = new Map(p), b = o.querySelectorAll("div[data-code]");
      for (const w of b) {
        const v = _.get(w.dataset.code ?? "");
        v && _n(w, v);
      }
      (C = e.asyncRenderCallback) == null || C.call(e);
    });
  else if (h.length > 0) {
    const p = new Map(h), _ = o.querySelectorAll("div[data-code]");
    for (const b of _) {
      const C = p.get(b.dataset.code ?? "");
      C && _n(b, C);
    }
  }
  if (e.asyncRenderCallback)
    for (const p of o.getElementsByTagName("img")) {
      const _ = i.add(z(p, "load", () => {
        _.dispose(), e.asyncRenderCallback();
      }));
    }
  return {
    element: o,
    dispose: () => {
      n = !0, i.dispose();
    }
  };
}
function J2(s) {
  if (!s)
    return "";
  const e = s.split(/[\s+|:|,|\{|\?]/, 1);
  return e.length ? e[0] : s;
}
function x0(s, e) {
  return /^\w[\w\d+.-]*:/.test(e) ? e : s.path.endsWith("/") ? z2(s, e).toString() : z2(BE(s), e).toString();
}
const DW = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
function gS(s, e) {
  const { config: t, allowedSchemes: i } = IW(s), n = new ne();
  n.add(eT("uponSanitizeAttribute", (o, r) => {
    var a;
    if (r.attrName === "style" || r.attrName === "class") {
      if (o.tagName === "SPAN") {
        if (r.attrName === "style") {
          r.keepAttr = /^(color\:(#[0-9a-fA-F]+|var\(--vscode(-[a-zA-Z]+)+\));)?(background-color\:(#[0-9a-fA-F]+|var\(--vscode(-[a-zA-Z]+)+\));)?(border-radius:[0-9]+px;)?$/.test(r.attrValue);
          return;
        } else if (r.attrName === "class") {
          r.keepAttr = /^codicon codicon-[a-z\-]+( codicon-modifier-[a-z\-]+)?$/.test(r.attrValue);
          return;
        }
      }
      r.keepAttr = !1;
      return;
    } else if (o.tagName === "INPUT" && ((a = o.attributes.getNamedItem("type")) == null ? void 0 : a.value) === "checkbox") {
      if (r.attrName === "type" && r.attrValue === "checkbox" || r.attrName === "disabled" || r.attrName === "checked") {
        r.keepAttr = !0;
        return;
      }
      r.keepAttr = !1;
    }
  })), n.add(eT("uponSanitizeElement", (o, r) => {
    var a;
    if (r.tagName === "input" && (((a = o.attributes.getNamedItem("type")) == null ? void 0 : a.value) === "checkbox" ? o.setAttribute("disabled", "") : s.replaceWithPlaintext || o.remove()), s.replaceWithPlaintext && !r.allowedTags[r.tagName] && r.tagName !== "body" && o.parentElement) {
      let l, c;
      if (r.tagName === "#comment")
        l = `<!--${o.textContent}-->`;
      else {
        const f = DW.includes(r.tagName), g = o.attributes.length ? " " + Array.from(o.attributes).map((p) => `${p.name}="${p.value}"`).join(" ") : "";
        l = `<${r.tagName}${g}>`, f || (c = `</${r.tagName}>`);
      }
      const h = document.createDocumentFragment(), d = o.parentElement.ownerDocument.createTextNode(l);
      h.appendChild(d);
      const u = c ? o.parentElement.ownerDocument.createTextNode(c) : void 0;
      for (; o.firstChild; )
        h.appendChild(o.firstChild);
      u && h.appendChild(u), o.nodeType === Node.COMMENT_NODE ? o.parentElement.insertBefore(h, o) : o.parentElement.replaceChild(h, o);
    }
  })), n.add(rB(i));
  try {
    return N4(e, { ...t, RETURN_TRUSTED_TYPE: !0 });
  } finally {
    n.dispose();
  }
}
const EW = [
  "align",
  "autoplay",
  "alt",
  "checked",
  "class",
  "colspan",
  "controls",
  "data-code",
  "data-href",
  "disabled",
  "draggable",
  "height",
  "href",
  "loop",
  "muted",
  "playsinline",
  "poster",
  "rowspan",
  "src",
  "style",
  "target",
  "title",
  "type",
  "width",
  "start"
];
function IW(s) {
  const e = [
    Ie.http,
    Ie.https,
    Ie.mailto,
    Ie.data,
    Ie.file,
    Ie.vscodeFileResource,
    Ie.vscodeRemote,
    Ie.vscodeRemoteResource
  ];
  return s.isTrusted && e.push(Ie.command), {
    config: {
      // allowedTags should included everything that markdown renders to.
      // Since we have our own sanitize function for marked, it's possible we missed some tag so let dompurify make sure.
      // HTML tags that can result from markdown are from reading https://spec.commonmark.org/0.29/
      // HTML table tags that can result from markdown are from https://github.github.com/gfm/#tables-extension-
      ALLOWED_TAGS: s.allowedTags ?? [...aB],
      ALLOWED_ATTR: EW,
      ALLOW_UNKNOWN_PROTOCOLS: !0
    },
    allowedSchemes: e
  };
}
function NW(s) {
  return typeof s == "string" ? s : TW(s);
}
function TW(s, e) {
  let t = s.value ?? "";
  t.length > 1e5 && (t = `${t.substr(0, 1e5)}…`);
  const i = pO(t, { async: !1, renderer: AW.value }).replace(/&(#\d+|[a-zA-Z]+);/g, (n) => MW.get(n) ?? n);
  return gS({ isTrusted: !1 }, i).toString();
}
const MW = /* @__PURE__ */ new Map([
  ["&quot;", '"'],
  ["&nbsp;", " "],
  ["&amp;", "&"],
  ["&#39;", "'"],
  ["&lt;", "<"],
  ["&gt;", ">"]
]);
function RW() {
  const s = new mO();
  return s.code = ({ text: e }) => e, s.blockquote = ({ text: e }) => e + `
`, s.html = (e) => "", s.heading = function({ tokens: e }) {
    return this.parser.parseInline(e) + `
`;
  }, s.hr = () => "", s.list = function({ items: e }) {
    return e.map((t) => this.listitem(t)).join(`
`) + `
`;
  }, s.listitem = ({ text: e }) => e + `
`, s.paragraph = function({ tokens: e }) {
    return this.parser.parseInline(e) + `
`;
  }, s.table = function({ header: e, rows: t }) {
    return e.map((i) => this.tablecell(i)).join(" ") + `
` + t.map((i) => i.map((n) => this.tablecell(n)).join(" ")).join(`
`) + `
`;
  }, s.tablerow = ({ text: e }) => e, s.tablecell = function({ tokens: e }) {
    return this.parser.parseInline(e);
  }, s.strong = ({ text: e }) => e, s.em = ({ text: e }) => e, s.codespan = ({ text: e }) => e, s.br = (e) => `
`, s.del = ({ text: e }) => e, s.image = (e) => "", s.text = ({ text: e }) => e, s.link = ({ text: e }) => e, s;
}
const AW = new Fr((s) => RW());
function Jb(s) {
  let e = "";
  return s.forEach((t) => {
    e += t.raw;
  }), e;
}
function CO(s) {
  var e, t;
  if (s.tokens)
    for (let i = s.tokens.length - 1; i >= 0; i--) {
      const n = s.tokens[i];
      if (n.type === "text") {
        const o = n.raw.split(`
`), r = o[o.length - 1];
        if (r.includes("`"))
          return VW(s);
        if (r.includes("**"))
          return qW(s);
        if (r.match(/\*\w/))
          return zW(s);
        if (r.match(/(^|\s)__\w/))
          return GW(s);
        if (r.match(/(^|\s)_\w/))
          return UW(s);
        if (
          // Text with start of link target
          PW(r) || // This token doesn't have the link text, eg if it contains other markdown constructs that are in other subtokens.
          // But some preceding token does have an unbalanced [ at least
          OW(r) && s.tokens.slice(0, i).some((a) => a.type === "text" && a.raw.match(/\[[^\]]*$/))
        ) {
          const a = s.tokens.slice(i + 1);
          return (
            // If the link was parsed as a link, then look for a link token and a text token with a quote
            ((e = a[0]) == null ? void 0 : e.type) === "link" && ((t = a[1]) == null ? void 0 : t.type) === "text" && a[1].raw.match(/^ *"[^"]*$/) || // And if the link was not parsed as a link (eg command link), just look for a single quote in this token
            r.match(/^[^"]* +"[^"]*$/) ? KW(s) : $W(s)
          );
        } else if (r.match(/(^|\s)\[\w*/))
          return jW(s);
      }
    }
}
function PW(s) {
  return !!s.match(/(^|\s)\[.*\]\(\w*/);
}
function OW(s) {
  return !!s.match(/^[^\[]*\]\([^\)]*$/);
}
function FW(s) {
  var l;
  const e = s.items[s.items.length - 1], t = e.tokens ? e.tokens[e.tokens.length - 1] : void 0;
  let i;
  if ((t == null ? void 0 : t.type) === "text" && !("inRawBlock" in e) && (i = CO(t)), !i || i.type !== "paragraph")
    return;
  const n = Jb(s.items.slice(0, -1)), o = (l = e.raw.match(/^(\s*(-|\d+\.|\*) +)/)) == null ? void 0 : l[0];
  if (!o)
    return;
  const r = o + Jb(e.tokens.slice(0, -1)) + i.raw, a = nw(n + r)[0];
  if (a.type === "list")
    return a;
}
const BW = 3;
function WW(s) {
  for (let e = 0; e < BW; e++) {
    const t = HW(s);
    if (t)
      s = t;
    else
      break;
  }
  return s;
}
function HW(s) {
  let e, t;
  for (e = 0; e < s.length; e++) {
    const i = s[e];
    if (i.type === "paragraph" && i.raw.match(/(\n|^)\|/)) {
      t = ZW(s.slice(e));
      break;
    }
    if (e === s.length - 1 && i.type === "list") {
      const n = FW(i);
      if (n) {
        t = [n];
        break;
      }
    }
    if (e === s.length - 1 && i.type === "paragraph") {
      const n = CO(i);
      if (n) {
        t = [n];
        break;
      }
    }
  }
  if (t) {
    const i = [
      ...s.slice(0, e),
      ...t
    ];
    return i.links = s.links, i;
  }
  return null;
}
function VW(s) {
  return nc(s, "`");
}
function zW(s) {
  return nc(s, "*");
}
function UW(s) {
  return nc(s, "_");
}
function $W(s) {
  return nc(s, ")");
}
function KW(s) {
  return nc(s, '")');
}
function jW(s) {
  return nc(s, "](https://microsoft.com)");
}
function qW(s) {
  return nc(s, "**");
}
function GW(s) {
  return nc(s, "__");
}
function nc(s, e) {
  const t = Jb(Array.isArray(s) ? s : [s]);
  return nw(t + e)[0];
}
function ZW(s) {
  const e = Jb(s), t = e.split(`
`);
  let i, n = !1;
  for (let o = 0; o < t.length; o++) {
    const r = t[o].trim();
    if (typeof i > "u" && r.match(/^\s*\|/)) {
      const a = r.match(/(\|[^\|]+)(?=\||$)/g);
      a && (i = a.length);
    } else if (typeof i == "number")
      if (r.match(/^\s*\|/)) {
        if (o !== t.length - 1)
          return;
        n = !0;
      } else
        return;
  }
  if (typeof i == "number" && i > 0) {
    const o = n ? t.slice(0, -1).join(`
`) : e, r = !!o.match(/\|\s*$/), a = o + (r ? "" : "|") + `
|${" --- |".repeat(i)}`;
    return nw(a);
  }
}
function eT(s, e) {
  return T4(s, e), _e(() => M4(s));
}
let vO = {
  showHover: () => {
  },
  hideHover: () => {
  },
  showAndFocusLastHover: () => {
  },
  setupManagedHover: () => null,
  showManagedHover: () => {
  }
};
function YW(s) {
  vO = s;
}
function jr() {
  return vO;
}
const tT = 2e4;
let Ic, nb, mS, sb, pS;
function XW(s) {
  Ic = document.createElement("div"), Ic.className = "monaco-aria-container";
  const e = () => {
    const i = document.createElement("div");
    return i.className = "monaco-alert", i.setAttribute("role", "alert"), i.setAttribute("aria-atomic", "true"), Ic.appendChild(i), i;
  };
  nb = e(), mS = e();
  const t = () => {
    const i = document.createElement("div");
    return i.className = "monaco-status", i.setAttribute("aria-live", "polite"), i.setAttribute("aria-atomic", "true"), Ic.appendChild(i), i;
  };
  sb = t(), pS = t(), s.appendChild(Ic);
}
function Uh(s) {
  Ic && (nb.textContent !== s ? (ks(mS), e1(nb, s)) : (ks(nb), e1(mS, s)));
}
function Rm(s) {
  Ic && (sb.textContent !== s ? (ks(pS), e1(sb, s)) : (ks(sb), e1(pS, s)));
}
function e1(s, e) {
  ks(s), e.length > tT && (e = e.substr(0, tT)), s.textContent = e, s.style.visibility = "hidden", s.style.visibility = "visible";
}
class QW {
  constructor(e) {
    this.spliceables = e;
  }
  splice(e, t, i) {
    this.spliceables.forEach((n) => n.splice(e, t, i));
  }
}
function Ml(s, e) {
  const t = Math.pow(10, e);
  return Math.round(s * t) / t;
}
class ze {
  constructor(e, t, i, n = 1) {
    this._rgbaBrand = void 0, this.r = Math.min(255, Math.max(0, e)) | 0, this.g = Math.min(255, Math.max(0, t)) | 0, this.b = Math.min(255, Math.max(0, i)) | 0, this.a = Ml(Math.max(Math.min(1, n), 0), 3);
  }
  static equals(e, t) {
    return e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a;
  }
}
class to {
  constructor(e, t, i, n) {
    this._hslaBrand = void 0, this.h = Math.max(Math.min(360, e), 0) | 0, this.s = Ml(Math.max(Math.min(1, t), 0), 3), this.l = Ml(Math.max(Math.min(1, i), 0), 3), this.a = Ml(Math.max(Math.min(1, n), 0), 3);
  }
  static equals(e, t) {
    return e.h === t.h && e.s === t.s && e.l === t.l && e.a === t.a;
  }
  /**
   * Converts an RGB color value to HSL. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes r, g, and b are contained in the set [0, 255] and
   * returns h in the set [0, 360], s, and l in the set [0, 1].
   */
  static fromRGBA(e) {
    const t = e.r / 255, i = e.g / 255, n = e.b / 255, o = e.a, r = Math.max(t, i, n), a = Math.min(t, i, n);
    let l = 0, c = 0;
    const h = (a + r) / 2, d = r - a;
    if (d > 0) {
      switch (c = Math.min(h <= 0.5 ? d / (2 * h) : d / (2 - 2 * h), 1), r) {
        case t:
          l = (i - n) / d + (i < n ? 6 : 0);
          break;
        case i:
          l = (n - t) / d + 2;
          break;
        case n:
          l = (t - i) / d + 4;
          break;
      }
      l *= 60, l = Math.round(l);
    }
    return new to(l, c, h, o);
  }
  static _hue2rgb(e, t, i) {
    return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + (t - e) * 6 * i : i < 1 / 2 ? t : i < 2 / 3 ? e + (t - e) * (2 / 3 - i) * 6 : e;
  }
  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   */
  static toRGBA(e) {
    const t = e.h / 360, { s: i, l: n, a: o } = e;
    let r, a, l;
    if (i === 0)
      r = a = l = n;
    else {
      const c = n < 0.5 ? n * (1 + i) : n + i - n * i, h = 2 * n - c;
      r = to._hue2rgb(h, c, t + 1 / 3), a = to._hue2rgb(h, c, t), l = to._hue2rgb(h, c, t - 1 / 3);
    }
    return new ze(Math.round(r * 255), Math.round(a * 255), Math.round(l * 255), o);
  }
}
class Ir {
  constructor(e, t, i, n) {
    this._hsvaBrand = void 0, this.h = Math.max(Math.min(360, e), 0) | 0, this.s = Ml(Math.max(Math.min(1, t), 0), 3), this.v = Ml(Math.max(Math.min(1, i), 0), 3), this.a = Ml(Math.max(Math.min(1, n), 0), 3);
  }
  static equals(e, t) {
    return e.h === t.h && e.s === t.s && e.v === t.v && e.a === t.a;
  }
  // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
  static fromRGBA(e) {
    const t = e.r / 255, i = e.g / 255, n = e.b / 255, o = Math.max(t, i, n), r = Math.min(t, i, n), a = o - r, l = o === 0 ? 0 : a / o;
    let c;
    return a === 0 ? c = 0 : o === t ? c = ((i - n) / a % 6 + 6) % 6 : o === i ? c = (n - t) / a + 2 : c = (t - i) / a + 4, new Ir(Math.round(c * 60), l, o, e.a);
  }
  // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
  static toRGBA(e) {
    const { h: t, s: i, v: n, a: o } = e, r = n * i, a = r * (1 - Math.abs(t / 60 % 2 - 1)), l = n - r;
    let [c, h, d] = [0, 0, 0];
    return t < 60 ? (c = r, h = a) : t < 120 ? (c = a, h = r) : t < 180 ? (h = r, d = a) : t < 240 ? (h = a, d = r) : t < 300 ? (c = a, d = r) : t <= 360 && (c = r, d = a), c = Math.round((c + l) * 255), h = Math.round((h + l) * 255), d = Math.round((d + l) * 255), new ze(c, h, d, o);
  }
}
const Vt = class Vt {
  static fromHex(e) {
    return Vt.Format.CSS.parseHex(e) || Vt.red;
  }
  static equals(e, t) {
    return !e && !t ? !0 : !e || !t ? !1 : e.equals(t);
  }
  get hsla() {
    return this._hsla ? this._hsla : to.fromRGBA(this.rgba);
  }
  get hsva() {
    return this._hsva ? this._hsva : Ir.fromRGBA(this.rgba);
  }
  constructor(e) {
    if (e)
      if (e instanceof ze)
        this.rgba = e;
      else if (e instanceof to)
        this._hsla = e, this.rgba = to.toRGBA(e);
      else if (e instanceof Ir)
        this._hsva = e, this.rgba = Ir.toRGBA(e);
      else
        throw new Error("Invalid color ctor argument");
    else throw new Error("Color needs a value");
  }
  equals(e) {
    return !!e && ze.equals(this.rgba, e.rgba) && to.equals(this.hsla, e.hsla) && Ir.equals(this.hsva, e.hsva);
  }
  /**
   * http://www.w3.org/TR/WCAG20/#relativeluminancedef
   * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
   */
  getRelativeLuminance() {
    const e = Vt._relativeLuminanceForComponent(this.rgba.r), t = Vt._relativeLuminanceForComponent(this.rgba.g), i = Vt._relativeLuminanceForComponent(this.rgba.b), n = 0.2126 * e + 0.7152 * t + 0.0722 * i;
    return Ml(n, 4);
  }
  static _relativeLuminanceForComponent(e) {
    const t = e / 255;
    return t <= 0.03928 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
  }
  /**
   *	http://24ways.org/2010/calculating-color-contrast
   *  Return 'true' if lighter color otherwise 'false'
   */
  isLighter() {
    return (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3 >= 128;
  }
  isLighterThan(e) {
    const t = this.getRelativeLuminance(), i = e.getRelativeLuminance();
    return t > i;
  }
  isDarkerThan(e) {
    const t = this.getRelativeLuminance(), i = e.getRelativeLuminance();
    return t < i;
  }
  lighten(e) {
    return new Vt(new to(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * e, this.hsla.a));
  }
  darken(e) {
    return new Vt(new to(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * e, this.hsla.a));
  }
  transparent(e) {
    const { r: t, g: i, b: n, a: o } = this.rgba;
    return new Vt(new ze(t, i, n, o * e));
  }
  isTransparent() {
    return this.rgba.a === 0;
  }
  isOpaque() {
    return this.rgba.a === 1;
  }
  opposite() {
    return new Vt(new ze(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
  }
  makeOpaque(e) {
    if (this.isOpaque() || e.rgba.a !== 1)
      return this;
    const { r: t, g: i, b: n, a: o } = this.rgba;
    return new Vt(new ze(e.rgba.r - o * (e.rgba.r - t), e.rgba.g - o * (e.rgba.g - i), e.rgba.b - o * (e.rgba.b - n), 1));
  }
  toString() {
    return this._toString || (this._toString = Vt.Format.CSS.format(this)), this._toString;
  }
  static getLighterColor(e, t, i) {
    if (e.isLighterThan(t))
      return e;
    i = i || 0.5;
    const n = e.getRelativeLuminance(), o = t.getRelativeLuminance();
    return i = i * (o - n) / o, e.lighten(i);
  }
  static getDarkerColor(e, t, i) {
    if (e.isDarkerThan(t))
      return e;
    i = i || 0.5;
    const n = e.getRelativeLuminance(), o = t.getRelativeLuminance();
    return i = i * (n - o) / n, e.darken(i);
  }
};
Vt.white = new Vt(new ze(255, 255, 255, 1)), Vt.black = new Vt(new ze(0, 0, 0, 1)), Vt.red = new Vt(new ze(255, 0, 0, 1)), Vt.blue = new Vt(new ze(0, 0, 255, 1)), Vt.green = new Vt(new ze(0, 255, 0, 1)), Vt.cyan = new Vt(new ze(0, 255, 255, 1)), Vt.lightgrey = new Vt(new ze(211, 211, 211, 1)), Vt.transparent = new Vt(new ze(0, 0, 0, 0));
let j = Vt;
(function(s) {
  (function(e) {
    (function(t) {
      function i(f) {
        return f.rgba.a === 1 ? `rgb(${f.rgba.r}, ${f.rgba.g}, ${f.rgba.b})` : s.Format.CSS.formatRGBA(f);
      }
      t.formatRGB = i;
      function n(f) {
        return `rgba(${f.rgba.r}, ${f.rgba.g}, ${f.rgba.b}, ${+f.rgba.a.toFixed(2)})`;
      }
      t.formatRGBA = n;
      function o(f) {
        return f.hsla.a === 1 ? `hsl(${f.hsla.h}, ${(f.hsla.s * 100).toFixed(2)}%, ${(f.hsla.l * 100).toFixed(2)}%)` : s.Format.CSS.formatHSLA(f);
      }
      t.formatHSL = o;
      function r(f) {
        return `hsla(${f.hsla.h}, ${(f.hsla.s * 100).toFixed(2)}%, ${(f.hsla.l * 100).toFixed(2)}%, ${f.hsla.a.toFixed(2)})`;
      }
      t.formatHSLA = r;
      function a(f) {
        const g = f.toString(16);
        return g.length !== 2 ? "0" + g : g;
      }
      function l(f) {
        return `#${a(f.rgba.r)}${a(f.rgba.g)}${a(f.rgba.b)}`;
      }
      t.formatHex = l;
      function c(f, g = !1) {
        return g && f.rgba.a === 1 ? s.Format.CSS.formatHex(f) : `#${a(f.rgba.r)}${a(f.rgba.g)}${a(f.rgba.b)}${a(Math.round(f.rgba.a * 255))}`;
      }
      t.formatHexA = c;
      function h(f) {
        return f.isOpaque() ? s.Format.CSS.formatHex(f) : s.Format.CSS.formatRGBA(f);
      }
      t.format = h;
      function d(f) {
        const g = f.length;
        if (g === 0 || f.charCodeAt(0) !== 35)
          return null;
        if (g === 7) {
          const p = 16 * u(f.charCodeAt(1)) + u(f.charCodeAt(2)), _ = 16 * u(f.charCodeAt(3)) + u(f.charCodeAt(4)), b = 16 * u(f.charCodeAt(5)) + u(f.charCodeAt(6));
          return new s(new ze(p, _, b, 1));
        }
        if (g === 9) {
          const p = 16 * u(f.charCodeAt(1)) + u(f.charCodeAt(2)), _ = 16 * u(f.charCodeAt(3)) + u(f.charCodeAt(4)), b = 16 * u(f.charCodeAt(5)) + u(f.charCodeAt(6)), C = 16 * u(f.charCodeAt(7)) + u(f.charCodeAt(8));
          return new s(new ze(p, _, b, C / 255));
        }
        if (g === 4) {
          const p = u(f.charCodeAt(1)), _ = u(f.charCodeAt(2)), b = u(f.charCodeAt(3));
          return new s(new ze(16 * p + p, 16 * _ + _, 16 * b + b));
        }
        if (g === 5) {
          const p = u(f.charCodeAt(1)), _ = u(f.charCodeAt(2)), b = u(f.charCodeAt(3)), C = u(f.charCodeAt(4));
          return new s(new ze(16 * p + p, 16 * _ + _, 16 * b + b, (16 * C + C) / 255));
        }
        return null;
      }
      t.parseHex = d;
      function u(f) {
        switch (f) {
          case 48:
            return 0;
          case 49:
            return 1;
          case 50:
            return 2;
          case 51:
            return 3;
          case 52:
            return 4;
          case 53:
            return 5;
          case 54:
            return 6;
          case 55:
            return 7;
          case 56:
            return 8;
          case 57:
            return 9;
          case 97:
            return 10;
          case 65:
            return 10;
          case 98:
            return 11;
          case 66:
            return 11;
          case 99:
            return 12;
          case 67:
            return 12;
          case 100:
            return 13;
          case 68:
            return 13;
          case 101:
            return 14;
          case 69:
            return 14;
          case 102:
            return 15;
          case 70:
            return 15;
        }
        return 0;
      }
    })(e.CSS || (e.CSS = {}));
  })(s.Format || (s.Format = {}));
})(j || (j = {}));
function Dn(s, e, t) {
  return Math.min(Math.max(s, e), t);
}
class wO {
  constructor() {
    this._n = 1, this._val = 0;
  }
  update(e) {
    return this._val = this._val + (e - this._val) / this._n, this._n += 1, this._val;
  }
  get value() {
    return this._val;
  }
}
class JW {
  constructor(e) {
    this._n = 0, this._val = 0, this._values = [], this._index = 0, this._sum = 0, this._values = new Array(e), this._values.fill(0, 0, e);
  }
  update(e) {
    const t = this._values[this._index];
    return this._values[this._index] = e, this._index = (this._index + 1) % this._values.length, this._sum -= t, this._sum += e, this._n < this._values.length && (this._n += 1), this._val = this._sum / this._n, this._val;
  }
  get value() {
    return this._val;
  }
}
class uc extends Error {
  constructor(e, t) {
    super(`ListError [${e}] ${t}`);
  }
}
class yO {
  constructor(e) {
    this.domNode = e, this._maxWidth = "", this._width = "", this._height = "", this._top = "", this._left = "", this._bottom = "", this._right = "", this._paddingLeft = "", this._fontFamily = "", this._fontWeight = "", this._fontSize = "", this._fontStyle = "", this._fontFeatureSettings = "", this._fontVariationSettings = "", this._textDecoration = "", this._lineHeight = "", this._letterSpacing = "", this._className = "", this._display = "", this._position = "", this._visibility = "", this._color = "", this._backgroundColor = "", this._layerHint = !1, this._contain = "none", this._boxShadow = "";
  }
  setMaxWidth(e) {
    const t = Lo(e);
    this._maxWidth !== t && (this._maxWidth = t, this.domNode.style.maxWidth = this._maxWidth);
  }
  setWidth(e) {
    const t = Lo(e);
    this._width !== t && (this._width = t, this.domNode.style.width = this._width);
  }
  setHeight(e) {
    const t = Lo(e);
    this._height !== t && (this._height = t, this.domNode.style.height = this._height);
  }
  setTop(e) {
    const t = Lo(e);
    this._top !== t && (this._top = t, this.domNode.style.top = this._top);
  }
  setLeft(e) {
    const t = Lo(e);
    this._left !== t && (this._left = t, this.domNode.style.left = this._left);
  }
  setBottom(e) {
    const t = Lo(e);
    this._bottom !== t && (this._bottom = t, this.domNode.style.bottom = this._bottom);
  }
  setRight(e) {
    const t = Lo(e);
    this._right !== t && (this._right = t, this.domNode.style.right = this._right);
  }
  setPaddingLeft(e) {
    const t = Lo(e);
    this._paddingLeft !== t && (this._paddingLeft = t, this.domNode.style.paddingLeft = this._paddingLeft);
  }
  setFontFamily(e) {
    this._fontFamily !== e && (this._fontFamily = e, this.domNode.style.fontFamily = this._fontFamily);
  }
  setFontWeight(e) {
    this._fontWeight !== e && (this._fontWeight = e, this.domNode.style.fontWeight = this._fontWeight);
  }
  setFontSize(e) {
    const t = Lo(e);
    this._fontSize !== t && (this._fontSize = t, this.domNode.style.fontSize = this._fontSize);
  }
  setFontStyle(e) {
    this._fontStyle !== e && (this._fontStyle = e, this.domNode.style.fontStyle = this._fontStyle);
  }
  setFontFeatureSettings(e) {
    this._fontFeatureSettings !== e && (this._fontFeatureSettings = e, this.domNode.style.fontFeatureSettings = this._fontFeatureSettings);
  }
  setFontVariationSettings(e) {
    this._fontVariationSettings !== e && (this._fontVariationSettings = e, this.domNode.style.fontVariationSettings = this._fontVariationSettings);
  }
  setTextDecoration(e) {
    this._textDecoration !== e && (this._textDecoration = e, this.domNode.style.textDecoration = this._textDecoration);
  }
  setLineHeight(e) {
    const t = Lo(e);
    this._lineHeight !== t && (this._lineHeight = t, this.domNode.style.lineHeight = this._lineHeight);
  }
  setLetterSpacing(e) {
    const t = Lo(e);
    this._letterSpacing !== t && (this._letterSpacing = t, this.domNode.style.letterSpacing = this._letterSpacing);
  }
  setClassName(e) {
    this._className !== e && (this._className = e, this.domNode.className = this._className);
  }
  toggleClassName(e, t) {
    this.domNode.classList.toggle(e, t), this._className = this.domNode.className;
  }
  setDisplay(e) {
    this._display !== e && (this._display = e, this.domNode.style.display = this._display);
  }
  setPosition(e) {
    this._position !== e && (this._position = e, this.domNode.style.position = this._position);
  }
  setVisibility(e) {
    this._visibility !== e && (this._visibility = e, this.domNode.style.visibility = this._visibility);
  }
  setColor(e) {
    this._color !== e && (this._color = e, this.domNode.style.color = this._color);
  }
  setBackgroundColor(e) {
    this._backgroundColor !== e && (this._backgroundColor = e, this.domNode.style.backgroundColor = this._backgroundColor);
  }
  setLayerHinting(e) {
    this._layerHint !== e && (this._layerHint = e, this.domNode.style.transform = this._layerHint ? "translate3d(0px, 0px, 0px)" : "");
  }
  setBoxShadow(e) {
    this._boxShadow !== e && (this._boxShadow = e, this.domNode.style.boxShadow = e);
  }
  setContain(e) {
    this._contain !== e && (this._contain = e, this.domNode.style.contain = this._contain);
  }
  setAttribute(e, t) {
    this.domNode.setAttribute(e, t);
  }
  removeAttribute(e) {
    this.domNode.removeAttribute(e);
  }
  appendChild(e) {
    this.domNode.appendChild(e.domNode);
  }
  removeChild(e) {
    this.domNode.removeChild(e.domNode);
  }
}
function Lo(s) {
  return typeof s == "number" ? `${s}px` : s;
}
function st(s) {
  return new yO(s);
}
class Af {
  constructor() {
    this._hooks = new ne(), this._pointerMoveCallback = null, this._onStopCallback = null;
  }
  dispose() {
    this.stopMonitoring(!1), this._hooks.dispose();
  }
  stopMonitoring(e, t) {
    if (!this.isMonitoring())
      return;
    this._hooks.clear(), this._pointerMoveCallback = null;
    const i = this._onStopCallback;
    this._onStopCallback = null, e && i && i(t);
  }
  isMonitoring() {
    return !!this._pointerMoveCallback;
  }
  startMonitoring(e, t, i, n, o) {
    this.isMonitoring() && this.stopMonitoring(!1), this._pointerMoveCallback = n, this._onStopCallback = o;
    let r = e;
    try {
      e.setPointerCapture(t), this._hooks.add(_e(() => {
        try {
          e.releasePointerCapture(t);
        } catch {
        }
      }));
    } catch {
      r = fe(e);
    }
    this._hooks.add(z(r, X.POINTER_MOVE, (a) => {
      if (a.buttons !== i) {
        this.stopMonitoring(!0);
        return;
      }
      a.preventDefault(), this._pointerMoveCallback(a);
    })), this._hooks.add(z(r, X.POINTER_UP, (a) => this.stopMonitoring(!0)));
  }
}
let qr = class extends U {
  onclick(e, t) {
    this._register(z(e, X.CLICK, (i) => t(new Uo(fe(e), i))));
  }
  onmousedown(e, t) {
    this._register(z(e, X.MOUSE_DOWN, (i) => t(new Uo(fe(e), i))));
  }
  onmouseover(e, t) {
    this._register(z(e, X.MOUSE_OVER, (i) => t(new Uo(fe(e), i))));
  }
  onmouseleave(e, t) {
    this._register(z(e, X.MOUSE_LEAVE, (i) => t(new Uo(fe(e), i))));
  }
  onkeydown(e, t) {
    this._register(z(e, X.KEY_DOWN, (i) => t(new Dt(i))));
  }
  onkeyup(e, t) {
    this._register(z(e, X.KEY_UP, (i) => t(new Dt(i))));
  }
  oninput(e, t) {
    this._register(z(e, X.INPUT, t));
  }
  onblur(e, t) {
    this._register(z(e, X.BLUR, t));
  }
  onfocus(e, t) {
    this._register(z(e, X.FOCUS, t));
  }
  ignoreGesture(e) {
    return ln.ignoreTarget(e);
  }
};
const af = 11;
class eH extends qr {
  constructor(e) {
    super(), this._onActivate = e.onActivate, this.bgDomNode = document.createElement("div"), this.bgDomNode.className = "arrow-background", this.bgDomNode.style.position = "absolute", this.bgDomNode.style.width = e.bgWidth + "px", this.bgDomNode.style.height = e.bgHeight + "px", typeof e.top < "u" && (this.bgDomNode.style.top = "0px"), typeof e.left < "u" && (this.bgDomNode.style.left = "0px"), typeof e.bottom < "u" && (this.bgDomNode.style.bottom = "0px"), typeof e.right < "u" && (this.bgDomNode.style.right = "0px"), this.domNode = document.createElement("div"), this.domNode.className = e.className, this.domNode.classList.add(...Te.asClassNameArray(e.icon)), this.domNode.style.position = "absolute", this.domNode.style.width = af + "px", this.domNode.style.height = af + "px", typeof e.top < "u" && (this.domNode.style.top = e.top + "px"), typeof e.left < "u" && (this.domNode.style.left = e.left + "px"), typeof e.bottom < "u" && (this.domNode.style.bottom = e.bottom + "px"), typeof e.right < "u" && (this.domNode.style.right = e.right + "px"), this._pointerMoveMonitor = this._register(new Af()), this._register(Zt(this.bgDomNode, X.POINTER_DOWN, (t) => this._arrowPointerDown(t))), this._register(Zt(this.domNode, X.POINTER_DOWN, (t) => this._arrowPointerDown(t))), this._pointerdownRepeatTimer = this._register(new LE()), this._pointerdownScheduleRepeatTimer = this._register(new Ya());
  }
  _arrowPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const t = () => {
      this._pointerdownRepeatTimer.cancelAndSet(() => this._onActivate(), 1e3 / 24, fe(e));
    };
    this._onActivate(), this._pointerdownRepeatTimer.cancel(), this._pointerdownScheduleRepeatTimer.cancelAndSet(t, 200), this._pointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (i) => {
    }, () => {
      this._pointerdownRepeatTimer.cancel(), this._pointerdownScheduleRepeatTimer.cancel();
    }), e.preventDefault();
  }
}
class tH extends U {
  constructor(e, t, i) {
    super(), this._visibility = e, this._visibleClassName = t, this._invisibleClassName = i, this._domNode = null, this._isVisible = !1, this._isNeeded = !1, this._rawShouldBeVisible = !1, this._shouldBeVisible = !1, this._revealTimer = this._register(new Ya());
  }
  setVisibility(e) {
    this._visibility !== e && (this._visibility = e, this._updateShouldBeVisible());
  }
  // ----------------- Hide / Reveal
  setShouldBeVisible(e) {
    this._rawShouldBeVisible = e, this._updateShouldBeVisible();
  }
  _applyVisibilitySetting() {
    return this._visibility === 2 ? !1 : this._visibility === 3 ? !0 : this._rawShouldBeVisible;
  }
  _updateShouldBeVisible() {
    const e = this._applyVisibilitySetting();
    this._shouldBeVisible !== e && (this._shouldBeVisible = e, this.ensureVisibility());
  }
  setIsNeeded(e) {
    this._isNeeded !== e && (this._isNeeded = e, this.ensureVisibility());
  }
  setDomNode(e) {
    this._domNode = e, this._domNode.setClassName(this._invisibleClassName), this.setShouldBeVisible(!1);
  }
  ensureVisibility() {
    if (!this._isNeeded) {
      this._hide(!1);
      return;
    }
    this._shouldBeVisible ? this._reveal() : this._hide(!0);
  }
  _reveal() {
    this._isVisible || (this._isVisible = !0, this._revealTimer.setIfNotSet(() => {
      var e;
      (e = this._domNode) == null || e.setClassName(this._visibleClassName);
    }, 0));
  }
  _hide(e) {
    var t;
    this._revealTimer.cancel(), this._isVisible && (this._isVisible = !1, (t = this._domNode) == null || t.setClassName(this._invisibleClassName + (e ? " fade" : "")));
  }
}
const iH = 140;
class SO extends qr {
  constructor(e) {
    super(), this._lazyRender = e.lazyRender, this._host = e.host, this._scrollable = e.scrollable, this._scrollByPage = e.scrollByPage, this._scrollbarState = e.scrollbarState, this._visibilityController = this._register(new tH(e.visibility, "visible scrollbar " + e.extraScrollbarClassName, "invisible scrollbar " + e.extraScrollbarClassName)), this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._pointerMoveMonitor = this._register(new Af()), this._shouldRender = !0, this.domNode = st(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this._visibilityController.setDomNode(this.domNode), this.domNode.setPosition("absolute"), this._register(z(this.domNode.domNode, X.POINTER_DOWN, (t) => this._domNodePointerDown(t)));
  }
  // ----------------- creation
  /**
   * Creates the dom node for an arrow & adds it to the container
   */
  _createArrow(e) {
    const t = this._register(new eH(e));
    this.domNode.domNode.appendChild(t.bgDomNode), this.domNode.domNode.appendChild(t.domNode);
  }
  /**
   * Creates the slider dom node, adds it to the container & hooks up the events
   */
  _createSlider(e, t, i, n) {
    this.slider = st(document.createElement("div")), this.slider.setClassName("slider"), this.slider.setPosition("absolute"), this.slider.setTop(e), this.slider.setLeft(t), typeof i == "number" && this.slider.setWidth(i), typeof n == "number" && this.slider.setHeight(n), this.slider.setLayerHinting(!0), this.slider.setContain("strict"), this.domNode.domNode.appendChild(this.slider.domNode), this._register(z(this.slider.domNode, X.POINTER_DOWN, (o) => {
      o.button === 0 && (o.preventDefault(), this._sliderPointerDown(o));
    })), this.onclick(this.slider.domNode, (o) => {
      o.leftButton && o.stopPropagation();
    });
  }
  // ----------------- Update state
  _onElementSize(e) {
    return this._scrollbarState.setVisibleSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  _onElementScrollSize(e) {
    return this._scrollbarState.setScrollSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  _onElementScrollPosition(e) {
    return this._scrollbarState.setScrollPosition(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  // ----------------- rendering
  beginReveal() {
    this._visibilityController.setShouldBeVisible(!0);
  }
  beginHide() {
    this._visibilityController.setShouldBeVisible(!1);
  }
  render() {
    this._shouldRender && (this._shouldRender = !1, this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize()), this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition()));
  }
  // ----------------- DOM events
  _domNodePointerDown(e) {
    e.target === this.domNode.domNode && this._onPointerDown(e);
  }
  delegatePointerDown(e) {
    const t = this.domNode.domNode.getClientRects()[0].top, i = t + this._scrollbarState.getSliderPosition(), n = t + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize(), o = this._sliderPointerPosition(e);
    i <= o && o <= n ? e.button === 0 && (e.preventDefault(), this._sliderPointerDown(e)) : this._onPointerDown(e);
  }
  _onPointerDown(e) {
    let t, i;
    if (e.target === this.domNode.domNode && typeof e.offsetX == "number" && typeof e.offsetY == "number")
      t = e.offsetX, i = e.offsetY;
    else {
      const o = ui(this.domNode.domNode);
      t = e.pageX - o.left, i = e.pageY - o.top;
    }
    const n = this._pointerDownRelativePosition(t, i);
    this._setDesiredScrollPositionNow(this._scrollByPage ? this._scrollbarState.getDesiredScrollPositionFromOffsetPaged(n) : this._scrollbarState.getDesiredScrollPositionFromOffset(n)), e.button === 0 && (e.preventDefault(), this._sliderPointerDown(e));
  }
  _sliderPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const t = this._sliderPointerPosition(e), i = this._sliderOrthogonalPointerPosition(e), n = this._scrollbarState.clone();
    this.slider.toggleClassName("active", !0), this._pointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (o) => {
      const r = this._sliderOrthogonalPointerPosition(o), a = Math.abs(r - i);
      if (es && a > iH) {
        this._setDesiredScrollPositionNow(n.getScrollPosition());
        return;
      }
      const c = this._sliderPointerPosition(o) - t;
      this._setDesiredScrollPositionNow(n.getDesiredScrollPositionFromDelta(c));
    }, () => {
      this.slider.toggleClassName("active", !1), this._host.onDragEnd();
    }), this._host.onDragStart();
  }
  _setDesiredScrollPositionNow(e) {
    const t = {};
    this.writeScrollPosition(t, e), this._scrollable.setScrollPositionNow(t);
  }
  updateScrollbarSize(e) {
    this._updateScrollbarSize(e), this._scrollbarState.setScrollbarSize(e), this._shouldRender = !0, this._lazyRender || this.render();
  }
  isNeeded() {
    return this._scrollbarState.isNeeded();
  }
}
const nH = 20;
class lf {
  constructor(e, t, i, n, o, r) {
    this._scrollbarSize = Math.round(t), this._oppositeScrollbarSize = Math.round(i), this._arrowSize = Math.round(e), this._visibleSize = n, this._scrollSize = o, this._scrollPosition = r, this._computedAvailableSize = 0, this._computedIsNeeded = !1, this._computedSliderSize = 0, this._computedSliderRatio = 0, this._computedSliderPosition = 0, this._refreshComputedValues();
  }
  clone() {
    return new lf(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);
  }
  setVisibleSize(e) {
    const t = Math.round(e);
    return this._visibleSize !== t ? (this._visibleSize = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollSize(e) {
    const t = Math.round(e);
    return this._scrollSize !== t ? (this._scrollSize = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollPosition(e) {
    const t = Math.round(e);
    return this._scrollPosition !== t ? (this._scrollPosition = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollbarSize(e) {
    this._scrollbarSize = Math.round(e);
  }
  setOppositeScrollbarSize(e) {
    this._oppositeScrollbarSize = Math.round(e);
  }
  static _computeValues(e, t, i, n, o) {
    const r = Math.max(0, i - e), a = Math.max(0, r - 2 * t), l = n > 0 && n > i;
    if (!l)
      return {
        computedAvailableSize: Math.round(r),
        computedIsNeeded: l,
        computedSliderSize: Math.round(a),
        computedSliderRatio: 0,
        computedSliderPosition: 0
      };
    const c = Math.round(Math.max(nH, Math.floor(i * a / n))), h = (a - c) / (n - i), d = o * h;
    return {
      computedAvailableSize: Math.round(r),
      computedIsNeeded: l,
      computedSliderSize: Math.round(c),
      computedSliderRatio: h,
      computedSliderPosition: Math.round(d)
    };
  }
  _refreshComputedValues() {
    const e = lf._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);
    this._computedAvailableSize = e.computedAvailableSize, this._computedIsNeeded = e.computedIsNeeded, this._computedSliderSize = e.computedSliderSize, this._computedSliderRatio = e.computedSliderRatio, this._computedSliderPosition = e.computedSliderPosition;
  }
  getArrowSize() {
    return this._arrowSize;
  }
  getScrollPosition() {
    return this._scrollPosition;
  }
  getRectangleLargeSize() {
    return this._computedAvailableSize;
  }
  getRectangleSmallSize() {
    return this._scrollbarSize;
  }
  isNeeded() {
    return this._computedIsNeeded;
  }
  getSliderSize() {
    return this._computedSliderSize;
  }
  getSliderPosition() {
    return this._computedSliderPosition;
  }
  /**
   * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.
   * `offset` is based on the same coordinate system as the `sliderPosition`.
   */
  getDesiredScrollPositionFromOffset(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = e - this._arrowSize - this._computedSliderSize / 2;
    return Math.round(t / this._computedSliderRatio);
  }
  /**
   * Compute a desired `scrollPosition` from if offset is before or after the slider position.
   * If offset is before slider, treat as a page up (or left).  If after, page down (or right).
   * `offset` and `_computedSliderPosition` are based on the same coordinate system.
   * `_visibleSize` corresponds to a "page" of lines in the returned coordinate system.
   */
  getDesiredScrollPositionFromOffsetPaged(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = e - this._arrowSize;
    let i = this._scrollPosition;
    return t < this._computedSliderPosition ? i -= this._visibleSize : i += this._visibleSize, i;
  }
  /**
   * Compute a desired `scrollPosition` such that the slider moves by `delta`.
   */
  getDesiredScrollPositionFromDelta(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = this._computedSliderPosition + e;
    return Math.round(t / this._computedSliderRatio);
  }
}
class sH extends SO {
  constructor(e, t, i) {
    const n = e.getScrollDimensions(), o = e.getCurrentScrollPosition();
    if (super({
      lazyRender: t.lazyRender,
      host: i,
      scrollbarState: new lf(t.horizontalHasArrows ? t.arrowSize : 0, t.horizontal === 2 ? 0 : t.horizontalScrollbarSize, t.vertical === 2 ? 0 : t.verticalScrollbarSize, n.width, n.scrollWidth, o.scrollLeft),
      visibility: t.horizontal,
      extraScrollbarClassName: "horizontal",
      scrollable: e,
      scrollByPage: t.scrollByPage
    }), t.horizontalHasArrows) {
      const r = (t.arrowSize - af) / 2, a = (t.horizontalScrollbarSize - af) / 2;
      this._createArrow({
        className: "scra",
        icon: ie.scrollbarButtonLeft,
        top: a,
        left: r,
        bottom: void 0,
        right: void 0,
        bgWidth: t.arrowSize,
        bgHeight: t.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new Hh(null, 1, 0))
      }), this._createArrow({
        className: "scra",
        icon: ie.scrollbarButtonRight,
        top: a,
        left: void 0,
        bottom: void 0,
        right: r,
        bgWidth: t.arrowSize,
        bgHeight: t.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new Hh(null, -1, 0))
      });
    }
    this._createSlider(Math.floor((t.horizontalScrollbarSize - t.horizontalSliderSize) / 2), 0, void 0, t.horizontalSliderSize);
  }
  _updateSlider(e, t) {
    this.slider.setWidth(e), this.slider.setLeft(t);
  }
  _renderDomNode(e, t) {
    this.domNode.setWidth(e), this.domNode.setHeight(t), this.domNode.setLeft(0), this.domNode.setBottom(0);
  }
  onDidScroll(e) {
    return this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender, this._shouldRender = this._onElementSize(e.width) || this._shouldRender, this._shouldRender;
  }
  _pointerDownRelativePosition(e, t) {
    return e;
  }
  _sliderPointerPosition(e) {
    return e.pageX;
  }
  _sliderOrthogonalPointerPosition(e) {
    return e.pageY;
  }
  _updateScrollbarSize(e) {
    this.slider.setHeight(e);
  }
  writeScrollPosition(e, t) {
    e.scrollLeft = t;
  }
  updateOptions(e) {
    this.updateScrollbarSize(e.horizontal === 2 ? 0 : e.horizontalScrollbarSize), this._scrollbarState.setOppositeScrollbarSize(e.vertical === 2 ? 0 : e.verticalScrollbarSize), this._visibilityController.setVisibility(e.horizontal), this._scrollByPage = e.scrollByPage;
  }
}
class oH extends SO {
  constructor(e, t, i) {
    const n = e.getScrollDimensions(), o = e.getCurrentScrollPosition();
    if (super({
      lazyRender: t.lazyRender,
      host: i,
      scrollbarState: new lf(
        t.verticalHasArrows ? t.arrowSize : 0,
        t.vertical === 2 ? 0 : t.verticalScrollbarSize,
        // give priority to vertical scroll bar over horizontal and let it scroll all the way to the bottom
        0,
        n.height,
        n.scrollHeight,
        o.scrollTop
      ),
      visibility: t.vertical,
      extraScrollbarClassName: "vertical",
      scrollable: e,
      scrollByPage: t.scrollByPage
    }), t.verticalHasArrows) {
      const r = (t.arrowSize - af) / 2, a = (t.verticalScrollbarSize - af) / 2;
      this._createArrow({
        className: "scra",
        icon: ie.scrollbarButtonUp,
        top: r,
        left: a,
        bottom: void 0,
        right: void 0,
        bgWidth: t.verticalScrollbarSize,
        bgHeight: t.arrowSize,
        onActivate: () => this._host.onMouseWheel(new Hh(null, 0, 1))
      }), this._createArrow({
        className: "scra",
        icon: ie.scrollbarButtonDown,
        top: void 0,
        left: a,
        bottom: r,
        right: void 0,
        bgWidth: t.verticalScrollbarSize,
        bgHeight: t.arrowSize,
        onActivate: () => this._host.onMouseWheel(new Hh(null, 0, -1))
      });
    }
    this._createSlider(0, Math.floor((t.verticalScrollbarSize - t.verticalSliderSize) / 2), t.verticalSliderSize, void 0);
  }
  _updateSlider(e, t) {
    this.slider.setHeight(e), this.slider.setTop(t);
  }
  _renderDomNode(e, t) {
    this.domNode.setWidth(t), this.domNode.setHeight(e), this.domNode.setRight(0), this.domNode.setTop(0);
  }
  onDidScroll(e) {
    return this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender, this._shouldRender = this._onElementSize(e.height) || this._shouldRender, this._shouldRender;
  }
  _pointerDownRelativePosition(e, t) {
    return t;
  }
  _sliderPointerPosition(e) {
    return e.pageY;
  }
  _sliderOrthogonalPointerPosition(e) {
    return e.pageX;
  }
  _updateScrollbarSize(e) {
    this.slider.setWidth(e);
  }
  writeScrollPosition(e, t) {
    e.scrollTop = t;
  }
  updateOptions(e) {
    this.updateScrollbarSize(e.vertical === 2 ? 0 : e.verticalScrollbarSize), this._scrollbarState.setOppositeScrollbarSize(0), this._visibilityController.setVisibility(e.vertical), this._scrollByPage = e.scrollByPage;
  }
}
class t1 {
  constructor(e, t, i, n, o, r, a) {
    this._forceIntegerValues = e, this._scrollStateBrand = void 0, this._forceIntegerValues && (t = t | 0, i = i | 0, n = n | 0, o = o | 0, r = r | 0, a = a | 0), this.rawScrollLeft = n, this.rawScrollTop = a, t < 0 && (t = 0), n + t > i && (n = i - t), n < 0 && (n = 0), o < 0 && (o = 0), a + o > r && (a = r - o), a < 0 && (a = 0), this.width = t, this.scrollWidth = i, this.scrollLeft = n, this.height = o, this.scrollHeight = r, this.scrollTop = a;
  }
  equals(e) {
    return this.rawScrollLeft === e.rawScrollLeft && this.rawScrollTop === e.rawScrollTop && this.width === e.width && this.scrollWidth === e.scrollWidth && this.scrollLeft === e.scrollLeft && this.height === e.height && this.scrollHeight === e.scrollHeight && this.scrollTop === e.scrollTop;
  }
  withScrollDimensions(e, t) {
    return new t1(this._forceIntegerValues, typeof e.width < "u" ? e.width : this.width, typeof e.scrollWidth < "u" ? e.scrollWidth : this.scrollWidth, t ? this.rawScrollLeft : this.scrollLeft, typeof e.height < "u" ? e.height : this.height, typeof e.scrollHeight < "u" ? e.scrollHeight : this.scrollHeight, t ? this.rawScrollTop : this.scrollTop);
  }
  withScrollPosition(e) {
    return new t1(this._forceIntegerValues, this.width, this.scrollWidth, typeof e.scrollLeft < "u" ? e.scrollLeft : this.rawScrollLeft, this.height, this.scrollHeight, typeof e.scrollTop < "u" ? e.scrollTop : this.rawScrollTop);
  }
  createScrollEvent(e, t) {
    const i = this.width !== e.width, n = this.scrollWidth !== e.scrollWidth, o = this.scrollLeft !== e.scrollLeft, r = this.height !== e.height, a = this.scrollHeight !== e.scrollHeight, l = this.scrollTop !== e.scrollTop;
    return {
      inSmoothScrolling: t,
      oldWidth: e.width,
      oldScrollWidth: e.scrollWidth,
      oldScrollLeft: e.scrollLeft,
      width: this.width,
      scrollWidth: this.scrollWidth,
      scrollLeft: this.scrollLeft,
      oldHeight: e.height,
      oldScrollHeight: e.scrollHeight,
      oldScrollTop: e.scrollTop,
      height: this.height,
      scrollHeight: this.scrollHeight,
      scrollTop: this.scrollTop,
      widthChanged: i,
      scrollWidthChanged: n,
      scrollLeftChanged: o,
      heightChanged: r,
      scrollHeightChanged: a,
      scrollTopChanged: l
    };
  }
}
class Pf extends U {
  constructor(e) {
    super(), this._scrollableBrand = void 0, this._onScroll = this._register(new A()), this.onScroll = this._onScroll.event, this._smoothScrollDuration = e.smoothScrollDuration, this._scheduleAtNextAnimationFrame = e.scheduleAtNextAnimationFrame, this._state = new t1(e.forceIntegerValues, 0, 0, 0, 0, 0, 0), this._smoothScrolling = null;
  }
  dispose() {
    this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), super.dispose();
  }
  setSmoothScrollDuration(e) {
    this._smoothScrollDuration = e;
  }
  validateScrollPosition(e) {
    return this._state.withScrollPosition(e);
  }
  getScrollDimensions() {
    return this._state;
  }
  setScrollDimensions(e, t) {
    var n;
    const i = this._state.withScrollDimensions(e, t);
    this._setState(i, !!this._smoothScrolling), (n = this._smoothScrolling) == null || n.acceptScrollDimensions(this._state);
  }
  /**
   * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.
   * If no scroll animation is occurring, it will return the current scroll position instead.
   */
  getFutureScrollPosition() {
    return this._smoothScrolling ? this._smoothScrolling.to : this._state;
  }
  /**
   * Returns the current scroll position.
   * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.
   */
  getCurrentScrollPosition() {
    return this._state;
  }
  setScrollPositionNow(e) {
    const t = this._state.withScrollPosition(e);
    this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), this._setState(t, !1);
  }
  setScrollPositionSmooth(e, t) {
    if (this._smoothScrollDuration === 0)
      return this.setScrollPositionNow(e);
    if (this._smoothScrolling) {
      e = {
        scrollLeft: typeof e.scrollLeft > "u" ? this._smoothScrolling.to.scrollLeft : e.scrollLeft,
        scrollTop: typeof e.scrollTop > "u" ? this._smoothScrolling.to.scrollTop : e.scrollTop
      };
      const i = this._state.withScrollPosition(e);
      if (this._smoothScrolling.to.scrollLeft === i.scrollLeft && this._smoothScrolling.to.scrollTop === i.scrollTop)
        return;
      let n;
      t ? n = new Am(this._smoothScrolling.from, i, this._smoothScrolling.startTime, this._smoothScrolling.duration) : n = this._smoothScrolling.combine(this._state, i, this._smoothScrollDuration), this._smoothScrolling.dispose(), this._smoothScrolling = n;
    } else {
      const i = this._state.withScrollPosition(e);
      this._smoothScrolling = Am.start(this._state, i, this._smoothScrollDuration);
    }
    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
      this._smoothScrolling && (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
    });
  }
  hasPendingScrollAnimation() {
    return !!this._smoothScrolling;
  }
  _performSmoothScrolling() {
    if (!this._smoothScrolling)
      return;
    const e = this._smoothScrolling.tick(), t = this._state.withScrollPosition(e);
    if (this._setState(t, !0), !!this._smoothScrolling) {
      if (e.isDone) {
        this._smoothScrolling.dispose(), this._smoothScrolling = null;
        return;
      }
      this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
        this._smoothScrolling && (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
      });
    }
  }
  _setState(e, t) {
    const i = this._state;
    i.equals(e) || (this._state = e, this._onScroll.fire(this._state.createScrollEvent(i, t)));
  }
}
class iT {
  constructor(e, t, i) {
    this.scrollLeft = e, this.scrollTop = t, this.isDone = i;
  }
}
function D0(s, e) {
  const t = e - s;
  return function(i) {
    return s + t * lH(i);
  };
}
function rH(s, e, t) {
  return function(i) {
    return i < t ? s(i / t) : e((i - t) / (1 - t));
  };
}
class Am {
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.duration = n, this.startTime = i, this.animationFrameDisposable = null, this._initAnimations();
  }
  _initAnimations() {
    this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width), this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
  }
  _initAnimation(e, t, i) {
    if (Math.abs(e - t) > 2.5 * i) {
      let o, r;
      return e < t ? (o = e + 0.75 * i, r = t - 0.75 * i) : (o = e - 0.75 * i, r = t + 0.75 * i), rH(D0(e, o), D0(r, t), 0.33);
    }
    return D0(e, t);
  }
  dispose() {
    this.animationFrameDisposable !== null && (this.animationFrameDisposable.dispose(), this.animationFrameDisposable = null);
  }
  acceptScrollDimensions(e) {
    this.to = e.withScrollPosition(this.to), this._initAnimations();
  }
  tick() {
    return this._tick(Date.now());
  }
  _tick(e) {
    const t = (e - this.startTime) / this.duration;
    if (t < 1) {
      const i = this.scrollLeft(t), n = this.scrollTop(t);
      return new iT(i, n, !1);
    }
    return new iT(this.to.scrollLeft, this.to.scrollTop, !0);
  }
  combine(e, t, i) {
    return Am.start(e, t, i);
  }
  static start(e, t, i) {
    i = i + 10;
    const n = Date.now() - 10;
    return new Am(e, t, n, i);
  }
}
function aH(s) {
  return Math.pow(s, 3);
}
function lH(s) {
  return 1 - aH(1 - s);
}
const cH = 500, nT = 50;
class hH {
  constructor(e, t, i) {
    this.timestamp = e, this.deltaX = t, this.deltaY = i, this.score = 0;
  }
}
const GC = class GC {
  constructor() {
    this._capacity = 5, this._memory = [], this._front = -1, this._rear = -1;
  }
  isPhysicalMouseWheel() {
    if (this._front === -1 && this._rear === -1)
      return !1;
    let e = 1, t = 0, i = 1, n = this._rear;
    do {
      const o = n === this._front ? e : Math.pow(2, -i);
      if (e -= o, t += this._memory[n].score * o, n === this._front)
        break;
      n = (this._capacity + n - 1) % this._capacity, i++;
    } while (!0);
    return t <= 0.5;
  }
  acceptStandardWheelEvent(e) {
    if (Ip) {
      const t = fe(e.browserEvent), i = X8(t);
      this.accept(Date.now(), e.deltaX * i, e.deltaY * i);
    } else
      this.accept(Date.now(), e.deltaX, e.deltaY);
  }
  accept(e, t, i) {
    let n = null;
    const o = new hH(e, t, i);
    this._front === -1 && this._rear === -1 ? (this._memory[0] = o, this._front = 0, this._rear = 0) : (n = this._memory[this._rear], this._rear = (this._rear + 1) % this._capacity, this._rear === this._front && (this._front = (this._front + 1) % this._capacity), this._memory[this._rear] = o), o.score = this._computeScore(o, n);
  }
  /**
   * A score between 0 and 1 for `item`.
   *  - a score towards 0 indicates that the source appears to be a physical mouse wheel
   *  - a score towards 1 indicates that the source appears to be a touchpad or magic mouse, etc.
   */
  _computeScore(e, t) {
    if (Math.abs(e.deltaX) > 0 && Math.abs(e.deltaY) > 0)
      return 1;
    let i = 0.5;
    if ((!this._isAlmostInt(e.deltaX) || !this._isAlmostInt(e.deltaY)) && (i += 0.25), t) {
      const n = Math.abs(e.deltaX), o = Math.abs(e.deltaY), r = Math.abs(t.deltaX), a = Math.abs(t.deltaY), l = Math.max(Math.min(n, r), 1), c = Math.max(Math.min(o, a), 1), h = Math.max(n, r), d = Math.max(o, a);
      h % l === 0 && d % c === 0 && (i -= 0.5);
    }
    return Math.min(Math.max(i, 0), 1);
  }
  _isAlmostInt(e) {
    return Math.abs(Math.round(e) - e) < 0.01;
  }
};
GC.INSTANCE = new GC();
let i1 = GC;
class jE extends qr {
  get options() {
    return this._options;
  }
  constructor(e, t, i) {
    super(), this._onScroll = this._register(new A()), this.onScroll = this._onScroll.event, this._onWillScroll = this._register(new A()), e.style.overflow = "hidden", this._options = dH(t), this._scrollable = i, this._register(this._scrollable.onScroll((o) => {
      this._onWillScroll.fire(o), this._onDidScroll(o), this._onScroll.fire(o);
    }));
    const n = {
      onMouseWheel: (o) => this._onMouseWheel(o),
      onDragStart: () => this._onDragStart(),
      onDragEnd: () => this._onDragEnd()
    };
    this._verticalScrollbar = this._register(new oH(this._scrollable, this._options, n)), this._horizontalScrollbar = this._register(new sH(this._scrollable, this._options, n)), this._domNode = document.createElement("div"), this._domNode.className = "monaco-scrollable-element " + this._options.className, this._domNode.setAttribute("role", "presentation"), this._domNode.style.position = "relative", this._domNode.style.overflow = "hidden", this._domNode.appendChild(e), this._domNode.appendChild(this._horizontalScrollbar.domNode.domNode), this._domNode.appendChild(this._verticalScrollbar.domNode.domNode), this._options.useShadows ? (this._leftShadowDomNode = st(document.createElement("div")), this._leftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._leftShadowDomNode.domNode), this._topShadowDomNode = st(document.createElement("div")), this._topShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topShadowDomNode.domNode), this._topLeftShadowDomNode = st(document.createElement("div")), this._topLeftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topLeftShadowDomNode.domNode)) : (this._leftShadowDomNode = null, this._topShadowDomNode = null, this._topLeftShadowDomNode = null), this._listenOnDomNode = this._options.listenOnDomNode || this._domNode, this._mouseWheelToDispose = [], this._setListeningToMouseWheel(this._options.handleMouseWheel), this.onmouseover(this._listenOnDomNode, (o) => this._onMouseOver(o)), this.onmouseleave(this._listenOnDomNode, (o) => this._onMouseLeave(o)), this._hideTimeout = this._register(new Ya()), this._isDragging = !1, this._mouseIsOver = !1, this._shouldRender = !0, this._revealOnScroll = !0;
  }
  dispose() {
    this._mouseWheelToDispose = Ft(this._mouseWheelToDispose), super.dispose();
  }
  /**
   * Get the generated 'scrollable' dom node
   */
  getDomNode() {
    return this._domNode;
  }
  getOverviewRulerLayoutInfo() {
    return {
      parent: this._domNode,
      insertBefore: this._verticalScrollbar.domNode.domNode
    };
  }
  /**
   * Delegate a pointer down event to the vertical scrollbar.
   * This is to help with clicking somewhere else and having the scrollbar react.
   */
  delegateVerticalScrollbarPointerDown(e) {
    this._verticalScrollbar.delegatePointerDown(e);
  }
  getScrollDimensions() {
    return this._scrollable.getScrollDimensions();
  }
  setScrollDimensions(e) {
    this._scrollable.setScrollDimensions(e, !1);
  }
  /**
   * Update the class name of the scrollable element.
   */
  updateClassName(e) {
    this._options.className = e, $e && (this._options.className += " mac"), this._domNode.className = "monaco-scrollable-element " + this._options.className;
  }
  /**
   * Update configuration options for the scrollbar.
   */
  updateOptions(e) {
    typeof e.handleMouseWheel < "u" && (this._options.handleMouseWheel = e.handleMouseWheel, this._setListeningToMouseWheel(this._options.handleMouseWheel)), typeof e.mouseWheelScrollSensitivity < "u" && (this._options.mouseWheelScrollSensitivity = e.mouseWheelScrollSensitivity), typeof e.fastScrollSensitivity < "u" && (this._options.fastScrollSensitivity = e.fastScrollSensitivity), typeof e.scrollPredominantAxis < "u" && (this._options.scrollPredominantAxis = e.scrollPredominantAxis), typeof e.horizontal < "u" && (this._options.horizontal = e.horizontal), typeof e.vertical < "u" && (this._options.vertical = e.vertical), typeof e.horizontalScrollbarSize < "u" && (this._options.horizontalScrollbarSize = e.horizontalScrollbarSize), typeof e.verticalScrollbarSize < "u" && (this._options.verticalScrollbarSize = e.verticalScrollbarSize), typeof e.scrollByPage < "u" && (this._options.scrollByPage = e.scrollByPage), this._horizontalScrollbar.updateOptions(this._options), this._verticalScrollbar.updateOptions(this._options), this._options.lazyRender || this._render();
  }
  delegateScrollFromMouseWheelEvent(e) {
    this._onMouseWheel(new Hh(e));
  }
  // -------------------- mouse wheel scrolling --------------------
  _setListeningToMouseWheel(e) {
    if (this._mouseWheelToDispose.length > 0 !== e && (this._mouseWheelToDispose = Ft(this._mouseWheelToDispose), e)) {
      const i = (n) => {
        this._onMouseWheel(new Hh(n));
      };
      this._mouseWheelToDispose.push(z(this._listenOnDomNode, X.MOUSE_WHEEL, i, { passive: !1 }));
    }
  }
  _onMouseWheel(e) {
    var o;
    if ((o = e.browserEvent) != null && o.defaultPrevented)
      return;
    const t = i1.INSTANCE;
    t.acceptStandardWheelEvent(e);
    let i = !1;
    if (e.deltaY || e.deltaX) {
      let r = e.deltaY * this._options.mouseWheelScrollSensitivity, a = e.deltaX * this._options.mouseWheelScrollSensitivity;
      this._options.scrollPredominantAxis && (this._options.scrollYToX && a + r === 0 ? a = r = 0 : Math.abs(r) >= Math.abs(a) ? a = 0 : r = 0), this._options.flipAxes && ([r, a] = [a, r]);
      const l = !$e && e.browserEvent && e.browserEvent.shiftKey;
      (this._options.scrollYToX || l) && !a && (a = r, r = 0), e.browserEvent && e.browserEvent.altKey && (a = a * this._options.fastScrollSensitivity, r = r * this._options.fastScrollSensitivity);
      const c = this._scrollable.getFutureScrollPosition();
      let h = {};
      if (r) {
        const d = nT * r, u = c.scrollTop - (d < 0 ? Math.floor(d) : Math.ceil(d));
        this._verticalScrollbar.writeScrollPosition(h, u);
      }
      if (a) {
        const d = nT * a, u = c.scrollLeft - (d < 0 ? Math.floor(d) : Math.ceil(d));
        this._horizontalScrollbar.writeScrollPosition(h, u);
      }
      h = this._scrollable.validateScrollPosition(h), (c.scrollLeft !== h.scrollLeft || c.scrollTop !== h.scrollTop) && (this._options.mouseWheelSmoothScroll && t.isPhysicalMouseWheel() ? this._scrollable.setScrollPositionSmooth(h) : this._scrollable.setScrollPositionNow(h), i = !0);
    }
    let n = i;
    !n && this._options.alwaysConsumeMouseWheel && (n = !0), !n && this._options.consumeMouseWheelIfScrollbarIsNeeded && (this._verticalScrollbar.isNeeded() || this._horizontalScrollbar.isNeeded()) && (n = !0), n && (e.preventDefault(), e.stopPropagation());
  }
  _onDidScroll(e) {
    this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender, this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender, this._options.useShadows && (this._shouldRender = !0), this._revealOnScroll && this._reveal(), this._options.lazyRender || this._render();
  }
  /**
   * Render / mutate the DOM now.
   * Should be used together with the ctor option `lazyRender`.
   */
  renderNow() {
    if (!this._options.lazyRender)
      throw new Error("Please use `lazyRender` together with `renderNow`!");
    this._render();
  }
  _render() {
    if (this._shouldRender && (this._shouldRender = !1, this._horizontalScrollbar.render(), this._verticalScrollbar.render(), this._options.useShadows)) {
      const e = this._scrollable.getCurrentScrollPosition(), t = e.scrollTop > 0, i = e.scrollLeft > 0, n = i ? " left" : "", o = t ? " top" : "", r = i || t ? " top-left-corner" : "";
      this._leftShadowDomNode.setClassName(`shadow${n}`), this._topShadowDomNode.setClassName(`shadow${o}`), this._topLeftShadowDomNode.setClassName(`shadow${r}${o}${n}`);
    }
  }
  // -------------------- fade in / fade out --------------------
  _onDragStart() {
    this._isDragging = !0, this._reveal();
  }
  _onDragEnd() {
    this._isDragging = !1, this._hide();
  }
  _onMouseLeave(e) {
    this._mouseIsOver = !1, this._hide();
  }
  _onMouseOver(e) {
    this._mouseIsOver = !0, this._reveal();
  }
  _reveal() {
    this._verticalScrollbar.beginReveal(), this._horizontalScrollbar.beginReveal(), this._scheduleHide();
  }
  _hide() {
    !this._mouseIsOver && !this._isDragging && (this._verticalScrollbar.beginHide(), this._horizontalScrollbar.beginHide());
  }
  _scheduleHide() {
    !this._mouseIsOver && !this._isDragging && this._hideTimeout.cancelAndSet(() => this._hide(), cH);
  }
}
class LO extends jE {
  constructor(e, t) {
    t = t || {}, t.mouseWheelSmoothScroll = !1;
    const i = new Pf({
      forceIntegerValues: !0,
      smoothScrollDuration: 0,
      scheduleAtNextAnimationFrame: (n) => ns(fe(e), n)
    });
    super(e, t, i), this._register(i);
  }
  setScrollPosition(e) {
    this._scrollable.setScrollPositionNow(e);
  }
}
class rw extends jE {
  constructor(e, t, i) {
    super(e, t, i);
  }
  setScrollPosition(e) {
    e.reuseAnimation ? this._scrollable.setScrollPositionSmooth(e, e.reuseAnimation) : this._scrollable.setScrollPositionNow(e);
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
}
class qE extends jE {
  constructor(e, t) {
    t = t || {}, t.mouseWheelSmoothScroll = !1;
    const i = new Pf({
      forceIntegerValues: !1,
      // See https://github.com/microsoft/vscode/issues/139877
      smoothScrollDuration: 0,
      scheduleAtNextAnimationFrame: (n) => ns(fe(e), n)
    });
    super(e, t, i), this._register(i), this._element = e, this._register(this.onScroll((n) => {
      n.scrollTopChanged && (this._element.scrollTop = n.scrollTop), n.scrollLeftChanged && (this._element.scrollLeft = n.scrollLeft);
    })), this.scanDomNode();
  }
  setScrollPosition(e) {
    this._scrollable.setScrollPositionNow(e);
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
  scanDomNode() {
    this.setScrollDimensions({
      width: this._element.clientWidth,
      scrollWidth: this._element.scrollWidth,
      height: this._element.clientHeight,
      scrollHeight: this._element.scrollHeight
    }), this.setScrollPosition({
      scrollLeft: this._element.scrollLeft,
      scrollTop: this._element.scrollTop
    });
  }
}
function dH(s) {
  const e = {
    lazyRender: typeof s.lazyRender < "u" ? s.lazyRender : !1,
    className: typeof s.className < "u" ? s.className : "",
    useShadows: typeof s.useShadows < "u" ? s.useShadows : !0,
    handleMouseWheel: typeof s.handleMouseWheel < "u" ? s.handleMouseWheel : !0,
    flipAxes: typeof s.flipAxes < "u" ? s.flipAxes : !1,
    consumeMouseWheelIfScrollbarIsNeeded: typeof s.consumeMouseWheelIfScrollbarIsNeeded < "u" ? s.consumeMouseWheelIfScrollbarIsNeeded : !1,
    alwaysConsumeMouseWheel: typeof s.alwaysConsumeMouseWheel < "u" ? s.alwaysConsumeMouseWheel : !1,
    scrollYToX: typeof s.scrollYToX < "u" ? s.scrollYToX : !1,
    mouseWheelScrollSensitivity: typeof s.mouseWheelScrollSensitivity < "u" ? s.mouseWheelScrollSensitivity : 1,
    fastScrollSensitivity: typeof s.fastScrollSensitivity < "u" ? s.fastScrollSensitivity : 5,
    scrollPredominantAxis: typeof s.scrollPredominantAxis < "u" ? s.scrollPredominantAxis : !0,
    mouseWheelSmoothScroll: typeof s.mouseWheelSmoothScroll < "u" ? s.mouseWheelSmoothScroll : !0,
    arrowSize: typeof s.arrowSize < "u" ? s.arrowSize : 11,
    listenOnDomNode: typeof s.listenOnDomNode < "u" ? s.listenOnDomNode : null,
    horizontal: typeof s.horizontal < "u" ? s.horizontal : 1,
    horizontalScrollbarSize: typeof s.horizontalScrollbarSize < "u" ? s.horizontalScrollbarSize : 10,
    horizontalSliderSize: typeof s.horizontalSliderSize < "u" ? s.horizontalSliderSize : 0,
    horizontalHasArrows: typeof s.horizontalHasArrows < "u" ? s.horizontalHasArrows : !1,
    vertical: typeof s.vertical < "u" ? s.vertical : 1,
    verticalScrollbarSize: typeof s.verticalScrollbarSize < "u" ? s.verticalScrollbarSize : 10,
    verticalHasArrows: typeof s.verticalHasArrows < "u" ? s.verticalHasArrows : !1,
    verticalSliderSize: typeof s.verticalSliderSize < "u" ? s.verticalSliderSize : 0,
    scrollByPage: typeof s.scrollByPage < "u" ? s.scrollByPage : !1
  };
  return e.horizontalSliderSize = typeof s.horizontalSliderSize < "u" ? s.horizontalSliderSize : e.horizontalScrollbarSize, e.verticalSliderSize = typeof s.verticalSliderSize < "u" ? s.verticalSliderSize : e.verticalScrollbarSize, $e && (e.className += " mac"), e;
}
var Ki;
(function(s) {
  function e(o, r) {
    if (o.start >= r.end || r.start >= o.end)
      return { start: 0, end: 0 };
    const a = Math.max(o.start, r.start), l = Math.min(o.end, r.end);
    return l - a <= 0 ? { start: 0, end: 0 } : { start: a, end: l };
  }
  s.intersect = e;
  function t(o) {
    return o.end - o.start <= 0;
  }
  s.isEmpty = t;
  function i(o, r) {
    return !t(e(o, r));
  }
  s.intersects = i;
  function n(o, r) {
    const a = [], l = { start: o.start, end: Math.min(r.start, o.end) }, c = { start: Math.max(r.end, o.start), end: o.end };
    return t(l) || a.push(l), t(c) || a.push(c), a;
  }
  s.relativeComplement = n;
})(Ki || (Ki = {}));
function sT(s, e) {
  const t = [];
  for (const i of e) {
    if (s.start >= i.range.end)
      continue;
    if (s.end < i.range.start)
      break;
    const n = Ki.intersect(s, i.range);
    Ki.isEmpty(n) || t.push({
      range: n,
      size: i.size
    });
  }
  return t;
}
function _S({ start: s, end: e }, t) {
  return { start: s + t, end: e + t };
}
function uH(s) {
  const e = [];
  let t = null;
  for (const i of s) {
    const n = i.range.start, o = i.range.end, r = i.size;
    if (t && r === t.size) {
      t.range.end = o;
      continue;
    }
    t = { range: { start: n, end: o }, size: r }, e.push(t);
  }
  return e;
}
function fH(...s) {
  return uH(s.reduce((e, t) => e.concat(t), []));
}
class gH {
  get paddingTop() {
    return this._paddingTop;
  }
  set paddingTop(e) {
    this._size = this._size + e - this._paddingTop, this._paddingTop = e;
  }
  constructor(e) {
    this.groups = [], this._size = 0, this._paddingTop = 0, this._paddingTop = e ?? 0, this._size = this._paddingTop;
  }
  splice(e, t, i = []) {
    const n = i.length - t, o = sT({ start: 0, end: e }, this.groups), r = sT({ start: e + t, end: Number.POSITIVE_INFINITY }, this.groups).map((l) => ({ range: _S(l.range, n), size: l.size })), a = i.map((l, c) => ({
      range: { start: e + c, end: e + c + 1 },
      size: l.size
    }));
    this.groups = fH(o, a, r), this._size = this._paddingTop + this.groups.reduce((l, c) => l + c.size * (c.range.end - c.range.start), 0);
  }
  /**
   * Returns the number of items in the range map.
   */
  get count() {
    const e = this.groups.length;
    return e ? this.groups[e - 1].range.end : 0;
  }
  /**
   * Returns the sum of the sizes of all items in the range map.
   */
  get size() {
    return this._size;
  }
  /**
   * Returns the index of the item at the given position.
   */
  indexAt(e) {
    if (e < 0)
      return -1;
    if (e < this._paddingTop)
      return 0;
    let t = 0, i = this._paddingTop;
    for (const n of this.groups) {
      const o = n.range.end - n.range.start, r = i + o * n.size;
      if (e < r)
        return t + Math.floor((e - i) / n.size);
      t += o, i = r;
    }
    return t;
  }
  /**
   * Returns the index of the item right after the item at the
   * index of the given position.
   */
  indexAfter(e) {
    return Math.min(this.indexAt(e) + 1, this.count);
  }
  /**
   * Returns the start position of the item at the given index.
   */
  positionAt(e) {
    if (e < 0)
      return -1;
    let t = 0, i = 0;
    for (const n of this.groups) {
      const o = n.range.end - n.range.start, r = i + o;
      if (e < r)
        return this._paddingTop + t + (e - i) * n.size;
      t += o * n.size, i = r;
    }
    return -1;
  }
}
class mH {
  constructor(e) {
    this.renderers = e, this.cache = /* @__PURE__ */ new Map(), this.transactionNodesPendingRemoval = /* @__PURE__ */ new Set(), this.inTransaction = !1;
  }
  /**
   * Returns a row either by creating a new one or reusing
   * a previously released row which shares the same templateId.
   *
   * @returns A row and `isReusingConnectedDomNode` if the row's node is already in the dom in a stale position.
   */
  alloc(e) {
    let t = this.getTemplateCache(e).pop(), i = !1;
    if (t)
      i = this.transactionNodesPendingRemoval.has(t.domNode), i && this.transactionNodesPendingRemoval.delete(t.domNode);
    else {
      const n = he(".monaco-list-row"), r = this.getRenderer(e).renderTemplate(n);
      t = { domNode: n, templateId: e, templateData: r };
    }
    return { row: t, isReusingConnectedDomNode: i };
  }
  /**
   * Releases the row for eventual reuse.
   */
  release(e) {
    e && this.releaseRow(e);
  }
  /**
   * Begin a set of changes that use the cache. This lets us skip work when a row is removed and then inserted again.
   */
  transact(e) {
    if (this.inTransaction)
      throw new Error("Already in transaction");
    this.inTransaction = !0;
    try {
      e();
    } finally {
      for (const t of this.transactionNodesPendingRemoval)
        this.doRemoveNode(t);
      this.transactionNodesPendingRemoval.clear(), this.inTransaction = !1;
    }
  }
  releaseRow(e) {
    const { domNode: t, templateId: i } = e;
    t && (this.inTransaction ? this.transactionNodesPendingRemoval.add(t) : this.doRemoveNode(t)), this.getTemplateCache(i).push(e);
  }
  doRemoveNode(e) {
    e.classList.remove("scrolling"), e.remove();
  }
  getTemplateCache(e) {
    let t = this.cache.get(e);
    return t || (t = [], this.cache.set(e, t)), t;
  }
  dispose() {
    this.cache.forEach((e, t) => {
      for (const i of e)
        this.getRenderer(t).disposeTemplate(i.templateData), i.templateData = null;
    }), this.cache.clear(), this.transactionNodesPendingRemoval.clear();
  }
  getRenderer(e) {
    const t = this.renderers.get(e);
    if (!t)
      throw new Error(`No renderer found for ${e}`);
    return t;
  }
}
var Qa = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
};
const fc = {
  CurrentDragAndDropData: void 0
}, lr = {
  useShadows: !0,
  verticalScrollMode: 1,
  setRowLineHeight: !0,
  setRowHeight: !0,
  supportDynamicHeights: !1,
  dnd: {
    getDragElements(s) {
      return [s];
    },
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return !1;
    },
    drop() {
    },
    dispose() {
    }
  },
  horizontalScrolling: !1,
  transformOptimization: !0,
  alwaysConsumeMouseWheel: !0
};
class Mp {
  constructor(e) {
    this.elements = e;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
}
class pH {
  constructor(e) {
    this.elements = e;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
}
class _H {
  constructor() {
    this.types = [], this.files = [];
  }
  update(e) {
    if (e.types && this.types.splice(0, this.types.length, ...e.types), e.files) {
      this.files.splice(0, this.files.length);
      for (let t = 0; t < e.files.length; t++) {
        const i = e.files.item(t);
        i && (i.size || i.type) && this.files.push(i);
      }
    }
  }
  getData() {
    return {
      types: this.types,
      files: this.files
    };
  }
}
function bH(s, e) {
  return Array.isArray(s) && Array.isArray(e) ? li(s, e) : s === e;
}
class CH {
  constructor(e) {
    e != null && e.getSetSize ? this.getSetSize = e.getSetSize.bind(e) : this.getSetSize = (t, i, n) => n, e != null && e.getPosInSet ? this.getPosInSet = e.getPosInSet.bind(e) : this.getPosInSet = (t, i) => i + 1, e != null && e.getRole ? this.getRole = e.getRole.bind(e) : this.getRole = (t) => "listitem", e != null && e.isChecked ? this.isChecked = e.isChecked.bind(e) : this.isChecked = (t) => {
    };
  }
}
const ZC = class ZC {
  get contentHeight() {
    return this.rangeMap.size;
  }
  get onDidScroll() {
    return this.scrollableElement.onScroll;
  }
  get scrollableElementDomNode() {
    return this.scrollableElement.getDomNode();
  }
  get horizontalScrolling() {
    return this._horizontalScrolling;
  }
  set horizontalScrolling(e) {
    if (e !== this._horizontalScrolling) {
      if (e && this.supportDynamicHeights)
        throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
      if (this._horizontalScrolling = e, this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this._horizontalScrolling) {
        for (const t of this.items)
          this.measureItemWidth(t);
        this.updateScrollWidth(), this.scrollableElement.setScrollDimensions({ width: m0(this.domNode) }), this.rowsContainer.style.width = `${Math.max(this.scrollWidth || 0, this.renderWidth)}px`;
      } else
        this.scrollableElementWidthDelayer.cancel(), this.scrollableElement.setScrollDimensions({ width: this.renderWidth, scrollWidth: this.renderWidth }), this.rowsContainer.style.width = "";
    }
  }
  constructor(e, t, i, n = lr) {
    var r, a;
    if (this.virtualDelegate = t, this.domId = `list_id_${++ZC.InstanceCount}`, this.renderers = /* @__PURE__ */ new Map(), this.renderWidth = 0, this._scrollHeight = 0, this.scrollableElementUpdateDisposable = null, this.scrollableElementWidthDelayer = new Np(50), this.splicing = !1, this.dragOverAnimationStopDisposable = U.None, this.dragOverMouseY = 0, this.canDrop = !1, this.currentDragFeedbackDisposable = U.None, this.onDragLeaveTimeout = U.None, this.disposables = new ne(), this._onDidChangeContentHeight = new A(), this._onDidChangeContentWidth = new A(), this.onDidChangeContentHeight = ee.latch(this._onDidChangeContentHeight.event, void 0, this.disposables), this._horizontalScrolling = !1, n.horizontalScrolling && n.supportDynamicHeights)
      throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
    this.items = [], this.itemId = 0, this.rangeMap = this.createRangeMap(n.paddingTop ?? 0);
    for (const l of i)
      this.renderers.set(l.templateId, l);
    this.cache = this.disposables.add(new mH(this.renderers)), this.lastRenderTop = 0, this.lastRenderHeight = 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-list", this.domNode.classList.add(this.domId), this.domNode.tabIndex = 0, this.domNode.classList.toggle("mouse-support", typeof n.mouseSupport == "boolean" ? n.mouseSupport : !0), this._horizontalScrolling = n.horizontalScrolling ?? lr.horizontalScrolling, this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this.paddingBottom = typeof n.paddingBottom > "u" ? 0 : n.paddingBottom, this.accessibilityProvider = new CH(n.accessibilityProvider), this.rowsContainer = document.createElement("div"), this.rowsContainer.className = "monaco-list-rows", (n.transformOptimization ?? lr.transformOptimization) && (this.rowsContainer.style.transform = "translate3d(0px, 0px, 0px)", this.rowsContainer.style.overflow = "hidden", this.rowsContainer.style.contain = "strict"), this.disposables.add(ln.addTarget(this.rowsContainer)), this.scrollable = this.disposables.add(new Pf({
      forceIntegerValues: !0,
      smoothScrollDuration: n.smoothScrolling ?? !1 ? 125 : 0,
      scheduleAtNextAnimationFrame: (l) => ns(fe(this.domNode), l)
    })), this.scrollableElement = this.disposables.add(new rw(this.rowsContainer, {
      alwaysConsumeMouseWheel: n.alwaysConsumeMouseWheel ?? lr.alwaysConsumeMouseWheel,
      horizontal: 1,
      vertical: n.verticalScrollMode ?? lr.verticalScrollMode,
      useShadows: n.useShadows ?? lr.useShadows,
      mouseWheelScrollSensitivity: n.mouseWheelScrollSensitivity,
      fastScrollSensitivity: n.fastScrollSensitivity,
      scrollByPage: n.scrollByPage
    }, this.scrollable)), this.domNode.appendChild(this.scrollableElement.getDomNode()), e.appendChild(this.domNode), this.scrollableElement.onScroll(this.onScroll, this, this.disposables), this.disposables.add(z(this.rowsContainer, vt.Change, (l) => this.onTouchChange(l))), this.disposables.add(z(this.scrollableElement.getDomNode(), "scroll", (l) => l.target.scrollTop = 0)), this.disposables.add(z(this.domNode, "dragover", (l) => this.onDragOver(this.toDragEvent(l)))), this.disposables.add(z(this.domNode, "drop", (l) => this.onDrop(this.toDragEvent(l)))), this.disposables.add(z(this.domNode, "dragleave", (l) => this.onDragLeave(this.toDragEvent(l)))), this.disposables.add(z(this.domNode, "dragend", (l) => this.onDragEnd(l))), this.setRowLineHeight = n.setRowLineHeight ?? lr.setRowLineHeight, this.setRowHeight = n.setRowHeight ?? lr.setRowHeight, this.supportDynamicHeights = n.supportDynamicHeights ?? lr.supportDynamicHeights, this.dnd = n.dnd ?? this.disposables.add(lr.dnd), this.layout((r = n.initialSize) == null ? void 0 : r.height, (a = n.initialSize) == null ? void 0 : a.width);
  }
  updateOptions(e) {
    e.paddingBottom !== void 0 && (this.paddingBottom = e.paddingBottom, this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight })), e.smoothScrolling !== void 0 && this.scrollable.setSmoothScrollDuration(e.smoothScrolling ? 125 : 0), e.horizontalScrolling !== void 0 && (this.horizontalScrolling = e.horizontalScrolling);
    let t;
    if (e.scrollByPage !== void 0 && (t = { ...t ?? {}, scrollByPage: e.scrollByPage }), e.mouseWheelScrollSensitivity !== void 0 && (t = { ...t ?? {}, mouseWheelScrollSensitivity: e.mouseWheelScrollSensitivity }), e.fastScrollSensitivity !== void 0 && (t = { ...t ?? {}, fastScrollSensitivity: e.fastScrollSensitivity }), t && this.scrollableElement.updateOptions(t), e.paddingTop !== void 0 && e.paddingTop !== this.rangeMap.paddingTop) {
      const i = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), n = e.paddingTop - this.rangeMap.paddingTop;
      this.rangeMap.paddingTop = e.paddingTop, this.render(i, Math.max(0, this.lastRenderTop + n), this.lastRenderHeight, void 0, void 0, !0), this.setScrollTop(this.lastRenderTop), this.eventuallyUpdateScrollDimensions(), this.supportDynamicHeights && this._rerender(this.lastRenderTop, this.lastRenderHeight);
    }
  }
  createRangeMap(e) {
    return new gH(e);
  }
  splice(e, t, i = []) {
    if (this.splicing)
      throw new Error("Can't run recursive splices.");
    this.splicing = !0;
    try {
      return this._splice(e, t, i);
    } finally {
      this.splicing = !1, this._onDidChangeContentHeight.fire(this.contentHeight);
    }
  }
  _splice(e, t, i = []) {
    const n = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), o = { start: e, end: e + t }, r = Ki.intersect(n, o), a = /* @__PURE__ */ new Map();
    for (let S = r.end - 1; S >= r.start; S--) {
      const L = this.items[S];
      if (L.dragStartDisposable.dispose(), L.checkedDisposable.dispose(), L.row) {
        let k = a.get(L.templateId);
        k || (k = [], a.set(L.templateId, k));
        const x = this.renderers.get(L.templateId);
        x && x.disposeElement && x.disposeElement(L.element, S, L.row.templateData, L.size), k.unshift(L.row);
      }
      L.row = null, L.stale = !0;
    }
    const l = { start: e + t, end: this.items.length }, c = Ki.intersect(l, n), h = Ki.relativeComplement(l, n), d = i.map((S) => ({
      id: String(this.itemId++),
      element: S,
      templateId: this.virtualDelegate.getTemplateId(S),
      size: this.virtualDelegate.getHeight(S),
      width: void 0,
      hasDynamicHeight: !!this.virtualDelegate.hasDynamicHeight && this.virtualDelegate.hasDynamicHeight(S),
      lastDynamicHeightWidth: void 0,
      row: null,
      uri: void 0,
      dropTarget: !1,
      dragStartDisposable: U.None,
      checkedDisposable: U.None,
      stale: !1
    }));
    let u;
    e === 0 && t >= this.items.length ? (this.rangeMap = this.createRangeMap(this.rangeMap.paddingTop), this.rangeMap.splice(0, 0, d), u = this.items, this.items = d) : (this.rangeMap.splice(e, t, d), u = this.items.splice(e, t, ...d));
    const f = i.length - t, g = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), p = _S(c, f), _ = Ki.intersect(g, p);
    for (let S = _.start; S < _.end; S++)
      this.updateItemInDOM(this.items[S], S);
    const b = Ki.relativeComplement(p, g);
    for (const S of b)
      for (let L = S.start; L < S.end; L++)
        this.removeItemFromDOM(L);
    const C = h.map((S) => _S(S, f)), v = [{ start: e, end: e + i.length }, ...C].map((S) => Ki.intersect(g, S)).reverse();
    for (const S of v)
      for (let L = S.end - 1; L >= S.start; L--) {
        const k = this.items[L], x = a.get(k.templateId), I = x == null ? void 0 : x.pop();
        this.insertItemInDOM(L, I);
      }
    for (const S of a.values())
      for (const L of S)
        this.cache.release(L);
    return this.eventuallyUpdateScrollDimensions(), this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight), u.map((S) => S.element);
  }
  eventuallyUpdateScrollDimensions() {
    this._scrollHeight = this.contentHeight, this.rowsContainer.style.height = `${this._scrollHeight}px`, this.scrollableElementUpdateDisposable || (this.scrollableElementUpdateDisposable = ns(fe(this.domNode), () => {
      this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight }), this.updateScrollWidth(), this.scrollableElementUpdateDisposable = null;
    }));
  }
  eventuallyUpdateScrollWidth() {
    if (!this.horizontalScrolling) {
      this.scrollableElementWidthDelayer.cancel();
      return;
    }
    this.scrollableElementWidthDelayer.trigger(() => this.updateScrollWidth());
  }
  updateScrollWidth() {
    if (!this.horizontalScrolling)
      return;
    let e = 0;
    for (const t of this.items)
      typeof t.width < "u" && (e = Math.max(e, t.width));
    this.scrollWidth = e, this.scrollableElement.setScrollDimensions({ scrollWidth: e === 0 ? 0 : e + 10 }), this._onDidChangeContentWidth.fire(this.scrollWidth);
  }
  rerender() {
    if (this.supportDynamicHeights) {
      for (const e of this.items)
        e.lastDynamicHeightWidth = void 0;
      this._rerender(this.lastRenderTop, this.lastRenderHeight);
    }
  }
  get length() {
    return this.items.length;
  }
  get renderHeight() {
    return this.scrollableElement.getScrollDimensions().height;
  }
  get firstVisibleIndex() {
    return this.getRenderRange(this.lastRenderTop, this.lastRenderHeight).start;
  }
  element(e) {
    return this.items[e].element;
  }
  indexOf(e) {
    return this.items.findIndex((t) => t.element === e);
  }
  domElement(e) {
    const t = this.items[e].row;
    return t && t.domNode;
  }
  elementHeight(e) {
    return this.items[e].size;
  }
  elementTop(e) {
    return this.rangeMap.positionAt(e);
  }
  indexAt(e) {
    return this.rangeMap.indexAt(e);
  }
  indexAfter(e) {
    return this.rangeMap.indexAfter(e);
  }
  layout(e, t) {
    const i = {
      height: typeof e == "number" ? e : q6(this.domNode)
    };
    this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, i.scrollHeight = this.scrollHeight), this.scrollableElement.setScrollDimensions(i), typeof t < "u" && (this.renderWidth = t, this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight)), this.horizontalScrolling && this.scrollableElement.setScrollDimensions({
      width: typeof t == "number" ? t : m0(this.domNode)
    });
  }
  // Render
  render(e, t, i, n, o, r = !1) {
    const a = this.getRenderRange(t, i), l = Ki.relativeComplement(a, e).reverse(), c = Ki.relativeComplement(e, a);
    if (r) {
      const h = Ki.intersect(e, a);
      for (let d = h.start; d < h.end; d++)
        this.updateItemInDOM(this.items[d], d);
    }
    this.cache.transact(() => {
      for (const h of c)
        for (let d = h.start; d < h.end; d++)
          this.removeItemFromDOM(d);
      for (const h of l)
        for (let d = h.end - 1; d >= h.start; d--)
          this.insertItemInDOM(d);
    }), n !== void 0 && (this.rowsContainer.style.left = `-${n}px`), this.rowsContainer.style.top = `-${t}px`, this.horizontalScrolling && o !== void 0 && (this.rowsContainer.style.width = `${Math.max(o, this.renderWidth)}px`), this.lastRenderTop = t, this.lastRenderHeight = i;
  }
  // DOM operations
  insertItemInDOM(e, t) {
    var l, c;
    const i = this.items[e];
    if (!i.row)
      if (t)
        i.row = t, i.stale = !0;
      else {
        const h = this.cache.alloc(i.templateId);
        i.row = h.row, i.stale || (i.stale = h.isReusingConnectedDomNode);
      }
    const n = this.accessibilityProvider.getRole(i.element) || "listitem";
    i.row.domNode.setAttribute("role", n);
    const o = this.accessibilityProvider.isChecked(i.element);
    if (typeof o == "boolean")
      i.row.domNode.setAttribute("aria-checked", String(!!o));
    else if (o) {
      const h = (d) => i.row.domNode.setAttribute("aria-checked", String(!!d));
      h(o.value), i.checkedDisposable = o.onDidChange(() => h(o.value));
    }
    if (i.stale || !i.row.domNode.parentElement) {
      const h = ((c = (l = this.items.at(e + 1)) == null ? void 0 : l.row) == null ? void 0 : c.domNode) ?? null;
      (i.row.domNode.parentElement !== this.rowsContainer || i.row.domNode.nextElementSibling !== h) && this.rowsContainer.insertBefore(i.row.domNode, h), i.stale = !1;
    }
    this.updateItemInDOM(i, e);
    const r = this.renderers.get(i.templateId);
    if (!r)
      throw new Error(`No renderer found for template id ${i.templateId}`);
    r == null || r.renderElement(i.element, e, i.row.templateData, i.size);
    const a = this.dnd.getDragURI(i.element);
    i.dragStartDisposable.dispose(), i.row.domNode.draggable = !!a, a && (i.dragStartDisposable = z(i.row.domNode, "dragstart", (h) => this.onDragStart(i.element, a, h))), this.horizontalScrolling && (this.measureItemWidth(i), this.eventuallyUpdateScrollWidth());
  }
  measureItemWidth(e) {
    if (!e.row || !e.row.domNode)
      return;
    e.row.domNode.style.width = "fit-content", e.width = m0(e.row.domNode);
    const t = fe(e.row.domNode).getComputedStyle(e.row.domNode);
    t.paddingLeft && (e.width += parseFloat(t.paddingLeft)), t.paddingRight && (e.width += parseFloat(t.paddingRight)), e.row.domNode.style.width = "";
  }
  updateItemInDOM(e, t) {
    e.row.domNode.style.top = `${this.elementTop(t)}px`, this.setRowHeight && (e.row.domNode.style.height = `${e.size}px`), this.setRowLineHeight && (e.row.domNode.style.lineHeight = `${e.size}px`), e.row.domNode.setAttribute("data-index", `${t}`), e.row.domNode.setAttribute("data-last-element", t === this.length - 1 ? "true" : "false"), e.row.domNode.setAttribute("data-parity", t % 2 === 0 ? "even" : "odd"), e.row.domNode.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(e.element, t, this.length))), e.row.domNode.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(e.element, t))), e.row.domNode.setAttribute("id", this.getElementDomId(t)), e.row.domNode.classList.toggle("drop-target", e.dropTarget);
  }
  removeItemFromDOM(e) {
    const t = this.items[e];
    if (t.dragStartDisposable.dispose(), t.checkedDisposable.dispose(), t.row) {
      const i = this.renderers.get(t.templateId);
      i && i.disposeElement && i.disposeElement(t.element, e, t.row.templateData, t.size), this.cache.release(t.row), t.row = null;
    }
    this.horizontalScrolling && this.eventuallyUpdateScrollWidth();
  }
  getScrollTop() {
    return this.scrollableElement.getScrollPosition().scrollTop;
  }
  setScrollTop(e, t) {
    this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight })), this.scrollableElement.setScrollPosition({ scrollTop: e, reuseAnimation: t });
  }
  get scrollTop() {
    return this.getScrollTop();
  }
  set scrollTop(e) {
    this.setScrollTop(e);
  }
  get scrollHeight() {
    return this._scrollHeight + (this.horizontalScrolling ? 10 : 0) + this.paddingBottom;
  }
  // Events
  get onMouseClick() {
    return ee.map(this.disposables.add(new He(this.domNode, "click")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseDblClick() {
    return ee.map(this.disposables.add(new He(this.domNode, "dblclick")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseMiddleClick() {
    return ee.filter(ee.map(this.disposables.add(new He(this.domNode, "auxclick")).event, (e) => this.toMouseEvent(e), this.disposables), (e) => e.browserEvent.button === 1, this.disposables);
  }
  get onMouseDown() {
    return ee.map(this.disposables.add(new He(this.domNode, "mousedown")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseOver() {
    return ee.map(this.disposables.add(new He(this.domNode, "mouseover")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseOut() {
    return ee.map(this.disposables.add(new He(this.domNode, "mouseout")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onContextMenu() {
    return ee.any(ee.map(this.disposables.add(new He(this.domNode, "contextmenu")).event, (e) => this.toMouseEvent(e), this.disposables), ee.map(this.disposables.add(new He(this.domNode, vt.Contextmenu)).event, (e) => this.toGestureEvent(e), this.disposables));
  }
  get onTouchStart() {
    return ee.map(this.disposables.add(new He(this.domNode, "touchstart")).event, (e) => this.toTouchEvent(e), this.disposables);
  }
  get onTap() {
    return ee.map(this.disposables.add(new He(this.rowsContainer, vt.Tap)).event, (e) => this.toGestureEvent(e), this.disposables);
  }
  toMouseEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
    return { browserEvent: e, index: t, element: n };
  }
  toTouchEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
    return { browserEvent: e, index: t, element: n };
  }
  toGestureEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.initialTarget || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
    return { browserEvent: e, index: t, element: n };
  }
  toDragEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element, o = this.getTargetSector(e, t);
    return { browserEvent: e, index: t, element: n, sector: o };
  }
  onScroll(e) {
    try {
      const t = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
      this.render(t, e.scrollTop, e.height, e.scrollLeft, e.scrollWidth), this.supportDynamicHeights && this._rerender(e.scrollTop, e.height, e.inSmoothScrolling);
    } catch (t) {
      throw console.error("Got bad scroll event:", e), t;
    }
  }
  onTouchChange(e) {
    e.preventDefault(), e.stopPropagation(), this.scrollTop -= e.translationY;
  }
  // DND
  onDragStart(e, t, i) {
    var o, r;
    if (!i.dataTransfer)
      return;
    const n = this.dnd.getDragElements(e);
    if (i.dataTransfer.effectAllowed = "copyMove", i.dataTransfer.setData(cO.TEXT, t), i.dataTransfer.setDragImage) {
      let a;
      this.dnd.getDragLabel && (a = this.dnd.getDragLabel(n, i)), typeof a > "u" && (a = String(n.length));
      const l = he(".monaco-drag-image");
      l.textContent = a, ((d) => {
        for (; d && !d.classList.contains("monaco-workbench"); )
          d = d.parentElement;
        return d || this.domNode.ownerDocument;
      })(this.domNode).appendChild(l), i.dataTransfer.setDragImage(l, -10, -10), setTimeout(() => l.remove(), 0);
    }
    this.domNode.classList.add("dragging"), this.currentDragData = new Mp(n), fc.CurrentDragAndDropData = new pH(n), (r = (o = this.dnd).onDragStart) == null || r.call(o, this.currentDragData, i);
  }
  onDragOver(e) {
    var o, r;
    if (e.browserEvent.preventDefault(), this.onDragLeaveTimeout.dispose(), fc.CurrentDragAndDropData && fc.CurrentDragAndDropData.getData() === "vscode-ui" || (this.setupDragAndDropScrollTopAnimation(e.browserEvent), !e.browserEvent.dataTransfer))
      return !1;
    if (!this.currentDragData)
      if (fc.CurrentDragAndDropData)
        this.currentDragData = fc.CurrentDragAndDropData;
      else {
        if (!e.browserEvent.dataTransfer.types)
          return !1;
        this.currentDragData = new _H();
      }
    const t = this.dnd.onDragOver(this.currentDragData, e.element, e.index, e.sector, e.browserEvent);
    if (this.canDrop = typeof t == "boolean" ? t : t.accept, !this.canDrop)
      return this.currentDragFeedback = void 0, this.currentDragFeedbackDisposable.dispose(), !1;
    e.browserEvent.dataTransfer.dropEffect = typeof t != "boolean" && ((o = t.effect) == null ? void 0 : o.type) === 0 ? "copy" : "move";
    let i;
    typeof t != "boolean" && t.feedback ? i = t.feedback : typeof e.index > "u" ? i = [-1] : i = [e.index], i = zh(i).filter((a) => a >= -1 && a < this.length).sort((a, l) => a - l), i = i[0] === -1 ? [-1] : i;
    let n = typeof t != "boolean" && t.effect && t.effect.position ? t.effect.position : "drop-target";
    if (bH(this.currentDragFeedback, i) && this.currentDragFeedbackPosition === n)
      return !0;
    if (this.currentDragFeedback = i, this.currentDragFeedbackPosition = n, this.currentDragFeedbackDisposable.dispose(), i[0] === -1)
      this.domNode.classList.add(n), this.rowsContainer.classList.add(n), this.currentDragFeedbackDisposable = _e(() => {
        this.domNode.classList.remove(n), this.rowsContainer.classList.remove(n);
      });
    else {
      if (i.length > 1 && n !== "drop-target")
        throw new Error("Can't use multiple feedbacks with position different than 'over'");
      n === "drop-target-after" && i[0] < this.length - 1 && (i[0] += 1, n = "drop-target-before");
      for (const a of i) {
        const l = this.items[a];
        l.dropTarget = !0, (r = l.row) == null || r.domNode.classList.add(n);
      }
      this.currentDragFeedbackDisposable = _e(() => {
        var a;
        for (const l of i) {
          const c = this.items[l];
          c.dropTarget = !1, (a = c.row) == null || a.domNode.classList.remove(n);
        }
      });
    }
    return !0;
  }
  onDragLeave(e) {
    var t, i;
    this.onDragLeaveTimeout.dispose(), this.onDragLeaveTimeout = Kb(() => this.clearDragOverFeedback(), 100, this.disposables), this.currentDragData && ((i = (t = this.dnd).onDragLeave) == null || i.call(t, this.currentDragData, e.element, e.index, e.browserEvent));
  }
  onDrop(e) {
    if (!this.canDrop)
      return;
    const t = this.currentDragData;
    this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.domNode.classList.remove("dragging"), this.currentDragData = void 0, fc.CurrentDragAndDropData = void 0, !(!t || !e.browserEvent.dataTransfer) && (e.browserEvent.preventDefault(), t.update(e.browserEvent.dataTransfer), this.dnd.drop(t, e.element, e.index, e.sector, e.browserEvent));
  }
  onDragEnd(e) {
    var t, i;
    this.canDrop = !1, this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.domNode.classList.remove("dragging"), this.currentDragData = void 0, fc.CurrentDragAndDropData = void 0, (i = (t = this.dnd).onDragEnd) == null || i.call(t, e);
  }
  clearDragOverFeedback() {
    this.currentDragFeedback = void 0, this.currentDragFeedbackPosition = void 0, this.currentDragFeedbackDisposable.dispose(), this.currentDragFeedbackDisposable = U.None;
  }
  // DND scroll top animation
  setupDragAndDropScrollTopAnimation(e) {
    if (!this.dragOverAnimationDisposable) {
      const t = j6(this.domNode).top;
      this.dragOverAnimationDisposable = oB(fe(this.domNode), this.animateDragAndDropScrollTop.bind(this, t));
    }
    this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationStopDisposable = Kb(() => {
      this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
    }, 1e3, this.disposables), this.dragOverMouseY = e.pageY;
  }
  animateDragAndDropScrollTop(e) {
    if (this.dragOverMouseY === void 0)
      return;
    const t = this.dragOverMouseY - e, i = this.renderHeight - 35;
    t < 35 ? this.scrollTop += Math.max(-14, Math.floor(0.3 * (t - 35))) : t > i && (this.scrollTop += Math.min(14, Math.floor(0.3 * (t - i))));
  }
  teardownDragAndDropScrollTopAnimation() {
    this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
  }
  // Util
  getTargetSector(e, t) {
    if (t === void 0)
      return;
    const i = e.offsetY / this.items[t].size, n = Math.floor(i / 0.25);
    return Dn(n, 0, 3);
  }
  getItemIndexFromEventTarget(e) {
    const t = this.scrollableElement.getDomNode();
    let i = e;
    for (; (ki(i) || Q6(i)) && i !== this.rowsContainer && t.contains(i); ) {
      const n = i.getAttribute("data-index");
      if (n) {
        const o = Number(n);
        if (!isNaN(o))
          return o;
      }
      i = i.parentElement;
    }
  }
  getRenderRange(e, t) {
    return {
      start: this.rangeMap.indexAt(e),
      end: this.rangeMap.indexAfter(e + t - 1)
    };
  }
  /**
   * Given a stable rendered state, checks every rendered element whether it needs
   * to be probed for dynamic height. Adjusts scroll height and top if necessary.
   */
  _rerender(e, t, i) {
    const n = this.getRenderRange(e, t);
    let o, r;
    e === this.elementTop(n.start) ? (o = n.start, r = 0) : n.end - n.start > 1 && (o = n.start + 1, r = this.elementTop(o) - e);
    let a = 0;
    for (; ; ) {
      const l = this.getRenderRange(e, t);
      let c = !1;
      for (let h = l.start; h < l.end; h++) {
        const d = this.probeDynamicHeight(h);
        d !== 0 && this.rangeMap.splice(h, 1, [this.items[h]]), a += d, c = c || d !== 0;
      }
      if (!c) {
        a !== 0 && this.eventuallyUpdateScrollDimensions();
        const h = Ki.relativeComplement(n, l);
        for (const u of h)
          for (let f = u.start; f < u.end; f++)
            this.items[f].row && this.removeItemFromDOM(f);
        const d = Ki.relativeComplement(l, n).reverse();
        for (const u of d)
          for (let f = u.end - 1; f >= u.start; f--)
            this.insertItemInDOM(f);
        for (let u = l.start; u < l.end; u++)
          this.items[u].row && this.updateItemInDOM(this.items[u], u);
        if (typeof o == "number") {
          const u = this.scrollable.getFutureScrollPosition().scrollTop - e, f = this.elementTop(o) - r + u;
          this.setScrollTop(f, i);
        }
        this._onDidChangeContentHeight.fire(this.contentHeight);
        return;
      }
    }
  }
  probeDynamicHeight(e) {
    var r, a, l;
    const t = this.items[e];
    if (this.virtualDelegate.getDynamicHeight) {
      const c = this.virtualDelegate.getDynamicHeight(t.element);
      if (c !== null) {
        const h = t.size;
        return t.size = c, t.lastDynamicHeightWidth = this.renderWidth, c - h;
      }
    }
    if (!t.hasDynamicHeight || t.lastDynamicHeightWidth === this.renderWidth || this.virtualDelegate.hasDynamicHeight && !this.virtualDelegate.hasDynamicHeight(t.element))
      return 0;
    const i = t.size;
    if (t.row)
      return t.row.domNode.style.height = "", t.size = t.row.domNode.offsetHeight, t.size === 0 && !_i(t.row.domNode, fe(t.row.domNode).document.body) && console.warn("Measuring item node that is not in DOM! Add ListView to the DOM before measuring row height!", new Error().stack), t.lastDynamicHeightWidth = this.renderWidth, t.size - i;
    const { row: n } = this.cache.alloc(t.templateId);
    n.domNode.style.height = "", this.rowsContainer.appendChild(n.domNode);
    const o = this.renderers.get(t.templateId);
    if (!o)
      throw new at("Missing renderer for templateId: " + t.templateId);
    return o.renderElement(t.element, e, n.templateData, void 0), t.size = n.domNode.offsetHeight, (r = o.disposeElement) == null || r.call(o, t.element, e, n.templateData, void 0), (l = (a = this.virtualDelegate).setDynamicHeight) == null || l.call(a, t.element, t.size), t.lastDynamicHeightWidth = this.renderWidth, n.domNode.remove(), this.cache.release(n), t.size - i;
  }
  getElementDomId(e) {
    return `${this.domId}_${e}`;
  }
  // Dispose
  dispose() {
    var e, t, i;
    for (const n of this.items)
      if (n.dragStartDisposable.dispose(), n.checkedDisposable.dispose(), n.row) {
        const o = this.renderers.get(n.row.templateId);
        o && ((e = o.disposeElement) == null || e.call(o, n.element, -1, n.row.templateData, void 0), o.disposeTemplate(n.row.templateData));
      }
    this.items = [], (t = this.domNode) == null || t.remove(), (i = this.dragOverAnimationDisposable) == null || i.dispose(), this.disposables.dispose();
  }
};
ZC.InstanceCount = 0;
let go = ZC;
Qa([
  Yt
], go.prototype, "onMouseClick", null);
Qa([
  Yt
], go.prototype, "onMouseDblClick", null);
Qa([
  Yt
], go.prototype, "onMouseMiddleClick", null);
Qa([
  Yt
], go.prototype, "onMouseDown", null);
Qa([
  Yt
], go.prototype, "onMouseOver", null);
Qa([
  Yt
], go.prototype, "onMouseOut", null);
Qa([
  Yt
], go.prototype, "onContextMenu", null);
Qa([
  Yt
], go.prototype, "onTouchStart", null);
Qa([
  Yt
], go.prototype, "onTap", null);
const mo = (s, e) => s === e;
function vH(s = mo) {
  return (e, t) => li(e, t, s);
}
function oT(s, e, t) {
  {
    const i = s;
    return (n, o) => n == null || o === void 0 || o === null ? o === n : i(n, o);
  }
}
class Cn {
  constructor(e, t, i) {
    this.owner = e, this.debugNameSource = t, this.referenceFn = i;
  }
  getDebugName(e) {
    return wH(e, this);
  }
}
const rT = /* @__PURE__ */ new Map(), bS = /* @__PURE__ */ new WeakMap();
function wH(s, e) {
  const t = bS.get(s);
  if (t)
    return t;
  const i = yH(s, e);
  if (i) {
    let n = rT.get(i) ?? 0;
    n++, rT.set(i, n);
    const o = n === 1 ? i : `${i}#${n}`;
    return bS.set(s, o), o;
  }
}
function yH(s, e) {
  const t = bS.get(s);
  if (t)
    return t;
  const i = e.owner ? LH(e.owner) + "." : "";
  let n;
  const o = e.debugNameSource;
  if (o !== void 0)
    if (typeof o == "function") {
      if (n = o(), n !== void 0)
        return i + n;
    } else
      return i + o;
  const r = e.referenceFn;
  if (r !== void 0 && (n = GE(r), n !== void 0))
    return i + n;
  if (e.owner !== void 0) {
    const a = SH(e.owner, s);
    if (a !== void 0)
      return i + a;
  }
}
function SH(s, e) {
  for (const t in s)
    if (s[t] === e)
      return t;
}
const aT = /* @__PURE__ */ new Map(), lT = /* @__PURE__ */ new WeakMap();
function LH(s) {
  const e = lT.get(s);
  if (e)
    return e;
  const t = kH(s);
  let i = aT.get(t) ?? 0;
  i++, aT.set(t, i);
  const n = i === 1 ? t : `${t}#${i}`;
  return lT.set(s, n), n;
}
function kH(s) {
  const e = s.constructor;
  return e ? e.name : "Object";
}
function GE(s) {
  const e = s.toString(), i = /\/\*\*\s*@description\s*([^*]*)\*\//.exec(e), n = i ? i[1] : void 0;
  return n == null ? void 0 : n.trim();
}
let xH;
function kO() {
  return xH;
}
let xO;
function DH(s) {
  xO = s;
}
let DO;
function EH(s) {
  DO = s;
}
let CS;
function IH(s) {
  CS = s;
}
class EO {
  get TChange() {
    return null;
  }
  reportChanges() {
    this.get();
  }
  /** @sealed */
  read(e) {
    return e ? e.readObservable(this) : this.get();
  }
  map(e, t) {
    const i = t === void 0 ? void 0 : e, n = t === void 0 ? e : t;
    return CS({
      owner: i,
      debugName: () => {
        const o = GE(n);
        if (o !== void 0)
          return o;
        const a = /^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/.exec(n.toString());
        if (a)
          return `${this.debugName}.${a[2]}`;
        if (!i)
          return `${this.debugName} (mapped)`;
      },
      debugReferenceFn: n
    }, (o) => n(this.read(o), o));
  }
  /**
   * @sealed
   * Converts an observable of an observable value into a direct observable of the value.
  */
  flatten() {
    return CS({
      owner: void 0,
      debugName: () => `${this.debugName} (flattened)`
    }, (e) => this.read(e).read(e));
  }
  recomputeInitiallyAndOnChange(e, t) {
    return e.add(xO(this, t)), this;
  }
  /**
   * Ensures that this observable is observed. This keeps the cache alive.
   * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).
   * Use `recomputeInitiallyAndOnChange` for eager evaluation.
   */
  keepObserved(e) {
    return e.add(DO(this)), this;
  }
}
class Of extends EO {
  constructor() {
    super(...arguments), this.observers = /* @__PURE__ */ new Set();
  }
  addObserver(e) {
    const t = this.observers.size;
    this.observers.add(e), t === 0 && this.onFirstObserverAdded();
  }
  removeObserver(e) {
    this.observers.delete(e) && this.observers.size === 0 && this.onLastObserverRemoved();
  }
  onFirstObserverAdded() {
  }
  onLastObserverRemoved() {
  }
}
function bi(s, e) {
  const t = new Rp(s, e);
  try {
    s(t);
  } finally {
    t.finish();
  }
}
let f_;
function _g(s) {
  if (f_)
    s(f_);
  else {
    const e = new Rp(s, void 0);
    f_ = e;
    try {
      s(e);
    } finally {
      e.finish(), f_ = void 0;
    }
  }
}
function ZE(s, e, t) {
  s ? e(s) : bi(e, t);
}
class Rp {
  constructor(e, t) {
    this._fn = e, this._getDebugName = t, this.updatingObservers = [];
  }
  getDebugName() {
    return this._getDebugName ? this._getDebugName() : GE(this._fn);
  }
  updateObserver(e, t) {
    this.updatingObservers.push({ observer: e, observable: t }), e.beginUpdate(t);
  }
  finish() {
    const e = this.updatingObservers;
    for (let t = 0; t < e.length; t++) {
      const { observer: i, observable: n } = e[t];
      i.endUpdate(n);
    }
    this.updatingObservers = null;
  }
}
function it(s, e) {
  let t;
  return typeof s == "string" ? t = new Cn(void 0, s, void 0) : t = new Cn(s, void 0, void 0), new YE(t, e, mo);
}
class YE extends Of {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "ObservableValue";
  }
  constructor(e, t, i) {
    super(), this._debugNameData = e, this._equalityComparator = i, this._value = t;
  }
  get() {
    return this._value;
  }
  set(e, t, i) {
    var o;
    if (i === void 0 && this._equalityComparator(this._value, e))
      return;
    let n;
    t || (t = n = new Rp(() => {
    }, () => `Setting ${this.debugName}`));
    try {
      const r = this._value;
      this._setValue(e), (o = kO()) == null || o.handleObservableChanged(this, { oldValue: r, newValue: e, change: i, didChange: !0, hadValue: !0 });
      for (const a of this.observers)
        t.updateObserver(a, this), a.handleChange(this, i);
    } finally {
      n && n.finish();
    }
  }
  toString() {
    return `${this.debugName}: ${this._value}`;
  }
  _setValue(e) {
    this._value = e;
  }
}
function IO(s, e) {
  let t;
  return typeof s == "string" ? t = new Cn(void 0, s, void 0) : t = new Cn(s, void 0, void 0), new NH(t, e, mo);
}
class NH extends YE {
  _setValue(e) {
    this._value !== e && (this._value && this._value.dispose(), this._value = e);
  }
  dispose() {
    var e;
    (e = this._value) == null || e.dispose();
  }
}
function xe(s, e) {
  return e !== void 0 ? new cf(new Cn(s, void 0, e), e, void 0, void 0, void 0, mo) : new cf(new Cn(void 0, void 0, s), s, void 0, void 0, void 0, mo);
}
function XE(s, e, t) {
  return new TH(new Cn(s, void 0, e), e, void 0, void 0, void 0, mo, t);
}
function aw(s, e) {
  return new cf(new Cn(s.owner, s.debugName, s.debugReferenceFn), e, void 0, void 0, s.onLastObserverRemoved, s.equalsFn ?? mo);
}
IH(aw);
function rd(s, e) {
  let t, i;
  e === void 0 ? (t = s, i = void 0) : (i = s, t = e);
  const n = new ne();
  return new cf(new Cn(i, void 0, t), (o) => (n.clear(), t(o, n)), void 0, void 0, () => n.dispose(), mo);
}
function mr(s, e) {
  let t, i;
  e === void 0 ? (t = s, i = void 0) : (i = s, t = e);
  let n;
  return new cf(new Cn(i, void 0, t), (o) => {
    n ? n.clear() : n = new ne();
    const r = t(o);
    return r && n.add(r), r;
  }, void 0, void 0, () => {
    n && (n.dispose(), n = void 0);
  }, mo);
}
class cf extends Of {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "(anonymous)";
  }
  constructor(e, t, i, n, o = void 0, r) {
    var a;
    super(), this._debugNameData = e, this._computeFn = t, this.createChangeSummary = i, this._handleChange = n, this._handleLastObserverRemoved = o, this._equalityComparator = r, this.state = 0, this.value = void 0, this.updateCount = 0, this.dependencies = /* @__PURE__ */ new Set(), this.dependenciesToBeRemoved = /* @__PURE__ */ new Set(), this.changeSummary = void 0, this.changeSummary = (a = this.createChangeSummary) == null ? void 0 : a.call(this);
  }
  onLastObserverRemoved() {
    var e;
    this.state = 0, this.value = void 0;
    for (const t of this.dependencies)
      t.removeObserver(this);
    this.dependencies.clear(), (e = this._handleLastObserverRemoved) == null || e.call(this);
  }
  get() {
    var e;
    if (this.observers.size === 0) {
      const t = this._computeFn(this, (e = this.createChangeSummary) == null ? void 0 : e.call(this));
      return this.onLastObserverRemoved(), t;
    } else {
      do {
        if (this.state === 1) {
          for (const t of this.dependencies)
            if (t.reportChanges(), this.state === 2)
              break;
        }
        this.state === 1 && (this.state = 3), this._recomputeIfNeeded();
      } while (this.state !== 3);
      return this.value;
    }
  }
  _recomputeIfNeeded() {
    var r;
    if (this.state === 3)
      return;
    const e = this.dependenciesToBeRemoved;
    this.dependenciesToBeRemoved = this.dependencies, this.dependencies = e;
    const t = this.state !== 0, i = this.value;
    this.state = 3;
    const n = this.changeSummary;
    this.changeSummary = (r = this.createChangeSummary) == null ? void 0 : r.call(this);
    try {
      this.value = this._computeFn(this, n);
    } finally {
      for (const a of this.dependenciesToBeRemoved)
        a.removeObserver(this);
      this.dependenciesToBeRemoved.clear();
    }
    if (t && !this._equalityComparator(i, this.value))
      for (const a of this.observers)
        a.handleChange(this, void 0);
  }
  toString() {
    return `LazyDerived<${this.debugName}>`;
  }
  // IObserver Implementation
  beginUpdate(e) {
    this.updateCount++;
    const t = this.updateCount === 1;
    if (this.state === 3 && (this.state = 1, !t))
      for (const i of this.observers)
        i.handlePossibleChange(this);
    if (t)
      for (const i of this.observers)
        i.beginUpdate(this);
  }
  endUpdate(e) {
    if (this.updateCount--, this.updateCount === 0) {
      const t = [...this.observers];
      for (const i of t)
        i.endUpdate(this);
    }
    Wh(() => this.updateCount >= 0);
  }
  handlePossibleChange(e) {
    if (this.state === 3 && this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e)) {
      this.state = 1;
      for (const t of this.observers)
        t.handlePossibleChange(this);
    }
  }
  handleChange(e, t) {
    if (this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e)) {
      const i = this._handleChange ? this._handleChange({
        changedObservable: e,
        change: t,
        didChange: (o) => o === e
      }, this.changeSummary) : !0, n = this.state === 3;
      if (i && (this.state === 1 || n) && (this.state = 2, n))
        for (const o of this.observers)
          o.handlePossibleChange(this);
    }
  }
  // IReader Implementation
  readObservable(e) {
    e.addObserver(this);
    const t = e.get();
    return this.dependencies.add(e), this.dependenciesToBeRemoved.delete(e), t;
  }
  addObserver(e) {
    const t = !this.observers.has(e) && this.updateCount > 0;
    super.addObserver(e), t && e.beginUpdate(this);
  }
  removeObserver(e) {
    const t = this.observers.has(e) && this.updateCount > 0;
    super.removeObserver(e), t && e.endUpdate(this);
  }
}
class TH extends cf {
  constructor(e, t, i, n, o = void 0, r, a) {
    super(e, t, i, n, o, r), this.set = a;
  }
}
function Qe(s) {
  return new hw(new Cn(void 0, void 0, s), s, void 0, void 0);
}
function lw(s, e) {
  return new hw(new Cn(s.owner, s.debugName, s.debugReferenceFn ?? e), e, void 0, void 0);
}
function cw(s, e) {
  return new hw(new Cn(s.owner, s.debugName, s.debugReferenceFn ?? e), e, s.createEmptyChangeSummary, s.handleChange);
}
function ho(s) {
  const e = new ne(), t = lw({
    owner: void 0,
    debugName: void 0,
    debugReferenceFn: s
  }, (i) => {
    e.clear(), s(i, e);
  });
  return _e(() => {
    t.dispose(), e.dispose();
  });
}
class hw {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "(anonymous)";
  }
  constructor(e, t, i, n) {
    var o;
    this._debugNameData = e, this._runFn = t, this.createChangeSummary = i, this._handleChange = n, this.state = 2, this.updateCount = 0, this.disposed = !1, this.dependencies = /* @__PURE__ */ new Set(), this.dependenciesToBeRemoved = /* @__PURE__ */ new Set(), this.changeSummary = (o = this.createChangeSummary) == null ? void 0 : o.call(this), this._runIfNeeded();
  }
  dispose() {
    this.disposed = !0;
    for (const e of this.dependencies)
      e.removeObserver(this);
    this.dependencies.clear();
  }
  _runIfNeeded() {
    var i, n;
    if (this.state === 3)
      return;
    const e = this.dependenciesToBeRemoved;
    this.dependenciesToBeRemoved = this.dependencies, this.dependencies = e, this.state = 3;
    const t = this.disposed;
    try {
      if (!t) {
        (i = kO()) == null || i.handleAutorunTriggered(this);
        const o = this.changeSummary;
        this.changeSummary = (n = this.createChangeSummary) == null ? void 0 : n.call(this), this._runFn(this, o);
      }
    } finally {
      for (const o of this.dependenciesToBeRemoved)
        o.removeObserver(this);
      this.dependenciesToBeRemoved.clear();
    }
  }
  toString() {
    return `Autorun<${this.debugName}>`;
  }
  // IObserver implementation
  beginUpdate() {
    this.state === 3 && (this.state = 1), this.updateCount++;
  }
  endUpdate() {
    if (this.updateCount === 1)
      do {
        if (this.state === 1) {
          this.state = 3;
          for (const e of this.dependencies)
            if (e.reportChanges(), this.state === 2)
              break;
        }
        this._runIfNeeded();
      } while (this.state !== 3);
    this.updateCount--, Wh(() => this.updateCount >= 0);
  }
  handlePossibleChange(e) {
    this.state === 3 && this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e) && (this.state = 1);
  }
  handleChange(e, t) {
    this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e) && (!this._handleChange || this._handleChange({
      changedObservable: e,
      change: t,
      didChange: (n) => n === e
    }, this.changeSummary)) && (this.state = 2);
  }
  // IReader implementation
  readObservable(e) {
    if (this.disposed)
      return e.get();
    e.addObserver(this);
    const t = e.get();
    return this.dependencies.add(e), this.dependenciesToBeRemoved.delete(e), t;
  }
}
(function(s) {
  s.Observer = hw;
})(Qe || (Qe = {}));
function n1(s) {
  return new MH(s);
}
class MH extends EO {
  constructor(e) {
    super(), this.value = e;
  }
  get debugName() {
    return this.toString();
  }
  get() {
    return this.value;
  }
  addObserver(e) {
  }
  removeObserver(e) {
  }
  toString() {
    return `Const: ${this.value}`;
  }
}
function zt(...s) {
  let e, t, i;
  return s.length === 3 ? [e, t, i] = s : [t, i] = s, new Yd(new Cn(e, void 0, i), t, i, () => Yd.globalTransaction, mo);
}
class Yd extends Of {
  constructor(e, t, i, n, o) {
    super(), this._debugNameData = e, this.event = t, this._getValue = i, this._getTransaction = n, this._equalityComparator = o, this.hasValue = !1, this.handleEvent = (r) => {
      const a = this._getValue(r), l = this.value;
      (!this.hasValue || !this._equalityComparator(l, a)) && (this.value = a, this.hasValue && ZE(this._getTransaction(), (h) => {
        for (const d of this.observers)
          h.updateObserver(d, this), d.handleChange(this, void 0);
      }, () => {
        const h = this.getDebugName();
        return "Event fired" + (h ? `: ${h}` : "");
      }), this.hasValue = !0);
    };
  }
  getDebugName() {
    return this._debugNameData.getDebugName(this);
  }
  get debugName() {
    const e = this.getDebugName();
    return "From Event" + (e ? `: ${e}` : "");
  }
  onFirstObserverAdded() {
    this.subscription = this.event(this.handleEvent);
  }
  onLastObserverRemoved() {
    this.subscription.dispose(), this.subscription = void 0, this.hasValue = !1, this.value = void 0;
  }
  get() {
    return this.subscription ? (this.hasValue || this.handleEvent(void 0), this.value) : this._getValue(void 0);
  }
}
(function(s) {
  s.Observer = Yd;
  function e(t, i) {
    let n = !1;
    Yd.globalTransaction === void 0 && (Yd.globalTransaction = t, n = !0);
    try {
      i();
    } finally {
      n && (Yd.globalTransaction = void 0);
    }
  }
  s.batchEventsGlobally = e;
})(zt || (zt = {}));
function Ms(s, e) {
  return new RH(s, e);
}
class RH extends Of {
  constructor(e, t) {
    super(), this.debugName = e, this.event = t, this.handleEvent = () => {
      bi((i) => {
        for (const n of this.observers)
          i.updateObserver(n, this), n.handleChange(this, void 0);
      }, () => this.debugName);
    };
  }
  onFirstObserverAdded() {
    this.subscription = this.event(this.handleEvent);
  }
  onLastObserverRemoved() {
    this.subscription.dispose(), this.subscription = void 0;
  }
  get() {
  }
}
function QE(s) {
  return typeof s == "string" ? new cT(s) : new cT(void 0, s);
}
class cT extends Of {
  get debugName() {
    return new Cn(this._owner, this._debugName, void 0).getDebugName(this) ?? "Observable Signal";
  }
  toString() {
    return this.debugName;
  }
  constructor(e, t) {
    super(), this._debugName = e, this._owner = t;
  }
  trigger(e, t) {
    if (!e) {
      bi((i) => {
        this.trigger(i, t);
      }, () => `Trigger signal ${this.debugName}`);
      return;
    }
    for (const i of this.observers)
      e.updateObserver(i, this), i.handleChange(this, t);
  }
  get() {
  }
}
function AH(s) {
  const e = new NO(!1, void 0);
  return s.addObserver(e), _e(() => {
    s.removeObserver(e);
  });
}
EH(AH);
function dw(s, e) {
  const t = new NO(!0, e);
  return s.addObserver(t), e ? e(s.get()) : s.reportChanges(), _e(() => {
    s.removeObserver(t);
  });
}
DH(dw);
class NO {
  constructor(e, t) {
    this._forceRecompute = e, this._handleValue = t, this._counter = 0;
  }
  beginUpdate(e) {
    this._counter++;
  }
  endUpdate(e) {
    this._counter--, this._counter === 0 && this._forceRecompute && (this._handleValue ? this._handleValue(e.get()) : e.reportChanges());
  }
  handlePossibleChange(e) {
  }
  handleChange(e, t) {
  }
}
function TO(s, e) {
  let t;
  return aw({ owner: s, debugReferenceFn: e }, (n) => (t = e(n, t), t));
}
function PH(s, e) {
  return TO(s, (t, i) => i ?? e(t));
}
function OH(s, e, t, i) {
  return e || (e = (n) => n != null), new Promise((n, o) => {
    let r = !0, a = !1;
    const l = s.map((h) => ({
      isFinished: e(h),
      error: !1,
      state: h
    })), c = Qe((h) => {
      const { isFinished: d, error: u, state: f } = l.read(h);
      (d || u) && (r ? a = !0 : c.dispose(), u ? o(u === !0 ? f : u) : n(f));
    });
    r = !1, a && c.dispose();
  });
}
class FH extends Of {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "LazyObservableValue";
  }
  constructor(e, t, i) {
    super(), this._debugNameData = e, this._equalityComparator = i, this._isUpToDate = !0, this._deltas = [], this._updateCounter = 0, this._value = t;
  }
  get() {
    return this._update(), this._value;
  }
  _update() {
    if (!this._isUpToDate)
      if (this._isUpToDate = !0, this._deltas.length > 0) {
        for (const e of this.observers)
          for (const t of this._deltas)
            e.handleChange(this, t);
        this._deltas.length = 0;
      } else
        for (const e of this.observers)
          e.handleChange(this, void 0);
  }
  _beginUpdate() {
    if (this._updateCounter++, this._updateCounter === 1)
      for (const e of this.observers)
        e.beginUpdate(this);
  }
  _endUpdate() {
    if (this._updateCounter--, this._updateCounter === 0) {
      this._update();
      const e = [...this.observers];
      for (const t of e)
        t.endUpdate(this);
    }
  }
  addObserver(e) {
    const t = !this.observers.has(e) && this._updateCounter > 0;
    super.addObserver(e), t && e.beginUpdate(this);
  }
  removeObserver(e) {
    const t = this.observers.has(e) && this._updateCounter > 0;
    super.removeObserver(e), t && e.endUpdate(this);
  }
  set(e, t, i) {
    if (i === void 0 && this._equalityComparator(this._value, e))
      return;
    let n;
    t || (t = n = new Rp(() => {
    }, () => `Setting ${this.debugName}`));
    try {
      if (this._isUpToDate = !1, this._setValue(e), i !== void 0 && this._deltas.push(i), t.updateObserver({
        beginUpdate: () => this._beginUpdate(),
        endUpdate: () => this._endUpdate(),
        handleChange: (o, r) => {
        },
        handlePossibleChange: (o) => {
        }
      }, this), this._updateCounter > 1)
        for (const o of this.observers)
          o.handlePossibleChange(this);
    } finally {
      n && n.finish();
    }
  }
  toString() {
    return `${this.debugName}: ${this._value}`;
  }
  _setValue(e) {
    this._value = e;
  }
}
function vS(s, e) {
  return s.lazy ? new FH(new Cn(s.owner, s.debugName, void 0), e, s.equalsFn ?? mo) : new YE(new Cn(s.owner, s.debugName, void 0), e, s.equalsFn ?? mo);
}
var sc = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
};
class BH {
  constructor(e) {
    this.trait = e, this.renderedElements = [];
  }
  get templateId() {
    return `template:${this.trait.name}`;
  }
  renderTemplate(e) {
    return e;
  }
  renderElement(e, t, i) {
    const n = this.renderedElements.findIndex((o) => o.templateData === i);
    if (n >= 0) {
      const o = this.renderedElements[n];
      this.trait.unrender(i), o.index = t;
    } else {
      const o = { index: t, templateData: i };
      this.renderedElements.push(o);
    }
    this.trait.renderIndex(t, i);
  }
  splice(e, t, i) {
    const n = [];
    for (const o of this.renderedElements)
      o.index < e ? n.push(o) : o.index >= e + t && n.push({
        index: o.index + i - t,
        templateData: o.templateData
      });
    this.renderedElements = n;
  }
  renderIndexes(e) {
    for (const { index: t, templateData: i } of this.renderedElements)
      e.indexOf(t) > -1 && this.trait.renderIndex(t, i);
  }
  disposeTemplate(e) {
    const t = this.renderedElements.findIndex((i) => i.templateData === e);
    t < 0 || this.renderedElements.splice(t, 1);
  }
}
let s1 = class {
  get name() {
    return this._trait;
  }
  get renderer() {
    return new BH(this);
  }
  constructor(e) {
    this._trait = e, this.indexes = [], this.sortedIndexes = [], this._onChange = new A(), this.onChange = this._onChange.event;
  }
  splice(e, t, i) {
    const n = i.length - t, o = e + t, r = [];
    let a = 0;
    for (; a < this.sortedIndexes.length && this.sortedIndexes[a] < e; )
      r.push(this.sortedIndexes[a++]);
    for (let l = 0; l < i.length; l++)
      i[l] && r.push(l + e);
    for (; a < this.sortedIndexes.length && this.sortedIndexes[a] >= o; )
      r.push(this.sortedIndexes[a++] + n);
    this.renderer.splice(e, t, i.length), this._set(r, r);
  }
  renderIndex(e, t) {
    t.classList.toggle(this._trait, this.contains(e));
  }
  unrender(e) {
    e.classList.remove(this._trait);
  }
  /**
   * Sets the indexes which should have this trait.
   *
   * @param indexes Indexes which should have this trait.
   * @return The old indexes which had this trait.
   */
  set(e, t) {
    return this._set(e, [...e].sort(dT), t);
  }
  _set(e, t, i) {
    const n = this.indexes, o = this.sortedIndexes;
    this.indexes = e, this.sortedIndexes = t;
    const r = wS(o, e);
    return this.renderer.renderIndexes(r), this._onChange.fire({ indexes: e, browserEvent: i }), n;
  }
  get() {
    return this.indexes;
  }
  contains(e) {
    return hO(this.sortedIndexes, e, dT) >= 0;
  }
  dispose() {
    Ft(this._onChange);
  }
};
sc([
  Yt
], s1.prototype, "renderer", null);
class WH extends s1 {
  constructor(e) {
    super("selected"), this.setAriaSelected = e;
  }
  renderIndex(e, t) {
    super.renderIndex(e, t), this.setAriaSelected && (this.contains(e) ? t.setAttribute("aria-selected", "true") : t.setAttribute("aria-selected", "false"));
  }
}
class E0 {
  constructor(e, t, i) {
    this.trait = e, this.view = t, this.identityProvider = i;
  }
  splice(e, t, i) {
    if (!this.identityProvider)
      return this.trait.splice(e, t, new Array(i.length).fill(!1));
    const n = this.trait.get().map((a) => this.identityProvider.getId(this.view.element(a)).toString());
    if (n.length === 0)
      return this.trait.splice(e, t, new Array(i.length).fill(!1));
    const o = new Set(n), r = i.map((a) => o.has(this.identityProvider.getId(a).toString()));
    this.trait.splice(e, t, r);
  }
}
function Rl(s) {
  return s.tagName === "INPUT" || s.tagName === "TEXTAREA";
}
function Ap(s, e) {
  return s.classList.contains(e) ? !0 : s.classList.contains("monaco-list") || !s.parentElement ? !1 : Ap(s.parentElement, e);
}
function bg(s) {
  return Ap(s, "monaco-editor");
}
function HH(s) {
  return Ap(s, "monaco-custom-toggle");
}
function VH(s) {
  return Ap(s, "action-item");
}
function Pg(s) {
  return Ap(s, "monaco-tree-sticky-row");
}
function Pm(s) {
  return s.classList.contains("monaco-tree-sticky-container");
}
function MO(s) {
  return s.tagName === "A" && s.classList.contains("monaco-button") || s.tagName === "DIV" && s.classList.contains("monaco-button-dropdown") ? !0 : s.classList.contains("monaco-list") || !s.parentElement ? !1 : MO(s.parentElement);
}
class RO {
  get onKeyDown() {
    return ee.chain(this.disposables.add(new He(this.view.domNode, "keydown")).event, (e) => e.filter((t) => !Rl(t.target)).map((t) => new Dt(t)));
  }
  constructor(e, t, i) {
    this.list = e, this.view = t, this.disposables = new ne(), this.multipleSelectionDisposables = new ne(), this.multipleSelectionSupport = i.multipleSelectionSupport, this.disposables.add(this.onKeyDown((n) => {
      switch (n.keyCode) {
        case 3:
          return this.onEnter(n);
        case 16:
          return this.onUpArrow(n);
        case 18:
          return this.onDownArrow(n);
        case 11:
          return this.onPageUpArrow(n);
        case 12:
          return this.onPageDownArrow(n);
        case 9:
          return this.onEscape(n);
        case 31:
          this.multipleSelectionSupport && ($e ? n.metaKey : n.ctrlKey) && this.onCtrlA(n);
      }
    }));
  }
  updateOptions(e) {
    e.multipleSelectionSupport !== void 0 && (this.multipleSelectionSupport = e.multipleSelectionSupport);
  }
  onEnter(e) {
    e.preventDefault(), e.stopPropagation(), this.list.setSelection(this.list.getFocus(), e.browserEvent);
  }
  onUpArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusPrevious(1, !1, e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onDownArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusNext(1, !1, e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onPageUpArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusPreviousPage(e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onPageDownArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusNextPage(e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onCtrlA(e) {
    e.preventDefault(), e.stopPropagation(), this.list.setSelection(xn(this.list.length), e.browserEvent), this.list.setAnchor(void 0), this.view.domNode.focus();
  }
  onEscape(e) {
    this.list.getSelection().length && (e.preventDefault(), e.stopPropagation(), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0), this.view.domNode.focus());
  }
  dispose() {
    this.disposables.dispose(), this.multipleSelectionDisposables.dispose();
  }
}
sc([
  Yt
], RO.prototype, "onKeyDown", null);
var Dr;
(function(s) {
  s[s.Automatic = 0] = "Automatic", s[s.Trigger = 1] = "Trigger";
})(Dr || (Dr = {}));
var Xd;
(function(s) {
  s[s.Idle = 0] = "Idle", s[s.Typing = 1] = "Typing";
})(Xd || (Xd = {}));
const zH = new class {
  mightProducePrintableCharacter(s) {
    return s.ctrlKey || s.metaKey || s.altKey ? !1 : s.keyCode >= 31 && s.keyCode <= 56 || s.keyCode >= 21 && s.keyCode <= 30 || s.keyCode >= 98 && s.keyCode <= 107 || s.keyCode >= 85 && s.keyCode <= 95;
  }
}();
class UH {
  constructor(e, t, i, n, o) {
    this.list = e, this.view = t, this.keyboardNavigationLabelProvider = i, this.keyboardNavigationEventFilter = n, this.delegate = o, this.enabled = !1, this.state = Xd.Idle, this.mode = Dr.Automatic, this.triggered = !1, this.previouslyFocused = -1, this.enabledDisposables = new ne(), this.disposables = new ne(), this.updateOptions(e.options);
  }
  updateOptions(e) {
    e.typeNavigationEnabled ?? !0 ? this.enable() : this.disable(), this.mode = e.typeNavigationMode ?? Dr.Automatic;
  }
  enable() {
    if (this.enabled)
      return;
    let e = !1;
    const t = ee.chain(this.enabledDisposables.add(new He(this.view.domNode, "keydown")).event, (o) => o.filter((r) => !Rl(r.target)).filter(() => this.mode === Dr.Automatic || this.triggered).map((r) => new Dt(r)).filter((r) => e || this.keyboardNavigationEventFilter(r)).filter((r) => this.delegate.mightProducePrintableCharacter(r)).forEach((r) => Ge.stop(r, !0)).map((r) => r.browserEvent.key)), i = ee.debounce(t, () => null, 800, void 0, void 0, void 0, this.enabledDisposables);
    ee.reduce(ee.any(t, i), (o, r) => r === null ? null : (o || "") + r, void 0, this.enabledDisposables)(this.onInput, this, this.enabledDisposables), i(this.onClear, this, this.enabledDisposables), t(() => e = !0, void 0, this.enabledDisposables), i(() => e = !1, void 0, this.enabledDisposables), this.enabled = !0, this.triggered = !1;
  }
  disable() {
    this.enabled && (this.enabledDisposables.clear(), this.enabled = !1, this.triggered = !1);
  }
  onClear() {
    var t;
    const e = this.list.getFocus();
    if (e.length > 0 && e[0] === this.previouslyFocused) {
      const i = (t = this.list.options.accessibilityProvider) == null ? void 0 : t.getAriaLabel(this.list.element(e[0]));
      typeof i == "string" ? Uh(i) : i && Uh(i.get());
    }
    this.previouslyFocused = -1;
  }
  onInput(e) {
    if (!e) {
      this.state = Xd.Idle, this.triggered = !1;
      return;
    }
    const t = this.list.getFocus(), i = t.length > 0 ? t[0] : 0, n = this.state === Xd.Idle ? 1 : 0;
    this.state = Xd.Typing;
    for (let o = 0; o < this.list.length; o++) {
      const r = (i + o + n) % this.list.length, a = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(r)), l = a && a.toString();
      if (this.list.options.typeNavigationEnabled) {
        if (typeof l < "u") {
          if (Yb(e, l)) {
            this.previouslyFocused = i, this.list.setFocus([r]), this.list.reveal(r);
            return;
          }
          const c = EB(e, l);
          if (c && c[0].end - c[0].start > 1 && c.length === 1) {
            this.previouslyFocused = i, this.list.setFocus([r]), this.list.reveal(r);
            return;
          }
        }
      } else if (typeof l > "u" || Yb(e, l)) {
        this.previouslyFocused = i, this.list.setFocus([r]), this.list.reveal(r);
        return;
      }
    }
  }
  dispose() {
    this.disable(), this.enabledDisposables.dispose(), this.disposables.dispose();
  }
}
class $H {
  constructor(e, t) {
    this.list = e, this.view = t, this.disposables = new ne();
    const i = ee.chain(this.disposables.add(new He(t.domNode, "keydown")).event, (o) => o.filter((r) => !Rl(r.target)).map((r) => new Dt(r)));
    ee.chain(i, (o) => o.filter((r) => r.keyCode === 2 && !r.ctrlKey && !r.metaKey && !r.shiftKey && !r.altKey))(this.onTab, this, this.disposables);
  }
  onTab(e) {
    if (e.target !== this.view.domNode)
      return;
    const t = this.list.getFocus();
    if (t.length === 0)
      return;
    const i = this.view.domElement(t[0]);
    if (!i)
      return;
    const n = i.querySelector("[tabIndex]");
    if (!n || !ki(n) || n.tabIndex === -1)
      return;
    const o = fe(n).getComputedStyle(n);
    o.visibility === "hidden" || o.display === "none" || (e.preventDefault(), e.stopPropagation(), n.focus());
  }
  dispose() {
    this.disposables.dispose();
  }
}
function AO(s) {
  return $e ? s.browserEvent.metaKey : s.browserEvent.ctrlKey;
}
function PO(s) {
  return s.browserEvent.shiftKey;
}
function KH(s) {
  return IE(s) && s.button === 2;
}
const hT = {
  isSelectionSingleChangeEvent: AO,
  isSelectionRangeChangeEvent: PO
};
class OO {
  constructor(e) {
    this.list = e, this.disposables = new ne(), this._onPointer = new A(), this.onPointer = this._onPointer.event, e.options.multipleSelectionSupport !== !1 && (this.multipleSelectionController = this.list.options.multipleSelectionController || hT), this.mouseSupport = typeof e.options.mouseSupport > "u" || !!e.options.mouseSupport, this.mouseSupport && (e.onMouseDown(this.onMouseDown, this, this.disposables), e.onContextMenu(this.onContextMenu, this, this.disposables), e.onMouseDblClick(this.onDoubleClick, this, this.disposables), e.onTouchStart(this.onMouseDown, this, this.disposables), this.disposables.add(ln.addTarget(e.getHTMLElement()))), ee.any(e.onMouseClick, e.onMouseMiddleClick, e.onTap)(this.onViewPointer, this, this.disposables);
  }
  updateOptions(e) {
    e.multipleSelectionSupport !== void 0 && (this.multipleSelectionController = void 0, e.multipleSelectionSupport && (this.multipleSelectionController = this.list.options.multipleSelectionController || hT));
  }
  isSelectionSingleChangeEvent(e) {
    return this.multipleSelectionController ? this.multipleSelectionController.isSelectionSingleChangeEvent(e) : !1;
  }
  isSelectionRangeChangeEvent(e) {
    return this.multipleSelectionController ? this.multipleSelectionController.isSelectionRangeChangeEvent(e) : !1;
  }
  isSelectionChangeEvent(e) {
    return this.isSelectionSingleChangeEvent(e) || this.isSelectionRangeChangeEvent(e);
  }
  onMouseDown(e) {
    bg(e.browserEvent.target) || Gi() !== e.browserEvent.target && this.list.domFocus();
  }
  onContextMenu(e) {
    if (Rl(e.browserEvent.target) || bg(e.browserEvent.target))
      return;
    const t = typeof e.index > "u" ? [] : [e.index];
    this.list.setFocus(t, e.browserEvent);
  }
  onViewPointer(e) {
    if (!this.mouseSupport || Rl(e.browserEvent.target) || bg(e.browserEvent.target) || e.browserEvent.isHandledByList)
      return;
    e.browserEvent.isHandledByList = !0;
    const t = e.index;
    if (typeof t > "u") {
      this.list.setFocus([], e.browserEvent), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0);
      return;
    }
    if (this.isSelectionChangeEvent(e))
      return this.changeSelection(e);
    this.list.setFocus([t], e.browserEvent), this.list.setAnchor(t), KH(e.browserEvent) || this.list.setSelection([t], e.browserEvent), this._onPointer.fire(e);
  }
  onDoubleClick(e) {
    if (Rl(e.browserEvent.target) || bg(e.browserEvent.target) || this.isSelectionChangeEvent(e) || e.browserEvent.isHandledByList)
      return;
    e.browserEvent.isHandledByList = !0;
    const t = this.list.getFocus();
    this.list.setSelection(t, e.browserEvent);
  }
  changeSelection(e) {
    const t = e.index;
    let i = this.list.getAnchor();
    if (this.isSelectionRangeChangeEvent(e)) {
      typeof i > "u" && (i = this.list.getFocus()[0] ?? t, this.list.setAnchor(i));
      const n = Math.min(i, t), o = Math.max(i, t), r = xn(n, o + 1), a = this.list.getSelection(), l = GH(wS(a, [i]), i);
      if (l.length === 0)
        return;
      const c = wS(r, ZH(a, l));
      this.list.setSelection(c, e.browserEvent), this.list.setFocus([t], e.browserEvent);
    } else if (this.isSelectionSingleChangeEvent(e)) {
      const n = this.list.getSelection(), o = n.filter((r) => r !== t);
      this.list.setFocus([t]), this.list.setAnchor(t), n.length === o.length ? this.list.setSelection([...o, t], e.browserEvent) : this.list.setSelection(o, e.browserEvent);
    }
  }
  dispose() {
    this.disposables.dispose();
  }
}
class FO {
  constructor(e, t) {
    this.styleElement = e, this.selectorSuffix = t;
  }
  style(e) {
    const t = this.selectorSuffix && `.${this.selectorSuffix}`, i = [];
    e.listBackground && i.push(`.monaco-list${t} .monaco-list-rows { background: ${e.listBackground}; }`), e.listFocusBackground && (i.push(`.monaco-list${t}:focus .monaco-list-row.focused { background-color: ${e.listFocusBackground}; }`), i.push(`.monaco-list${t}:focus .monaco-list-row.focused:hover { background-color: ${e.listFocusBackground}; }`)), e.listFocusForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.focused { color: ${e.listFocusForeground}; }`), e.listActiveSelectionBackground && (i.push(`.monaco-list${t}:focus .monaco-list-row.selected { background-color: ${e.listActiveSelectionBackground}; }`), i.push(`.monaco-list${t}:focus .monaco-list-row.selected:hover { background-color: ${e.listActiveSelectionBackground}; }`)), e.listActiveSelectionForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.selected { color: ${e.listActiveSelectionForeground}; }`), e.listActiveSelectionIconForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.selected .codicon { color: ${e.listActiveSelectionIconForeground}; }`), e.listFocusAndSelectionBackground && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.selected.focused { background-color: ${e.listFocusAndSelectionBackground}; }
			`), e.listFocusAndSelectionForeground && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.selected.focused { color: ${e.listFocusAndSelectionForeground}; }
			`), e.listInactiveFocusForeground && (i.push(`.monaco-list${t} .monaco-list-row.focused { color:  ${e.listInactiveFocusForeground}; }`), i.push(`.monaco-list${t} .monaco-list-row.focused:hover { color:  ${e.listInactiveFocusForeground}; }`)), e.listInactiveSelectionIconForeground && i.push(`.monaco-list${t} .monaco-list-row.focused .codicon { color:  ${e.listInactiveSelectionIconForeground}; }`), e.listInactiveFocusBackground && (i.push(`.monaco-list${t} .monaco-list-row.focused { background-color:  ${e.listInactiveFocusBackground}; }`), i.push(`.monaco-list${t} .monaco-list-row.focused:hover { background-color:  ${e.listInactiveFocusBackground}; }`)), e.listInactiveSelectionBackground && (i.push(`.monaco-list${t} .monaco-list-row.selected { background-color:  ${e.listInactiveSelectionBackground}; }`), i.push(`.monaco-list${t} .monaco-list-row.selected:hover { background-color:  ${e.listInactiveSelectionBackground}; }`)), e.listInactiveSelectionForeground && i.push(`.monaco-list${t} .monaco-list-row.selected { color: ${e.listInactiveSelectionForeground}; }`), e.listHoverBackground && i.push(`.monaco-list${t}:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused) { background-color: ${e.listHoverBackground}; }`), e.listHoverForeground && i.push(`.monaco-list${t}:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused) { color:  ${e.listHoverForeground}; }`);
    const n = Fa(e.listFocusAndSelectionOutline, Fa(e.listSelectionOutline, e.listFocusOutline ?? ""));
    n && i.push(`.monaco-list${t}:focus .monaco-list-row.focused.selected { outline: 1px solid ${n}; outline-offset: -1px;}`), e.listFocusOutline && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }
				.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }
			`);
    const o = Fa(e.listSelectionOutline, e.listInactiveFocusOutline ?? "");
    o && i.push(`.monaco-list${t} .monaco-list-row.focused.selected { outline: 1px dotted ${o}; outline-offset: -1px; }`), e.listSelectionOutline && i.push(`.monaco-list${t} .monaco-list-row.selected { outline: 1px dotted ${e.listSelectionOutline}; outline-offset: -1px; }`), e.listInactiveFocusOutline && i.push(`.monaco-list${t} .monaco-list-row.focused { outline: 1px dotted ${e.listInactiveFocusOutline}; outline-offset: -1px; }`), e.listHoverOutline && i.push(`.monaco-list${t} .monaco-list-row:hover { outline: 1px dashed ${e.listHoverOutline}; outline-offset: -1px; }`), e.listDropOverBackground && i.push(`
				.monaco-list${t}.drop-target,
				.monaco-list${t} .monaco-list-rows.drop-target,
				.monaco-list${t} .monaco-list-row.drop-target { background-color: ${e.listDropOverBackground} !important; color: inherit !important; }
			`), e.listDropBetweenBackground && (i.push(`
			.monaco-list${t} .monaco-list-rows.drop-target-before .monaco-list-row:first-child::before,
			.monaco-list${t} .monaco-list-row.drop-target-before::before {
				content: ""; position: absolute; top: 0px; left: 0px; width: 100%; height: 1px;
				background-color: ${e.listDropBetweenBackground};
			}`), i.push(`
			.monaco-list${t} .monaco-list-rows.drop-target-after .monaco-list-row:last-child::after,
			.monaco-list${t} .monaco-list-row.drop-target-after::after {
				content: ""; position: absolute; bottom: 0px; left: 0px; width: 100%; height: 1px;
				background-color: ${e.listDropBetweenBackground};
			}`)), e.tableColumnsBorder && i.push(`
				.monaco-table > .monaco-split-view2,
				.monaco-table > .monaco-split-view2 .monaco-sash.vertical::before,
				.monaco-workbench:not(.reduce-motion) .monaco-table:hover > .monaco-split-view2,
				.monaco-workbench:not(.reduce-motion) .monaco-table:hover > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: ${e.tableColumnsBorder};
				}

				.monaco-workbench:not(.reduce-motion) .monaco-table > .monaco-split-view2,
				.monaco-workbench:not(.reduce-motion) .monaco-table > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: transparent;
				}
			`), e.tableOddRowsBackgroundColor && i.push(`
				.monaco-table .monaco-list-row[data-parity=odd]:not(.focused):not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(:focus) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(.focused) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr {
					background-color: ${e.tableOddRowsBackgroundColor};
				}
			`), this.styleElement.textContent = i.join(`
`);
  }
}
const jH = {
  listFocusBackground: "#7FB0D0",
  listActiveSelectionBackground: "#0E639C",
  listActiveSelectionForeground: "#FFFFFF",
  listActiveSelectionIconForeground: "#FFFFFF",
  listFocusAndSelectionOutline: "#90C2F9",
  listFocusAndSelectionBackground: "#094771",
  listFocusAndSelectionForeground: "#FFFFFF",
  listInactiveSelectionBackground: "#3F3F46",
  listInactiveSelectionIconForeground: "#FFFFFF",
  listHoverBackground: "#2A2D2E",
  listDropOverBackground: "#383B3D",
  listDropBetweenBackground: "#EEEEEE",
  treeIndentGuidesStroke: "#a9a9a9",
  treeInactiveIndentGuidesStroke: j.fromHex("#a9a9a9").transparent(0.4).toString(),
  tableColumnsBorder: j.fromHex("#cccccc").transparent(0.2).toString(),
  tableOddRowsBackgroundColor: j.fromHex("#cccccc").transparent(0.04).toString(),
  listBackground: void 0,
  listFocusForeground: void 0,
  listInactiveSelectionForeground: void 0,
  listInactiveFocusForeground: void 0,
  listInactiveFocusBackground: void 0,
  listHoverForeground: void 0,
  listFocusOutline: void 0,
  listInactiveFocusOutline: void 0,
  listSelectionOutline: void 0,
  listHoverOutline: void 0,
  treeStickyScrollBackground: void 0,
  treeStickyScrollBorder: void 0,
  treeStickyScrollShadow: void 0
}, qH = {
  keyboardSupport: !0,
  mouseSupport: !0,
  multipleSelectionSupport: !0,
  dnd: {
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return !1;
    },
    drop() {
    },
    dispose() {
    }
  }
};
function GH(s, e) {
  const t = s.indexOf(e);
  if (t === -1)
    return [];
  const i = [];
  let n = t - 1;
  for (; n >= 0 && s[n] === e - (t - n); )
    i.push(s[n--]);
  for (i.reverse(), n = t; n < s.length && s[n] === e + (n - t); )
    i.push(s[n++]);
  return i;
}
function wS(s, e) {
  const t = [];
  let i = 0, n = 0;
  for (; i < s.length || n < e.length; )
    if (i >= s.length)
      t.push(e[n++]);
    else if (n >= e.length)
      t.push(s[i++]);
    else if (s[i] === e[n]) {
      t.push(s[i]), i++, n++;
      continue;
    } else s[i] < e[n] ? t.push(s[i++]) : t.push(e[n++]);
  return t;
}
function ZH(s, e) {
  const t = [];
  let i = 0, n = 0;
  for (; i < s.length || n < e.length; )
    if (i >= s.length)
      t.push(e[n++]);
    else if (n >= e.length)
      t.push(s[i++]);
    else if (s[i] === e[n]) {
      i++, n++;
      continue;
    } else s[i] < e[n] ? t.push(s[i++]) : n++;
  return t;
}
const dT = (s, e) => s - e;
class YH {
  constructor(e, t) {
    this._templateId = e, this.renderers = t;
  }
  get templateId() {
    return this._templateId;
  }
  renderTemplate(e) {
    return this.renderers.map((t) => t.renderTemplate(e));
  }
  renderElement(e, t, i, n) {
    let o = 0;
    for (const r of this.renderers)
      r.renderElement(e, t, i[o++], n);
  }
  disposeElement(e, t, i, n) {
    var r;
    let o = 0;
    for (const a of this.renderers)
      (r = a.disposeElement) == null || r.call(a, e, t, i[o], n), o += 1;
  }
  disposeTemplate(e) {
    let t = 0;
    for (const i of this.renderers)
      i.disposeTemplate(e[t++]);
  }
}
class XH {
  constructor(e) {
    this.accessibilityProvider = e, this.templateId = "a18n";
  }
  renderTemplate(e) {
    return { container: e, disposables: new ne() };
  }
  renderElement(e, t, i) {
    const n = this.accessibilityProvider.getAriaLabel(e), o = n && typeof n != "string" ? n : n1(n);
    i.disposables.add(Qe((a) => {
      this.setAriaLabel(a.readObservable(o), i.container);
    }));
    const r = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(e);
    typeof r == "number" ? i.container.setAttribute("aria-level", `${r}`) : i.container.removeAttribute("aria-level");
  }
  setAriaLabel(e, t) {
    e ? t.setAttribute("aria-label", e) : t.removeAttribute("aria-label");
  }
  disposeElement(e, t, i, n) {
    i.disposables.clear();
  }
  disposeTemplate(e) {
    e.disposables.dispose();
  }
}
class QH {
  constructor(e, t) {
    this.list = e, this.dnd = t;
  }
  getDragElements(e) {
    const t = this.list.getSelectedElements();
    return t.indexOf(e) > -1 ? t : [e];
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e, t);
  }
  onDragStart(e, t) {
    var i, n;
    (n = (i = this.dnd).onDragStart) == null || n.call(i, e, t);
  }
  onDragOver(e, t, i, n, o) {
    return this.dnd.onDragOver(e, t, i, n, o);
  }
  onDragLeave(e, t, i, n) {
    var o, r;
    (r = (o = this.dnd).onDragLeave) == null || r.call(o, e, t, i, n);
  }
  onDragEnd(e) {
    var t, i;
    (i = (t = this.dnd).onDragEnd) == null || i.call(t, e);
  }
  drop(e, t, i, n, o) {
    this.dnd.drop(e, t, i, n, o);
  }
  dispose() {
    this.dnd.dispose();
  }
}
class wo {
  get onDidChangeFocus() {
    return ee.map(this.eventBufferer.wrapEvent(this.focus.onChange), (e) => this.toListEvent(e), this.disposables);
  }
  get onDidChangeSelection() {
    return ee.map(this.eventBufferer.wrapEvent(this.selection.onChange), (e) => this.toListEvent(e), this.disposables);
  }
  get domId() {
    return this.view.domId;
  }
  get onDidScroll() {
    return this.view.onDidScroll;
  }
  get onMouseClick() {
    return this.view.onMouseClick;
  }
  get onMouseDblClick() {
    return this.view.onMouseDblClick;
  }
  get onMouseMiddleClick() {
    return this.view.onMouseMiddleClick;
  }
  get onPointer() {
    return this.mouseController.onPointer;
  }
  get onMouseDown() {
    return this.view.onMouseDown;
  }
  get onMouseOver() {
    return this.view.onMouseOver;
  }
  get onMouseOut() {
    return this.view.onMouseOut;
  }
  get onTouchStart() {
    return this.view.onTouchStart;
  }
  get onTap() {
    return this.view.onTap;
  }
  /**
   * Possible context menu trigger events:
   * - ContextMenu key
   * - Shift F10
   * - Ctrl Option Shift M (macOS with VoiceOver)
   * - Mouse right click
   */
  get onContextMenu() {
    let e = !1;
    const t = ee.chain(this.disposables.add(new He(this.view.domNode, "keydown")).event, (o) => o.map((r) => new Dt(r)).filter((r) => e = r.keyCode === 58 || r.shiftKey && r.keyCode === 68).map((r) => Ge.stop(r, !0)).filter(() => !1)), i = ee.chain(this.disposables.add(new He(this.view.domNode, "keyup")).event, (o) => o.forEach(() => e = !1).map((r) => new Dt(r)).filter((r) => r.keyCode === 58 || r.shiftKey && r.keyCode === 68).map((r) => Ge.stop(r, !0)).map(({ browserEvent: r }) => {
      const a = this.getFocus(), l = a.length ? a[0] : void 0, c = typeof l < "u" ? this.view.element(l) : void 0, h = typeof l < "u" ? this.view.domElement(l) : this.view.domNode;
      return { index: l, element: c, anchor: h, browserEvent: r };
    })), n = ee.chain(this.view.onContextMenu, (o) => o.filter((r) => !e).map(({ element: r, index: a, browserEvent: l }) => ({ element: r, index: a, anchor: new Uo(fe(this.view.domNode), l), browserEvent: l })));
    return ee.any(t, i, n);
  }
  get onKeyDown() {
    return this.disposables.add(new He(this.view.domNode, "keydown")).event;
  }
  get onDidFocus() {
    return ee.signal(this.disposables.add(new He(this.view.domNode, "focus", !0)).event);
  }
  get onDidBlur() {
    return ee.signal(this.disposables.add(new He(this.view.domNode, "blur", !0)).event);
  }
  constructor(e, t, i, n, o = qH) {
    var c, h, d;
    this.user = e, this._options = o, this.focus = new s1("focused"), this.anchor = new s1("anchor"), this.eventBufferer = new xp(), this._ariaLabel = "", this.disposables = new ne(), this._onDidDispose = new A(), this.onDidDispose = this._onDidDispose.event;
    const r = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? (c = this._options.accessibilityProvider) == null ? void 0 : c.getWidgetRole() : "list";
    this.selection = new WH(r !== "listbox");
    const a = [this.focus.renderer, this.selection.renderer];
    this.accessibilityProvider = o.accessibilityProvider, this.accessibilityProvider && (a.push(new XH(this.accessibilityProvider)), (d = (h = this.accessibilityProvider).onDidChangeActiveDescendant) == null || d.call(h, this.onDidChangeActiveDescendant, this, this.disposables)), n = n.map((u) => new YH(u.templateId, [...a, u]));
    const l = {
      ...o,
      dnd: o.dnd && new QH(this, o.dnd)
    };
    if (this.view = this.createListView(t, i, n, l), this.view.domNode.setAttribute("role", r), o.styleController)
      this.styleController = o.styleController(this.view.domId);
    else {
      const u = Us(this.view.domNode);
      this.styleController = new FO(u, this.view.domId);
    }
    if (this.spliceable = new QW([
      new E0(this.focus, this.view, o.identityProvider),
      new E0(this.selection, this.view, o.identityProvider),
      new E0(this.anchor, this.view, o.identityProvider),
      this.view
    ]), this.disposables.add(this.focus), this.disposables.add(this.selection), this.disposables.add(this.anchor), this.disposables.add(this.view), this.disposables.add(this._onDidDispose), this.disposables.add(new $H(this, this.view)), (typeof o.keyboardSupport != "boolean" || o.keyboardSupport) && (this.keyboardController = new RO(this, this.view, o), this.disposables.add(this.keyboardController)), o.keyboardNavigationLabelProvider) {
      const u = o.keyboardNavigationDelegate || zH;
      this.typeNavigationController = new UH(this, this.view, o.keyboardNavigationLabelProvider, o.keyboardNavigationEventFilter ?? (() => !0), u), this.disposables.add(this.typeNavigationController);
    }
    this.mouseController = this.createMouseController(o), this.disposables.add(this.mouseController), this.onDidChangeFocus(this._onFocusChange, this, this.disposables), this.onDidChangeSelection(this._onSelectionChange, this, this.disposables), this.accessibilityProvider && (this.ariaLabel = this.accessibilityProvider.getWidgetAriaLabel()), this._options.multipleSelectionSupport !== !1 && this.view.domNode.setAttribute("aria-multiselectable", "true");
  }
  createListView(e, t, i, n) {
    return new go(e, t, i, n);
  }
  createMouseController(e) {
    return new OO(this);
  }
  updateOptions(e = {}) {
    var t, i;
    this._options = { ...this._options, ...e }, (t = this.typeNavigationController) == null || t.updateOptions(this._options), this._options.multipleSelectionController !== void 0 && (this._options.multipleSelectionSupport ? this.view.domNode.setAttribute("aria-multiselectable", "true") : this.view.domNode.removeAttribute("aria-multiselectable")), this.mouseController.updateOptions(e), (i = this.keyboardController) == null || i.updateOptions(e), this.view.updateOptions(e);
  }
  get options() {
    return this._options;
  }
  splice(e, t, i = []) {
    if (e < 0 || e > this.view.length)
      throw new uc(this.user, `Invalid start index: ${e}`);
    if (t < 0)
      throw new uc(this.user, `Invalid delete count: ${t}`);
    t === 0 && i.length === 0 || this.eventBufferer.bufferEvents(() => this.spliceable.splice(e, t, i));
  }
  rerender() {
    this.view.rerender();
  }
  element(e) {
    return this.view.element(e);
  }
  indexOf(e) {
    return this.view.indexOf(e);
  }
  indexAt(e) {
    return this.view.indexAt(e);
  }
  get length() {
    return this.view.length;
  }
  get contentHeight() {
    return this.view.contentHeight;
  }
  get onDidChangeContentHeight() {
    return this.view.onDidChangeContentHeight;
  }
  get scrollTop() {
    return this.view.getScrollTop();
  }
  set scrollTop(e) {
    this.view.setScrollTop(e);
  }
  get scrollHeight() {
    return this.view.scrollHeight;
  }
  get renderHeight() {
    return this.view.renderHeight;
  }
  get firstVisibleIndex() {
    return this.view.firstVisibleIndex;
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  set ariaLabel(e) {
    this._ariaLabel = e, this.view.domNode.setAttribute("aria-label", e);
  }
  domFocus() {
    this.view.domNode.focus({ preventScroll: !0 });
  }
  layout(e, t) {
    this.view.layout(e, t);
  }
  setSelection(e, t) {
    for (const i of e)
      if (i < 0 || i >= this.length)
        throw new uc(this.user, `Invalid index ${i}`);
    this.selection.set(e, t);
  }
  getSelection() {
    return this.selection.get();
  }
  getSelectedElements() {
    return this.getSelection().map((e) => this.view.element(e));
  }
  setAnchor(e) {
    if (typeof e > "u") {
      this.anchor.set([]);
      return;
    }
    if (e < 0 || e >= this.length)
      throw new uc(this.user, `Invalid index ${e}`);
    this.anchor.set([e]);
  }
  getAnchor() {
    return VE(this.anchor.get(), void 0);
  }
  getAnchorElement() {
    const e = this.getAnchor();
    return typeof e > "u" ? void 0 : this.element(e);
  }
  setFocus(e, t) {
    for (const i of e)
      if (i < 0 || i >= this.length)
        throw new uc(this.user, `Invalid index ${i}`);
    this.focus.set(e, t);
  }
  focusNext(e = 1, t = !1, i, n) {
    if (this.length === 0)
      return;
    const o = this.focus.get(), r = this.findNextIndex(o.length > 0 ? o[0] + e : 0, t, n);
    r > -1 && this.setFocus([r], i);
  }
  focusPrevious(e = 1, t = !1, i, n) {
    if (this.length === 0)
      return;
    const o = this.focus.get(), r = this.findPreviousIndex(o.length > 0 ? o[0] - e : 0, t, n);
    r > -1 && this.setFocus([r], i);
  }
  async focusNextPage(e, t) {
    let i = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
    i = i === 0 ? 0 : i - 1;
    const n = this.getFocus()[0];
    if (n !== i && (n === void 0 || i > n)) {
      const o = this.findPreviousIndex(i, !1, t);
      o > -1 && n !== o ? this.setFocus([o], e) : this.setFocus([i], e);
    } else {
      const o = this.view.getScrollTop();
      let r = o + this.view.renderHeight;
      i > n && (r -= this.view.elementHeight(i)), this.view.setScrollTop(r), this.view.getScrollTop() !== o && (this.setFocus([]), await Em(0), await this.focusNextPage(e, t));
    }
  }
  async focusPreviousPage(e, t, i = () => 0) {
    let n;
    const o = i(), r = this.view.getScrollTop() + o;
    r === 0 ? n = this.view.indexAt(r) : n = this.view.indexAfter(r - 1);
    const a = this.getFocus()[0];
    if (a !== n && (a === void 0 || a >= n)) {
      const l = this.findNextIndex(n, !1, t);
      l > -1 && a !== l ? this.setFocus([l], e) : this.setFocus([n], e);
    } else {
      const l = r;
      this.view.setScrollTop(r - this.view.renderHeight - o), this.view.getScrollTop() + i() !== l && (this.setFocus([]), await Em(0), await this.focusPreviousPage(e, t, i));
    }
  }
  focusLast(e, t) {
    if (this.length === 0)
      return;
    const i = this.findPreviousIndex(this.length - 1, !1, t);
    i > -1 && this.setFocus([i], e);
  }
  focusFirst(e, t) {
    this.focusNth(0, e, t);
  }
  focusNth(e, t, i) {
    if (this.length === 0)
      return;
    const n = this.findNextIndex(e, !1, i);
    n > -1 && this.setFocus([n], t);
  }
  findNextIndex(e, t = !1, i) {
    for (let n = 0; n < this.length; n++) {
      if (e >= this.length && !t)
        return -1;
      if (e = e % this.length, !i || i(this.element(e)))
        return e;
      e++;
    }
    return -1;
  }
  findPreviousIndex(e, t = !1, i) {
    for (let n = 0; n < this.length; n++) {
      if (e < 0 && !t)
        return -1;
      if (e = (this.length + e % this.length) % this.length, !i || i(this.element(e)))
        return e;
      e--;
    }
    return -1;
  }
  getFocus() {
    return this.focus.get();
  }
  getFocusedElements() {
    return this.getFocus().map((e) => this.view.element(e));
  }
  reveal(e, t, i = 0) {
    if (e < 0 || e >= this.length)
      throw new uc(this.user, `Invalid index ${e}`);
    const n = this.view.getScrollTop(), o = this.view.elementTop(e), r = this.view.elementHeight(e);
    if (If(t)) {
      const a = r - this.view.renderHeight + i;
      this.view.setScrollTop(a * Dn(t, 0, 1) + o - i);
    } else {
      const a = o + r, l = n + this.view.renderHeight;
      o < n + i && a >= l || (o < n + i || a >= l && r >= this.view.renderHeight ? this.view.setScrollTop(o - i) : a >= l && this.view.setScrollTop(a - this.view.renderHeight));
    }
  }
  /**
   * Returns the relative position of an element rendered in the list.
   * Returns `null` if the element isn't *entirely* in the visible viewport.
   */
  getRelativeTop(e, t = 0) {
    if (e < 0 || e >= this.length)
      throw new uc(this.user, `Invalid index ${e}`);
    const i = this.view.getScrollTop(), n = this.view.elementTop(e), o = this.view.elementHeight(e);
    if (n < i + t || n + o > i + this.view.renderHeight)
      return null;
    const r = o - this.view.renderHeight + t;
    return Math.abs((i + t - n) / r);
  }
  getHTMLElement() {
    return this.view.domNode;
  }
  getScrollableElement() {
    return this.view.scrollableElementDomNode;
  }
  getElementID(e) {
    return this.view.getElementDomId(e);
  }
  getElementTop(e) {
    return this.view.elementTop(e);
  }
  style(e) {
    this.styleController.style(e);
  }
  toListEvent({ indexes: e, browserEvent: t }) {
    return { indexes: e, elements: e.map((i) => this.view.element(i)), browserEvent: t };
  }
  _onFocusChange() {
    const e = this.focus.get();
    this.view.domNode.classList.toggle("element-focused", e.length > 0), this.onDidChangeActiveDescendant();
  }
  onDidChangeActiveDescendant() {
    var t;
    const e = this.focus.get();
    if (e.length > 0) {
      let i;
      (t = this.accessibilityProvider) != null && t.getActiveDescendantId && (i = this.accessibilityProvider.getActiveDescendantId(this.view.element(e[0]))), this.view.domNode.setAttribute("aria-activedescendant", i || this.view.getElementDomId(e[0]));
    } else
      this.view.domNode.removeAttribute("aria-activedescendant");
  }
  _onSelectionChange() {
    const e = this.selection.get();
    this.view.domNode.classList.toggle("selection-none", e.length === 0), this.view.domNode.classList.toggle("selection-single", e.length === 1), this.view.domNode.classList.toggle("selection-multiple", e.length > 1);
  }
  dispose() {
    this._onDidDispose.fire(), this.disposables.dispose(), this._onDidDispose.dispose();
  }
}
sc([
  Yt
], wo.prototype, "onDidChangeFocus", null);
sc([
  Yt
], wo.prototype, "onDidChangeSelection", null);
sc([
  Yt
], wo.prototype, "onContextMenu", null);
sc([
  Yt
], wo.prototype, "onKeyDown", null);
sc([
  Yt
], wo.prototype, "onDidFocus", null);
sc([
  Yt
], wo.prototype, "onDidBlur", null);
const Qc = he, BO = "selectOption.entry.template";
class JH {
  get templateId() {
    return BO;
  }
  renderTemplate(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return t.root = e, t.text = te(e, Qc(".option-text")), t.detail = te(e, Qc(".option-detail")), t.decoratorRight = te(e, Qc(".option-decorator-right")), t;
  }
  renderElement(e, t, i) {
    const n = i, o = e.text, r = e.detail, a = e.decoratorRight, l = e.isDisabled;
    n.text.textContent = o, n.detail.textContent = r || "", n.decoratorRight.innerText = a || "", l ? n.root.classList.add("option-disabled") : n.root.classList.remove("option-disabled");
  }
  disposeTemplate(e) {
  }
}
const br = class br extends U {
  constructor(e, t, i, n, o) {
    super(), this.options = [], this._currentSelection = 0, this._hasDetails = !1, this._skipLayout = !1, this._sticky = !1, this._isVisible = !1, this.styles = n, this.selectBoxOptions = o || /* @__PURE__ */ Object.create(null), typeof this.selectBoxOptions.minBottomMargin != "number" ? this.selectBoxOptions.minBottomMargin = br.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN : this.selectBoxOptions.minBottomMargin < 0 && (this.selectBoxOptions.minBottomMargin = 0), this.selectElement = document.createElement("select"), this.selectElement.className = "monaco-select-box monaco-select-box-dropdown-padding", typeof this.selectBoxOptions.ariaLabel == "string" && this.selectElement.setAttribute("aria-label", this.selectBoxOptions.ariaLabel), typeof this.selectBoxOptions.ariaDescription == "string" && this.selectElement.setAttribute("aria-description", this.selectBoxOptions.ariaDescription), this._onDidSelect = new A(), this._register(this._onDidSelect), this.registerListeners(), this.constructSelectDropDown(i), this.selected = t || 0, e && this.setOptions(e, t), this.initStyleSheet();
  }
  setTitle(e) {
    !this._hover && e ? this._hover = this._register(jr().setupManagedHover($s("mouse"), this.selectElement, e)) : this._hover && this._hover.update(e);
  }
  // IDelegate - List renderer
  getHeight() {
    return 22;
  }
  getTemplateId() {
    return BO;
  }
  constructSelectDropDown(e) {
    this.contextViewProvider = e, this.selectDropDownContainer = he(".monaco-select-box-dropdown-container"), this.selectDropDownContainer.classList.add("monaco-select-box-dropdown-padding"), this.selectionDetailsPane = te(this.selectDropDownContainer, Qc(".select-box-details-pane"));
    const t = te(this.selectDropDownContainer, Qc(".select-box-dropdown-container-width-control")), i = te(t, Qc(".width-control-div"));
    this.widthControlElement = document.createElement("span"), this.widthControlElement.className = "option-text-width-control", te(i, this.widthControlElement), this._dropDownPosition = 0, this.styleElement = Us(this.selectDropDownContainer), this.selectDropDownContainer.setAttribute("draggable", "true"), this._register(z(this.selectDropDownContainer, X.DRAG_START, (n) => {
      Ge.stop(n, !0);
    }));
  }
  registerListeners() {
    this._register(Zt(this.selectElement, "change", (t) => {
      this.selected = t.target.selectedIndex, this._onDidSelect.fire({
        index: t.target.selectedIndex,
        selected: t.target.value
      }), this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text);
    })), this._register(z(this.selectElement, X.CLICK, (t) => {
      Ge.stop(t), this._isVisible ? this.hideSelectDropDown(!0) : this.showSelectDropDown();
    })), this._register(z(this.selectElement, X.MOUSE_DOWN, (t) => {
      Ge.stop(t);
    }));
    let e;
    this._register(z(this.selectElement, "touchstart", (t) => {
      e = this._isVisible;
    })), this._register(z(this.selectElement, "touchend", (t) => {
      Ge.stop(t), e ? this.hideSelectDropDown(!0) : this.showSelectDropDown();
    })), this._register(z(this.selectElement, X.KEY_DOWN, (t) => {
      const i = new Dt(t);
      let n = !1;
      $e ? (i.keyCode === 18 || i.keyCode === 16 || i.keyCode === 10 || i.keyCode === 3) && (n = !0) : (i.keyCode === 18 && i.altKey || i.keyCode === 16 && i.altKey || i.keyCode === 10 || i.keyCode === 3) && (n = !0), n && (this.showSelectDropDown(), Ge.stop(t, !0));
    }));
  }
  get onDidSelect() {
    return this._onDidSelect.event;
  }
  setOptions(e, t) {
    li(this.options, e) || (this.options = e, this.selectElement.options.length = 0, this._hasDetails = !1, this._cachedMaxDetailsHeight = void 0, this.options.forEach((i, n) => {
      this.selectElement.add(this.createOption(i.text, n, i.isDisabled)), typeof i.description == "string" && (this._hasDetails = !0);
    })), t !== void 0 && (this.select(t), this._currentSelection = this.selected);
  }
  setOptionsList() {
    var e;
    (e = this.selectList) == null || e.splice(0, this.selectList.length, this.options);
  }
  select(e) {
    e >= 0 && e < this.options.length ? this.selected = e : e > this.options.length - 1 ? this.select(this.options.length - 1) : this.selected < 0 && (this.selected = 0), this.selectElement.selectedIndex = this.selected, this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text);
  }
  focus() {
    this.selectElement && (this.selectElement.tabIndex = 0, this.selectElement.focus());
  }
  blur() {
    this.selectElement && (this.selectElement.tabIndex = -1, this.selectElement.blur());
  }
  setFocusable(e) {
    this.selectElement.tabIndex = e ? 0 : -1;
  }
  render(e) {
    this.container = e, e.classList.add("select-container"), e.appendChild(this.selectElement), this.styleSelectElement();
  }
  initStyleSheet() {
    const e = [];
    this.styles.listFocusBackground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: ${this.styles.listFocusBackground} !important; }`), this.styles.listFocusForeground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { color: ${this.styles.listFocusForeground} !important; }`), this.styles.decoratorRightForeground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.focused) .option-decorator-right { color: ${this.styles.decoratorRightForeground}; }`), this.styles.selectBackground && this.styles.selectBorder && this.styles.selectBorder !== this.styles.selectBackground ? (e.push(`.monaco-select-box-dropdown-container { border: 1px solid ${this.styles.selectBorder} } `), e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectBorder} } `), e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectBorder} } `)) : this.styles.selectListBorder && (e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectListBorder} } `), e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectListBorder} } `)), this.styles.listHoverForeground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { color: ${this.styles.listHoverForeground} !important; }`), this.styles.listHoverBackground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: ${this.styles.listHoverBackground} !important; }`), this.styles.listFocusOutline && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`), this.styles.listHoverOutline && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { outline: 1.6px dashed ${this.styles.listHoverOutline} !important; outline-offset: -1.6px !important; }`), e.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled.focused { background-color: transparent !important; color: inherit !important; outline: none !important; }"), e.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: transparent !important; color: inherit !important; outline: none !important; }"), this.styleElement.textContent = e.join(`
`);
  }
  styleSelectElement() {
    const e = this.styles.selectBackground ?? "", t = this.styles.selectForeground ?? "", i = this.styles.selectBorder ?? "";
    this.selectElement.style.backgroundColor = e, this.selectElement.style.color = t, this.selectElement.style.borderColor = i;
  }
  styleList() {
    const e = this.styles.selectBackground ?? "", t = Fa(this.styles.selectListBackground, e);
    this.selectDropDownListContainer.style.backgroundColor = t, this.selectionDetailsPane.style.backgroundColor = t;
    const i = this.styles.focusBorder ?? "";
    this.selectDropDownContainer.style.outlineColor = i, this.selectDropDownContainer.style.outlineOffset = "-1px", this.selectList.style(this.styles);
  }
  createOption(e, t, i) {
    const n = document.createElement("option");
    return n.value = e, n.text = e, n.disabled = !!i, n;
  }
  // ContextView dropdown methods
  showSelectDropDown() {
    this.selectionDetailsPane.innerText = "", !(!this.contextViewProvider || this._isVisible) && (this.createSelectList(this.selectDropDownContainer), this.setOptionsList(), this.contextViewProvider.showContextView({
      getAnchor: () => this.selectElement,
      render: (e) => this.renderSelectDropDown(e, !0),
      layout: () => {
        this.layoutSelectDropDown();
      },
      onHide: () => {
        this.selectDropDownContainer.classList.remove("visible"), this.selectElement.classList.remove("synthetic-focus");
      },
      anchorPosition: this._dropDownPosition
    }, this.selectBoxOptions.optionsAsChildren ? this.container : void 0), this._isVisible = !0, this.hideSelectDropDown(!1), this.contextViewProvider.showContextView({
      getAnchor: () => this.selectElement,
      render: (e) => this.renderSelectDropDown(e),
      layout: () => this.layoutSelectDropDown(),
      onHide: () => {
        this.selectDropDownContainer.classList.remove("visible"), this.selectElement.classList.remove("synthetic-focus");
      },
      anchorPosition: this._dropDownPosition
    }, this.selectBoxOptions.optionsAsChildren ? this.container : void 0), this._currentSelection = this.selected, this._isVisible = !0, this.selectElement.setAttribute("aria-expanded", "true"));
  }
  hideSelectDropDown(e) {
    !this.contextViewProvider || !this._isVisible || (this._isVisible = !1, this.selectElement.setAttribute("aria-expanded", "false"), e && this.selectElement.focus(), this.contextViewProvider.hideContextView());
  }
  renderSelectDropDown(e, t) {
    return e.appendChild(this.selectDropDownContainer), this.layoutSelectDropDown(t), {
      dispose: () => {
        this.selectDropDownContainer.remove();
      }
    };
  }
  // Iterate over detailed descriptions, find max height
  measureMaxDetailsHeight() {
    let e = 0;
    return this.options.forEach((t, i) => {
      this.updateDetail(i), this.selectionDetailsPane.offsetHeight > e && (e = this.selectionDetailsPane.offsetHeight);
    }), e;
  }
  layoutSelectDropDown(e) {
    if (this._skipLayout)
      return !1;
    if (this.selectList) {
      this.selectDropDownContainer.classList.add("visible");
      const t = fe(this.selectElement), i = ui(this.selectElement), n = fe(this.selectElement).getComputedStyle(this.selectElement), o = parseFloat(n.getPropertyValue("--dropdown-padding-top")) + parseFloat(n.getPropertyValue("--dropdown-padding-bottom")), r = t.innerHeight - i.top - i.height - (this.selectBoxOptions.minBottomMargin || 0), a = i.top - br.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN, l = this.selectElement.offsetWidth, c = this.setWidthControlElement(this.widthControlElement), h = Math.max(c, Math.round(l)).toString() + "px";
      this.selectDropDownContainer.style.width = h, this.selectList.getHTMLElement().style.height = "", this.selectList.layout();
      let d = this.selectList.contentHeight;
      this._hasDetails && this._cachedMaxDetailsHeight === void 0 && (this._cachedMaxDetailsHeight = this.measureMaxDetailsHeight());
      const u = this._hasDetails ? this._cachedMaxDetailsHeight : 0, f = d + o + u, g = Math.floor((r - o - u) / this.getHeight()), p = Math.floor((a - o - u) / this.getHeight());
      if (e)
        return i.top + i.height > t.innerHeight - 22 || i.top < br.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN || g < 1 && p < 1 ? !1 : (g < br.DEFAULT_MINIMUM_VISIBLE_OPTIONS && p > g && this.options.length > g ? (this._dropDownPosition = 1, this.selectDropDownListContainer.remove(), this.selectionDetailsPane.remove(), this.selectDropDownContainer.appendChild(this.selectionDetailsPane), this.selectDropDownContainer.appendChild(this.selectDropDownListContainer), this.selectionDetailsPane.classList.remove("border-top"), this.selectionDetailsPane.classList.add("border-bottom")) : (this._dropDownPosition = 0, this.selectDropDownListContainer.remove(), this.selectionDetailsPane.remove(), this.selectDropDownContainer.appendChild(this.selectDropDownListContainer), this.selectDropDownContainer.appendChild(this.selectionDetailsPane), this.selectionDetailsPane.classList.remove("border-bottom"), this.selectionDetailsPane.classList.add("border-top")), !0);
      if (i.top + i.height > t.innerHeight - 22 || i.top < br.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN || this._dropDownPosition === 0 && g < 1 || this._dropDownPosition === 1 && p < 1)
        return this.hideSelectDropDown(!0), !1;
      if (this._dropDownPosition === 0) {
        if (this._isVisible && g + p < 1)
          return this.hideSelectDropDown(!0), !1;
        f > r && (d = g * this.getHeight());
      } else
        f > a && (d = p * this.getHeight());
      return this.selectList.layout(d), this.selectList.domFocus(), this.selectList.length > 0 && (this.selectList.setFocus([this.selected || 0]), this.selectList.reveal(this.selectList.getFocus()[0] || 0)), this._hasDetails ? (this.selectList.getHTMLElement().style.height = d + o + "px", this.selectDropDownContainer.style.height = "") : this.selectDropDownContainer.style.height = d + o + "px", this.updateDetail(this.selected), this.selectDropDownContainer.style.width = h, this.selectDropDownListContainer.setAttribute("tabindex", "0"), this.selectElement.classList.add("synthetic-focus"), this.selectDropDownContainer.classList.add("synthetic-focus"), !0;
    } else
      return !1;
  }
  setWidthControlElement(e) {
    let t = 0;
    if (e) {
      let i = 0, n = 0;
      this.options.forEach((o, r) => {
        const a = o.detail ? o.detail.length : 0, l = o.decoratorRight ? o.decoratorRight.length : 0, c = o.text.length + a + l;
        c > n && (i = r, n = c);
      }), e.textContent = this.options[i].text + (this.options[i].decoratorRight ? this.options[i].decoratorRight + " " : ""), t = Nm(e);
    }
    return t;
  }
  createSelectList(e) {
    if (this.selectList)
      return;
    this.selectDropDownListContainer = te(e, Qc(".select-box-dropdown-list-container")), this.listRenderer = new JH(), this.selectList = this._register(new wo("SelectBoxCustom", this.selectDropDownListContainer, this, [this.listRenderer], {
      useShadows: !1,
      verticalScrollMode: 3,
      keyboardSupport: !1,
      mouseSupport: !1,
      accessibilityProvider: {
        getAriaLabel: (n) => {
          let o = n.text;
          return n.detail && (o += `. ${n.detail}`), n.decoratorRight && (o += `. ${n.decoratorRight}`), n.description && (o += `. ${n.description}`), o;
        },
        getWidgetAriaLabel: () => m({ key: "selectBox", comment: ["Behave like native select dropdown element."] }, "Select Box"),
        getRole: () => $e ? "" : "option",
        getWidgetRole: () => "listbox"
      }
    })), this.selectBoxOptions.ariaLabel && (this.selectList.ariaLabel = this.selectBoxOptions.ariaLabel);
    const t = this._register(new He(this.selectDropDownListContainer, "keydown")), i = ee.chain(t.event, (n) => n.filter(() => this.selectList.length > 0).map((o) => new Dt(o)));
    this._register(ee.chain(i, (n) => n.filter(
      (o) => o.keyCode === 3
      /* KeyCode.Enter */
    ))(this.onEnter, this)), this._register(ee.chain(i, (n) => n.filter(
      (o) => o.keyCode === 2
      /* KeyCode.Tab */
    ))(this.onEnter, this)), this._register(ee.chain(i, (n) => n.filter(
      (o) => o.keyCode === 9
      /* KeyCode.Escape */
    ))(this.onEscape, this)), this._register(ee.chain(i, (n) => n.filter(
      (o) => o.keyCode === 16
      /* KeyCode.UpArrow */
    ))(this.onUpArrow, this)), this._register(ee.chain(i, (n) => n.filter(
      (o) => o.keyCode === 18
      /* KeyCode.DownArrow */
    ))(this.onDownArrow, this)), this._register(ee.chain(i, (n) => n.filter(
      (o) => o.keyCode === 12
      /* KeyCode.PageDown */
    ))(this.onPageDown, this)), this._register(ee.chain(i, (n) => n.filter(
      (o) => o.keyCode === 11
      /* KeyCode.PageUp */
    ))(this.onPageUp, this)), this._register(ee.chain(i, (n) => n.filter(
      (o) => o.keyCode === 14
      /* KeyCode.Home */
    ))(this.onHome, this)), this._register(ee.chain(i, (n) => n.filter(
      (o) => o.keyCode === 13
      /* KeyCode.End */
    ))(this.onEnd, this)), this._register(ee.chain(i, (n) => n.filter((o) => o.keyCode >= 21 && o.keyCode <= 56 || o.keyCode >= 85 && o.keyCode <= 113))(this.onCharacter, this)), this._register(z(this.selectList.getHTMLElement(), X.POINTER_UP, (n) => this.onPointerUp(n))), this._register(this.selectList.onMouseOver((n) => typeof n.index < "u" && this.selectList.setFocus([n.index]))), this._register(this.selectList.onDidChangeFocus((n) => this.onListFocus(n))), this._register(z(this.selectDropDownContainer, X.FOCUS_OUT, (n) => {
      !this._isVisible || _i(n.relatedTarget, this.selectDropDownContainer) || this.onListBlur();
    })), this.selectList.getHTMLElement().setAttribute("aria-label", this.selectBoxOptions.ariaLabel || ""), this.selectList.getHTMLElement().setAttribute("aria-expanded", "true"), this.styleList();
  }
  // List methods
  // List mouse controller - active exit, select option, fire onDidSelect if change, return focus to parent select
  // Also takes in touchend events
  onPointerUp(e) {
    if (!this.selectList.length)
      return;
    Ge.stop(e);
    const t = e.target;
    if (!t || t.classList.contains("slider"))
      return;
    const i = t.closest(".monaco-list-row");
    if (!i)
      return;
    const n = Number(i.getAttribute("data-index")), o = i.classList.contains("option-disabled");
    n >= 0 && n < this.options.length && !o && (this.selected = n, this.select(this.selected), this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selectList.getFocus()[0]), this.selected !== this._currentSelection && (this._currentSelection = this.selected, this._onDidSelect.fire({
      index: this.selectElement.selectedIndex,
      selected: this.options[this.selected].text
    }), this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text)), this.hideSelectDropDown(!0));
  }
  // List Exit - passive - implicit no selection change, hide drop-down
  onListBlur() {
    this._sticky || (this.selected !== this._currentSelection && this.select(this._currentSelection), this.hideSelectDropDown(!1));
  }
  renderDescriptionMarkdown(e, t) {
    const i = (o) => {
      for (let r = 0; r < o.childNodes.length; r++) {
        const a = o.childNodes.item(r);
        (a.tagName && a.tagName.toLowerCase()) === "img" ? a.remove() : i(a);
      }
    }, n = ow({ value: e, supportThemeIcons: !0 }, { actionHandler: t });
    return n.element.classList.add("select-box-description-markdown"), i(n.element), n.element;
  }
  // List Focus Change - passive - update details pane with newly focused element's data
  onListFocus(e) {
    !this._isVisible || !this._hasDetails || this.updateDetail(e.indexes[0]);
  }
  updateDetail(e) {
    this.selectionDetailsPane.innerText = "";
    const t = this.options[e], i = (t == null ? void 0 : t.description) ?? "", n = (t == null ? void 0 : t.descriptionIsMarkdown) ?? !1;
    if (i) {
      if (n) {
        const o = t.descriptionMarkdownActionHandler;
        this.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(i, o));
      } else
        this.selectionDetailsPane.innerText = i;
      this.selectionDetailsPane.style.display = "block";
    } else
      this.selectionDetailsPane.style.display = "none";
    this._skipLayout = !0, this.contextViewProvider.layout(), this._skipLayout = !1;
  }
  // List keyboard controller
  // List exit - active - hide ContextView dropdown, reset selection, return focus to parent select
  onEscape(e) {
    Ge.stop(e), this.select(this._currentSelection), this.hideSelectDropDown(!0);
  }
  // List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect if change
  onEnter(e) {
    Ge.stop(e), this.selected !== this._currentSelection && (this._currentSelection = this.selected, this._onDidSelect.fire({
      index: this.selectElement.selectedIndex,
      selected: this.options[this.selected].text
    }), this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text)), this.hideSelectDropDown(!0);
  }
  // List navigation - have to handle a disabled option (jump over)
  onDownArrow(e) {
    if (this.selected < this.options.length - 1) {
      Ge.stop(e, !0);
      const t = this.options[this.selected + 1].isDisabled;
      if (t && this.options.length > this.selected + 2)
        this.selected += 2;
      else {
        if (t)
          return;
        this.selected++;
      }
      this.select(this.selected), this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selectList.getFocus()[0]);
    }
  }
  onUpArrow(e) {
    this.selected > 0 && (Ge.stop(e, !0), this.options[this.selected - 1].isDisabled && this.selected > 1 ? this.selected -= 2 : this.selected--, this.select(this.selected), this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selectList.getFocus()[0]));
  }
  onPageUp(e) {
    Ge.stop(e), this.selectList.focusPreviousPage(), setTimeout(() => {
      this.selected = this.selectList.getFocus()[0], this.options[this.selected].isDisabled && this.selected < this.options.length - 1 && (this.selected++, this.selectList.setFocus([this.selected])), this.selectList.reveal(this.selected), this.select(this.selected);
    }, 1);
  }
  onPageDown(e) {
    Ge.stop(e), this.selectList.focusNextPage(), setTimeout(() => {
      this.selected = this.selectList.getFocus()[0], this.options[this.selected].isDisabled && this.selected > 0 && (this.selected--, this.selectList.setFocus([this.selected])), this.selectList.reveal(this.selected), this.select(this.selected);
    }, 1);
  }
  onHome(e) {
    Ge.stop(e), !(this.options.length < 2) && (this.selected = 0, this.options[this.selected].isDisabled && this.selected > 1 && this.selected++, this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selected), this.select(this.selected));
  }
  onEnd(e) {
    Ge.stop(e), !(this.options.length < 2) && (this.selected = this.options.length - 1, this.options[this.selected].isDisabled && this.selected > 1 && this.selected--, this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selected), this.select(this.selected));
  }
  // Mimic option first character navigation of native select
  onCharacter(e) {
    const t = Ca.toString(e.keyCode);
    let i = -1;
    for (let n = 0; n < this.options.length - 1; n++)
      if (i = (n + this.selected + 1) % this.options.length, this.options[i].text.charAt(0).toUpperCase() === t && !this.options[i].isDisabled) {
        this.select(i), this.selectList.setFocus([i]), this.selectList.reveal(this.selectList.getFocus()[0]), Ge.stop(e);
        break;
      }
  }
  dispose() {
    this.hideSelectDropDown(!1), super.dispose();
  }
};
br.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32, br.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN = 2, br.DEFAULT_MINIMUM_VISIBLE_OPTIONS = 3;
let yS = br;
class eV extends U {
  constructor(e, t, i, n) {
    super(), this.selected = 0, this.selectBoxOptions = n || /* @__PURE__ */ Object.create(null), this.options = [], this.selectElement = document.createElement("select"), this.selectElement.className = "monaco-select-box", typeof this.selectBoxOptions.ariaLabel == "string" && this.selectElement.setAttribute("aria-label", this.selectBoxOptions.ariaLabel), typeof this.selectBoxOptions.ariaDescription == "string" && this.selectElement.setAttribute("aria-description", this.selectBoxOptions.ariaDescription), this._onDidSelect = this._register(new A()), this.styles = i, this.registerListeners(), this.setOptions(e, t);
  }
  registerListeners() {
    this._register(ln.addTarget(this.selectElement)), [vt.Tap].forEach((e) => {
      this._register(z(this.selectElement, e, (t) => {
        this.selectElement.focus();
      }));
    }), this._register(Zt(this.selectElement, "click", (e) => {
      Ge.stop(e, !0);
    })), this._register(Zt(this.selectElement, "change", (e) => {
      this.selectElement.title = e.target.value, this._onDidSelect.fire({
        index: e.target.selectedIndex,
        selected: e.target.value
      });
    })), this._register(Zt(this.selectElement, "keydown", (e) => {
      let t = !1;
      $e ? (e.keyCode === 18 || e.keyCode === 16 || e.keyCode === 10) && (t = !0) : (e.keyCode === 18 && e.altKey || e.keyCode === 10 || e.keyCode === 3) && (t = !0), t && e.stopPropagation();
    }));
  }
  get onDidSelect() {
    return this._onDidSelect.event;
  }
  setOptions(e, t) {
    (!this.options || !li(this.options, e)) && (this.options = e, this.selectElement.options.length = 0, this.options.forEach((i, n) => {
      this.selectElement.add(this.createOption(i.text, n, i.isDisabled));
    })), t !== void 0 && this.select(t);
  }
  select(e) {
    this.options.length === 0 ? this.selected = 0 : e >= 0 && e < this.options.length ? this.selected = e : e > this.options.length - 1 ? this.select(this.options.length - 1) : this.selected < 0 && (this.selected = 0), this.selectElement.selectedIndex = this.selected, this.selected < this.options.length && typeof this.options[this.selected].text == "string" ? this.selectElement.title = this.options[this.selected].text : this.selectElement.title = "";
  }
  focus() {
    this.selectElement && (this.selectElement.tabIndex = 0, this.selectElement.focus());
  }
  blur() {
    this.selectElement && (this.selectElement.tabIndex = -1, this.selectElement.blur());
  }
  setFocusable(e) {
    this.selectElement.tabIndex = e ? 0 : -1;
  }
  render(e) {
    e.classList.add("select-container"), e.appendChild(this.selectElement), this.setOptions(this.options, this.selected), this.applyStyles();
  }
  applyStyles() {
    this.selectElement && (this.selectElement.style.backgroundColor = this.styles.selectBackground ?? "", this.selectElement.style.color = this.styles.selectForeground ?? "", this.selectElement.style.borderColor = this.styles.selectBorder ?? "");
  }
  createOption(e, t, i) {
    const n = document.createElement("option");
    return n.value = e, n.text = e, n.disabled = !!i, n;
  }
}
class tV extends qr {
  constructor(e, t, i, n, o) {
    super(), $e && !(o != null && o.useCustomDrawn) ? this.selectBoxDelegate = new eV(e, t, n, o) : this.selectBoxDelegate = new yS(e, t, i, n, o), this._register(this.selectBoxDelegate);
  }
  // Public SelectBox Methods - routed through delegate interface
  get onDidSelect() {
    return this.selectBoxDelegate.onDidSelect;
  }
  setOptions(e, t) {
    this.selectBoxDelegate.setOptions(e, t);
  }
  select(e) {
    this.selectBoxDelegate.select(e);
  }
  focus() {
    this.selectBoxDelegate.focus();
  }
  blur() {
    this.selectBoxDelegate.blur();
  }
  setFocusable(e) {
    this.selectBoxDelegate.setFocusable(e);
  }
  render(e) {
    this.selectBoxDelegate.render(e);
  }
}
class Fo extends U {
  get action() {
    return this._action;
  }
  constructor(e, t, i = {}) {
    super(), this.options = i, this._context = e || this, this._action = t, t instanceof ys && this._register(t.onDidChange((n) => {
      this.element && this.handleActionChangeEvent(n);
    }));
  }
  handleActionChangeEvent(e) {
    e.enabled !== void 0 && this.updateEnabled(), e.checked !== void 0 && this.updateChecked(), e.class !== void 0 && this.updateClass(), e.label !== void 0 && (this.updateLabel(), this.updateTooltip()), e.tooltip !== void 0 && this.updateTooltip();
  }
  get actionRunner() {
    return this._actionRunner || (this._actionRunner = this._register(new Fh())), this._actionRunner;
  }
  set actionRunner(e) {
    this._actionRunner = e;
  }
  isEnabled() {
    return this._action.enabled;
  }
  setActionContext(e) {
    this._context = e;
  }
  render(e) {
    const t = this.element = e;
    this._register(ln.addTarget(e));
    const i = this.options && this.options.draggable;
    i && (e.draggable = !0, uo && this._register(z(e, X.DRAG_START, (n) => {
      var o;
      return (o = n.dataTransfer) == null ? void 0 : o.setData(cO.TEXT, this._action.label);
    }))), this._register(z(t, vt.Tap, (n) => this.onClick(n, !0))), this._register(z(t, X.MOUSE_DOWN, (n) => {
      i || Ge.stop(n, !0), this._action.enabled && n.button === 0 && t.classList.add("active");
    })), $e && this._register(z(t, X.CONTEXT_MENU, (n) => {
      n.button === 0 && n.ctrlKey === !0 && this.onClick(n);
    })), this._register(z(t, X.CLICK, (n) => {
      Ge.stop(n, !0), this.options && this.options.isMenu || this.onClick(n);
    })), this._register(z(t, X.DBLCLICK, (n) => {
      Ge.stop(n, !0);
    })), [X.MOUSE_UP, X.MOUSE_OUT].forEach((n) => {
      this._register(z(t, n, (o) => {
        Ge.stop(o), t.classList.remove("active");
      }));
    });
  }
  onClick(e, t = !1) {
    var n;
    Ge.stop(e, !0);
    const i = ms(this._context) ? (n = this.options) != null && n.useEventAsContext ? e : { preserveFocus: t } : this._context;
    this.actionRunner.run(this._action, i);
  }
  // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441
  focus() {
    this.element && (this.element.tabIndex = 0, this.element.focus(), this.element.classList.add("focused"));
  }
  blur() {
    this.element && (this.element.blur(), this.element.tabIndex = -1, this.element.classList.remove("focused"));
  }
  setFocusable(e) {
    this.element && (this.element.tabIndex = e ? 0 : -1);
  }
  get trapsArrowNavigation() {
    return !1;
  }
  updateEnabled() {
  }
  updateLabel() {
  }
  getClass() {
    return this.action.class;
  }
  getTooltip() {
    return this.action.tooltip;
  }
  updateTooltip() {
    var t;
    if (!this.element)
      return;
    const e = this.getTooltip() ?? "";
    if (this.updateAriaLabel(), (t = this.options.hoverDelegate) != null && t.showNativeHover)
      this.element.title = e;
    else if (!this.customHover && e !== "") {
      const i = this.options.hoverDelegate ?? $s("element");
      this.customHover = this._store.add(jr().setupManagedHover(i, this.element, e));
    } else this.customHover && this.customHover.update(e);
  }
  updateAriaLabel() {
    if (this.element) {
      const e = this.getTooltip() ?? "";
      this.element.setAttribute("aria-label", e);
    }
  }
  updateClass() {
  }
  updateChecked() {
  }
  dispose() {
    this.element && (this.element.remove(), this.element = void 0), this._context = void 0, super.dispose();
  }
}
class uw extends Fo {
  constructor(e, t, i) {
    super(e, t, i), this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : !1, this.options.label = i.label !== void 0 ? i.label : !0, this.cssClass = "";
  }
  render(e) {
    super.render(e), qi(this.element);
    const t = document.createElement("a");
    if (t.classList.add("action-label"), t.setAttribute("role", this.getDefaultAriaRole()), this.label = t, this.element.appendChild(t), this.options.label && this.options.keybinding) {
      const i = document.createElement("span");
      i.classList.add("keybinding"), i.textContent = this.options.keybinding, this.element.appendChild(i);
    }
    this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked();
  }
  getDefaultAriaRole() {
    return this._action.id === Vi.ID ? "presentation" : this.options.isMenu ? "menuitem" : this.options.isTabList ? "tab" : "button";
  }
  // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441
  focus() {
    this.label && (this.label.tabIndex = 0, this.label.focus());
  }
  blur() {
    this.label && (this.label.tabIndex = -1);
  }
  setFocusable(e) {
    this.label && (this.label.tabIndex = e ? 0 : -1);
  }
  updateLabel() {
    this.options.label && this.label && (this.label.textContent = this.action.label);
  }
  getTooltip() {
    let e = null;
    return this.action.tooltip ? e = this.action.tooltip : !this.options.label && this.action.label && this.options.icon && (e = this.action.label, this.options.keybinding && (e = m({ key: "titleLabel", comment: ["action title", "action keybinding"] }, "{0} ({1})", e, this.options.keybinding))), e ?? void 0;
  }
  updateClass() {
    var e;
    this.cssClass && this.label && this.label.classList.remove(...this.cssClass.split(" ")), this.options.icon ? (this.cssClass = this.getClass(), this.label && (this.label.classList.add("codicon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" "))), this.updateEnabled()) : (e = this.label) == null || e.classList.remove("codicon");
  }
  updateEnabled() {
    var e, t;
    this.action.enabled ? (this.label && (this.label.removeAttribute("aria-disabled"), this.label.classList.remove("disabled")), (e = this.element) == null || e.classList.remove("disabled")) : (this.label && (this.label.setAttribute("aria-disabled", "true"), this.label.classList.add("disabled")), (t = this.element) == null || t.classList.add("disabled"));
  }
  updateAriaLabel() {
    if (this.label) {
      const e = this.getTooltip() ?? "";
      this.label.setAttribute("aria-label", e);
    }
  }
  updateChecked() {
    this.label && (this.action.checked !== void 0 ? (this.label.classList.toggle("checked", this.action.checked), this.options.isTabList ? this.label.setAttribute("aria-selected", this.action.checked ? "true" : "false") : (this.label.setAttribute("aria-checked", this.action.checked ? "true" : "false"), this.label.setAttribute("role", "checkbox"))) : (this.label.classList.remove("checked"), this.label.removeAttribute(this.options.isTabList ? "aria-selected" : "aria-checked"), this.label.setAttribute("role", this.getDefaultAriaRole())));
  }
}
class iV extends Fo {
  constructor(e, t, i, n, o, r, a) {
    super(e, t), this.selectBox = new tV(i, n, o, r, a), this.selectBox.setFocusable(!1), this._register(this.selectBox), this.registerListeners();
  }
  select(e) {
    this.selectBox.select(e);
  }
  registerListeners() {
    this._register(this.selectBox.onDidSelect((e) => this.runAction(e.selected, e.index)));
  }
  runAction(e, t) {
    this.actionRunner.run(this._action, this.getActionContext(e, t));
  }
  getActionContext(e, t) {
    return e;
  }
  setFocusable(e) {
    this.selectBox.setFocusable(e);
  }
  focus() {
    var e;
    (e = this.selectBox) == null || e.focus();
  }
  blur() {
    var e;
    (e = this.selectBox) == null || e.blur();
  }
  render(e) {
    this.selectBox.render(e);
  }
}
class $o extends U {
  constructor(e, t = {}) {
    var o, r;
    super(), this._actionRunnerDisposables = this._register(new ne()), this.viewItemDisposables = this._register(new rE()), this.triggerKeyDown = !1, this.focusable = !0, this._onDidBlur = this._register(new A()), this.onDidBlur = this._onDidBlur.event, this._onDidCancel = this._register(new A({ onWillAddFirstListener: () => this.cancelHasListener = !0 })), this.onDidCancel = this._onDidCancel.event, this.cancelHasListener = !1, this._onDidRun = this._register(new A()), this.onDidRun = this._onDidRun.event, this._onWillRun = this._register(new A()), this.onWillRun = this._onWillRun.event, this.options = t, this._context = t.context ?? null, this._orientation = this.options.orientation ?? 0, this._triggerKeys = {
      keyDown: ((o = this.options.triggerKeys) == null ? void 0 : o.keyDown) ?? !1,
      keys: ((r = this.options.triggerKeys) == null ? void 0 : r.keys) ?? [
        3,
        10
        /* KeyCode.Space */
      ]
    }, this._hoverDelegate = t.hoverDelegate ?? this._register(zE()), this.options.actionRunner ? this._actionRunner = this.options.actionRunner : (this._actionRunner = new Fh(), this._actionRunnerDisposables.add(this._actionRunner)), this._actionRunnerDisposables.add(this._actionRunner.onDidRun((a) => this._onDidRun.fire(a))), this._actionRunnerDisposables.add(this._actionRunner.onWillRun((a) => this._onWillRun.fire(a))), this.viewItems = [], this.focusedItem = void 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-action-bar";
    let i, n;
    switch (this._orientation) {
      case 0:
        i = [
          15
          /* KeyCode.LeftArrow */
        ], n = [
          17
          /* KeyCode.RightArrow */
        ];
        break;
      case 1:
        i = [
          16
          /* KeyCode.UpArrow */
        ], n = [
          18
          /* KeyCode.DownArrow */
        ], this.domNode.className += " vertical";
        break;
    }
    this._register(z(this.domNode, X.KEY_DOWN, (a) => {
      const l = new Dt(a);
      let c = !0;
      const h = typeof this.focusedItem == "number" ? this.viewItems[this.focusedItem] : void 0;
      i && (l.equals(i[0]) || l.equals(i[1])) ? c = this.focusPrevious() : n && (l.equals(n[0]) || l.equals(n[1])) ? c = this.focusNext() : l.equals(
        9
        /* KeyCode.Escape */
      ) && this.cancelHasListener ? this._onDidCancel.fire() : l.equals(
        14
        /* KeyCode.Home */
      ) ? c = this.focusFirst() : l.equals(
        13
        /* KeyCode.End */
      ) ? c = this.focusLast() : l.equals(
        2
        /* KeyCode.Tab */
      ) && h instanceof Fo && h.trapsArrowNavigation ? c = this.focusNext(void 0, !0) : this.isTriggerKeyEvent(l) ? this._triggerKeys.keyDown ? this.doTrigger(l) : this.triggerKeyDown = !0 : c = !1, c && (l.preventDefault(), l.stopPropagation());
    })), this._register(z(this.domNode, X.KEY_UP, (a) => {
      const l = new Dt(a);
      this.isTriggerKeyEvent(l) ? (!this._triggerKeys.keyDown && this.triggerKeyDown && (this.triggerKeyDown = !1, this.doTrigger(l)), l.preventDefault(), l.stopPropagation()) : (l.equals(
        2
        /* KeyCode.Tab */
      ) || l.equals(
        1026
        /* KeyCode.Tab */
      ) || l.equals(
        16
        /* KeyCode.UpArrow */
      ) || l.equals(
        18
        /* KeyCode.DownArrow */
      ) || l.equals(
        15
        /* KeyCode.LeftArrow */
      ) || l.equals(
        17
        /* KeyCode.RightArrow */
      )) && this.updateFocusedItem();
    })), this.focusTracker = this._register(Vh(this.domNode)), this._register(this.focusTracker.onDidBlur(() => {
      (Gi() === this.domNode || !_i(Gi(), this.domNode)) && (this._onDidBlur.fire(), this.previouslyFocusedItem = this.focusedItem, this.focusedItem = void 0, this.triggerKeyDown = !1);
    })), this._register(this.focusTracker.onDidFocus(() => this.updateFocusedItem())), this.actionsList = document.createElement("ul"), this.actionsList.className = "actions-container", this.options.highlightToggledItems && this.actionsList.classList.add("highlight-toggled"), this.actionsList.setAttribute("role", this.options.ariaRole || "toolbar"), this.options.ariaLabel && this.actionsList.setAttribute("aria-label", this.options.ariaLabel), this.domNode.appendChild(this.actionsList), e.appendChild(this.domNode);
  }
  refreshRole() {
    this.length() >= 1 ? this.actionsList.setAttribute("role", this.options.ariaRole || "toolbar") : this.actionsList.setAttribute("role", "presentation");
  }
  // Some action bars should not be focusable at times
  // When an action bar is not focusable make sure to make all the elements inside it not focusable
  // When an action bar is focusable again, make sure the first item can be focused
  setFocusable(e) {
    if (this.focusable = e, this.focusable) {
      const t = this.viewItems.find((i) => i instanceof Fo && i.isEnabled());
      t instanceof Fo && t.setFocusable(!0);
    } else
      this.viewItems.forEach((t) => {
        t instanceof Fo && t.setFocusable(!1);
      });
  }
  isTriggerKeyEvent(e) {
    let t = !1;
    return this._triggerKeys.keys.forEach((i) => {
      t = t || e.equals(i);
    }), t;
  }
  updateFocusedItem() {
    var e, t;
    for (let i = 0; i < this.actionsList.children.length; i++) {
      const n = this.actionsList.children[i];
      if (_i(Gi(), n)) {
        this.focusedItem = i, (t = (e = this.viewItems[this.focusedItem]) == null ? void 0 : e.showHover) == null || t.call(e);
        break;
      }
    }
  }
  get context() {
    return this._context;
  }
  set context(e) {
    this._context = e, this.viewItems.forEach((t) => t.setActionContext(e));
  }
  get actionRunner() {
    return this._actionRunner;
  }
  set actionRunner(e) {
    this._actionRunner = e, this._actionRunnerDisposables.clear(), this._actionRunnerDisposables.add(this._actionRunner.onDidRun((t) => this._onDidRun.fire(t))), this._actionRunnerDisposables.add(this._actionRunner.onWillRun((t) => this._onWillRun.fire(t))), this.viewItems.forEach((t) => t.actionRunner = e);
  }
  getContainer() {
    return this.domNode;
  }
  getAction(e) {
    var t;
    if (typeof e == "number")
      return (t = this.viewItems[e]) == null ? void 0 : t.action;
    if (ki(e)) {
      for (; e.parentElement !== this.actionsList; ) {
        if (!e.parentElement)
          return;
        e = e.parentElement;
      }
      for (let i = 0; i < this.actionsList.childNodes.length; i++)
        if (this.actionsList.childNodes[i] === e)
          return this.viewItems[i].action;
    }
  }
  push(e, t = {}) {
    const i = Array.isArray(e) ? e : [e];
    let n = If(t.index) ? t.index : null;
    i.forEach((o) => {
      const r = document.createElement("li");
      r.className = "action-item", r.setAttribute("role", "presentation");
      let a;
      const l = { hoverDelegate: this._hoverDelegate, ...t, isTabList: this.options.ariaRole === "tablist" };
      this.options.actionViewItemProvider && (a = this.options.actionViewItemProvider(o, l)), a || (a = new uw(this.context, o, l)), this.options.allowContextMenu || this.viewItemDisposables.set(a, z(r, X.CONTEXT_MENU, (c) => {
        Ge.stop(c, !0);
      })), a.actionRunner = this._actionRunner, a.setActionContext(this.context), a.render(r), this.focusable && a instanceof Fo && this.viewItems.length === 0 && a.setFocusable(!0), n === null || n < 0 || n >= this.actionsList.children.length ? (this.actionsList.appendChild(r), this.viewItems.push(a)) : (this.actionsList.insertBefore(r, this.actionsList.children[n]), this.viewItems.splice(n, 0, a), n++);
    }), typeof this.focusedItem == "number" && this.focus(this.focusedItem), this.refreshRole();
  }
  clear() {
    this.isEmpty() || (this.viewItems = Ft(this.viewItems), this.viewItemDisposables.clearAndDisposeAll(), ks(this.actionsList), this.refreshRole());
  }
  length() {
    return this.viewItems.length;
  }
  isEmpty() {
    return this.viewItems.length === 0;
  }
  focus(e) {
    let t = !1, i;
    if (e === void 0 ? t = !0 : typeof e == "number" ? i = e : typeof e == "boolean" && (t = e), t && typeof this.focusedItem > "u") {
      const n = this.viewItems.findIndex((o) => o.isEnabled());
      this.focusedItem = n === -1 ? void 0 : n, this.updateFocus(void 0, void 0, !0);
    } else
      i !== void 0 && (this.focusedItem = i), this.updateFocus(void 0, void 0, !0);
  }
  focusFirst() {
    return this.focusedItem = this.length() - 1, this.focusNext(!0);
  }
  focusLast() {
    return this.focusedItem = 0, this.focusPrevious(!0);
  }
  focusNext(e, t) {
    if (typeof this.focusedItem > "u")
      this.focusedItem = this.viewItems.length - 1;
    else if (this.viewItems.length <= 1)
      return !1;
    const i = this.focusedItem;
    let n;
    do {
      if (!e && this.options.preventLoopNavigation && this.focusedItem + 1 >= this.viewItems.length)
        return this.focusedItem = i, !1;
      this.focusedItem = (this.focusedItem + 1) % this.viewItems.length, n = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== i && (this.options.focusOnlyEnabledItems && !n.isEnabled() || n.action.id === Vi.ID));
    return this.updateFocus(void 0, void 0, t), !0;
  }
  focusPrevious(e) {
    if (typeof this.focusedItem > "u")
      this.focusedItem = 0;
    else if (this.viewItems.length <= 1)
      return !1;
    const t = this.focusedItem;
    let i;
    do {
      if (this.focusedItem = this.focusedItem - 1, this.focusedItem < 0) {
        if (!e && this.options.preventLoopNavigation)
          return this.focusedItem = t, !1;
        this.focusedItem = this.viewItems.length - 1;
      }
      i = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== t && (this.options.focusOnlyEnabledItems && !i.isEnabled() || i.action.id === Vi.ID));
    return this.updateFocus(!0), !0;
  }
  updateFocus(e, t, i = !1) {
    var o, r;
    typeof this.focusedItem > "u" && this.actionsList.focus({ preventScroll: t }), this.previouslyFocusedItem !== void 0 && this.previouslyFocusedItem !== this.focusedItem && ((o = this.viewItems[this.previouslyFocusedItem]) == null || o.blur());
    const n = this.focusedItem !== void 0 ? this.viewItems[this.focusedItem] : void 0;
    if (n) {
      let a = !0;
      Wb(n.focus) || (a = !1), this.options.focusOnlyEnabledItems && Wb(n.isEnabled) && !n.isEnabled() && (a = !1), n.action.id === Vi.ID && (a = !1), a ? (i || this.previouslyFocusedItem !== this.focusedItem) && (n.focus(e), this.previouslyFocusedItem = this.focusedItem) : (this.actionsList.focus({ preventScroll: t }), this.previouslyFocusedItem = void 0), a && ((r = n.showHover) == null || r.call(n));
    }
  }
  doTrigger(e) {
    if (typeof this.focusedItem > "u")
      return;
    const t = this.viewItems[this.focusedItem];
    if (t instanceof Fo) {
      const i = t._context === null || t._context === void 0 ? e : t._context;
      this.run(t._action, i);
    }
  }
  async run(e, t) {
    await this._actionRunner.run(e, t);
  }
  dispose() {
    this._context = void 0, this.viewItems = Ft(this.viewItems), this.getContainer().remove(), super.dispose();
  }
}
const JE = Be("markerDecorationsService");
var nV = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, sV = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Yu;
let o1 = (Yu = class {
  constructor(e, t) {
  }
  dispose() {
  }
}, Yu.ID = "editor.contrib.markerDecorations", Yu);
o1 = nV([
  sV(1, JE)
], o1);
Xa(
  o1.ID,
  o1,
  0
  /* EditorContributionInstantiation.Eager */
);
function Zi(s, e) {
  s instanceof yO ? (s.setFontFamily(e.getMassagedFontFamily()), s.setFontWeight(e.fontWeight), s.setFontSize(e.fontSize), s.setFontFeatureSettings(e.fontFeatureSettings), s.setFontVariationSettings(e.fontVariationSettings), s.setLineHeight(e.lineHeight), s.setLetterSpacing(e.letterSpacing)) : (s.style.fontFamily = e.getMassagedFontFamily(), s.style.fontWeight = e.fontWeight, s.style.fontSize = e.fontSize + "px", s.style.fontFeatureSettings = e.fontFeatureSettings, s.style.fontVariationSettings = e.fontVariationSettings, s.style.lineHeight = e.lineHeight + "px", s.style.letterSpacing = e.letterSpacing + "px");
}
class WO extends U {
  constructor(e, t) {
    super(), this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, this._referenceDomElement = e, this._width = -1, this._height = -1, this._resizeObserver = null, this.measureReferenceDomElement(!1, t);
  }
  dispose() {
    this.stopObserving(), super.dispose();
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  startObserving() {
    if (!this._resizeObserver && this._referenceDomElement) {
      let e = null;
      const t = () => {
        e ? this.observe({ width: e.width, height: e.height }) : this.observe();
      };
      let i = !1, n = !1;
      const o = () => {
        if (i && !n)
          try {
            i = !1, n = !0, t();
          } finally {
            ns(fe(this._referenceDomElement), () => {
              n = !1, o();
            });
          }
      };
      this._resizeObserver = new ResizeObserver((r) => {
        r && r[0] && r[0].contentRect ? e = { width: r[0].contentRect.width, height: r[0].contentRect.height } : e = null, i = !0, o();
      }), this._resizeObserver.observe(this._referenceDomElement);
    }
  }
  stopObserving() {
    this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null);
  }
  observe(e) {
    this.measureReferenceDomElement(!0, e);
  }
  measureReferenceDomElement(e, t) {
    let i = 0, n = 0;
    t ? (i = t.width, n = t.height) : this._referenceDomElement && (i = this._referenceDomElement.clientWidth, n = this._referenceDomElement.clientHeight), i = Math.max(5, i), n = Math.max(5, n), (this._width !== i || this._height !== n) && (this._width = i, this._height = n, e && this._onDidChange.fire());
  }
}
class oV extends U {
  constructor(e) {
    super(), this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, this._listener = () => this._handleChange(e, !0), this._mediaQueryList = null, this._handleChange(e, !1);
  }
  _handleChange(e, t) {
    var i;
    (i = this._mediaQueryList) == null || i.removeEventListener("change", this._listener), this._mediaQueryList = e.matchMedia(`(resolution: ${e.devicePixelRatio}dppx)`), this._mediaQueryList.addEventListener("change", this._listener), t && this._onDidChange.fire();
  }
}
class rV extends U {
  get value() {
    return this._value;
  }
  constructor(e) {
    super(), this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, this._value = this._getPixelRatio(e);
    const t = this._register(new oV(e));
    this._register(t.onDidChange(() => {
      this._value = this._getPixelRatio(e), this._onDidChange.fire(this._value);
    }));
  }
  _getPixelRatio(e) {
    const t = document.createElement("canvas").getContext("2d"), i = e.devicePixelRatio || 1, n = t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1;
    return i / n;
  }
}
class aV {
  constructor() {
    this.mapWindowIdToPixelRatioMonitor = /* @__PURE__ */ new Map();
  }
  _getOrCreatePixelRatioMonitor(e) {
    const t = jb(e);
    let i = this.mapWindowIdToPixelRatioMonitor.get(t);
    return i || (i = new rV(e), this.mapWindowIdToPixelRatioMonitor.set(t, i), ee.once(V6)(({ vscodeWindowId: n }) => {
      n === t && (i == null || i.dispose(), this.mapWindowIdToPixelRatioMonitor.delete(t));
    })), i;
  }
  getInstance(e) {
    return this._getOrCreatePixelRatioMonitor(e);
  }
}
const Om = new aV();
class lV {
  constructor(e, t) {
    this.chr = e, this.type = t, this.width = 0;
  }
  fulfill(e) {
    this.width = e;
  }
}
class eI {
  constructor(e, t) {
    this._bareFontInfo = e, this._requests = t, this._container = null, this._testElements = null;
  }
  read(e) {
    var t;
    this._createDomElements(), e.document.body.appendChild(this._container), this._readFromDomElements(), (t = this._container) == null || t.remove(), this._container = null, this._testElements = null;
  }
  _createDomElements() {
    const e = document.createElement("div");
    e.style.position = "absolute", e.style.top = "-50000px", e.style.width = "50000px";
    const t = document.createElement("div");
    Zi(t, this._bareFontInfo), e.appendChild(t);
    const i = document.createElement("div");
    Zi(i, this._bareFontInfo), i.style.fontWeight = "bold", e.appendChild(i);
    const n = document.createElement("div");
    Zi(n, this._bareFontInfo), n.style.fontStyle = "italic", e.appendChild(n);
    const o = [];
    for (const r of this._requests) {
      let a;
      r.type === 0 && (a = t), r.type === 2 && (a = i), r.type === 1 && (a = n), a.appendChild(document.createElement("br"));
      const l = document.createElement("span");
      eI._render(l, r), a.appendChild(l), o.push(l);
    }
    this._container = e, this._testElements = o;
  }
  static _render(e, t) {
    if (t.chr === " ") {
      let i = " ";
      for (let n = 0; n < 8; n++)
        i += i;
      e.innerText = i;
    } else {
      let i = t.chr;
      for (let n = 0; n < 8; n++)
        i += i;
      e.textContent = i;
    }
  }
  _readFromDomElements() {
    for (let e = 0, t = this._requests.length; e < t; e++) {
      const i = this._requests[e], n = this._testElements[e];
      i.fulfill(n.offsetWidth / 256);
    }
  }
}
function cV(s, e, t) {
  new eI(e, t).read(s);
}
const ji = {
  tabSize: 4,
  indentSize: 4,
  insertSpaces: !0,
  detectIndentation: !0,
  trimAutoWhitespace: !0,
  largeFileOptimizations: !0,
  bracketPairColorizationOptions: {
    enabled: !0,
    independentColorPoolPerBracketType: !1
  }
}, HO = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
function hV(s = "") {
  let e = "(-?\\d*\\.\\d\\w*)|([^";
  for (const t of HO)
    s.indexOf(t) >= 0 || (e += "\\" + t);
  return e += "\\s]+)", new RegExp(e, "g");
}
const tI = hV();
function iI(s) {
  let e = tI;
  if (s && s instanceof RegExp)
    if (s.global)
      e = s;
    else {
      let t = "g";
      s.ignoreCase && (t += "i"), s.multiline && (t += "m"), s.unicode && (t += "u"), e = new RegExp(s.source, t);
    }
  return e.lastIndex = 0, e;
}
const VO = new Tn();
VO.unshift({
  maxLen: 1e3,
  windowSize: 15,
  timeBudget: 150
});
function Fm(s, e, t, i, n) {
  if (e = iI(e), n || (n = nt.first(VO)), t.length > n.maxLen) {
    let c = s - n.maxLen / 2;
    return c < 0 ? c = 0 : i += c, t = t.substring(c, s + n.maxLen / 2), Fm(s, e, t, i, n);
  }
  const o = Date.now(), r = s - 1 - i;
  let a = -1, l = null;
  for (let c = 1; !(Date.now() - o >= n.timeBudget); c++) {
    const h = r - n.windowSize * c;
    e.lastIndex = Math.max(0, h);
    const d = dV(e, t, r, a);
    if (!d && l || (l = d, h <= 0))
      break;
    a = h;
  }
  if (l) {
    const c = {
      word: l[0],
      startColumn: i + 1 + l.index,
      endColumn: i + 1 + l.index + l[0].length
    };
    return e.lastIndex = 0, c;
  }
  return null;
}
function dV(s, e, t, i) {
  let n;
  for (; n = s.exec(e); ) {
    const o = n.index || 0;
    if (o <= t && s.lastIndex >= t)
      return n;
    if (i > 0 && o > i)
      return null;
  }
  return null;
}
const ur = 8;
class zO {
  /**
   * @internal
   */
  constructor(e) {
    this._values = e;
  }
  hasChanged(e) {
    return this._values[e];
  }
}
class UO {
  constructor() {
    this.stableMinimapLayoutInput = null, this.stableFitMaxMinimapScale = 0, this.stableFitRemainingWidth = 0;
  }
}
class It {
  constructor(e, t, i, n) {
    this.id = e, this.name = t, this.defaultValue = i, this.schema = n;
  }
  applyUpdate(e, t) {
    return fw(e, t);
  }
  compute(e, t, i) {
    return i;
  }
}
class Og {
  constructor(e, t) {
    this.newValue = e, this.didChange = t;
  }
}
function fw(s, e) {
  if (typeof s != "object" || typeof e != "object" || !s || !e)
    return new Og(e, s !== e);
  if (Array.isArray(s) || Array.isArray(e)) {
    const i = Array.isArray(s) && Array.isArray(e) && li(s, e);
    return new Og(e, !i);
  }
  let t = !1;
  for (const i in e)
    if (e.hasOwnProperty(i)) {
      const n = fw(s[i], e[i]);
      n.didChange && (s[i] = n.newValue, t = !0);
    }
  return new Og(s, t);
}
class Pp {
  constructor(e) {
    this.schema = void 0, this.id = e, this.name = "_never_", this.defaultValue = void 0;
  }
  applyUpdate(e, t) {
    return fw(e, t);
  }
  validate(e) {
    return this.defaultValue;
  }
}
class Ff {
  constructor(e, t, i, n) {
    this.id = e, this.name = t, this.defaultValue = i, this.schema = n;
  }
  applyUpdate(e, t) {
    return fw(e, t);
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : e;
  }
  compute(e, t, i) {
    return i;
  }
}
function le(s, e) {
  return typeof s > "u" ? e : s === "false" ? !1 : !!s;
}
class qe extends Ff {
  constructor(e, t, i, n = void 0) {
    typeof n < "u" && (n.type = "boolean", n.default = i), super(e, t, i, n);
  }
  validate(e) {
    return le(e, this.defaultValue);
  }
}
function wc(s, e, t, i) {
  if (typeof s > "u")
    return e;
  let n = parseInt(s, 10);
  return isNaN(n) ? e : (n = Math.max(t, n), n = Math.min(i, n), n | 0);
}
class ft extends Ff {
  static clampedInt(e, t, i, n) {
    return wc(e, t, i, n);
  }
  constructor(e, t, i, n, o, r = void 0) {
    typeof r < "u" && (r.type = "integer", r.default = i, r.minimum = n, r.maximum = o), super(e, t, i, r), this.minimum = n, this.maximum = o;
  }
  validate(e) {
    return ft.clampedInt(e, this.defaultValue, this.minimum, this.maximum);
  }
}
function uV(s, e, t, i) {
  if (typeof s > "u")
    return e;
  const n = vs.float(s, e);
  return vs.clamp(n, t, i);
}
class vs extends Ff {
  static clamp(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  static float(e, t) {
    if (typeof e == "number")
      return e;
    if (typeof e > "u")
      return t;
    const i = parseFloat(e);
    return isNaN(i) ? t : i;
  }
  constructor(e, t, i, n, o) {
    typeof o < "u" && (o.type = "number", o.default = i), super(e, t, i, o), this.validationFn = n;
  }
  validate(e) {
    return this.validationFn(vs.float(e, this.defaultValue));
  }
}
class rn extends Ff {
  static string(e, t) {
    return typeof e != "string" ? t : e;
  }
  constructor(e, t, i, n = void 0) {
    typeof n < "u" && (n.type = "string", n.default = i), super(e, t, i, n);
  }
  validate(e) {
    return rn.string(e, this.defaultValue);
  }
}
function Ot(s, e, t, i) {
  return typeof s != "string" ? e : i && s in i ? i[s] : t.indexOf(s) === -1 ? e : s;
}
class Pt extends Ff {
  constructor(e, t, i, n, o = void 0) {
    typeof o < "u" && (o.type = "string", o.enum = n, o.default = i), super(e, t, i, o), this._allowedValues = n;
  }
  validate(e) {
    return Ot(e, this.defaultValue, this._allowedValues);
  }
}
class g_ extends It {
  constructor(e, t, i, n, o, r, a = void 0) {
    typeof a < "u" && (a.type = "string", a.enum = o, a.default = n), super(e, t, i, a), this._allowedValues = o, this._convert = r;
  }
  validate(e) {
    return typeof e != "string" ? this.defaultValue : this._allowedValues.indexOf(e) === -1 ? this.defaultValue : this._convert(e);
  }
}
function fV(s) {
  switch (s) {
    case "none":
      return 0;
    case "keep":
      return 1;
    case "brackets":
      return 2;
    case "advanced":
      return 3;
    case "full":
      return 4;
  }
}
class gV extends It {
  constructor() {
    super(2, "accessibilitySupport", 0, {
      type: "string",
      enum: ["auto", "on", "off"],
      enumDescriptions: [
        m("accessibilitySupport.auto", "Use platform APIs to detect when a Screen Reader is attached."),
        m("accessibilitySupport.on", "Optimize for usage with a Screen Reader."),
        m("accessibilitySupport.off", "Assume a screen reader is not attached.")
      ],
      default: "auto",
      tags: ["accessibility"],
      description: m("accessibilitySupport", "Controls if the UI should run in a mode where it is optimized for screen readers.")
    });
  }
  validate(e) {
    switch (e) {
      case "auto":
        return 0;
      case "off":
        return 1;
      case "on":
        return 2;
    }
    return this.defaultValue;
  }
  compute(e, t, i) {
    return i === 0 ? e.accessibilitySupport : i;
  }
}
class mV extends It {
  constructor() {
    const e = {
      insertSpace: !0,
      ignoreEmptyLines: !0
    };
    super(23, "comments", e, {
      "editor.comments.insertSpace": {
        type: "boolean",
        default: e.insertSpace,
        description: m("comments.insertSpace", "Controls whether a space character is inserted when commenting.")
      },
      "editor.comments.ignoreEmptyLines": {
        type: "boolean",
        default: e.ignoreEmptyLines,
        description: m("comments.ignoreEmptyLines", "Controls if empty lines should be ignored with toggle, add or remove actions for line comments.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      insertSpace: le(t.insertSpace, this.defaultValue.insertSpace),
      ignoreEmptyLines: le(t.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines)
    };
  }
}
function pV(s) {
  switch (s) {
    case "blink":
      return 1;
    case "smooth":
      return 2;
    case "phase":
      return 3;
    case "expand":
      return 4;
    case "solid":
      return 5;
  }
}
var Ii;
(function(s) {
  s[s.Line = 1] = "Line", s[s.Block = 2] = "Block", s[s.Underline = 3] = "Underline", s[s.LineThin = 4] = "LineThin", s[s.BlockOutline = 5] = "BlockOutline", s[s.UnderlineThin = 6] = "UnderlineThin";
})(Ii || (Ii = {}));
function _V(s) {
  switch (s) {
    case "line":
      return Ii.Line;
    case "block":
      return Ii.Block;
    case "underline":
      return Ii.Underline;
    case "line-thin":
      return Ii.LineThin;
    case "block-outline":
      return Ii.BlockOutline;
    case "underline-thin":
      return Ii.UnderlineThin;
  }
}
class bV extends Pp {
  constructor() {
    super(
      143
      /* EditorOption.editorClassName */
    );
  }
  compute(e, t, i) {
    const n = ["monaco-editor"];
    return t.get(
      39
      /* EditorOption.extraEditorClassName */
    ) && n.push(t.get(
      39
      /* EditorOption.extraEditorClassName */
    )), e.extraEditorClassName && n.push(e.extraEditorClassName), t.get(
      74
      /* EditorOption.mouseStyle */
    ) === "default" ? n.push("mouse-default") : t.get(
      74
      /* EditorOption.mouseStyle */
    ) === "copy" && n.push("mouse-copy"), t.get(
      112
      /* EditorOption.showUnused */
    ) && n.push("showUnused"), t.get(
      141
      /* EditorOption.showDeprecated */
    ) && n.push("showDeprecated"), n.join(" ");
  }
}
class CV extends qe {
  constructor() {
    super(37, "emptySelectionClipboard", !0, { description: m("emptySelectionClipboard", "Controls whether copying without a selection copies the current line.") });
  }
  compute(e, t, i) {
    return i && e.emptySelectionClipboard;
  }
}
class vV extends It {
  constructor() {
    const e = {
      cursorMoveOnType: !0,
      seedSearchStringFromSelection: "always",
      autoFindInSelection: "never",
      globalFindClipboard: !1,
      addExtraSpaceOnTop: !0,
      loop: !0
    };
    super(41, "find", e, {
      "editor.find.cursorMoveOnType": {
        type: "boolean",
        default: e.cursorMoveOnType,
        description: m("find.cursorMoveOnType", "Controls whether the cursor should jump to find matches while typing.")
      },
      "editor.find.seedSearchStringFromSelection": {
        type: "string",
        enum: ["never", "always", "selection"],
        default: e.seedSearchStringFromSelection,
        enumDescriptions: [
          m("editor.find.seedSearchStringFromSelection.never", "Never seed search string from the editor selection."),
          m("editor.find.seedSearchStringFromSelection.always", "Always seed search string from the editor selection, including word at cursor position."),
          m("editor.find.seedSearchStringFromSelection.selection", "Only seed search string from the editor selection.")
        ],
        description: m("find.seedSearchStringFromSelection", "Controls whether the search string in the Find Widget is seeded from the editor selection.")
      },
      "editor.find.autoFindInSelection": {
        type: "string",
        enum: ["never", "always", "multiline"],
        default: e.autoFindInSelection,
        enumDescriptions: [
          m("editor.find.autoFindInSelection.never", "Never turn on Find in Selection automatically (default)."),
          m("editor.find.autoFindInSelection.always", "Always turn on Find in Selection automatically."),
          m("editor.find.autoFindInSelection.multiline", "Turn on Find in Selection automatically when multiple lines of content are selected.")
        ],
        description: m("find.autoFindInSelection", "Controls the condition for turning on Find in Selection automatically.")
      },
      "editor.find.globalFindClipboard": {
        type: "boolean",
        default: e.globalFindClipboard,
        description: m("find.globalFindClipboard", "Controls whether the Find Widget should read or modify the shared find clipboard on macOS."),
        included: $e
      },
      "editor.find.addExtraSpaceOnTop": {
        type: "boolean",
        default: e.addExtraSpaceOnTop,
        description: m("find.addExtraSpaceOnTop", "Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.")
      },
      "editor.find.loop": {
        type: "boolean",
        default: e.loop,
        description: m("find.loop", "Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      cursorMoveOnType: le(t.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
      seedSearchStringFromSelection: typeof e.seedSearchStringFromSelection == "boolean" ? e.seedSearchStringFromSelection ? "always" : "never" : Ot(t.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, ["never", "always", "selection"]),
      autoFindInSelection: typeof e.autoFindInSelection == "boolean" ? e.autoFindInSelection ? "always" : "never" : Ot(t.autoFindInSelection, this.defaultValue.autoFindInSelection, ["never", "always", "multiline"]),
      globalFindClipboard: le(t.globalFindClipboard, this.defaultValue.globalFindClipboard),
      addExtraSpaceOnTop: le(t.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
      loop: le(t.loop, this.defaultValue.loop)
    };
  }
}
const ha = class ha extends It {
  constructor() {
    super(51, "fontLigatures", ha.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: m("fontLigatures", "Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.")
        },
        {
          type: "string",
          description: m("fontFeatureSettings", "Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.")
        }
      ],
      description: m("fontLigaturesGeneral", "Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property."),
      default: !1
    });
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e === "false" || e.length === 0 ? ha.OFF : e === "true" ? ha.ON : e : e ? ha.ON : ha.OFF;
  }
};
ha.OFF = '"liga" off, "calt" off', ha.ON = '"liga" on, "calt" on';
let $h = ha;
const da = class da extends It {
  constructor() {
    super(54, "fontVariations", da.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: m("fontVariations", "Enables/Disables the translation from font-weight to font-variation-settings. Change this to a string for fine-grained control of the 'font-variation-settings' CSS property.")
        },
        {
          type: "string",
          description: m("fontVariationSettings", "Explicit 'font-variation-settings' CSS property. A boolean can be passed instead if one only needs to translate font-weight to font-variation-settings.")
        }
      ],
      description: m("fontVariationsGeneral", "Configures font variations. Can be either a boolean to enable/disable the translation from font-weight to font-variation-settings or a string for the value of the CSS 'font-variation-settings' property."),
      default: !1
    });
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e === "false" ? da.OFF : e === "true" ? da.TRANSLATE : e : e ? da.TRANSLATE : da.OFF;
  }
  compute(e, t, i) {
    return e.fontInfo.fontVariationSettings;
  }
};
da.OFF = "normal", da.TRANSLATE = "translate";
let Bm = da;
class wV extends Pp {
  constructor() {
    super(
      50
      /* EditorOption.fontInfo */
    );
  }
  compute(e, t, i) {
    return e.fontInfo;
  }
}
class yV extends Ff {
  constructor() {
    super(52, "fontSize", Qn.fontSize, {
      type: "number",
      minimum: 6,
      maximum: 100,
      default: Qn.fontSize,
      description: m("fontSize", "Controls the font size in pixels.")
    });
  }
  validate(e) {
    const t = vs.float(e, this.defaultValue);
    return t === 0 ? Qn.fontSize : vs.clamp(t, 6, 100);
  }
  compute(e, t, i) {
    return e.fontInfo.fontSize;
  }
}
const Cr = class Cr extends It {
  constructor() {
    super(53, "fontWeight", Qn.fontWeight, {
      anyOf: [
        {
          type: "number",
          minimum: Cr.MINIMUM_VALUE,
          maximum: Cr.MAXIMUM_VALUE,
          errorMessage: m("fontWeightErrorMessage", 'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.')
        },
        {
          type: "string",
          pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
        },
        {
          enum: Cr.SUGGESTION_VALUES
        }
      ],
      default: Qn.fontWeight,
      description: m("fontWeight", 'Controls the font weight. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.')
    });
  }
  validate(e) {
    return e === "normal" || e === "bold" ? e : String(ft.clampedInt(e, Qn.fontWeight, Cr.MINIMUM_VALUE, Cr.MAXIMUM_VALUE));
  }
};
Cr.SUGGESTION_VALUES = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"], Cr.MINIMUM_VALUE = 1, Cr.MAXIMUM_VALUE = 1e3;
let SS = Cr;
class SV extends It {
  constructor() {
    const e = {
      multiple: "peek",
      multipleDefinitions: "peek",
      multipleTypeDefinitions: "peek",
      multipleDeclarations: "peek",
      multipleImplementations: "peek",
      multipleReferences: "peek",
      multipleTests: "peek",
      alternativeDefinitionCommand: "editor.action.goToReferences",
      alternativeTypeDefinitionCommand: "editor.action.goToReferences",
      alternativeDeclarationCommand: "editor.action.goToReferences",
      alternativeImplementationCommand: "",
      alternativeReferenceCommand: "",
      alternativeTestsCommand: ""
    }, t = {
      type: "string",
      enum: ["peek", "gotoAndPeek", "goto"],
      default: e.multiple,
      enumDescriptions: [
        m("editor.gotoLocation.multiple.peek", "Show Peek view of the results (default)"),
        m("editor.gotoLocation.multiple.gotoAndPeek", "Go to the primary result and show a Peek view"),
        m("editor.gotoLocation.multiple.goto", "Go to the primary result and enable Peek-less navigation to others")
      ]
    }, i = ["", "editor.action.referenceSearch.trigger", "editor.action.goToReferences", "editor.action.peekImplementation", "editor.action.goToImplementation", "editor.action.peekTypeDefinition", "editor.action.goToTypeDefinition", "editor.action.peekDeclaration", "editor.action.revealDeclaration", "editor.action.peekDefinition", "editor.action.revealDefinitionAside", "editor.action.revealDefinition"];
    super(58, "gotoLocation", e, {
      "editor.gotoLocation.multiple": {
        deprecationMessage: m("editor.gotoLocation.multiple.deprecated", "This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.")
      },
      "editor.gotoLocation.multipleDefinitions": {
        description: m("editor.editor.gotoLocation.multipleDefinitions", "Controls the behavior the 'Go to Definition'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.multipleTypeDefinitions": {
        description: m("editor.editor.gotoLocation.multipleTypeDefinitions", "Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.multipleDeclarations": {
        description: m("editor.editor.gotoLocation.multipleDeclarations", "Controls the behavior the 'Go to Declaration'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.multipleImplementations": {
        description: m("editor.editor.gotoLocation.multipleImplemenattions", "Controls the behavior the 'Go to Implementations'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.multipleReferences": {
        description: m("editor.editor.gotoLocation.multipleReferences", "Controls the behavior the 'Go to References'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.alternativeDefinitionCommand": {
        type: "string",
        default: e.alternativeDefinitionCommand,
        enum: i,
        description: m("alternativeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeTypeDefinitionCommand": {
        type: "string",
        default: e.alternativeTypeDefinitionCommand,
        enum: i,
        description: m("alternativeTypeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeDeclarationCommand": {
        type: "string",
        default: e.alternativeDeclarationCommand,
        enum: i,
        description: m("alternativeDeclarationCommand", "Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.")
      },
      "editor.gotoLocation.alternativeImplementationCommand": {
        type: "string",
        default: e.alternativeImplementationCommand,
        enum: i,
        description: m("alternativeImplementationCommand", "Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.")
      },
      "editor.gotoLocation.alternativeReferenceCommand": {
        type: "string",
        default: e.alternativeReferenceCommand,
        enum: i,
        description: m("alternativeReferenceCommand", "Alternative command id that is being executed when the result of 'Go to Reference' is the current location.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      multiple: Ot(t.multiple, this.defaultValue.multiple, ["peek", "gotoAndPeek", "goto"]),
      multipleDefinitions: t.multipleDefinitions ?? Ot(t.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleTypeDefinitions: t.multipleTypeDefinitions ?? Ot(t.multipleTypeDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleDeclarations: t.multipleDeclarations ?? Ot(t.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleImplementations: t.multipleImplementations ?? Ot(t.multipleImplementations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleReferences: t.multipleReferences ?? Ot(t.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleTests: t.multipleTests ?? Ot(t.multipleTests, "peek", ["peek", "gotoAndPeek", "goto"]),
      alternativeDefinitionCommand: rn.string(t.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
      alternativeTypeDefinitionCommand: rn.string(t.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
      alternativeDeclarationCommand: rn.string(t.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
      alternativeImplementationCommand: rn.string(t.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),
      alternativeReferenceCommand: rn.string(t.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand),
      alternativeTestsCommand: rn.string(t.alternativeTestsCommand, this.defaultValue.alternativeTestsCommand)
    };
  }
}
class LV extends It {
  constructor() {
    const e = {
      enabled: !0,
      delay: 300,
      hidingDelay: 300,
      sticky: !0,
      above: !0
    };
    super(60, "hover", e, {
      "editor.hover.enabled": {
        type: "boolean",
        default: e.enabled,
        description: m("hover.enabled", "Controls whether the hover is shown.")
      },
      "editor.hover.delay": {
        type: "number",
        default: e.delay,
        minimum: 0,
        maximum: 1e4,
        description: m("hover.delay", "Controls the delay in milliseconds after which the hover is shown.")
      },
      "editor.hover.sticky": {
        type: "boolean",
        default: e.sticky,
        description: m("hover.sticky", "Controls whether the hover should remain visible when mouse is moved over it.")
      },
      "editor.hover.hidingDelay": {
        type: "integer",
        minimum: 0,
        default: e.hidingDelay,
        description: m("hover.hidingDelay", "Controls the delay in milliseconds after which the hover is hidden. Requires `editor.hover.sticky` to be enabled.")
      },
      "editor.hover.above": {
        type: "boolean",
        default: e.above,
        description: m("hover.above", "Prefer showing hovers above the line, if there's space.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: le(t.enabled, this.defaultValue.enabled),
      delay: ft.clampedInt(t.delay, this.defaultValue.delay, 0, 1e4),
      sticky: le(t.sticky, this.defaultValue.sticky),
      hidingDelay: ft.clampedInt(t.hidingDelay, this.defaultValue.hidingDelay, 0, 6e5),
      above: le(t.above, this.defaultValue.above)
    };
  }
}
class Mu extends Pp {
  constructor() {
    super(
      146
      /* EditorOption.layoutInfo */
    );
  }
  compute(e, t, i) {
    return Mu.computeLayout(t, {
      memory: e.memory,
      outerWidth: e.outerWidth,
      outerHeight: e.outerHeight,
      isDominatedByLongLines: e.isDominatedByLongLines,
      lineHeight: e.fontInfo.lineHeight,
      viewLineCount: e.viewLineCount,
      lineNumbersDigitCount: e.lineNumbersDigitCount,
      typicalHalfwidthCharacterWidth: e.fontInfo.typicalHalfwidthCharacterWidth,
      maxDigitWidth: e.fontInfo.maxDigitWidth,
      pixelRatio: e.pixelRatio,
      glyphMarginDecorationLaneCount: e.glyphMarginDecorationLaneCount
    });
  }
  static computeContainedMinimapLineCount(e) {
    const t = e.height / e.lineHeight, i = Math.floor(e.paddingTop / e.lineHeight);
    let n = Math.floor(e.paddingBottom / e.lineHeight);
    e.scrollBeyondLastLine && (n = Math.max(n, t - 1));
    const o = (i + e.viewLineCount + n) / (e.pixelRatio * e.height), r = Math.floor(e.viewLineCount / o);
    return { typicalViewportLineCount: t, extraLinesBeforeFirstLine: i, extraLinesBeyondLastLine: n, desiredRatio: o, minimapLineCount: r };
  }
  static _computeMinimapLayout(e, t) {
    const i = e.outerWidth, n = e.outerHeight, o = e.pixelRatio;
    if (!e.minimap.enabled)
      return {
        renderMinimap: 0,
        minimapLeft: 0,
        minimapWidth: 0,
        minimapHeightIsEditorHeight: !1,
        minimapIsSampling: !1,
        minimapScale: 1,
        minimapLineHeight: 1,
        minimapCanvasInnerWidth: 0,
        minimapCanvasInnerHeight: Math.floor(o * n),
        minimapCanvasOuterWidth: 0,
        minimapCanvasOuterHeight: n
      };
    const r = t.stableMinimapLayoutInput, a = r && e.outerHeight === r.outerHeight && e.lineHeight === r.lineHeight && e.typicalHalfwidthCharacterWidth === r.typicalHalfwidthCharacterWidth && e.pixelRatio === r.pixelRatio && e.scrollBeyondLastLine === r.scrollBeyondLastLine && e.paddingTop === r.paddingTop && e.paddingBottom === r.paddingBottom && e.minimap.enabled === r.minimap.enabled && e.minimap.side === r.minimap.side && e.minimap.size === r.minimap.size && e.minimap.showSlider === r.minimap.showSlider && e.minimap.renderCharacters === r.minimap.renderCharacters && e.minimap.maxColumn === r.minimap.maxColumn && e.minimap.scale === r.minimap.scale && e.verticalScrollbarWidth === r.verticalScrollbarWidth && e.isViewportWrapping === r.isViewportWrapping, l = e.lineHeight, c = e.typicalHalfwidthCharacterWidth, h = e.scrollBeyondLastLine, d = e.minimap.renderCharacters;
    let u = o >= 2 ? Math.round(e.minimap.scale * 2) : e.minimap.scale;
    const f = e.minimap.maxColumn, g = e.minimap.size, p = e.minimap.side, _ = e.verticalScrollbarWidth, b = e.viewLineCount, C = e.remainingWidth, w = e.isViewportWrapping, v = d ? 2 : 3;
    let S = Math.floor(o * n);
    const L = S / o;
    let k = !1, x = !1, I = v * u, K = u / o, B = 1;
    if (g === "fill" || g === "fit") {
      const { typicalViewportLineCount: ae, extraLinesBeforeFirstLine: re, extraLinesBeyondLastLine: be, desiredRatio: Ce, minimapLineCount: At } = Mu.computeContainedMinimapLineCount({
        viewLineCount: b,
        scrollBeyondLastLine: h,
        paddingTop: e.paddingTop,
        paddingBottom: e.paddingBottom,
        height: n,
        lineHeight: l,
        pixelRatio: o
      });
      if (b / At > 1)
        k = !0, x = !0, u = 1, I = 1, K = u / o;
      else {
        let ct = !1, ot = u + 1;
        if (g === "fit") {
          const Xt = Math.ceil((re + b + be) * I);
          w && a && C <= t.stableFitRemainingWidth ? (ct = !0, ot = t.stableFitMaxMinimapScale) : ct = Xt > S;
        }
        if (g === "fill" || ct) {
          k = !0;
          const Xt = u;
          I = Math.min(l * o, Math.max(1, Math.floor(1 / Ce))), w && a && C <= t.stableFitRemainingWidth && (ot = t.stableFitMaxMinimapScale), u = Math.min(ot, Math.max(1, Math.floor(I / v))), u > Xt && (B = Math.min(2, u / Xt)), K = u / o / B, S = Math.ceil(Math.max(ae, re + b + be) * I), w ? (t.stableMinimapLayoutInput = e, t.stableFitRemainingWidth = C, t.stableFitMaxMinimapScale = u) : (t.stableMinimapLayoutInput = null, t.stableFitRemainingWidth = 0);
        }
      }
    }
    const W = Math.floor(f * K), H = Math.min(W, Math.max(0, Math.floor((C - _ - 2) * K / (c + K))) + ur);
    let P = Math.floor(o * H);
    const q = P / o;
    P = Math.floor(P * B);
    const J = d ? 1 : 2, oe = p === "left" ? 0 : i - H - _;
    return {
      renderMinimap: J,
      minimapLeft: oe,
      minimapWidth: H,
      minimapHeightIsEditorHeight: k,
      minimapIsSampling: x,
      minimapScale: u,
      minimapLineHeight: I,
      minimapCanvasInnerWidth: P,
      minimapCanvasInnerHeight: S,
      minimapCanvasOuterWidth: q,
      minimapCanvasOuterHeight: L
    };
  }
  static computeLayout(e, t) {
    const i = t.outerWidth | 0, n = t.outerHeight | 0, o = t.lineHeight | 0, r = t.lineNumbersDigitCount | 0, a = t.typicalHalfwidthCharacterWidth, l = t.maxDigitWidth, c = t.pixelRatio, h = t.viewLineCount, d = e.get(
      138
      /* EditorOption.wordWrapOverride2 */
    ), u = d === "inherit" ? e.get(
      137
      /* EditorOption.wordWrapOverride1 */
    ) : d, f = u === "inherit" ? e.get(
      133
      /* EditorOption.wordWrap */
    ) : u, g = e.get(
      136
      /* EditorOption.wordWrapColumn */
    ), p = t.isDominatedByLongLines, _ = e.get(
      57
      /* EditorOption.glyphMargin */
    ), b = e.get(
      68
      /* EditorOption.lineNumbers */
    ).renderType !== 0, C = e.get(
      69
      /* EditorOption.lineNumbersMinChars */
    ), w = e.get(
      106
      /* EditorOption.scrollBeyondLastLine */
    ), v = e.get(
      84
      /* EditorOption.padding */
    ), S = e.get(
      73
      /* EditorOption.minimap */
    ), L = e.get(
      104
      /* EditorOption.scrollbar */
    ), k = L.verticalScrollbarSize, x = L.verticalHasArrows, I = L.arrowSize, K = L.horizontalScrollbarSize, B = e.get(
      43
      /* EditorOption.folding */
    ), W = e.get(
      111
      /* EditorOption.showFoldingControls */
    ) !== "never";
    let H = e.get(
      66
      /* EditorOption.lineDecorationsWidth */
    );
    B && W && (H += 16);
    let P = 0;
    if (b) {
      const Sn = Math.max(r, C);
      P = Math.round(Sn * l);
    }
    let q = 0;
    _ && (q = o * t.glyphMarginDecorationLaneCount);
    let J = 0, oe = J + q, ae = oe + P, re = ae + H;
    const be = i - q - P - H;
    let Ce = !1, At = !1, ye = -1;
    u === "inherit" && p ? (Ce = !0, At = !0) : f === "on" || f === "bounded" ? At = !0 : f === "wordWrapColumn" && (ye = g);
    const ct = Mu._computeMinimapLayout({
      outerWidth: i,
      outerHeight: n,
      lineHeight: o,
      typicalHalfwidthCharacterWidth: a,
      pixelRatio: c,
      scrollBeyondLastLine: w,
      paddingTop: v.top,
      paddingBottom: v.bottom,
      minimap: S,
      verticalScrollbarWidth: k,
      viewLineCount: h,
      remainingWidth: be,
      isViewportWrapping: At
    }, t.memory || new UO());
    ct.renderMinimap !== 0 && ct.minimapLeft === 0 && (J += ct.minimapWidth, oe += ct.minimapWidth, ae += ct.minimapWidth, re += ct.minimapWidth);
    const ot = be - ct.minimapWidth, Xt = Math.max(1, Math.floor((ot - k - 2) / a)), hn = x ? I : 0;
    return At && (ye = Math.max(1, Xt), f === "bounded" && (ye = Math.min(ye, g))), {
      width: i,
      height: n,
      glyphMarginLeft: J,
      glyphMarginWidth: q,
      glyphMarginDecorationLaneCount: t.glyphMarginDecorationLaneCount,
      lineNumbersLeft: oe,
      lineNumbersWidth: P,
      decorationsLeft: ae,
      decorationsWidth: H,
      contentLeft: re,
      contentWidth: ot,
      minimap: ct,
      viewportColumn: Xt,
      isWordWrapMinified: Ce,
      isViewportWrapping: At,
      wrappingColumn: ye,
      verticalScrollbarWidth: k,
      horizontalScrollbarHeight: K,
      overviewRuler: {
        top: hn,
        width: k,
        height: n - 2 * hn,
        right: 0
      }
    };
  }
}
class kV extends It {
  constructor() {
    super(140, "wrappingStrategy", "simple", {
      "editor.wrappingStrategy": {
        enumDescriptions: [
          m("wrappingStrategy.simple", "Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width."),
          m("wrappingStrategy.advanced", "Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.")
        ],
        type: "string",
        enum: ["simple", "advanced"],
        default: "simple",
        description: m("wrappingStrategy", "Controls the algorithm that computes wrapping points. Note that when in accessibility mode, advanced will be used for the best experience.")
      }
    });
  }
  validate(e) {
    return Ot(e, "simple", ["simple", "advanced"]);
  }
  compute(e, t, i) {
    return t.get(
      2
      /* EditorOption.accessibilitySupport */
    ) === 2 ? "advanced" : i;
  }
}
var eo;
(function(s) {
  s.Off = "off", s.OnCode = "onCode", s.On = "on";
})(eo || (eo = {}));
class xV extends It {
  constructor() {
    const e = { enabled: eo.OnCode };
    super(65, "lightbulb", e, {
      "editor.lightbulb.enabled": {
        type: "string",
        tags: ["experimental"],
        enum: [eo.Off, eo.OnCode, eo.On],
        default: e.enabled,
        enumDescriptions: [
          m("editor.lightbulb.enabled.off", "Disable the code action menu."),
          m("editor.lightbulb.enabled.onCode", "Show the code action menu when the cursor is on lines with code."),
          m("editor.lightbulb.enabled.on", "Show the code action menu when the cursor is on lines with code or on empty lines.")
        ],
        description: m("enabled", "Enables the Code Action lightbulb in the editor.")
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      enabled: Ot(e.enabled, this.defaultValue.enabled, [eo.Off, eo.OnCode, eo.On])
    };
  }
}
class DV extends It {
  constructor() {
    const e = { enabled: !0, maxLineCount: 5, defaultModel: "outlineModel", scrollWithEditor: !0 };
    super(116, "stickyScroll", e, {
      "editor.stickyScroll.enabled": {
        type: "boolean",
        default: e.enabled,
        description: m("editor.stickyScroll.enabled", "Shows the nested current scopes during the scroll at the top of the editor."),
        tags: ["experimental"]
      },
      "editor.stickyScroll.maxLineCount": {
        type: "number",
        default: e.maxLineCount,
        minimum: 1,
        maximum: 20,
        description: m("editor.stickyScroll.maxLineCount", "Defines the maximum number of sticky lines to show.")
      },
      "editor.stickyScroll.defaultModel": {
        type: "string",
        enum: ["outlineModel", "foldingProviderModel", "indentationModel"],
        default: e.defaultModel,
        description: m("editor.stickyScroll.defaultModel", "Defines the model to use for determining which lines to stick. If the outline model does not exist, it will fall back on the folding provider model which falls back on the indentation model. This order is respected in all three cases.")
      },
      "editor.stickyScroll.scrollWithEditor": {
        type: "boolean",
        default: e.scrollWithEditor,
        description: m("editor.stickyScroll.scrollWithEditor", "Enable scrolling of Sticky Scroll with the editor's horizontal scrollbar.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: le(t.enabled, this.defaultValue.enabled),
      maxLineCount: ft.clampedInt(t.maxLineCount, this.defaultValue.maxLineCount, 1, 20),
      defaultModel: Ot(t.defaultModel, this.defaultValue.defaultModel, ["outlineModel", "foldingProviderModel", "indentationModel"]),
      scrollWithEditor: le(t.scrollWithEditor, this.defaultValue.scrollWithEditor)
    };
  }
}
class EV extends It {
  constructor() {
    const e = { enabled: "on", fontSize: 0, fontFamily: "", padding: !1 };
    super(142, "inlayHints", e, {
      "editor.inlayHints.enabled": {
        type: "string",
        default: e.enabled,
        description: m("inlayHints.enable", "Enables the inlay hints in the editor."),
        enum: ["on", "onUnlessPressed", "offUnlessPressed", "off"],
        markdownEnumDescriptions: [
          m("editor.inlayHints.on", "Inlay hints are enabled"),
          m("editor.inlayHints.onUnlessPressed", "Inlay hints are showing by default and hide when holding {0}", $e ? "Ctrl+Option" : "Ctrl+Alt"),
          m("editor.inlayHints.offUnlessPressed", "Inlay hints are hidden by default and show when holding {0}", $e ? "Ctrl+Option" : "Ctrl+Alt"),
          m("editor.inlayHints.off", "Inlay hints are disabled")
        ]
      },
      "editor.inlayHints.fontSize": {
        type: "number",
        default: e.fontSize,
        markdownDescription: m("inlayHints.fontSize", "Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.", "`#editor.fontSize#`", "`5`")
      },
      "editor.inlayHints.fontFamily": {
        type: "string",
        default: e.fontFamily,
        markdownDescription: m("inlayHints.fontFamily", "Controls font family of inlay hints in the editor. When set to empty, the {0} is used.", "`#editor.fontFamily#`")
      },
      "editor.inlayHints.padding": {
        type: "boolean",
        default: e.padding,
        description: m("inlayHints.padding", "Enables the padding around the inlay hints in the editor.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return typeof t.enabled == "boolean" && (t.enabled = t.enabled ? "on" : "off"), {
      enabled: Ot(t.enabled, this.defaultValue.enabled, ["on", "off", "offUnlessPressed", "onUnlessPressed"]),
      fontSize: ft.clampedInt(t.fontSize, this.defaultValue.fontSize, 0, 100),
      fontFamily: rn.string(t.fontFamily, this.defaultValue.fontFamily),
      padding: le(t.padding, this.defaultValue.padding)
    };
  }
}
class IV extends It {
  constructor() {
    super(66, "lineDecorationsWidth", 10);
  }
  validate(e) {
    return typeof e == "string" && /^\d+(\.\d+)?ch$/.test(e) ? -parseFloat(e.substring(0, e.length - 2)) : ft.clampedInt(e, this.defaultValue, 0, 1e3);
  }
  compute(e, t, i) {
    return i < 0 ? ft.clampedInt(-i * e.fontInfo.typicalHalfwidthCharacterWidth, this.defaultValue, 0, 1e3) : i;
  }
}
class NV extends vs {
  constructor() {
    super(67, "lineHeight", Qn.lineHeight, (e) => vs.clamp(e, 0, 150), { markdownDescription: m("lineHeight", `Controls the line height. 
 - Use 0 to automatically compute the line height from the font size.
 - Values between 0 and 8 will be used as a multiplier with the font size.
 - Values greater than or equal to 8 will be used as effective values.`) });
  }
  compute(e, t, i) {
    return e.fontInfo.lineHeight;
  }
}
class TV extends It {
  constructor() {
    const e = {
      enabled: !0,
      size: "proportional",
      side: "right",
      showSlider: "mouseover",
      autohide: !1,
      renderCharacters: !0,
      maxColumn: 120,
      scale: 1,
      showRegionSectionHeaders: !0,
      showMarkSectionHeaders: !0,
      sectionHeaderFontSize: 9,
      sectionHeaderLetterSpacing: 1
    };
    super(73, "minimap", e, {
      "editor.minimap.enabled": {
        type: "boolean",
        default: e.enabled,
        description: m("minimap.enabled", "Controls whether the minimap is shown.")
      },
      "editor.minimap.autohide": {
        type: "boolean",
        default: e.autohide,
        description: m("minimap.autohide", "Controls whether the minimap is hidden automatically.")
      },
      "editor.minimap.size": {
        type: "string",
        enum: ["proportional", "fill", "fit"],
        enumDescriptions: [
          m("minimap.size.proportional", "The minimap has the same size as the editor contents (and might scroll)."),
          m("minimap.size.fill", "The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling)."),
          m("minimap.size.fit", "The minimap will shrink as necessary to never be larger than the editor (no scrolling).")
        ],
        default: e.size,
        description: m("minimap.size", "Controls the size of the minimap.")
      },
      "editor.minimap.side": {
        type: "string",
        enum: ["left", "right"],
        default: e.side,
        description: m("minimap.side", "Controls the side where to render the minimap.")
      },
      "editor.minimap.showSlider": {
        type: "string",
        enum: ["always", "mouseover"],
        default: e.showSlider,
        description: m("minimap.showSlider", "Controls when the minimap slider is shown.")
      },
      "editor.minimap.scale": {
        type: "number",
        default: e.scale,
        minimum: 1,
        maximum: 3,
        enum: [1, 2, 3],
        description: m("minimap.scale", "Scale of content drawn in the minimap: 1, 2 or 3.")
      },
      "editor.minimap.renderCharacters": {
        type: "boolean",
        default: e.renderCharacters,
        description: m("minimap.renderCharacters", "Render the actual characters on a line as opposed to color blocks.")
      },
      "editor.minimap.maxColumn": {
        type: "number",
        default: e.maxColumn,
        description: m("minimap.maxColumn", "Limit the width of the minimap to render at most a certain number of columns.")
      },
      "editor.minimap.showRegionSectionHeaders": {
        type: "boolean",
        default: e.showRegionSectionHeaders,
        description: m("minimap.showRegionSectionHeaders", "Controls whether named regions are shown as section headers in the minimap.")
      },
      "editor.minimap.showMarkSectionHeaders": {
        type: "boolean",
        default: e.showMarkSectionHeaders,
        description: m("minimap.showMarkSectionHeaders", "Controls whether MARK: comments are shown as section headers in the minimap.")
      },
      "editor.minimap.sectionHeaderFontSize": {
        type: "number",
        default: e.sectionHeaderFontSize,
        description: m("minimap.sectionHeaderFontSize", "Controls the font size of section headers in the minimap.")
      },
      "editor.minimap.sectionHeaderLetterSpacing": {
        type: "number",
        default: e.sectionHeaderLetterSpacing,
        description: m("minimap.sectionHeaderLetterSpacing", "Controls the amount of space (in pixels) between characters of section header. This helps the readability of the header in small font sizes.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: le(t.enabled, this.defaultValue.enabled),
      autohide: le(t.autohide, this.defaultValue.autohide),
      size: Ot(t.size, this.defaultValue.size, ["proportional", "fill", "fit"]),
      side: Ot(t.side, this.defaultValue.side, ["right", "left"]),
      showSlider: Ot(t.showSlider, this.defaultValue.showSlider, ["always", "mouseover"]),
      renderCharacters: le(t.renderCharacters, this.defaultValue.renderCharacters),
      scale: ft.clampedInt(t.scale, 1, 1, 3),
      maxColumn: ft.clampedInt(t.maxColumn, this.defaultValue.maxColumn, 1, 1e4),
      showRegionSectionHeaders: le(t.showRegionSectionHeaders, this.defaultValue.showRegionSectionHeaders),
      showMarkSectionHeaders: le(t.showMarkSectionHeaders, this.defaultValue.showMarkSectionHeaders),
      sectionHeaderFontSize: vs.clamp(t.sectionHeaderFontSize ?? this.defaultValue.sectionHeaderFontSize, 4, 32),
      sectionHeaderLetterSpacing: vs.clamp(t.sectionHeaderLetterSpacing ?? this.defaultValue.sectionHeaderLetterSpacing, 0, 5)
    };
  }
}
function MV(s) {
  return s === "ctrlCmd" ? $e ? "metaKey" : "ctrlKey" : "altKey";
}
class RV extends It {
  constructor() {
    super(84, "padding", { top: 0, bottom: 0 }, {
      "editor.padding.top": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: m("padding.top", "Controls the amount of space between the top edge of the editor and the first line.")
      },
      "editor.padding.bottom": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: m("padding.bottom", "Controls the amount of space between the bottom edge of the editor and the last line.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      top: ft.clampedInt(t.top, 0, 0, 1e3),
      bottom: ft.clampedInt(t.bottom, 0, 0, 1e3)
    };
  }
}
class AV extends It {
  constructor() {
    const e = {
      enabled: !0,
      cycle: !0
    };
    super(86, "parameterHints", e, {
      "editor.parameterHints.enabled": {
        type: "boolean",
        default: e.enabled,
        description: m("parameterHints.enabled", "Enables a pop-up that shows parameter documentation and type information as you type.")
      },
      "editor.parameterHints.cycle": {
        type: "boolean",
        default: e.cycle,
        description: m("parameterHints.cycle", "Controls whether the parameter hints menu cycles or closes when reaching the end of the list.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: le(t.enabled, this.defaultValue.enabled),
      cycle: le(t.cycle, this.defaultValue.cycle)
    };
  }
}
class PV extends Pp {
  constructor() {
    super(
      144
      /* EditorOption.pixelRatio */
    );
  }
  compute(e, t, i) {
    return e.pixelRatio;
  }
}
class OV extends It {
  constructor() {
    super(88, "placeholder", void 0);
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e : this.defaultValue;
  }
}
class FV extends It {
  constructor() {
    const e = {
      other: "on",
      comments: "off",
      strings: "off"
    }, t = [
      { type: "boolean" },
      {
        type: "string",
        enum: ["on", "inline", "off"],
        enumDescriptions: [m("on", "Quick suggestions show inside the suggest widget"), m("inline", "Quick suggestions show as ghost text"), m("off", "Quick suggestions are disabled")]
      }
    ];
    super(90, "quickSuggestions", e, {
      type: "object",
      additionalProperties: !1,
      properties: {
        strings: {
          anyOf: t,
          default: e.strings,
          description: m("quickSuggestions.strings", "Enable quick suggestions inside strings.")
        },
        comments: {
          anyOf: t,
          default: e.comments,
          description: m("quickSuggestions.comments", "Enable quick suggestions inside comments.")
        },
        other: {
          anyOf: t,
          default: e.other,
          description: m("quickSuggestions.other", "Enable quick suggestions outside of strings and comments.")
        }
      },
      default: e,
      markdownDescription: m("quickSuggestions", "Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the {0}-setting which controls if suggestions are triggered by special characters.", "`#editor.suggestOnTriggerCharacters#`")
    }), this.defaultValue = e;
  }
  validate(e) {
    if (typeof e == "boolean") {
      const c = e ? "on" : "off";
      return { comments: c, strings: c, other: c };
    }
    if (!e || typeof e != "object")
      return this.defaultValue;
    const { other: t, comments: i, strings: n } = e, o = ["on", "inline", "off"];
    let r, a, l;
    return typeof t == "boolean" ? r = t ? "on" : "off" : r = Ot(t, this.defaultValue.other, o), typeof i == "boolean" ? a = i ? "on" : "off" : a = Ot(i, this.defaultValue.comments, o), typeof n == "boolean" ? l = n ? "on" : "off" : l = Ot(n, this.defaultValue.strings, o), {
      other: r,
      comments: a,
      strings: l
    };
  }
}
class BV extends It {
  constructor() {
    super(68, "lineNumbers", { renderType: 1, renderFn: null }, {
      type: "string",
      enum: ["off", "on", "relative", "interval"],
      enumDescriptions: [
        m("lineNumbers.off", "Line numbers are not rendered."),
        m("lineNumbers.on", "Line numbers are rendered as absolute number."),
        m("lineNumbers.relative", "Line numbers are rendered as distance in lines to cursor position."),
        m("lineNumbers.interval", "Line numbers are rendered every 10 lines.")
      ],
      default: "on",
      description: m("lineNumbers", "Controls the display of line numbers.")
    });
  }
  validate(e) {
    let t = this.defaultValue.renderType, i = this.defaultValue.renderFn;
    return typeof e < "u" && (typeof e == "function" ? (t = 4, i = e) : e === "interval" ? t = 3 : e === "relative" ? t = 2 : e === "on" ? t = 1 : t = 0), {
      renderType: t,
      renderFn: i
    };
  }
}
function r1(s) {
  const e = s.get(
    99
    /* EditorOption.renderValidationDecorations */
  );
  return e === "editable" ? s.get(
    92
    /* EditorOption.readOnly */
  ) : e !== "on";
}
class WV extends It {
  constructor() {
    const e = [], t = { type: "number", description: m("rulers.size", "Number of monospace characters at which this editor ruler will render.") };
    super(103, "rulers", e, {
      type: "array",
      items: {
        anyOf: [
          t,
          {
            type: [
              "object"
            ],
            properties: {
              column: t,
              color: {
                type: "string",
                description: m("rulers.color", "Color of this editor ruler."),
                format: "color-hex"
              }
            }
          }
        ]
      },
      default: e,
      description: m("rulers", "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.")
    });
  }
  validate(e) {
    if (Array.isArray(e)) {
      const t = [];
      for (const i of e)
        if (typeof i == "number")
          t.push({
            column: ft.clampedInt(i, 0, 0, 1e4),
            color: null
          });
        else if (i && typeof i == "object") {
          const n = i;
          t.push({
            column: ft.clampedInt(n.column, 0, 0, 1e4),
            color: n.color
          });
        }
      return t.sort((i, n) => i.column - n.column), t;
    }
    return this.defaultValue;
  }
}
class HV extends It {
  constructor() {
    super(93, "readOnlyMessage", void 0);
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : e;
  }
}
function uT(s, e) {
  if (typeof s != "string")
    return e;
  switch (s) {
    case "hidden":
      return 2;
    case "visible":
      return 3;
    default:
      return 1;
  }
}
let VV = class extends It {
  constructor() {
    const e = {
      vertical: 1,
      horizontal: 1,
      arrowSize: 11,
      useShadows: !0,
      verticalHasArrows: !1,
      horizontalHasArrows: !1,
      horizontalScrollbarSize: 12,
      horizontalSliderSize: 12,
      verticalScrollbarSize: 14,
      verticalSliderSize: 14,
      handleMouseWheel: !0,
      alwaysConsumeMouseWheel: !0,
      scrollByPage: !1,
      ignoreHorizontalScrollbarInContentHeight: !1
    };
    super(104, "scrollbar", e, {
      "editor.scrollbar.vertical": {
        type: "string",
        enum: ["auto", "visible", "hidden"],
        enumDescriptions: [
          m("scrollbar.vertical.auto", "The vertical scrollbar will be visible only when necessary."),
          m("scrollbar.vertical.visible", "The vertical scrollbar will always be visible."),
          m("scrollbar.vertical.fit", "The vertical scrollbar will always be hidden.")
        ],
        default: "auto",
        description: m("scrollbar.vertical", "Controls the visibility of the vertical scrollbar.")
      },
      "editor.scrollbar.horizontal": {
        type: "string",
        enum: ["auto", "visible", "hidden"],
        enumDescriptions: [
          m("scrollbar.horizontal.auto", "The horizontal scrollbar will be visible only when necessary."),
          m("scrollbar.horizontal.visible", "The horizontal scrollbar will always be visible."),
          m("scrollbar.horizontal.fit", "The horizontal scrollbar will always be hidden.")
        ],
        default: "auto",
        description: m("scrollbar.horizontal", "Controls the visibility of the horizontal scrollbar.")
      },
      "editor.scrollbar.verticalScrollbarSize": {
        type: "number",
        default: e.verticalScrollbarSize,
        description: m("scrollbar.verticalScrollbarSize", "The width of the vertical scrollbar.")
      },
      "editor.scrollbar.horizontalScrollbarSize": {
        type: "number",
        default: e.horizontalScrollbarSize,
        description: m("scrollbar.horizontalScrollbarSize", "The height of the horizontal scrollbar.")
      },
      "editor.scrollbar.scrollByPage": {
        type: "boolean",
        default: e.scrollByPage,
        description: m("scrollbar.scrollByPage", "Controls whether clicks scroll by page or jump to click position.")
      },
      "editor.scrollbar.ignoreHorizontalScrollbarInContentHeight": {
        type: "boolean",
        default: e.ignoreHorizontalScrollbarInContentHeight,
        description: m("scrollbar.ignoreHorizontalScrollbarInContentHeight", "When set, the horizontal scrollbar will not increase the size of the editor's content.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e, i = ft.clampedInt(t.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3), n = ft.clampedInt(t.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3);
    return {
      arrowSize: ft.clampedInt(t.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
      vertical: uT(t.vertical, this.defaultValue.vertical),
      horizontal: uT(t.horizontal, this.defaultValue.horizontal),
      useShadows: le(t.useShadows, this.defaultValue.useShadows),
      verticalHasArrows: le(t.verticalHasArrows, this.defaultValue.verticalHasArrows),
      horizontalHasArrows: le(t.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
      handleMouseWheel: le(t.handleMouseWheel, this.defaultValue.handleMouseWheel),
      alwaysConsumeMouseWheel: le(t.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
      horizontalScrollbarSize: i,
      horizontalSliderSize: ft.clampedInt(t.horizontalSliderSize, i, 0, 1e3),
      verticalScrollbarSize: n,
      verticalSliderSize: ft.clampedInt(t.verticalSliderSize, n, 0, 1e3),
      scrollByPage: le(t.scrollByPage, this.defaultValue.scrollByPage),
      ignoreHorizontalScrollbarInContentHeight: le(t.ignoreHorizontalScrollbarInContentHeight, this.defaultValue.ignoreHorizontalScrollbarInContentHeight)
    };
  }
};
const ko = "inUntrustedWorkspace", gc = {
  allowedCharacters: "editor.unicodeHighlight.allowedCharacters",
  invisibleCharacters: "editor.unicodeHighlight.invisibleCharacters",
  nonBasicASCII: "editor.unicodeHighlight.nonBasicASCII",
  ambiguousCharacters: "editor.unicodeHighlight.ambiguousCharacters",
  includeComments: "editor.unicodeHighlight.includeComments",
  includeStrings: "editor.unicodeHighlight.includeStrings",
  allowedLocales: "editor.unicodeHighlight.allowedLocales"
};
class zV extends It {
  constructor() {
    const e = {
      nonBasicASCII: ko,
      invisibleCharacters: !0,
      ambiguousCharacters: !0,
      includeComments: ko,
      includeStrings: !0,
      allowedCharacters: {},
      allowedLocales: { _os: !0, _vscode: !0 }
    };
    super(126, "unicodeHighlight", e, {
      [gc.nonBasicASCII]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, ko],
        default: e.nonBasicASCII,
        description: m("unicodeHighlight.nonBasicASCII", "Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.")
      },
      [gc.invisibleCharacters]: {
        restricted: !0,
        type: "boolean",
        default: e.invisibleCharacters,
        description: m("unicodeHighlight.invisibleCharacters", "Controls whether characters that just reserve space or have no width at all are highlighted.")
      },
      [gc.ambiguousCharacters]: {
        restricted: !0,
        type: "boolean",
        default: e.ambiguousCharacters,
        description: m("unicodeHighlight.ambiguousCharacters", "Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.")
      },
      [gc.includeComments]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, ko],
        default: e.includeComments,
        description: m("unicodeHighlight.includeComments", "Controls whether characters in comments should also be subject to Unicode highlighting.")
      },
      [gc.includeStrings]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, ko],
        default: e.includeStrings,
        description: m("unicodeHighlight.includeStrings", "Controls whether characters in strings should also be subject to Unicode highlighting.")
      },
      [gc.allowedCharacters]: {
        restricted: !0,
        type: "object",
        default: e.allowedCharacters,
        description: m("unicodeHighlight.allowedCharacters", "Defines allowed characters that are not being highlighted."),
        additionalProperties: {
          type: "boolean"
        }
      },
      [gc.allowedLocales]: {
        restricted: !0,
        type: "object",
        additionalProperties: {
          type: "boolean"
        },
        default: e.allowedLocales,
        description: m("unicodeHighlight.allowedLocales", "Unicode characters that are common in allowed locales are not being highlighted.")
      }
    });
  }
  applyUpdate(e, t) {
    let i = !1;
    t.allowedCharacters && e && (Xn(e.allowedCharacters, t.allowedCharacters) || (e = { ...e, allowedCharacters: t.allowedCharacters }, i = !0)), t.allowedLocales && e && (Xn(e.allowedLocales, t.allowedLocales) || (e = { ...e, allowedLocales: t.allowedLocales }, i = !0));
    const n = super.applyUpdate(e, t);
    return i ? new Og(n.newValue, !0) : n;
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      nonBasicASCII: Ru(t.nonBasicASCII, ko, [!0, !1, ko]),
      invisibleCharacters: le(t.invisibleCharacters, this.defaultValue.invisibleCharacters),
      ambiguousCharacters: le(t.ambiguousCharacters, this.defaultValue.ambiguousCharacters),
      includeComments: Ru(t.includeComments, ko, [!0, !1, ko]),
      includeStrings: Ru(t.includeStrings, ko, [!0, !1, ko]),
      allowedCharacters: this.validateBooleanMap(e.allowedCharacters, this.defaultValue.allowedCharacters),
      allowedLocales: this.validateBooleanMap(e.allowedLocales, this.defaultValue.allowedLocales)
    };
  }
  validateBooleanMap(e, t) {
    if (typeof e != "object" || !e)
      return t;
    const i = {};
    for (const [n, o] of Object.entries(e))
      o === !0 && (i[n] = !0);
    return i;
  }
}
class UV extends It {
  constructor() {
    const e = {
      enabled: !0,
      mode: "subwordSmart",
      showToolbar: "onHover",
      suppressSuggestions: !1,
      keepOnBlur: !1,
      fontFamily: "default"
    };
    super(62, "inlineSuggest", e, {
      "editor.inlineSuggest.enabled": {
        type: "boolean",
        default: e.enabled,
        description: m("inlineSuggest.enabled", "Controls whether to automatically show inline suggestions in the editor.")
      },
      "editor.inlineSuggest.showToolbar": {
        type: "string",
        default: e.showToolbar,
        enum: ["always", "onHover", "never"],
        enumDescriptions: [
          m("inlineSuggest.showToolbar.always", "Show the inline suggestion toolbar whenever an inline suggestion is shown."),
          m("inlineSuggest.showToolbar.onHover", "Show the inline suggestion toolbar when hovering over an inline suggestion."),
          m("inlineSuggest.showToolbar.never", "Never show the inline suggestion toolbar.")
        ],
        description: m("inlineSuggest.showToolbar", "Controls when to show the inline suggestion toolbar.")
      },
      "editor.inlineSuggest.suppressSuggestions": {
        type: "boolean",
        default: e.suppressSuggestions,
        description: m("inlineSuggest.suppressSuggestions", "Controls how inline suggestions interact with the suggest widget. If enabled, the suggest widget is not shown automatically when inline suggestions are available.")
      },
      "editor.inlineSuggest.fontFamily": {
        type: "string",
        default: e.fontFamily,
        description: m("inlineSuggest.fontFamily", "Controls the font family of the inline suggestions.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: le(t.enabled, this.defaultValue.enabled),
      mode: Ot(t.mode, this.defaultValue.mode, ["prefix", "subword", "subwordSmart"]),
      showToolbar: Ot(t.showToolbar, this.defaultValue.showToolbar, ["always", "onHover", "never"]),
      suppressSuggestions: le(t.suppressSuggestions, this.defaultValue.suppressSuggestions),
      keepOnBlur: le(t.keepOnBlur, this.defaultValue.keepOnBlur),
      fontFamily: rn.string(t.fontFamily, this.defaultValue.fontFamily)
    };
  }
}
class $V extends It {
  constructor() {
    const e = {
      enabled: !1,
      showToolbar: "onHover",
      fontFamily: "default",
      keepOnBlur: !1
    };
    super(63, "experimentalInlineEdit", e, {
      "editor.experimentalInlineEdit.enabled": {
        type: "boolean",
        default: e.enabled,
        description: m("inlineEdit.enabled", "Controls whether to show inline edits in the editor.")
      },
      "editor.experimentalInlineEdit.showToolbar": {
        type: "string",
        default: e.showToolbar,
        enum: ["always", "onHover", "never"],
        enumDescriptions: [
          m("inlineEdit.showToolbar.always", "Show the inline edit toolbar whenever an inline suggestion is shown."),
          m("inlineEdit.showToolbar.onHover", "Show the inline edit toolbar when hovering over an inline suggestion."),
          m("inlineEdit.showToolbar.never", "Never show the inline edit toolbar.")
        ],
        description: m("inlineEdit.showToolbar", "Controls when to show the inline edit toolbar.")
      },
      "editor.experimentalInlineEdit.fontFamily": {
        type: "string",
        default: e.fontFamily,
        description: m("inlineEdit.fontFamily", "Controls the font family of the inline edit.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: le(t.enabled, this.defaultValue.enabled),
      showToolbar: Ot(t.showToolbar, this.defaultValue.showToolbar, ["always", "onHover", "never"]),
      fontFamily: rn.string(t.fontFamily, this.defaultValue.fontFamily),
      keepOnBlur: le(t.keepOnBlur, this.defaultValue.keepOnBlur)
    };
  }
}
class KV extends It {
  constructor() {
    const e = {
      enabled: ji.bracketPairColorizationOptions.enabled,
      independentColorPoolPerBracketType: ji.bracketPairColorizationOptions.independentColorPoolPerBracketType
    };
    super(15, "bracketPairColorization", e, {
      "editor.bracketPairColorization.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: m("bracketPairColorization.enabled", "Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.", "`#workbench.colorCustomizations#`")
      },
      "editor.bracketPairColorization.independentColorPoolPerBracketType": {
        type: "boolean",
        default: e.independentColorPoolPerBracketType,
        description: m("bracketPairColorization.independentColorPoolPerBracketType", "Controls whether each bracket type has its own independent color pool.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: le(t.enabled, this.defaultValue.enabled),
      independentColorPoolPerBracketType: le(t.independentColorPoolPerBracketType, this.defaultValue.independentColorPoolPerBracketType)
    };
  }
}
class jV extends It {
  constructor() {
    const e = {
      bracketPairs: !1,
      bracketPairsHorizontal: "active",
      highlightActiveBracketPair: !0,
      indentation: !0,
      highlightActiveIndentation: !0
    };
    super(16, "guides", e, {
      "editor.guides.bracketPairs": {
        type: ["boolean", "string"],
        enum: [!0, "active", !1],
        enumDescriptions: [
          m("editor.guides.bracketPairs.true", "Enables bracket pair guides."),
          m("editor.guides.bracketPairs.active", "Enables bracket pair guides only for the active bracket pair."),
          m("editor.guides.bracketPairs.false", "Disables bracket pair guides.")
        ],
        default: e.bracketPairs,
        description: m("editor.guides.bracketPairs", "Controls whether bracket pair guides are enabled or not.")
      },
      "editor.guides.bracketPairsHorizontal": {
        type: ["boolean", "string"],
        enum: [!0, "active", !1],
        enumDescriptions: [
          m("editor.guides.bracketPairsHorizontal.true", "Enables horizontal guides as addition to vertical bracket pair guides."),
          m("editor.guides.bracketPairsHorizontal.active", "Enables horizontal guides only for the active bracket pair."),
          m("editor.guides.bracketPairsHorizontal.false", "Disables horizontal bracket pair guides.")
        ],
        default: e.bracketPairsHorizontal,
        description: m("editor.guides.bracketPairsHorizontal", "Controls whether horizontal bracket pair guides are enabled or not.")
      },
      "editor.guides.highlightActiveBracketPair": {
        type: "boolean",
        default: e.highlightActiveBracketPair,
        description: m("editor.guides.highlightActiveBracketPair", "Controls whether the editor should highlight the active bracket pair.")
      },
      "editor.guides.indentation": {
        type: "boolean",
        default: e.indentation,
        description: m("editor.guides.indentation", "Controls whether the editor should render indent guides.")
      },
      "editor.guides.highlightActiveIndentation": {
        type: ["boolean", "string"],
        enum: [!0, "always", !1],
        enumDescriptions: [
          m("editor.guides.highlightActiveIndentation.true", "Highlights the active indent guide."),
          m("editor.guides.highlightActiveIndentation.always", "Highlights the active indent guide even if bracket guides are highlighted."),
          m("editor.guides.highlightActiveIndentation.false", "Do not highlight the active indent guide.")
        ],
        default: e.highlightActiveIndentation,
        description: m("editor.guides.highlightActiveIndentation", "Controls whether the editor should highlight the active indent guide.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      bracketPairs: Ru(t.bracketPairs, this.defaultValue.bracketPairs, [!0, !1, "active"]),
      bracketPairsHorizontal: Ru(t.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [!0, !1, "active"]),
      highlightActiveBracketPair: le(t.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),
      indentation: le(t.indentation, this.defaultValue.indentation),
      highlightActiveIndentation: Ru(t.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation, [!0, !1, "always"])
    };
  }
}
function Ru(s, e, t) {
  const i = t.indexOf(s);
  return i === -1 ? e : t[i];
}
class qV extends It {
  constructor() {
    const e = {
      insertMode: "insert",
      filterGraceful: !0,
      snippetsPreventQuickSuggestions: !1,
      localityBonus: !1,
      shareSuggestSelections: !1,
      selectionMode: "always",
      showIcons: !0,
      showStatusBar: !1,
      preview: !1,
      previewMode: "subwordSmart",
      showInlineDetails: !0,
      showMethods: !0,
      showFunctions: !0,
      showConstructors: !0,
      showDeprecated: !0,
      matchOnWordStartOnly: !0,
      showFields: !0,
      showVariables: !0,
      showClasses: !0,
      showStructs: !0,
      showInterfaces: !0,
      showModules: !0,
      showProperties: !0,
      showEvents: !0,
      showOperators: !0,
      showUnits: !0,
      showValues: !0,
      showConstants: !0,
      showEnums: !0,
      showEnumMembers: !0,
      showKeywords: !0,
      showWords: !0,
      showColors: !0,
      showFiles: !0,
      showReferences: !0,
      showFolders: !0,
      showTypeParameters: !0,
      showSnippets: !0,
      showUsers: !0,
      showIssues: !0
    };
    super(119, "suggest", e, {
      "editor.suggest.insertMode": {
        type: "string",
        enum: ["insert", "replace"],
        enumDescriptions: [
          m("suggest.insertMode.insert", "Insert suggestion without overwriting text right of the cursor."),
          m("suggest.insertMode.replace", "Insert suggestion and overwrite text right of the cursor.")
        ],
        default: e.insertMode,
        description: m("suggest.insertMode", "Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.")
      },
      "editor.suggest.filterGraceful": {
        type: "boolean",
        default: e.filterGraceful,
        description: m("suggest.filterGraceful", "Controls whether filtering and sorting suggestions accounts for small typos.")
      },
      "editor.suggest.localityBonus": {
        type: "boolean",
        default: e.localityBonus,
        description: m("suggest.localityBonus", "Controls whether sorting favors words that appear close to the cursor.")
      },
      "editor.suggest.shareSuggestSelections": {
        type: "boolean",
        default: e.shareSuggestSelections,
        markdownDescription: m("suggest.shareSuggestSelections", "Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).")
      },
      "editor.suggest.selectionMode": {
        type: "string",
        enum: ["always", "never", "whenTriggerCharacter", "whenQuickSuggestion"],
        enumDescriptions: [
          m("suggest.insertMode.always", "Always select a suggestion when automatically triggering IntelliSense."),
          m("suggest.insertMode.never", "Never select a suggestion when automatically triggering IntelliSense."),
          m("suggest.insertMode.whenTriggerCharacter", "Select a suggestion only when triggering IntelliSense from a trigger character."),
          m("suggest.insertMode.whenQuickSuggestion", "Select a suggestion only when triggering IntelliSense as you type.")
        ],
        default: e.selectionMode,
        markdownDescription: m("suggest.selectionMode", "Controls whether a suggestion is selected when the widget shows. Note that this only applies to automatically triggered suggestions ({0} and {1}) and that a suggestion is always selected when explicitly invoked, e.g via `Ctrl+Space`.", "`#editor.quickSuggestions#`", "`#editor.suggestOnTriggerCharacters#`")
      },
      "editor.suggest.snippetsPreventQuickSuggestions": {
        type: "boolean",
        default: e.snippetsPreventQuickSuggestions,
        description: m("suggest.snippetsPreventQuickSuggestions", "Controls whether an active snippet prevents quick suggestions.")
      },
      "editor.suggest.showIcons": {
        type: "boolean",
        default: e.showIcons,
        description: m("suggest.showIcons", "Controls whether to show or hide icons in suggestions.")
      },
      "editor.suggest.showStatusBar": {
        type: "boolean",
        default: e.showStatusBar,
        description: m("suggest.showStatusBar", "Controls the visibility of the status bar at the bottom of the suggest widget.")
      },
      "editor.suggest.preview": {
        type: "boolean",
        default: e.preview,
        description: m("suggest.preview", "Controls whether to preview the suggestion outcome in the editor.")
      },
      "editor.suggest.showInlineDetails": {
        type: "boolean",
        default: e.showInlineDetails,
        description: m("suggest.showInlineDetails", "Controls whether suggest details show inline with the label or only in the details widget.")
      },
      "editor.suggest.maxVisibleSuggestions": {
        type: "number",
        deprecationMessage: m("suggest.maxVisibleSuggestions.dep", "This setting is deprecated. The suggest widget can now be resized.")
      },
      "editor.suggest.filteredTypes": {
        type: "object",
        deprecationMessage: m("deprecated", "This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.")
      },
      "editor.suggest.showMethods": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showMethods", "When enabled IntelliSense shows `method`-suggestions.")
      },
      "editor.suggest.showFunctions": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showFunctions", "When enabled IntelliSense shows `function`-suggestions.")
      },
      "editor.suggest.showConstructors": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showConstructors", "When enabled IntelliSense shows `constructor`-suggestions.")
      },
      "editor.suggest.showDeprecated": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showDeprecated", "When enabled IntelliSense shows `deprecated`-suggestions.")
      },
      "editor.suggest.matchOnWordStartOnly": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.matchOnWordStartOnly", "When enabled IntelliSense filtering requires that the first character matches on a word start. For example, `c` on `Console` or `WebContext` but _not_ on `description`. When disabled IntelliSense will show more results but still sorts them by match quality.")
      },
      "editor.suggest.showFields": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showFields", "When enabled IntelliSense shows `field`-suggestions.")
      },
      "editor.suggest.showVariables": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showVariables", "When enabled IntelliSense shows `variable`-suggestions.")
      },
      "editor.suggest.showClasses": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showClasss", "When enabled IntelliSense shows `class`-suggestions.")
      },
      "editor.suggest.showStructs": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showStructs", "When enabled IntelliSense shows `struct`-suggestions.")
      },
      "editor.suggest.showInterfaces": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showInterfaces", "When enabled IntelliSense shows `interface`-suggestions.")
      },
      "editor.suggest.showModules": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showModules", "When enabled IntelliSense shows `module`-suggestions.")
      },
      "editor.suggest.showProperties": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showPropertys", "When enabled IntelliSense shows `property`-suggestions.")
      },
      "editor.suggest.showEvents": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showEvents", "When enabled IntelliSense shows `event`-suggestions.")
      },
      "editor.suggest.showOperators": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showOperators", "When enabled IntelliSense shows `operator`-suggestions.")
      },
      "editor.suggest.showUnits": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showUnits", "When enabled IntelliSense shows `unit`-suggestions.")
      },
      "editor.suggest.showValues": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showValues", "When enabled IntelliSense shows `value`-suggestions.")
      },
      "editor.suggest.showConstants": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showConstants", "When enabled IntelliSense shows `constant`-suggestions.")
      },
      "editor.suggest.showEnums": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showEnums", "When enabled IntelliSense shows `enum`-suggestions.")
      },
      "editor.suggest.showEnumMembers": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showEnumMembers", "When enabled IntelliSense shows `enumMember`-suggestions.")
      },
      "editor.suggest.showKeywords": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showKeywords", "When enabled IntelliSense shows `keyword`-suggestions.")
      },
      "editor.suggest.showWords": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showTexts", "When enabled IntelliSense shows `text`-suggestions.")
      },
      "editor.suggest.showColors": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showColors", "When enabled IntelliSense shows `color`-suggestions.")
      },
      "editor.suggest.showFiles": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showFiles", "When enabled IntelliSense shows `file`-suggestions.")
      },
      "editor.suggest.showReferences": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showReferences", "When enabled IntelliSense shows `reference`-suggestions.")
      },
      "editor.suggest.showCustomcolors": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showCustomcolors", "When enabled IntelliSense shows `customcolor`-suggestions.")
      },
      "editor.suggest.showFolders": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showFolders", "When enabled IntelliSense shows `folder`-suggestions.")
      },
      "editor.suggest.showTypeParameters": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showTypeParameters", "When enabled IntelliSense shows `typeParameter`-suggestions.")
      },
      "editor.suggest.showSnippets": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showSnippets", "When enabled IntelliSense shows `snippet`-suggestions.")
      },
      "editor.suggest.showUsers": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showUsers", "When enabled IntelliSense shows `user`-suggestions.")
      },
      "editor.suggest.showIssues": {
        type: "boolean",
        default: !0,
        markdownDescription: m("editor.suggest.showIssues", "When enabled IntelliSense shows `issues`-suggestions.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      insertMode: Ot(t.insertMode, this.defaultValue.insertMode, ["insert", "replace"]),
      filterGraceful: le(t.filterGraceful, this.defaultValue.filterGraceful),
      snippetsPreventQuickSuggestions: le(t.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),
      localityBonus: le(t.localityBonus, this.defaultValue.localityBonus),
      shareSuggestSelections: le(t.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
      selectionMode: Ot(t.selectionMode, this.defaultValue.selectionMode, ["always", "never", "whenQuickSuggestion", "whenTriggerCharacter"]),
      showIcons: le(t.showIcons, this.defaultValue.showIcons),
      showStatusBar: le(t.showStatusBar, this.defaultValue.showStatusBar),
      preview: le(t.preview, this.defaultValue.preview),
      previewMode: Ot(t.previewMode, this.defaultValue.previewMode, ["prefix", "subword", "subwordSmart"]),
      showInlineDetails: le(t.showInlineDetails, this.defaultValue.showInlineDetails),
      showMethods: le(t.showMethods, this.defaultValue.showMethods),
      showFunctions: le(t.showFunctions, this.defaultValue.showFunctions),
      showConstructors: le(t.showConstructors, this.defaultValue.showConstructors),
      showDeprecated: le(t.showDeprecated, this.defaultValue.showDeprecated),
      matchOnWordStartOnly: le(t.matchOnWordStartOnly, this.defaultValue.matchOnWordStartOnly),
      showFields: le(t.showFields, this.defaultValue.showFields),
      showVariables: le(t.showVariables, this.defaultValue.showVariables),
      showClasses: le(t.showClasses, this.defaultValue.showClasses),
      showStructs: le(t.showStructs, this.defaultValue.showStructs),
      showInterfaces: le(t.showInterfaces, this.defaultValue.showInterfaces),
      showModules: le(t.showModules, this.defaultValue.showModules),
      showProperties: le(t.showProperties, this.defaultValue.showProperties),
      showEvents: le(t.showEvents, this.defaultValue.showEvents),
      showOperators: le(t.showOperators, this.defaultValue.showOperators),
      showUnits: le(t.showUnits, this.defaultValue.showUnits),
      showValues: le(t.showValues, this.defaultValue.showValues),
      showConstants: le(t.showConstants, this.defaultValue.showConstants),
      showEnums: le(t.showEnums, this.defaultValue.showEnums),
      showEnumMembers: le(t.showEnumMembers, this.defaultValue.showEnumMembers),
      showKeywords: le(t.showKeywords, this.defaultValue.showKeywords),
      showWords: le(t.showWords, this.defaultValue.showWords),
      showColors: le(t.showColors, this.defaultValue.showColors),
      showFiles: le(t.showFiles, this.defaultValue.showFiles),
      showReferences: le(t.showReferences, this.defaultValue.showReferences),
      showFolders: le(t.showFolders, this.defaultValue.showFolders),
      showTypeParameters: le(t.showTypeParameters, this.defaultValue.showTypeParameters),
      showSnippets: le(t.showSnippets, this.defaultValue.showSnippets),
      showUsers: le(t.showUsers, this.defaultValue.showUsers),
      showIssues: le(t.showIssues, this.defaultValue.showIssues)
    };
  }
}
class GV extends It {
  constructor() {
    super(114, "smartSelect", {
      selectLeadingAndTrailingWhitespace: !0,
      selectSubwords: !0
    }, {
      "editor.smartSelect.selectLeadingAndTrailingWhitespace": {
        description: m("selectLeadingAndTrailingWhitespace", "Whether leading and trailing whitespace should always be selected."),
        default: !0,
        type: "boolean"
      },
      "editor.smartSelect.selectSubwords": {
        description: m("selectSubwords", "Whether subwords (like 'foo' in 'fooBar' or 'foo_bar') should be selected."),
        default: !0,
        type: "boolean"
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      selectLeadingAndTrailingWhitespace: le(e.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace),
      selectSubwords: le(e.selectSubwords, this.defaultValue.selectSubwords)
    };
  }
}
class ZV extends It {
  constructor() {
    const e = [];
    super(131, "wordSegmenterLocales", e, {
      anyOf: [
        {
          description: m("wordSegmenterLocales", "Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.)."),
          type: "string"
        },
        {
          description: m("wordSegmenterLocales", "Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.)."),
          type: "array",
          items: {
            type: "string"
          }
        }
      ]
    });
  }
  validate(e) {
    if (typeof e == "string" && (e = [e]), Array.isArray(e)) {
      const t = [];
      for (const i of e)
        if (typeof i == "string")
          try {
            Intl.Segmenter.supportedLocalesOf(i).length > 0 && t.push(i);
          } catch {
          }
      return t;
    }
    return this.defaultValue;
  }
}
class YV extends It {
  constructor() {
    super(139, "wrappingIndent", 1, {
      "editor.wrappingIndent": {
        type: "string",
        enum: ["none", "same", "indent", "deepIndent"],
        enumDescriptions: [
          m("wrappingIndent.none", "No indentation. Wrapped lines begin at column 1."),
          m("wrappingIndent.same", "Wrapped lines get the same indentation as the parent."),
          m("wrappingIndent.indent", "Wrapped lines get +1 indentation toward the parent."),
          m("wrappingIndent.deepIndent", "Wrapped lines get +2 indentation toward the parent.")
        ],
        description: m("wrappingIndent", "Controls the indentation of wrapped lines."),
        default: "same"
      }
    });
  }
  validate(e) {
    switch (e) {
      case "none":
        return 0;
      case "same":
        return 1;
      case "indent":
        return 2;
      case "deepIndent":
        return 3;
    }
    return 1;
  }
  compute(e, t, i) {
    return t.get(
      2
      /* EditorOption.accessibilitySupport */
    ) === 2 ? 0 : i;
  }
}
class XV extends Pp {
  constructor() {
    super(
      147
      /* EditorOption.wrappingInfo */
    );
  }
  compute(e, t, i) {
    const n = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return {
      isDominatedByLongLines: e.isDominatedByLongLines,
      isWordWrapMinified: n.isWordWrapMinified,
      isViewportWrapping: n.isViewportWrapping,
      wrappingColumn: n.wrappingColumn
    };
  }
}
class QV extends It {
  constructor() {
    const e = { enabled: !0, showDropSelector: "afterDrop" };
    super(36, "dropIntoEditor", e, {
      "editor.dropIntoEditor.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: m("dropIntoEditor.enabled", "Controls whether you can drag and drop a file into a text editor by holding down the `Shift` key (instead of opening the file in an editor).")
      },
      "editor.dropIntoEditor.showDropSelector": {
        type: "string",
        markdownDescription: m("dropIntoEditor.showDropSelector", "Controls if a widget is shown when dropping files into the editor. This widget lets you control how the file is dropped."),
        enum: [
          "afterDrop",
          "never"
        ],
        enumDescriptions: [
          m("dropIntoEditor.showDropSelector.afterDrop", "Show the drop selector widget after a file is dropped into the editor."),
          m("dropIntoEditor.showDropSelector.never", "Never show the drop selector widget. Instead the default drop provider is always used.")
        ],
        default: "afterDrop"
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: le(t.enabled, this.defaultValue.enabled),
      showDropSelector: Ot(t.showDropSelector, this.defaultValue.showDropSelector, ["afterDrop", "never"])
    };
  }
}
class JV extends It {
  constructor() {
    const e = { enabled: !0, showPasteSelector: "afterPaste" };
    super(85, "pasteAs", e, {
      "editor.pasteAs.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: m("pasteAs.enabled", "Controls whether you can paste content in different ways.")
      },
      "editor.pasteAs.showPasteSelector": {
        type: "string",
        markdownDescription: m("pasteAs.showPasteSelector", "Controls if a widget is shown when pasting content in to the editor. This widget lets you control how the file is pasted."),
        enum: [
          "afterPaste",
          "never"
        ],
        enumDescriptions: [
          m("pasteAs.showPasteSelector.afterPaste", "Show the paste selector widget after content is pasted into the editor."),
          m("pasteAs.showPasteSelector.never", "Never show the paste selector widget. Instead the default pasting behavior is always used.")
        ],
        default: "afterPaste"
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: le(t.enabled, this.defaultValue.enabled),
      showPasteSelector: Ot(t.showPasteSelector, this.defaultValue.showPasteSelector, ["afterPaste", "never"])
    };
  }
}
const ez = "Consolas, 'Courier New', monospace", tz = "Menlo, Monaco, 'Courier New', monospace", iz = "'Droid Sans Mono', 'monospace', monospace", Qn = {
  fontFamily: $e ? tz : Rn ? iz : ez,
  fontWeight: "normal",
  fontSize: $e ? 12 : 14,
  lineHeight: 0,
  letterSpacing: 0
}, Qd = [];
function Y(s) {
  return Qd[s.id] = s, s;
}
const ad = {
  acceptSuggestionOnCommitCharacter: Y(new qe(0, "acceptSuggestionOnCommitCharacter", !0, { markdownDescription: m("acceptSuggestionOnCommitCharacter", "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.") })),
  acceptSuggestionOnEnter: Y(new Pt(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
    markdownEnumDescriptions: [
      "",
      m("acceptSuggestionOnEnterSmart", "Only accept a suggestion with `Enter` when it makes a textual change."),
      ""
    ],
    markdownDescription: m("acceptSuggestionOnEnter", "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.")
  })),
  accessibilitySupport: Y(new gV()),
  accessibilityPageSize: Y(new ft(3, "accessibilityPageSize", 10, 1, 1073741824, {
    description: m("accessibilityPageSize", "Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default."),
    tags: ["accessibility"]
  })),
  ariaLabel: Y(new rn(4, "ariaLabel", m("editorViewAccessibleLabel", "Editor content"))),
  ariaRequired: Y(new qe(5, "ariaRequired", !1, void 0)),
  screenReaderAnnounceInlineSuggestion: Y(new qe(8, "screenReaderAnnounceInlineSuggestion", !0, {
    description: m("screenReaderAnnounceInlineSuggestion", "Control whether inline suggestions are announced by a screen reader."),
    tags: ["accessibility"]
  })),
  autoClosingBrackets: Y(new Pt(6, "autoClosingBrackets", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      m("editor.autoClosingBrackets.languageDefined", "Use language configurations to determine when to autoclose brackets."),
      m("editor.autoClosingBrackets.beforeWhitespace", "Autoclose brackets only when the cursor is to the left of whitespace."),
      ""
    ],
    description: m("autoClosingBrackets", "Controls whether the editor should automatically close brackets after the user adds an opening bracket.")
  })),
  autoClosingComments: Y(new Pt(7, "autoClosingComments", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      m("editor.autoClosingComments.languageDefined", "Use language configurations to determine when to autoclose comments."),
      m("editor.autoClosingComments.beforeWhitespace", "Autoclose comments only when the cursor is to the left of whitespace."),
      ""
    ],
    description: m("autoClosingComments", "Controls whether the editor should automatically close comments after the user adds an opening comment.")
  })),
  autoClosingDelete: Y(new Pt(9, "autoClosingDelete", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      m("editor.autoClosingDelete.auto", "Remove adjacent closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: m("autoClosingDelete", "Controls whether the editor should remove adjacent closing quotes or brackets when deleting.")
  })),
  autoClosingOvertype: Y(new Pt(10, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      m("editor.autoClosingOvertype.auto", "Type over closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: m("autoClosingOvertype", "Controls whether the editor should type over closing quotes or brackets.")
  })),
  autoClosingQuotes: Y(new Pt(11, "autoClosingQuotes", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      m("editor.autoClosingQuotes.languageDefined", "Use language configurations to determine when to autoclose quotes."),
      m("editor.autoClosingQuotes.beforeWhitespace", "Autoclose quotes only when the cursor is to the left of whitespace."),
      ""
    ],
    description: m("autoClosingQuotes", "Controls whether the editor should automatically close quotes after the user adds an opening quote.")
  })),
  autoIndent: Y(new g_(12, "autoIndent", 4, "full", ["none", "keep", "brackets", "advanced", "full"], fV, {
    enumDescriptions: [
      m("editor.autoIndent.none", "The editor will not insert indentation automatically."),
      m("editor.autoIndent.keep", "The editor will keep the current line's indentation."),
      m("editor.autoIndent.brackets", "The editor will keep the current line's indentation and honor language defined brackets."),
      m("editor.autoIndent.advanced", "The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages."),
      m("editor.autoIndent.full", "The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.")
    ],
    description: m("autoIndent", "Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.")
  })),
  automaticLayout: Y(new qe(13, "automaticLayout", !1)),
  autoSurround: Y(new Pt(14, "autoSurround", "languageDefined", ["languageDefined", "quotes", "brackets", "never"], {
    enumDescriptions: [
      m("editor.autoSurround.languageDefined", "Use language configurations to determine when to automatically surround selections."),
      m("editor.autoSurround.quotes", "Surround with quotes but not brackets."),
      m("editor.autoSurround.brackets", "Surround with brackets but not quotes."),
      ""
    ],
    description: m("autoSurround", "Controls whether the editor should automatically surround selections when typing quotes or brackets.")
  })),
  bracketPairColorization: Y(new KV()),
  bracketPairGuides: Y(new jV()),
  stickyTabStops: Y(new qe(117, "stickyTabStops", !1, { description: m("stickyTabStops", "Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.") })),
  codeLens: Y(new qe(17, "codeLens", !0, { description: m("codeLens", "Controls whether the editor shows CodeLens.") })),
  codeLensFontFamily: Y(new rn(18, "codeLensFontFamily", "", { description: m("codeLensFontFamily", "Controls the font family for CodeLens.") })),
  codeLensFontSize: Y(new ft(19, "codeLensFontSize", 0, 0, 100, {
    type: "number",
    default: 0,
    minimum: 0,
    maximum: 100,
    markdownDescription: m("codeLensFontSize", "Controls the font size in pixels for CodeLens. When set to 0, 90% of `#editor.fontSize#` is used.")
  })),
  colorDecorators: Y(new qe(20, "colorDecorators", !0, { description: m("colorDecorators", "Controls whether the editor should render the inline color decorators and color picker.") })),
  colorDecoratorActivatedOn: Y(new Pt(149, "colorDecoratorsActivatedOn", "clickAndHover", ["clickAndHover", "hover", "click"], {
    enumDescriptions: [
      m("editor.colorDecoratorActivatedOn.clickAndHover", "Make the color picker appear both on click and hover of the color decorator"),
      m("editor.colorDecoratorActivatedOn.hover", "Make the color picker appear on hover of the color decorator"),
      m("editor.colorDecoratorActivatedOn.click", "Make the color picker appear on click of the color decorator")
    ],
    description: m("colorDecoratorActivatedOn", "Controls the condition to make a color picker appear from a color decorator")
  })),
  colorDecoratorsLimit: Y(new ft(21, "colorDecoratorsLimit", 500, 1, 1e6, {
    markdownDescription: m("colorDecoratorsLimit", "Controls the max number of color decorators that can be rendered in an editor at once.")
  })),
  columnSelection: Y(new qe(22, "columnSelection", !1, { description: m("columnSelection", "Enable that the selection with the mouse and keys is doing column selection.") })),
  comments: Y(new mV()),
  contextmenu: Y(new qe(24, "contextmenu", !0)),
  copyWithSyntaxHighlighting: Y(new qe(25, "copyWithSyntaxHighlighting", !0, { description: m("copyWithSyntaxHighlighting", "Controls whether syntax highlighting should be copied into the clipboard.") })),
  cursorBlinking: Y(new g_(26, "cursorBlinking", 1, "blink", ["blink", "smooth", "phase", "expand", "solid"], pV, { description: m("cursorBlinking", "Control the cursor animation style.") })),
  cursorSmoothCaretAnimation: Y(new Pt(27, "cursorSmoothCaretAnimation", "off", ["off", "explicit", "on"], {
    enumDescriptions: [
      m("cursorSmoothCaretAnimation.off", "Smooth caret animation is disabled."),
      m("cursorSmoothCaretAnimation.explicit", "Smooth caret animation is enabled only when the user moves the cursor with an explicit gesture."),
      m("cursorSmoothCaretAnimation.on", "Smooth caret animation is always enabled.")
    ],
    description: m("cursorSmoothCaretAnimation", "Controls whether the smooth caret animation should be enabled.")
  })),
  cursorStyle: Y(new g_(28, "cursorStyle", Ii.Line, "line", ["line", "block", "underline", "line-thin", "block-outline", "underline-thin"], _V, { description: m("cursorStyle", "Controls the cursor style.") })),
  cursorSurroundingLines: Y(new ft(29, "cursorSurroundingLines", 0, 0, 1073741824, { description: m("cursorSurroundingLines", "Controls the minimal number of visible leading lines (minimum 0) and trailing lines (minimum 1) surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.") })),
  cursorSurroundingLinesStyle: Y(new Pt(30, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
    enumDescriptions: [
      m("cursorSurroundingLinesStyle.default", "`cursorSurroundingLines` is enforced only when triggered via the keyboard or API."),
      m("cursorSurroundingLinesStyle.all", "`cursorSurroundingLines` is enforced always.")
    ],
    markdownDescription: m("cursorSurroundingLinesStyle", "Controls when `#editor.cursorSurroundingLines#` should be enforced.")
  })),
  cursorWidth: Y(new ft(31, "cursorWidth", 0, 0, 1073741824, { markdownDescription: m("cursorWidth", "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.") })),
  disableLayerHinting: Y(new qe(32, "disableLayerHinting", !1)),
  disableMonospaceOptimizations: Y(new qe(33, "disableMonospaceOptimizations", !1)),
  domReadOnly: Y(new qe(34, "domReadOnly", !1)),
  dragAndDrop: Y(new qe(35, "dragAndDrop", !0, { description: m("dragAndDrop", "Controls whether the editor should allow moving selections via drag and drop.") })),
  emptySelectionClipboard: Y(new CV()),
  dropIntoEditor: Y(new QV()),
  stickyScroll: Y(new DV()),
  experimentalWhitespaceRendering: Y(new Pt(38, "experimentalWhitespaceRendering", "svg", ["svg", "font", "off"], {
    enumDescriptions: [
      m("experimentalWhitespaceRendering.svg", "Use a new rendering method with svgs."),
      m("experimentalWhitespaceRendering.font", "Use a new rendering method with font characters."),
      m("experimentalWhitespaceRendering.off", "Use the stable rendering method.")
    ],
    description: m("experimentalWhitespaceRendering", "Controls whether whitespace is rendered with a new, experimental method.")
  })),
  extraEditorClassName: Y(new rn(39, "extraEditorClassName", "")),
  fastScrollSensitivity: Y(new vs(40, "fastScrollSensitivity", 5, (s) => s <= 0 ? 5 : s, { markdownDescription: m("fastScrollSensitivity", "Scrolling speed multiplier when pressing `Alt`.") })),
  find: Y(new vV()),
  fixedOverflowWidgets: Y(new qe(42, "fixedOverflowWidgets", !1)),
  folding: Y(new qe(43, "folding", !0, { description: m("folding", "Controls whether the editor has code folding enabled.") })),
  foldingStrategy: Y(new Pt(44, "foldingStrategy", "auto", ["auto", "indentation"], {
    enumDescriptions: [
      m("foldingStrategy.auto", "Use a language-specific folding strategy if available, else the indentation-based one."),
      m("foldingStrategy.indentation", "Use the indentation-based folding strategy.")
    ],
    description: m("foldingStrategy", "Controls the strategy for computing folding ranges.")
  })),
  foldingHighlight: Y(new qe(45, "foldingHighlight", !0, { description: m("foldingHighlight", "Controls whether the editor should highlight folded ranges.") })),
  foldingImportsByDefault: Y(new qe(46, "foldingImportsByDefault", !1, { description: m("foldingImportsByDefault", "Controls whether the editor automatically collapses import ranges.") })),
  foldingMaximumRegions: Y(new ft(
    47,
    "foldingMaximumRegions",
    5e3,
    10,
    65e3,
    // limit must be less than foldingRanges MAX_FOLDING_REGIONS
    { description: m("foldingMaximumRegions", "The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.") }
  )),
  unfoldOnClickAfterEndOfLine: Y(new qe(48, "unfoldOnClickAfterEndOfLine", !1, { description: m("unfoldOnClickAfterEndOfLine", "Controls whether clicking on the empty content after a folded line will unfold the line.") })),
  fontFamily: Y(new rn(49, "fontFamily", Qn.fontFamily, { description: m("fontFamily", "Controls the font family.") })),
  fontInfo: Y(new wV()),
  fontLigatures2: Y(new $h()),
  fontSize: Y(new yV()),
  fontWeight: Y(new SS()),
  fontVariations: Y(new Bm()),
  formatOnPaste: Y(new qe(55, "formatOnPaste", !1, { description: m("formatOnPaste", "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.") })),
  formatOnType: Y(new qe(56, "formatOnType", !1, { description: m("formatOnType", "Controls whether the editor should automatically format the line after typing.") })),
  glyphMargin: Y(new qe(57, "glyphMargin", !0, { description: m("glyphMargin", "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.") })),
  gotoLocation: Y(new SV()),
  hideCursorInOverviewRuler: Y(new qe(59, "hideCursorInOverviewRuler", !1, { description: m("hideCursorInOverviewRuler", "Controls whether the cursor should be hidden in the overview ruler.") })),
  hover: Y(new LV()),
  inDiffEditor: Y(new qe(61, "inDiffEditor", !1)),
  letterSpacing: Y(new vs(64, "letterSpacing", Qn.letterSpacing, (s) => vs.clamp(s, -5, 20), { description: m("letterSpacing", "Controls the letter spacing in pixels.") })),
  lightbulb: Y(new xV()),
  lineDecorationsWidth: Y(new IV()),
  lineHeight: Y(new NV()),
  lineNumbers: Y(new BV()),
  lineNumbersMinChars: Y(new ft(69, "lineNumbersMinChars", 5, 1, 300)),
  linkedEditing: Y(new qe(70, "linkedEditing", !1, { description: m("linkedEditing", "Controls whether the editor has linked editing enabled. Depending on the language, related symbols such as HTML tags, are updated while editing.") })),
  links: Y(new qe(71, "links", !0, { description: m("links", "Controls whether the editor should detect links and make them clickable.") })),
  matchBrackets: Y(new Pt(72, "matchBrackets", "always", ["always", "near", "never"], { description: m("matchBrackets", "Highlight matching brackets.") })),
  minimap: Y(new TV()),
  mouseStyle: Y(new Pt(74, "mouseStyle", "text", ["text", "default", "copy"])),
  mouseWheelScrollSensitivity: Y(new vs(75, "mouseWheelScrollSensitivity", 1, (s) => s === 0 ? 1 : s, { markdownDescription: m("mouseWheelScrollSensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.") })),
  mouseWheelZoom: Y(new qe(76, "mouseWheelZoom", !1, {
    markdownDescription: $e ? m("mouseWheelZoom.mac", "Zoom the font of the editor when using mouse wheel and holding `Cmd`.") : m("mouseWheelZoom", "Zoom the font of the editor when using mouse wheel and holding `Ctrl`.")
  })),
  multiCursorMergeOverlapping: Y(new qe(77, "multiCursorMergeOverlapping", !0, { description: m("multiCursorMergeOverlapping", "Merge multiple cursors when they are overlapping.") })),
  multiCursorModifier: Y(new g_(78, "multiCursorModifier", "altKey", "alt", ["ctrlCmd", "alt"], MV, {
    markdownEnumDescriptions: [
      m("multiCursorModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
      m("multiCursorModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
    ],
    markdownDescription: m({
      key: "multiCursorModifier",
      comment: [
        "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
        "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
      ]
    }, "The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the [multicursor modifier](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).")
  })),
  multiCursorPaste: Y(new Pt(79, "multiCursorPaste", "spread", ["spread", "full"], {
    markdownEnumDescriptions: [
      m("multiCursorPaste.spread", "Each cursor pastes a single line of the text."),
      m("multiCursorPaste.full", "Each cursor pastes the full text.")
    ],
    markdownDescription: m("multiCursorPaste", "Controls pasting when the line count of the pasted text matches the cursor count.")
  })),
  multiCursorLimit: Y(new ft(80, "multiCursorLimit", 1e4, 1, 1e5, {
    markdownDescription: m("multiCursorLimit", "Controls the max number of cursors that can be in an active editor at once.")
  })),
  occurrencesHighlight: Y(new Pt(81, "occurrencesHighlight", "singleFile", ["off", "singleFile", "multiFile"], {
    markdownEnumDescriptions: [
      m("occurrencesHighlight.off", "Does not highlight occurrences."),
      m("occurrencesHighlight.singleFile", "Highlights occurrences only in the current file."),
      m("occurrencesHighlight.multiFile", "Experimental: Highlights occurrences across all valid open files.")
    ],
    markdownDescription: m("occurrencesHighlight", "Controls whether occurrences should be highlighted across open files.")
  })),
  overviewRulerBorder: Y(new qe(82, "overviewRulerBorder", !0, { description: m("overviewRulerBorder", "Controls whether a border should be drawn around the overview ruler.") })),
  overviewRulerLanes: Y(new ft(83, "overviewRulerLanes", 3, 0, 3)),
  padding: Y(new RV()),
  pasteAs: Y(new JV()),
  parameterHints: Y(new AV()),
  peekWidgetDefaultFocus: Y(new Pt(87, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
    enumDescriptions: [
      m("peekWidgetDefaultFocus.tree", "Focus the tree when opening peek"),
      m("peekWidgetDefaultFocus.editor", "Focus the editor when opening peek")
    ],
    description: m("peekWidgetDefaultFocus", "Controls whether to focus the inline editor or the tree in the peek widget.")
  })),
  placeholder: Y(new OV()),
  definitionLinkOpensInPeek: Y(new qe(89, "definitionLinkOpensInPeek", !1, { description: m("definitionLinkOpensInPeek", "Controls whether the Go to Definition mouse gesture always opens the peek widget.") })),
  quickSuggestions: Y(new FV()),
  quickSuggestionsDelay: Y(new ft(91, "quickSuggestionsDelay", 10, 0, 1073741824, { description: m("quickSuggestionsDelay", "Controls the delay in milliseconds after which quick suggestions will show up.") })),
  readOnly: Y(new qe(92, "readOnly", !1)),
  readOnlyMessage: Y(new HV()),
  renameOnType: Y(new qe(94, "renameOnType", !1, { description: m("renameOnType", "Controls whether the editor auto renames on type."), markdownDeprecationMessage: m("renameOnTypeDeprecate", "Deprecated, use `editor.linkedEditing` instead.") })),
  renderControlCharacters: Y(new qe(95, "renderControlCharacters", !0, { description: m("renderControlCharacters", "Controls whether the editor should render control characters."), restricted: !0 })),
  renderFinalNewline: Y(new Pt(96, "renderFinalNewline", Rn ? "dimmed" : "on", ["off", "on", "dimmed"], { description: m("renderFinalNewline", "Render last line number when the file ends with a newline.") })),
  renderLineHighlight: Y(new Pt(97, "renderLineHighlight", "line", ["none", "gutter", "line", "all"], {
    enumDescriptions: [
      "",
      "",
      "",
      m("renderLineHighlight.all", "Highlights both the gutter and the current line.")
    ],
    description: m("renderLineHighlight", "Controls how the editor should render the current line highlight.")
  })),
  renderLineHighlightOnlyWhenFocus: Y(new qe(98, "renderLineHighlightOnlyWhenFocus", !1, { description: m("renderLineHighlightOnlyWhenFocus", "Controls if the editor should render the current line highlight only when the editor is focused.") })),
  renderValidationDecorations: Y(new Pt(99, "renderValidationDecorations", "editable", ["editable", "on", "off"])),
  renderWhitespace: Y(new Pt(100, "renderWhitespace", "selection", ["none", "boundary", "selection", "trailing", "all"], {
    enumDescriptions: [
      "",
      m("renderWhitespace.boundary", "Render whitespace characters except for single spaces between words."),
      m("renderWhitespace.selection", "Render whitespace characters only on selected text."),
      m("renderWhitespace.trailing", "Render only trailing whitespace characters."),
      ""
    ],
    description: m("renderWhitespace", "Controls how the editor should render whitespace characters.")
  })),
  revealHorizontalRightPadding: Y(new ft(101, "revealHorizontalRightPadding", 15, 0, 1e3)),
  roundedSelection: Y(new qe(102, "roundedSelection", !0, { description: m("roundedSelection", "Controls whether selections should have rounded corners.") })),
  rulers: Y(new WV()),
  scrollbar: Y(new VV()),
  scrollBeyondLastColumn: Y(new ft(105, "scrollBeyondLastColumn", 4, 0, 1073741824, { description: m("scrollBeyondLastColumn", "Controls the number of extra characters beyond which the editor will scroll horizontally.") })),
  scrollBeyondLastLine: Y(new qe(106, "scrollBeyondLastLine", !0, { description: m("scrollBeyondLastLine", "Controls whether the editor will scroll beyond the last line.") })),
  scrollPredominantAxis: Y(new qe(107, "scrollPredominantAxis", !0, { description: m("scrollPredominantAxis", "Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.") })),
  selectionClipboard: Y(new qe(108, "selectionClipboard", !0, {
    description: m("selectionClipboard", "Controls whether the Linux primary clipboard should be supported."),
    included: Rn
  })),
  selectionHighlight: Y(new qe(109, "selectionHighlight", !0, { description: m("selectionHighlight", "Controls whether the editor should highlight matches similar to the selection.") })),
  selectOnLineNumbers: Y(new qe(110, "selectOnLineNumbers", !0)),
  showFoldingControls: Y(new Pt(111, "showFoldingControls", "mouseover", ["always", "never", "mouseover"], {
    enumDescriptions: [
      m("showFoldingControls.always", "Always show the folding controls."),
      m("showFoldingControls.never", "Never show the folding controls and reduce the gutter size."),
      m("showFoldingControls.mouseover", "Only show the folding controls when the mouse is over the gutter.")
    ],
    description: m("showFoldingControls", "Controls when the folding controls on the gutter are shown.")
  })),
  showUnused: Y(new qe(112, "showUnused", !0, { description: m("showUnused", "Controls fading out of unused code.") })),
  showDeprecated: Y(new qe(141, "showDeprecated", !0, { description: m("showDeprecated", "Controls strikethrough deprecated variables.") })),
  inlayHints: Y(new EV()),
  snippetSuggestions: Y(new Pt(113, "snippetSuggestions", "inline", ["top", "bottom", "inline", "none"], {
    enumDescriptions: [
      m("snippetSuggestions.top", "Show snippet suggestions on top of other suggestions."),
      m("snippetSuggestions.bottom", "Show snippet suggestions below other suggestions."),
      m("snippetSuggestions.inline", "Show snippets suggestions with other suggestions."),
      m("snippetSuggestions.none", "Do not show snippet suggestions.")
    ],
    description: m("snippetSuggestions", "Controls whether snippets are shown with other suggestions and how they are sorted.")
  })),
  smartSelect: Y(new GV()),
  smoothScrolling: Y(new qe(115, "smoothScrolling", !1, { description: m("smoothScrolling", "Controls whether the editor will scroll using an animation.") })),
  stopRenderingLineAfter: Y(new ft(
    118,
    "stopRenderingLineAfter",
    1e4,
    -1,
    1073741824
    /* Constants.MAX_SAFE_SMALL_INTEGER */
  )),
  suggest: Y(new qV()),
  inlineSuggest: Y(new UV()),
  inlineEdit: Y(new $V()),
  inlineCompletionsAccessibilityVerbose: Y(new qe(150, "inlineCompletionsAccessibilityVerbose", !1, { description: m("inlineCompletionsAccessibilityVerbose", "Controls whether the accessibility hint should be provided to screen reader users when an inline completion is shown.") })),
  suggestFontSize: Y(new ft(120, "suggestFontSize", 0, 0, 1e3, { markdownDescription: m("suggestFontSize", "Font size for the suggest widget. When set to {0}, the value of {1} is used.", "`0`", "`#editor.fontSize#`") })),
  suggestLineHeight: Y(new ft(121, "suggestLineHeight", 0, 0, 1e3, { markdownDescription: m("suggestLineHeight", "Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.", "`0`", "`#editor.lineHeight#`") })),
  suggestOnTriggerCharacters: Y(new qe(122, "suggestOnTriggerCharacters", !0, { description: m("suggestOnTriggerCharacters", "Controls whether suggestions should automatically show up when typing trigger characters.") })),
  suggestSelection: Y(new Pt(123, "suggestSelection", "first", ["first", "recentlyUsed", "recentlyUsedByPrefix"], {
    markdownEnumDescriptions: [
      m("suggestSelection.first", "Always select the first suggestion."),
      m("suggestSelection.recentlyUsed", "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."),
      m("suggestSelection.recentlyUsedByPrefix", "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.")
    ],
    description: m("suggestSelection", "Controls how suggestions are pre-selected when showing the suggest list.")
  })),
  tabCompletion: Y(new Pt(124, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
    enumDescriptions: [
      m("tabCompletion.on", "Tab complete will insert the best matching suggestion when pressing tab."),
      m("tabCompletion.off", "Disable tab completions."),
      m("tabCompletion.onlySnippets", "Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.")
    ],
    description: m("tabCompletion", "Enables tab completions.")
  })),
  tabIndex: Y(new ft(
    125,
    "tabIndex",
    0,
    -1,
    1073741824
    /* Constants.MAX_SAFE_SMALL_INTEGER */
  )),
  unicodeHighlight: Y(new zV()),
  unusualLineTerminators: Y(new Pt(127, "unusualLineTerminators", "prompt", ["auto", "off", "prompt"], {
    enumDescriptions: [
      m("unusualLineTerminators.auto", "Unusual line terminators are automatically removed."),
      m("unusualLineTerminators.off", "Unusual line terminators are ignored."),
      m("unusualLineTerminators.prompt", "Unusual line terminators prompt to be removed.")
    ],
    description: m("unusualLineTerminators", "Remove unusual line terminators that might cause problems.")
  })),
  useShadowDOM: Y(new qe(128, "useShadowDOM", !0)),
  useTabStops: Y(new qe(129, "useTabStops", !0, { description: m("useTabStops", "Spaces and tabs are inserted and deleted in alignment with tab stops.") })),
  wordBreak: Y(new Pt(130, "wordBreak", "normal", ["normal", "keepAll"], {
    markdownEnumDescriptions: [
      m("wordBreak.normal", "Use the default line break rule."),
      m("wordBreak.keepAll", "Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal.")
    ],
    description: m("wordBreak", "Controls the word break rules used for Chinese/Japanese/Korean (CJK) text.")
  })),
  wordSegmenterLocales: Y(new ZV()),
  wordSeparators: Y(new rn(132, "wordSeparators", HO, { description: m("wordSeparators", "Characters that will be used as word separators when doing word related navigations or operations.") })),
  wordWrap: Y(new Pt(133, "wordWrap", "off", ["off", "on", "wordWrapColumn", "bounded"], {
    markdownEnumDescriptions: [
      m("wordWrap.off", "Lines will never wrap."),
      m("wordWrap.on", "Lines will wrap at the viewport width."),
      m({
        key: "wordWrap.wordWrapColumn",
        comment: [
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at `#editor.wordWrapColumn#`."),
      m({
        key: "wordWrap.bounded",
        comment: [
          "- viewport means the edge of the visible window size.",
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.")
    ],
    description: m({
      key: "wordWrap",
      comment: [
        "- 'off', 'on', 'wordWrapColumn' and 'bounded' refer to values the setting can take and should not be localized.",
        "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
      ]
    }, "Controls how lines should wrap.")
  })),
  wordWrapBreakAfterCharacters: Y(new rn(
    134,
    "wordWrapBreakAfterCharacters",
    // allow-any-unicode-next-line
    " 	})]?|/&.,;¢°′″‰℃、。｡､￠，．：；？！％・･ゝゞヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻ｧｨｩｪｫｬｭｮｯｰ”〉》」』】〕）］｝｣"
  )),
  wordWrapBreakBeforeCharacters: Y(new rn(
    135,
    "wordWrapBreakBeforeCharacters",
    // allow-any-unicode-next-line
    "([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋"
  )),
  wordWrapColumn: Y(new ft(136, "wordWrapColumn", 80, 1, 1073741824, {
    markdownDescription: m({
      key: "wordWrapColumn",
      comment: [
        "- `editor.wordWrap` refers to a different setting and should not be localized.",
        "- 'wordWrapColumn' and 'bounded' refer to values the different setting can take and should not be localized."
      ]
    }, "Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.")
  })),
  wordWrapOverride1: Y(new Pt(137, "wordWrapOverride1", "inherit", ["off", "on", "inherit"])),
  wordWrapOverride2: Y(new Pt(138, "wordWrapOverride2", "inherit", ["off", "on", "inherit"])),
  // Leave these at the end (because they have dependencies!)
  editorClassName: Y(new bV()),
  defaultColorDecorators: Y(new qe(148, "defaultColorDecorators", !1, { markdownDescription: m("defaultColorDecorators", "Controls whether inline color decorations should be shown using the default document color provider") })),
  pixelRatio: Y(new PV()),
  tabFocusMode: Y(new qe(145, "tabFocusMode", !1, { markdownDescription: m("tabFocusMode", "Controls whether the editor receives tabs or defers them to the workbench for navigation.") })),
  layoutInfo: Y(new Mu()),
  wrappingInfo: Y(new XV()),
  wrappingIndent: Y(new YV()),
  wrappingStrategy: Y(new kV())
}, pl = new class {
  constructor() {
    this._zoomLevel = 0, this._onDidChangeZoomLevel = new A(), this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
  }
  getZoomLevel() {
    return this._zoomLevel;
  }
  setZoomLevel(s) {
    s = Math.min(Math.max(-5, s), 20), this._zoomLevel !== s && (this._zoomLevel = s, this._onDidChangeZoomLevel.fire(this._zoomLevel));
  }
}(), nz = $e ? 1.5 : 1.35, I0 = 8;
class ch {
  /**
   * @internal
   */
  static createFromValidatedSettings(e, t, i) {
    const n = e.get(
      49
      /* EditorOption.fontFamily */
    ), o = e.get(
      53
      /* EditorOption.fontWeight */
    ), r = e.get(
      52
      /* EditorOption.fontSize */
    ), a = e.get(
      51
      /* EditorOption.fontLigatures */
    ), l = e.get(
      54
      /* EditorOption.fontVariations */
    ), c = e.get(
      67
      /* EditorOption.lineHeight */
    ), h = e.get(
      64
      /* EditorOption.letterSpacing */
    );
    return ch._create(n, o, r, a, l, c, h, t, i);
  }
  /**
   * @internal
   */
  static _create(e, t, i, n, o, r, a, l, c) {
    r === 0 ? r = nz * i : r < I0 && (r = r * i), r = Math.round(r), r < I0 && (r = I0);
    const h = 1 + (c ? 0 : pl.getZoomLevel() * 0.1);
    return i *= h, r *= h, o === Bm.TRANSLATE && (t === "normal" || t === "bold" ? o = Bm.OFF : (o = `'wght' ${parseInt(t, 10)}`, t = "normal")), new ch({
      pixelRatio: l,
      fontFamily: e,
      fontWeight: t,
      fontSize: i,
      fontFeatureSettings: n,
      fontVariationSettings: o,
      lineHeight: r,
      letterSpacing: a
    });
  }
  /**
   * @internal
   */
  constructor(e) {
    this._bareFontInfoBrand = void 0, this.pixelRatio = e.pixelRatio, this.fontFamily = String(e.fontFamily), this.fontWeight = String(e.fontWeight), this.fontSize = e.fontSize, this.fontFeatureSettings = e.fontFeatureSettings, this.fontVariationSettings = e.fontVariationSettings, this.lineHeight = e.lineHeight | 0, this.letterSpacing = e.letterSpacing;
  }
  /**
   * @internal
   */
  getId() {
    return `${this.pixelRatio}-${this.fontFamily}-${this.fontWeight}-${this.fontSize}-${this.fontFeatureSettings}-${this.fontVariationSettings}-${this.lineHeight}-${this.letterSpacing}`;
  }
  /**
   * @internal
   */
  getMassagedFontFamily() {
    const e = Qn.fontFamily, t = ch._wrapInQuotes(this.fontFamily);
    return e && this.fontFamily !== e ? `${t}, ${e}` : t;
  }
  static _wrapInQuotes(e) {
    return /[,"']/.test(e) ? e : /[+ ]/.test(e) ? `"${e}"` : e;
  }
}
const sz = 2;
class LS extends ch {
  /**
   * @internal
   */
  constructor(e, t) {
    super(e), this._editorStylingBrand = void 0, this.version = sz, this.isTrusted = t, this.isMonospace = e.isMonospace, this.typicalHalfwidthCharacterWidth = e.typicalHalfwidthCharacterWidth, this.typicalFullwidthCharacterWidth = e.typicalFullwidthCharacterWidth, this.canUseHalfwidthRightwardsArrow = e.canUseHalfwidthRightwardsArrow, this.spaceWidth = e.spaceWidth, this.middotWidth = e.middotWidth, this.wsmiddotWidth = e.wsmiddotWidth, this.maxDigitWidth = e.maxDigitWidth;
  }
  /**
   * @internal
   */
  equals(e) {
    return this.fontFamily === e.fontFamily && this.fontWeight === e.fontWeight && this.fontSize === e.fontSize && this.fontFeatureSettings === e.fontFeatureSettings && this.fontVariationSettings === e.fontVariationSettings && this.lineHeight === e.lineHeight && this.letterSpacing === e.letterSpacing && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.typicalFullwidthCharacterWidth === e.typicalFullwidthCharacterWidth && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.maxDigitWidth === e.maxDigitWidth;
  }
}
class oz extends U {
  constructor() {
    super(...arguments), this._cache = /* @__PURE__ */ new Map(), this._evictUntrustedReadingsTimeout = -1, this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event;
  }
  dispose() {
    this._evictUntrustedReadingsTimeout !== -1 && (clearTimeout(this._evictUntrustedReadingsTimeout), this._evictUntrustedReadingsTimeout = -1), super.dispose();
  }
  /**
   * Clear all cached font information and trigger a change event.
   */
  clearAllFontInfos() {
    this._cache.clear(), this._onDidChange.fire();
  }
  _ensureCache(e) {
    const t = jb(e);
    let i = this._cache.get(t);
    return i || (i = new rz(), this._cache.set(t, i)), i;
  }
  _writeToCache(e, t, i) {
    this._ensureCache(e).put(t, i), !i.isTrusted && this._evictUntrustedReadingsTimeout === -1 && (this._evictUntrustedReadingsTimeout = e.setTimeout(() => {
      this._evictUntrustedReadingsTimeout = -1, this._evictUntrustedReadings(e);
    }, 5e3));
  }
  _evictUntrustedReadings(e) {
    const t = this._ensureCache(e), i = t.getValues();
    let n = !1;
    for (const o of i)
      o.isTrusted || (n = !0, t.remove(o));
    n && this._onDidChange.fire();
  }
  /**
   * Read font information.
   */
  readFontInfo(e, t) {
    const i = this._ensureCache(e);
    if (!i.has(t)) {
      let n = this._actualReadFontInfo(e, t);
      (n.typicalHalfwidthCharacterWidth <= 2 || n.typicalFullwidthCharacterWidth <= 2 || n.spaceWidth <= 2 || n.maxDigitWidth <= 2) && (n = new LS({
        pixelRatio: Om.getInstance(e).value,
        fontFamily: n.fontFamily,
        fontWeight: n.fontWeight,
        fontSize: n.fontSize,
        fontFeatureSettings: n.fontFeatureSettings,
        fontVariationSettings: n.fontVariationSettings,
        lineHeight: n.lineHeight,
        letterSpacing: n.letterSpacing,
        isMonospace: n.isMonospace,
        typicalHalfwidthCharacterWidth: Math.max(n.typicalHalfwidthCharacterWidth, 5),
        typicalFullwidthCharacterWidth: Math.max(n.typicalFullwidthCharacterWidth, 5),
        canUseHalfwidthRightwardsArrow: n.canUseHalfwidthRightwardsArrow,
        spaceWidth: Math.max(n.spaceWidth, 5),
        middotWidth: Math.max(n.middotWidth, 5),
        wsmiddotWidth: Math.max(n.wsmiddotWidth, 5),
        maxDigitWidth: Math.max(n.maxDigitWidth, 5)
      }, !1)), this._writeToCache(e, t, n);
    }
    return i.get(t);
  }
  _createRequest(e, t, i, n) {
    const o = new lV(e, t);
    return i.push(o), n == null || n.push(o), o;
  }
  _actualReadFontInfo(e, t) {
    const i = [], n = [], o = this._createRequest("n", 0, i, n), r = this._createRequest("ｍ", 0, i, null), a = this._createRequest(" ", 0, i, n), l = this._createRequest("0", 0, i, n), c = this._createRequest("1", 0, i, n), h = this._createRequest("2", 0, i, n), d = this._createRequest("3", 0, i, n), u = this._createRequest("4", 0, i, n), f = this._createRequest("5", 0, i, n), g = this._createRequest("6", 0, i, n), p = this._createRequest("7", 0, i, n), _ = this._createRequest("8", 0, i, n), b = this._createRequest("9", 0, i, n), C = this._createRequest("→", 0, i, n), w = this._createRequest("￫", 0, i, null), v = this._createRequest("·", 0, i, n), S = this._createRequest("⸱", 0, i, null), L = "|/-_ilm%";
    for (let B = 0, W = L.length; B < W; B++)
      this._createRequest(L.charAt(B), 0, i, n), this._createRequest(L.charAt(B), 1, i, n), this._createRequest(L.charAt(B), 2, i, n);
    cV(e, t, i);
    const k = Math.max(l.width, c.width, h.width, d.width, u.width, f.width, g.width, p.width, _.width, b.width);
    let x = t.fontFeatureSettings === $h.OFF;
    const I = n[0].width;
    for (let B = 1, W = n.length; x && B < W; B++) {
      const H = I - n[B].width;
      if (H < -1e-3 || H > 1e-3) {
        x = !1;
        break;
      }
    }
    let K = !0;
    return x && w.width !== I && (K = !1), w.width > C.width && (K = !1), new LS({
      pixelRatio: Om.getInstance(e).value,
      fontFamily: t.fontFamily,
      fontWeight: t.fontWeight,
      fontSize: t.fontSize,
      fontFeatureSettings: t.fontFeatureSettings,
      fontVariationSettings: t.fontVariationSettings,
      lineHeight: t.lineHeight,
      letterSpacing: t.letterSpacing,
      isMonospace: x,
      typicalHalfwidthCharacterWidth: o.width,
      typicalFullwidthCharacterWidth: r.width,
      canUseHalfwidthRightwardsArrow: K,
      spaceWidth: a.width,
      middotWidth: v.width,
      wsmiddotWidth: S.width,
      maxDigitWidth: k
    }, !0);
  }
}
class rz {
  constructor() {
    this._keys = /* @__PURE__ */ Object.create(null), this._values = /* @__PURE__ */ Object.create(null);
  }
  has(e) {
    const t = e.getId();
    return !!this._values[t];
  }
  get(e) {
    const t = e.getId();
    return this._values[t];
  }
  put(e, t) {
    const i = e.getId();
    this._keys[i] = e, this._values[i] = t;
  }
  remove(e) {
    const t = e.getId();
    delete this._keys[t], delete this._values[t];
  }
  getValues() {
    return Object.keys(this._keys).map((e) => this._values[e]);
  }
}
const kS = new oz(), Cu = class Cu {
  constructor(e, t) {
    this.key = e, this.migrate = t;
  }
  apply(e) {
    const t = Cu._read(e, this.key), i = (o) => Cu._read(e, o), n = (o, r) => Cu._write(e, o, r);
    this.migrate(t, i, n);
  }
  static _read(e, t) {
    if (typeof e > "u")
      return;
    const i = t.indexOf(".");
    if (i >= 0) {
      const n = t.substring(0, i);
      return this._read(e[n], t.substring(i + 1));
    }
    return e[t];
  }
  static _write(e, t, i) {
    const n = t.indexOf(".");
    if (n >= 0) {
      const o = t.substring(0, n);
      e[o] = e[o] || {}, this._write(e[o], t.substring(n + 1), i);
      return;
    }
    e[t] = i;
  }
};
Cu.items = [];
let Wm = Cu;
function er(s, e) {
  Wm.items.push(new Wm(s, e));
}
function os(s, e) {
  er(s, (t, i, n) => {
    if (typeof t < "u") {
      for (const [o, r] of e)
        if (t === o) {
          n(s, r);
          return;
        }
    }
  });
}
function az(s) {
  Wm.items.forEach((e) => e.apply(s));
}
os("wordWrap", [[!0, "on"], [!1, "off"]]);
os("lineNumbers", [[!0, "on"], [!1, "off"]]);
os("cursorBlinking", [["visible", "solid"]]);
os("renderWhitespace", [[!0, "boundary"], [!1, "none"]]);
os("renderLineHighlight", [[!0, "line"], [!1, "none"]]);
os("acceptSuggestionOnEnter", [[!0, "on"], [!1, "off"]]);
os("tabCompletion", [[!1, "off"], [!0, "onlySnippets"]]);
os("hover", [[!0, { enabled: !0 }], [!1, { enabled: !1 }]]);
os("parameterHints", [[!0, { enabled: !0 }], [!1, { enabled: !1 }]]);
os("autoIndent", [[!1, "advanced"], [!0, "full"]]);
os("matchBrackets", [[!0, "always"], [!1, "never"]]);
os("renderFinalNewline", [[!0, "on"], [!1, "off"]]);
os("cursorSmoothCaretAnimation", [[!0, "on"], [!1, "off"]]);
os("occurrencesHighlight", [[!0, "singleFile"], [!1, "off"]]);
os("wordBasedSuggestions", [[!0, "matchingDocuments"], [!1, "off"]]);
er("autoClosingBrackets", (s, e, t) => {
  s === !1 && (t("autoClosingBrackets", "never"), typeof e("autoClosingQuotes") > "u" && t("autoClosingQuotes", "never"), typeof e("autoSurround") > "u" && t("autoSurround", "never"));
});
er("renderIndentGuides", (s, e, t) => {
  typeof s < "u" && (t("renderIndentGuides", void 0), typeof e("guides.indentation") > "u" && t("guides.indentation", !!s));
});
er("highlightActiveIndentGuide", (s, e, t) => {
  typeof s < "u" && (t("highlightActiveIndentGuide", void 0), typeof e("guides.highlightActiveIndentation") > "u" && t("guides.highlightActiveIndentation", !!s));
});
const lz = {
  method: "showMethods",
  function: "showFunctions",
  constructor: "showConstructors",
  deprecated: "showDeprecated",
  field: "showFields",
  variable: "showVariables",
  class: "showClasses",
  struct: "showStructs",
  interface: "showInterfaces",
  module: "showModules",
  property: "showProperties",
  event: "showEvents",
  operator: "showOperators",
  unit: "showUnits",
  value: "showValues",
  constant: "showConstants",
  enum: "showEnums",
  enumMember: "showEnumMembers",
  keyword: "showKeywords",
  text: "showWords",
  color: "showColors",
  file: "showFiles",
  reference: "showReferences",
  folder: "showFolders",
  typeParameter: "showTypeParameters",
  snippet: "showSnippets"
};
er("suggest.filteredTypes", (s, e, t) => {
  if (s && typeof s == "object") {
    for (const i of Object.entries(lz))
      s[i[0]] === !1 && typeof e(`suggest.${i[1]}`) > "u" && t(`suggest.${i[1]}`, !1);
    t("suggest.filteredTypes", void 0);
  }
});
er("quickSuggestions", (s, e, t) => {
  if (typeof s == "boolean") {
    const i = s ? "on" : "off";
    t("quickSuggestions", { comments: i, strings: i, other: i });
  }
});
er("experimental.stickyScroll.enabled", (s, e, t) => {
  typeof s == "boolean" && (t("experimental.stickyScroll.enabled", void 0), typeof e("stickyScroll.enabled") > "u" && t("stickyScroll.enabled", s));
});
er("experimental.stickyScroll.maxLineCount", (s, e, t) => {
  typeof s == "number" && (t("experimental.stickyScroll.maxLineCount", void 0), typeof e("stickyScroll.maxLineCount") > "u" && t("stickyScroll.maxLineCount", s));
});
er("codeActionsOnSave", (s, e, t) => {
  if (s && typeof s == "object") {
    let i = !1;
    const n = {};
    for (const o of Object.entries(s))
      typeof o[1] == "boolean" ? (i = !0, n[o[0]] = o[1] ? "explicit" : "never") : n[o[0]] = o[1];
    i && t("codeActionsOnSave", n);
  }
});
er("codeActionWidget.includeNearbyQuickfixes", (s, e, t) => {
  typeof s == "boolean" && (t("codeActionWidget.includeNearbyQuickfixes", void 0), typeof e("codeActionWidget.includeNearbyQuickFixes") > "u" && t("codeActionWidget.includeNearbyQuickFixes", s));
});
er("lightbulb.enabled", (s, e, t) => {
  typeof s == "boolean" && t("lightbulb.enabled", s ? void 0 : "off");
});
class cz {
  constructor() {
    this._tabFocus = !1, this._onDidChangeTabFocus = new A(), this.onDidChangeTabFocus = this._onDidChangeTabFocus.event;
  }
  getTabFocusMode() {
    return this._tabFocus;
  }
  setTabFocusMode(e) {
    this._tabFocus = e, this._onDidChangeTabFocus.fire(this._tabFocus);
  }
}
const a1 = new cz(), Ks = Be("accessibilityService"), hz = new ce("accessibilityModeEnabled", !1);
var dz = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, uz = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let xS = class extends U {
  constructor(e, t, i, n, o) {
    super(), this._accessibilityService = o, this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, this._onDidChangeFast = this._register(new A()), this.onDidChangeFast = this._onDidChangeFast.event, this._isDominatedByLongLines = !1, this._viewLineCount = 1, this._lineNumbersDigitCount = 1, this._reservedHeight = 0, this._glyphMarginDecorationLaneCount = 1, this._computeOptionsMemory = new UO(), this.isSimpleWidget = e, this.contextMenuId = t, this._containerObserver = this._register(new WO(n, i.dimension)), this._targetWindowId = fe(n).vscodeWindowId, this._rawOptions = fT(i), this._validatedOptions = _l.validateOptions(this._rawOptions), this.options = this._computeOptions(), this.options.get(
      13
      /* EditorOption.automaticLayout */
    ) && this._containerObserver.startObserving(), this._register(pl.onDidChangeZoomLevel(() => this._recomputeOptions())), this._register(a1.onDidChangeTabFocus(() => this._recomputeOptions())), this._register(this._containerObserver.onDidChange(() => this._recomputeOptions())), this._register(kS.onDidChange(() => this._recomputeOptions())), this._register(Om.getInstance(fe(n)).onDidChange(() => this._recomputeOptions())), this._register(this._accessibilityService.onDidChangeScreenReaderOptimized(() => this._recomputeOptions()));
  }
  _recomputeOptions() {
    const e = this._computeOptions(), t = _l.checkEquals(this.options, e);
    t !== null && (this.options = e, this._onDidChangeFast.fire(t), this._onDidChange.fire(t));
  }
  _computeOptions() {
    const e = this._readEnvConfiguration(), t = ch.createFromValidatedSettings(this._validatedOptions, e.pixelRatio, this.isSimpleWidget), i = this._readFontInfo(t), n = {
      memory: this._computeOptionsMemory,
      outerWidth: e.outerWidth,
      outerHeight: e.outerHeight - this._reservedHeight,
      fontInfo: i,
      extraEditorClassName: e.extraEditorClassName,
      isDominatedByLongLines: this._isDominatedByLongLines,
      viewLineCount: this._viewLineCount,
      lineNumbersDigitCount: this._lineNumbersDigitCount,
      emptySelectionClipboard: e.emptySelectionClipboard,
      pixelRatio: e.pixelRatio,
      tabFocusMode: a1.getTabFocusMode(),
      accessibilitySupport: e.accessibilitySupport,
      glyphMarginDecorationLaneCount: this._glyphMarginDecorationLaneCount
    };
    return _l.computeOptions(this._validatedOptions, n);
  }
  _readEnvConfiguration() {
    return {
      extraEditorClassName: gz(),
      outerWidth: this._containerObserver.getWidth(),
      outerHeight: this._containerObserver.getHeight(),
      emptySelectionClipboard: Zv || uo,
      pixelRatio: Om.getInstance(M2(this._targetWindowId, !0).window).value,
      accessibilitySupport: this._accessibilityService.isScreenReaderOptimized() ? 2 : this._accessibilityService.getAccessibilitySupport()
    };
  }
  _readFontInfo(e) {
    return kS.readFontInfo(M2(this._targetWindowId, !0).window, e);
  }
  getRawOptions() {
    return this._rawOptions;
  }
  updateOptions(e) {
    const t = fT(e);
    _l.applyUpdate(this._rawOptions, t) && (this._validatedOptions = _l.validateOptions(this._rawOptions), this._recomputeOptions());
  }
  observeContainer(e) {
    this._containerObserver.observe(e);
  }
  setIsDominatedByLongLines(e) {
    this._isDominatedByLongLines !== e && (this._isDominatedByLongLines = e, this._recomputeOptions());
  }
  setModelLineCount(e) {
    const t = fz(e);
    this._lineNumbersDigitCount !== t && (this._lineNumbersDigitCount = t, this._recomputeOptions());
  }
  setViewLineCount(e) {
    this._viewLineCount !== e && (this._viewLineCount = e, this._recomputeOptions());
  }
  setReservedHeight(e) {
    this._reservedHeight !== e && (this._reservedHeight = e, this._recomputeOptions());
  }
  setGlyphMarginDecorationLaneCount(e) {
    this._glyphMarginDecorationLaneCount !== e && (this._glyphMarginDecorationLaneCount = e, this._recomputeOptions());
  }
};
xS = dz([
  uz(4, Ks)
], xS);
function fz(s) {
  let e = 0;
  for (; s; )
    s = Math.floor(s / 10), e++;
  return e || 1;
}
function gz() {
  let s = "";
  return !ql && !C4 && (s += "no-user-select "), ql && (s += "no-minimap-shadow ", s += "enable-user-select "), $e && (s += "mac "), s;
}
class mz {
  constructor() {
    this._values = [];
  }
  _read(e) {
    return this._values[e];
  }
  get(e) {
    return this._values[e];
  }
  _write(e, t) {
    this._values[e] = t;
  }
}
class pz {
  constructor() {
    this._values = [];
  }
  _read(e) {
    if (e >= this._values.length)
      throw new Error("Cannot read uninitialized value");
    return this._values[e];
  }
  get(e) {
    return this._read(e);
  }
  _write(e, t) {
    this._values[e] = t;
  }
}
class _l {
  static validateOptions(e) {
    const t = new mz();
    for (const i of Qd) {
      const n = i.name === "_never_" ? void 0 : e[i.name];
      t._write(i.id, i.validate(n));
    }
    return t;
  }
  static computeOptions(e, t) {
    const i = new pz();
    for (const n of Qd)
      i._write(n.id, n.compute(t, i, e._read(n.id)));
    return i;
  }
  static _deepEquals(e, t) {
    if (typeof e != "object" || typeof t != "object" || !e || !t)
      return e === t;
    if (Array.isArray(e) || Array.isArray(t))
      return Array.isArray(e) && Array.isArray(t) ? li(e, t) : !1;
    if (Object.keys(e).length !== Object.keys(t).length)
      return !1;
    for (const i in e)
      if (!_l._deepEquals(e[i], t[i]))
        return !1;
    return !0;
  }
  static checkEquals(e, t) {
    const i = [];
    let n = !1;
    for (const o of Qd) {
      const r = !_l._deepEquals(e._read(o.id), t._read(o.id));
      i[o.id] = r, r && (n = !0);
    }
    return n ? new zO(i) : null;
  }
  /**
   * Returns true if something changed.
   * Modifies `options`.
  */
  static applyUpdate(e, t) {
    let i = !1;
    for (const n of Qd)
      if (t.hasOwnProperty(n.name)) {
        const o = n.applyUpdate(e[n.name], t[n.name]);
        e[n.name] = o.newValue, i = i || o.didChange;
      }
    return i;
  }
}
function fT(s) {
  const e = pa(s);
  return az(e), e;
}
var Ll;
(function(s) {
  const e = { total: 0, min: Number.MAX_VALUE, max: 0 }, t = { ...e }, i = { ...e }, n = { ...e };
  let o = 0;
  const r = {
    keydown: 0,
    input: 0,
    render: 0
  };
  function a() {
    b(), performance.mark("inputlatency/start"), performance.mark("keydown/start"), r.keydown = 1, queueMicrotask(l);
  }
  s.onKeyDown = a;
  function l() {
    r.keydown === 1 && (performance.mark("keydown/end"), r.keydown = 2);
  }
  function c() {
    performance.mark("input/start"), r.input = 1, _();
  }
  s.onBeforeInput = c;
  function h() {
    r.input === 0 && c(), queueMicrotask(d);
  }
  s.onInput = h;
  function d() {
    r.input === 1 && (performance.mark("input/end"), r.input = 2);
  }
  function u() {
    b();
  }
  s.onKeyUp = u;
  function f() {
    b();
  }
  s.onSelectionChange = f;
  function g() {
    r.keydown === 2 && r.input === 2 && r.render === 0 && (performance.mark("render/start"), r.render = 1, queueMicrotask(p), _());
  }
  s.onRenderStart = g;
  function p() {
    r.render === 1 && (performance.mark("render/end"), r.render = 2);
  }
  function _() {
    setTimeout(b);
  }
  function b() {
    r.keydown === 2 && r.input === 2 && r.render === 2 && (performance.mark("inputlatency/end"), performance.measure("keydown", "keydown/start", "keydown/end"), performance.measure("input", "input/start", "input/end"), performance.measure("render", "render/start", "render/end"), performance.measure("inputlatency", "inputlatency/start", "inputlatency/end"), C("keydown", e), C("input", t), C("render", i), C("inputlatency", n), o++, w());
  }
  function C(k, x) {
    const I = performance.getEntriesByName(k)[0].duration;
    x.total += I, x.min = Math.min(x.min, I), x.max = Math.max(x.max, I);
  }
  function w() {
    performance.clearMarks("keydown/start"), performance.clearMarks("keydown/end"), performance.clearMarks("input/start"), performance.clearMarks("input/end"), performance.clearMarks("render/start"), performance.clearMarks("render/end"), performance.clearMarks("inputlatency/start"), performance.clearMarks("inputlatency/end"), performance.clearMeasures("keydown"), performance.clearMeasures("input"), performance.clearMeasures("render"), performance.clearMeasures("inputlatency"), r.keydown = 0, r.input = 0, r.render = 0;
  }
  function v() {
    if (o === 0)
      return;
    const k = {
      keydown: S(e),
      input: S(t),
      render: S(i),
      total: S(n),
      sampleCount: o
    };
    return L(e), L(t), L(i), L(n), o = 0, k;
  }
  s.getAndClearMeasurements = v;
  function S(k) {
    return {
      average: k.total / o,
      max: k.max,
      min: k.min
    };
  }
  function L(k) {
    k.total = 0, k.min = Number.MAX_VALUE, k.max = 0;
  }
})(Ll || (Ll = {}));
const gw = {
  JSONContribution: "base.contributions.json"
};
function _z(s) {
  return s.length > 0 && s.charAt(s.length - 1) === "#" ? s.substring(0, s.length - 1) : s;
}
class bz {
  constructor() {
    this._onDidChangeSchema = new A(), this.schemasById = {};
  }
  registerSchema(e, t) {
    this.schemasById[_z(e)] = t, this._onDidChangeSchema.fire(e);
  }
  notifySchemaChanged(e) {
    this._onDidChangeSchema.fire(e);
  }
}
const Cz = new bz();
Mi.add(gw.JSONContribution, Cz);
function nI(s) {
  return `--vscode-${s.replace(/\./g, "-")}`;
}
function se(s) {
  return `var(${nI(s)})`;
}
function vz(s, e) {
  return `var(${nI(s)}, ${e})`;
}
function wz(s) {
  return s !== null && typeof s == "object" && "light" in s && "dark" in s;
}
const $O = {
  ColorContribution: "base.contributions.colors"
}, yz = "default";
class Sz {
  constructor() {
    this._onDidChangeSchema = new A(), this.onDidChangeSchema = this._onDidChangeSchema.event, this.colorSchema = { type: "object", properties: {} }, this.colorReferenceSchema = { type: "string", enum: [], enumDescriptions: [] }, this.colorsById = {};
  }
  registerColor(e, t, i, n = !1, o) {
    const r = { id: e, description: i, defaults: t, needsTransparency: n, deprecationMessage: o };
    this.colorsById[e] = r;
    const a = { type: "string", format: "color-hex", defaultSnippets: [{ body: "${1:#ff0000}" }] };
    return o && (a.deprecationMessage = o), n && (a.pattern = "^#(?:(?<rgba>[0-9a-fA-f]{3}[0-9a-eA-E])|(?:[0-9a-fA-F]{6}(?:(?![fF]{2})(?:[0-9a-fA-F]{2}))))?$", a.patternErrorMessage = m("transparecyRequired", "This color must be transparent or it will obscure content")), this.colorSchema.properties[e] = {
      description: i,
      oneOf: [
        a,
        { type: "string", const: yz, description: m("useDefault", "Use the default color.") }
      ]
    }, this.colorReferenceSchema.enum.push(e), this.colorReferenceSchema.enumDescriptions.push(i), this._onDidChangeSchema.fire(), e;
  }
  getColors() {
    return Object.keys(this.colorsById).map((e) => this.colorsById[e]);
  }
  resolveDefaultColor(e, t) {
    const i = this.colorsById[e];
    if (i != null && i.defaults) {
      const n = wz(i.defaults) ? i.defaults[t.type] : i.defaults;
      return Do(n, t);
    }
  }
  getColorSchema() {
    return this.colorSchema;
  }
  toString() {
    const e = (t, i) => {
      const n = t.indexOf(".") === -1 ? 0 : 1, o = i.indexOf(".") === -1 ? 0 : 1;
      return n !== o ? n - o : t.localeCompare(i);
    };
    return Object.keys(this.colorsById).sort(e).map((t) => `- \`${t}\`: ${this.colorsById[t].description}`).join(`
`);
  }
}
const mw = new Sz();
Mi.add($O.ColorContribution, mw);
function E(s, e, t, i, n) {
  return mw.registerColor(s, e, t, i, n);
}
function Lz(s, e) {
  var t, i, n, o;
  switch (s.op) {
    case 0:
      return (t = Do(s.value, e)) == null ? void 0 : t.darken(s.factor);
    case 1:
      return (i = Do(s.value, e)) == null ? void 0 : i.lighten(s.factor);
    case 2:
      return (n = Do(s.value, e)) == null ? void 0 : n.transparent(s.factor);
    case 3: {
      const r = Do(s.background, e);
      return r ? (o = Do(s.value, e)) == null ? void 0 : o.makeOpaque(r) : Do(s.value, e);
    }
    case 4:
      for (const r of s.values) {
        const a = Do(r, e);
        if (a)
          return a;
      }
      return;
    case 6:
      return Do(e.defines(s.if) ? s.then : s.else, e);
    case 5: {
      const r = Do(s.value, e);
      if (!r)
        return;
      const a = Do(s.background, e);
      return a ? r.isDarkerThan(a) ? j.getLighterColor(r, a, s.factor).transparent(s.transparency) : j.getDarkerColor(r, a, s.factor).transparent(s.transparency) : r.transparent(s.factor * s.transparency);
    }
    default:
      throw _E();
  }
}
function ld(s, e) {
  return { op: 0, value: s, factor: e };
}
function Ko(s, e) {
  return { op: 1, value: s, factor: e };
}
function Ae(s, e) {
  return { op: 2, value: s, factor: e };
}
function Hm(...s) {
  return { op: 4, values: s };
}
function kz(s, e, t) {
  return { op: 6, if: s, then: e, else: t };
}
function gT(s, e, t, i) {
  return { op: 5, value: s, background: e, factor: t, transparency: i };
}
function Do(s, e) {
  if (s !== null) {
    if (typeof s == "string")
      return s[0] === "#" ? j.fromHex(s) : e.getColor(s);
    if (s instanceof j)
      return s;
    if (typeof s == "object")
      return Lz(s, e);
  }
}
const KO = "vscode://schemas/workbench-colors", jO = Mi.as(gw.JSONContribution);
jO.registerSchema(KO, mw.getColorSchema());
const mT = new ai(() => jO.notifySchemaChanged(KO), 200);
mw.onDidChangeSchema(() => {
  mT.isScheduled() || mT.schedule();
});
const Me = E("foreground", { dark: "#CCCCCC", light: "#616161", hcDark: "#FFFFFF", hcLight: "#292929" }, m("foreground", "Overall foreground color. This color is only used if not overridden by a component."));
E("disabledForeground", { dark: "#CCCCCC80", light: "#61616180", hcDark: "#A5A5A5", hcLight: "#7F7F7F" }, m("disabledForeground", "Overall foreground for disabled elements. This color is only used if not overridden by a component."));
E("errorForeground", { dark: "#F48771", light: "#A1260D", hcDark: "#F48771", hcLight: "#B5200D" }, m("errorForeground", "Overall foreground color for error messages. This color is only used if not overridden by a component."));
E("descriptionForeground", { light: "#717171", dark: Ae(Me, 0.7), hcDark: Ae(Me, 0.7), hcLight: Ae(Me, 0.7) }, m("descriptionForeground", "Foreground color for description text providing additional information, for example for a label."));
const DS = E("icon.foreground", { dark: "#C5C5C5", light: "#424242", hcDark: "#FFFFFF", hcLight: "#292929" }, m("iconForeground", "The default color for icons in the workbench.")), Br = E("focusBorder", { dark: "#007FD4", light: "#0090F1", hcDark: "#F38518", hcLight: "#006BBD" }, m("focusBorder", "Overall border color for focused elements. This color is only used if not overridden by a component.")), Ke = E("contrastBorder", { light: null, dark: null, hcDark: "#6FC3DF", hcLight: "#0F4A85" }, m("contrastBorder", "An extra border around elements to separate them from others for greater contrast.")), Ut = E("contrastActiveBorder", { light: null, dark: null, hcDark: Br, hcLight: Br }, m("activeContrastBorder", "An extra border around active elements to separate them from others for greater contrast."));
E("selection.background", null, m("selectionBackground", "The background color of text selections in the workbench (e.g. for input fields or text areas). Note that this does not apply to selections within the editor."));
const xz = E("textLink.foreground", { light: "#006AB1", dark: "#3794FF", hcDark: "#21A6FF", hcLight: "#0F4A85" }, m("textLinkForeground", "Foreground color for links in text."));
E("textLink.activeForeground", { light: "#006AB1", dark: "#3794FF", hcDark: "#21A6FF", hcLight: "#0F4A85" }, m("textLinkActiveForeground", "Foreground color for links in text when clicked on and on mouse hover."));
E("textSeparator.foreground", { light: "#0000002e", dark: "#ffffff2e", hcDark: j.black, hcLight: "#292929" }, m("textSeparatorForeground", "Color for text separators."));
E("textPreformat.foreground", { light: "#A31515", dark: "#D7BA7D", hcDark: "#000000", hcLight: "#FFFFFF" }, m("textPreformatForeground", "Foreground color for preformatted text segments."));
E("textPreformat.background", { light: "#0000001A", dark: "#FFFFFF1A", hcDark: "#FFFFFF", hcLight: "#09345f" }, m("textPreformatBackground", "Background color for preformatted text segments."));
E("textBlockQuote.background", { light: "#f2f2f2", dark: "#222222", hcDark: null, hcLight: "#F2F2F2" }, m("textBlockQuoteBackground", "Background color for block quotes in text."));
E("textBlockQuote.border", { light: "#007acc80", dark: "#007acc80", hcDark: j.white, hcLight: "#292929" }, m("textBlockQuoteBorder", "Border color for block quotes in text."));
E("textCodeBlock.background", { light: "#dcdcdc66", dark: "#0a0a0a66", hcDark: j.black, hcLight: "#F2F2F2" }, m("textCodeBlockBackground", "Background color for code blocks in text."));
E("sash.hoverBorder", Br, m("sashActiveBorder", "Border color of active sashes."));
const ob = E("badge.background", { dark: "#4D4D4D", light: "#C4C4C4", hcDark: j.black, hcLight: "#0F4A85" }, m("badgeBackground", "Badge background color. Badges are small information labels, e.g. for search results count.")), Dz = E("badge.foreground", { dark: j.white, light: "#333", hcDark: j.white, hcLight: j.white }, m("badgeForeground", "Badge foreground color. Badges are small information labels, e.g. for search results count.")), sI = E("scrollbar.shadow", { dark: "#000000", light: "#DDDDDD", hcDark: null, hcLight: null }, m("scrollbarShadow", "Scrollbar shadow to indicate that the view is scrolled.")), qO = E("scrollbarSlider.background", { dark: j.fromHex("#797979").transparent(0.4), light: j.fromHex("#646464").transparent(0.4), hcDark: Ae(Ke, 0.6), hcLight: Ae(Ke, 0.4) }, m("scrollbarSliderBackground", "Scrollbar slider background color.")), GO = E("scrollbarSlider.hoverBackground", { dark: j.fromHex("#646464").transparent(0.7), light: j.fromHex("#646464").transparent(0.7), hcDark: Ae(Ke, 0.8), hcLight: Ae(Ke, 0.8) }, m("scrollbarSliderHoverBackground", "Scrollbar slider background color when hovering.")), ZO = E("scrollbarSlider.activeBackground", { dark: j.fromHex("#BFBFBF").transparent(0.4), light: j.fromHex("#000000").transparent(0.6), hcDark: Ke, hcLight: Ke }, m("scrollbarSliderActiveBackground", "Scrollbar slider background color when clicked on.")), Ez = E("progressBar.background", { dark: j.fromHex("#0E70C0"), light: j.fromHex("#0E70C0"), hcDark: Ke, hcLight: Ke }, m("progressBarBackground", "Background color of the progress bar that can show for long running operations.")), po = E("editor.background", { light: "#ffffff", dark: "#1E1E1E", hcDark: j.black, hcLight: j.white }, m("editorBackground", "Editor background color.")), Ja = E("editor.foreground", { light: "#333333", dark: "#BBBBBB", hcDark: j.white, hcLight: Me }, m("editorForeground", "Editor default foreground color."));
E("editorStickyScroll.background", po, m("editorStickyScrollBackground", "Background color of sticky scroll in the editor"));
E("editorStickyScrollHover.background", { dark: "#2A2D2E", light: "#F0F0F0", hcDark: null, hcLight: j.fromHex("#0F4A85").transparent(0.1) }, m("editorStickyScrollHoverBackground", "Background color of sticky scroll on hover in the editor"));
E("editorStickyScroll.border", { dark: null, light: null, hcDark: Ke, hcLight: Ke }, m("editorStickyScrollBorder", "Border color of sticky scroll in the editor"));
E("editorStickyScroll.shadow", sI, m("editorStickyScrollShadow", " Shadow color of sticky scroll in the editor"));
const oo = E("editorWidget.background", { dark: "#252526", light: "#F3F3F3", hcDark: "#0C141F", hcLight: j.white }, m("editorWidgetBackground", "Background color of editor widgets, such as find/replace.")), pw = E("editorWidget.foreground", Me, m("editorWidgetForeground", "Foreground color of editor widgets, such as find/replace.")), YO = E("editorWidget.border", { dark: "#454545", light: "#C8C8C8", hcDark: Ke, hcLight: Ke }, m("editorWidgetBorder", "Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget."));
E("editorWidget.resizeBorder", null, m("editorWidgetResizeBorder", "Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget."));
E("editorError.background", null, m("editorError.background", "Background color of error text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0);
const _w = E("editorError.foreground", { dark: "#F14C4C", light: "#E51400", hcDark: "#F48771", hcLight: "#B5200D" }, m("editorError.foreground", "Foreground color of error squigglies in the editor.")), Iz = E("editorError.border", { dark: null, light: null, hcDark: j.fromHex("#E47777").transparent(0.8), hcLight: "#B5200D" }, m("errorBorder", "If set, color of double underlines for errors in the editor.")), Nz = E("editorWarning.background", null, m("editorWarning.background", "Background color of warning text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0), Ka = E("editorWarning.foreground", { dark: "#CCA700", light: "#BF8803", hcDark: "#FFD370", hcLight: "#895503" }, m("editorWarning.foreground", "Foreground color of warning squigglies in the editor.")), Vm = E("editorWarning.border", { dark: null, light: null, hcDark: j.fromHex("#FFCC00").transparent(0.8), hcLight: j.fromHex("#FFCC00").transparent(0.8) }, m("warningBorder", "If set, color of double underlines for warnings in the editor."));
E("editorInfo.background", null, m("editorInfo.background", "Background color of info text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0);
const Wr = E("editorInfo.foreground", { dark: "#3794FF", light: "#1a85ff", hcDark: "#3794FF", hcLight: "#1a85ff" }, m("editorInfo.foreground", "Foreground color of info squigglies in the editor.")), zm = E("editorInfo.border", { dark: null, light: null, hcDark: j.fromHex("#3794FF").transparent(0.8), hcLight: "#292929" }, m("infoBorder", "If set, color of double underlines for infos in the editor.")), Tz = E("editorHint.foreground", { dark: j.fromHex("#eeeeee").transparent(0.7), light: "#6c6c6c", hcDark: null, hcLight: null }, m("editorHint.foreground", "Foreground color of hint squigglies in the editor."));
E("editorHint.border", { dark: null, light: null, hcDark: j.fromHex("#eeeeee").transparent(0.8), hcLight: "#292929" }, m("hintBorder", "If set, color of double underlines for hints in the editor."));
const Mz = E("editorLink.activeForeground", { dark: "#4E94CE", light: j.blue, hcDark: j.cyan, hcLight: "#292929" }, m("activeLinkForeground", "Color of active links.")), Jd = E("editor.selectionBackground", { light: "#ADD6FF", dark: "#264F78", hcDark: "#f3f518", hcLight: "#0F4A85" }, m("editorSelectionBackground", "Color of the editor selection.")), Rz = E("editor.selectionForeground", { light: null, dark: null, hcDark: "#000000", hcLight: j.white }, m("editorSelectionForeground", "Color of the selected text for high contrast.")), XO = E("editor.inactiveSelectionBackground", { light: Ae(Jd, 0.5), dark: Ae(Jd, 0.5), hcDark: Ae(Jd, 0.7), hcLight: Ae(Jd, 0.5) }, m("editorInactiveSelection", "Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations."), !0), QO = E("editor.selectionHighlightBackground", { light: gT(Jd, po, 0.3, 0.6), dark: gT(Jd, po, 0.3, 0.6), hcDark: null, hcLight: null }, m("editorSelectionHighlight", "Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations."), !0);
E("editor.selectionHighlightBorder", { light: null, dark: null, hcDark: Ut, hcLight: Ut }, m("editorSelectionHighlightBorder", "Border color for regions with the same content as the selection."));
E("editor.findMatchBackground", { light: "#A8AC94", dark: "#515C6A", hcDark: null, hcLight: null }, m("editorFindMatch", "Color of the current search match."));
E("editor.findMatchForeground", null, m("editorFindMatchForeground", "Text color of the current search match."));
const Da = E("editor.findMatchHighlightBackground", { light: "#EA5C0055", dark: "#EA5C0055", hcDark: null, hcLight: null }, m("findMatchHighlight", "Color of the other search matches. The color must not be opaque so as not to hide underlying decorations."), !0);
E("editor.findMatchHighlightForeground", null, m("findMatchHighlightForeground", "Foreground color of the other search matches."), !0);
E("editor.findRangeHighlightBackground", { dark: "#3a3d4166", light: "#b4b4b44d", hcDark: null, hcLight: null }, m("findRangeHighlight", "Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), !0);
E("editor.findMatchBorder", { light: null, dark: null, hcDark: Ut, hcLight: Ut }, m("editorFindMatchBorder", "Border color of the current search match."));
const Jc = E("editor.findMatchHighlightBorder", { light: null, dark: null, hcDark: Ut, hcLight: Ut }, m("findMatchHighlightBorder", "Border color of the other search matches."));
E("editor.findRangeHighlightBorder", { dark: null, light: null, hcDark: Ae(Ut, 0.4), hcLight: Ae(Ut, 0.4) }, m("findRangeHighlightBorder", "Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), !0);
E("editor.hoverHighlightBackground", { light: "#ADD6FF26", dark: "#264f7840", hcDark: "#ADD6FF26", hcLight: null }, m("hoverHighlight", "Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations."), !0);
const l1 = E("editorHoverWidget.background", oo, m("hoverBackground", "Background color of the editor hover."));
E("editorHoverWidget.foreground", pw, m("hoverForeground", "Foreground color of the editor hover."));
const JO = E("editorHoverWidget.border", YO, m("hoverBorder", "Border color of the editor hover."));
E("editorHoverWidget.statusBarBackground", { dark: Ko(l1, 0.2), light: ld(l1, 0.05), hcDark: oo, hcLight: oo }, m("statusBarBackground", "Background color of the editor hover status bar."));
const oI = E("editorInlayHint.foreground", { dark: "#969696", light: "#969696", hcDark: j.white, hcLight: j.black }, m("editorInlayHintForeground", "Foreground color of inline hints")), rI = E("editorInlayHint.background", { dark: Ae(ob, 0.1), light: Ae(ob, 0.1), hcDark: Ae(j.white, 0.1), hcLight: Ae(ob, 0.1) }, m("editorInlayHintBackground", "Background color of inline hints")), Az = E("editorInlayHint.typeForeground", oI, m("editorInlayHintForegroundTypes", "Foreground color of inline hints for types")), Pz = E("editorInlayHint.typeBackground", rI, m("editorInlayHintBackgroundTypes", "Background color of inline hints for types")), Oz = E("editorInlayHint.parameterForeground", oI, m("editorInlayHintForegroundParameter", "Foreground color of inline hints for parameters")), Fz = E("editorInlayHint.parameterBackground", rI, m("editorInlayHintBackgroundParameter", "Background color of inline hints for parameters")), Bz = E("editorLightBulb.foreground", { dark: "#FFCC00", light: "#DDB100", hcDark: "#FFCC00", hcLight: "#007ACC" }, m("editorLightBulbForeground", "The color used for the lightbulb actions icon."));
E("editorLightBulbAutoFix.foreground", { dark: "#75BEFF", light: "#007ACC", hcDark: "#75BEFF", hcLight: "#007ACC" }, m("editorLightBulbAutoFixForeground", "The color used for the lightbulb auto fix actions icon."));
E("editorLightBulbAi.foreground", Bz, m("editorLightBulbAiForeground", "The color used for the lightbulb AI icon."));
E("editor.snippetTabstopHighlightBackground", { dark: new j(new ze(124, 124, 124, 0.3)), light: new j(new ze(10, 50, 100, 0.2)), hcDark: new j(new ze(124, 124, 124, 0.3)), hcLight: new j(new ze(10, 50, 100, 0.2)) }, m("snippetTabstopHighlightBackground", "Highlight background color of a snippet tabstop."));
E("editor.snippetTabstopHighlightBorder", null, m("snippetTabstopHighlightBorder", "Highlight border color of a snippet tabstop."));
E("editor.snippetFinalTabstopHighlightBackground", null, m("snippetFinalTabstopHighlightBackground", "Highlight background color of the final tabstop of a snippet."));
E("editor.snippetFinalTabstopHighlightBorder", { dark: "#525252", light: new j(new ze(10, 50, 100, 0.5)), hcDark: "#525252", hcLight: "#292929" }, m("snippetFinalTabstopHighlightBorder", "Highlight border color of the final tabstop of a snippet."));
const ES = new j(new ze(155, 185, 85, 0.2)), IS = new j(new ze(255, 0, 0, 0.2)), Wz = E("diffEditor.insertedTextBackground", { dark: "#9ccc2c33", light: "#9ccc2c40", hcDark: null, hcLight: null }, m("diffEditorInserted", "Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations."), !0), Hz = E("diffEditor.removedTextBackground", { dark: "#ff000033", light: "#ff000033", hcDark: null, hcLight: null }, m("diffEditorRemoved", "Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations."), !0);
E("diffEditor.insertedLineBackground", { dark: ES, light: ES, hcDark: null, hcLight: null }, m("diffEditorInsertedLines", "Background color for lines that got inserted. The color must not be opaque so as not to hide underlying decorations."), !0);
E("diffEditor.removedLineBackground", { dark: IS, light: IS, hcDark: null, hcLight: null }, m("diffEditorRemovedLines", "Background color for lines that got removed. The color must not be opaque so as not to hide underlying decorations."), !0);
E("diffEditorGutter.insertedLineBackground", null, m("diffEditorInsertedLineGutter", "Background color for the margin where lines got inserted."));
E("diffEditorGutter.removedLineBackground", null, m("diffEditorRemovedLineGutter", "Background color for the margin where lines got removed."));
const Vz = E("diffEditorOverview.insertedForeground", null, m("diffEditorOverviewInserted", "Diff overview ruler foreground for inserted content.")), zz = E("diffEditorOverview.removedForeground", null, m("diffEditorOverviewRemoved", "Diff overview ruler foreground for removed content."));
E("diffEditor.insertedTextBorder", { dark: null, light: null, hcDark: "#33ff2eff", hcLight: "#374E06" }, m("diffEditorInsertedOutline", "Outline color for the text that got inserted."));
E("diffEditor.removedTextBorder", { dark: null, light: null, hcDark: "#FF008F", hcLight: "#AD0707" }, m("diffEditorRemovedOutline", "Outline color for text that got removed."));
E("diffEditor.border", { dark: null, light: null, hcDark: Ke, hcLight: Ke }, m("diffEditorBorder", "Border color between the two text editors."));
E("diffEditor.diagonalFill", { dark: "#cccccc33", light: "#22222233", hcDark: null, hcLight: null }, m("diffDiagonalFill", "Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views."));
E("diffEditor.unchangedRegionBackground", "sideBar.background", m("diffEditor.unchangedRegionBackground", "The background color of unchanged blocks in the diff editor."));
E("diffEditor.unchangedRegionForeground", "foreground", m("diffEditor.unchangedRegionForeground", "The foreground color of unchanged blocks in the diff editor."));
E("diffEditor.unchangedCodeBackground", { dark: "#74747429", light: "#b8b8b829", hcDark: null, hcLight: null }, m("diffEditor.unchangedCodeBackground", "The background color of unchanged code in the diff editor."));
const Op = E("widget.shadow", { dark: Ae(j.black, 0.36), light: Ae(j.black, 0.16), hcDark: null, hcLight: null }, m("widgetShadow", "Shadow color of widgets such as find/replace inside the editor.")), Uz = E("widget.border", { dark: null, light: null, hcDark: Ke, hcLight: Ke }, m("widgetBorder", "Border color of widgets such as find/replace inside the editor.")), pT = E("toolbar.hoverBackground", { dark: "#5a5d5e50", light: "#b8b8b850", hcDark: null, hcLight: null }, m("toolbarHoverBackground", "Toolbar background when hovering over actions using the mouse"));
E("toolbar.hoverOutline", { dark: null, light: null, hcDark: Ut, hcLight: Ut }, m("toolbarHoverOutline", "Toolbar outline when hovering over actions using the mouse"));
E("toolbar.activeBackground", { dark: Ko(pT, 0.1), light: ld(pT, 0.1), hcDark: null, hcLight: null }, m("toolbarActiveBackground", "Toolbar background when holding the mouse over actions"));
const $z = E("breadcrumb.foreground", Ae(Me, 0.8), m("breadcrumbsFocusForeground", "Color of focused breadcrumb items.")), Kz = E("breadcrumb.background", po, m("breadcrumbsBackground", "Background color of breadcrumb items.")), _T = E("breadcrumb.focusForeground", { light: ld(Me, 0.2), dark: Ko(Me, 0.1), hcDark: Ko(Me, 0.1), hcLight: Ko(Me, 0.1) }, m("breadcrumbsFocusForeground", "Color of focused breadcrumb items.")), jz = E("breadcrumb.activeSelectionForeground", { light: ld(Me, 0.2), dark: Ko(Me, 0.1), hcDark: Ko(Me, 0.1), hcLight: Ko(Me, 0.1) }, m("breadcrumbsSelectedForeground", "Color of selected breadcrumb items."));
E("breadcrumbPicker.background", oo, m("breadcrumbsSelectedBackground", "Background color of breadcrumb item picker."));
const e5 = 0.5, bT = j.fromHex("#40C8AE").transparent(e5), CT = j.fromHex("#40A6FF").transparent(e5), vT = j.fromHex("#606060").transparent(0.4), aI = 0.4, hf = 1, NS = E("merge.currentHeaderBackground", { dark: bT, light: bT, hcDark: null, hcLight: null }, m("mergeCurrentHeaderBackground", "Current header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
E("merge.currentContentBackground", Ae(NS, aI), m("mergeCurrentContentBackground", "Current content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
const TS = E("merge.incomingHeaderBackground", { dark: CT, light: CT, hcDark: null, hcLight: null }, m("mergeIncomingHeaderBackground", "Incoming header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
E("merge.incomingContentBackground", Ae(TS, aI), m("mergeIncomingContentBackground", "Incoming content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
const MS = E("merge.commonHeaderBackground", { dark: vT, light: vT, hcDark: null, hcLight: null }, m("mergeCommonHeaderBackground", "Common ancestor header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
E("merge.commonContentBackground", Ae(MS, aI), m("mergeCommonContentBackground", "Common ancestor content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
const df = E("merge.border", { dark: null, light: null, hcDark: "#C3DF6F", hcLight: "#007ACC" }, m("mergeBorder", "Border color on headers and the splitter in inline merge-conflicts."));
E("editorOverviewRuler.currentContentForeground", { dark: Ae(NS, hf), light: Ae(NS, hf), hcDark: df, hcLight: df }, m("overviewRulerCurrentContentForeground", "Current overview ruler foreground for inline merge-conflicts."));
E("editorOverviewRuler.incomingContentForeground", { dark: Ae(TS, hf), light: Ae(TS, hf), hcDark: df, hcLight: df }, m("overviewRulerIncomingContentForeground", "Incoming overview ruler foreground for inline merge-conflicts."));
E("editorOverviewRuler.commonContentForeground", { dark: Ae(MS, hf), light: Ae(MS, hf), hcDark: df, hcLight: df }, m("overviewRulerCommonContentForeground", "Common ancestor overview ruler foreground for inline merge-conflicts."));
E("editorOverviewRuler.findMatchForeground", { dark: "#d186167e", light: "#d186167e", hcDark: "#AB5A00", hcLight: "#AB5A00" }, m("overviewRulerFindMatchForeground", "Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations."), !0);
E("editorOverviewRuler.selectionHighlightForeground", "#A0A0A0CC", m("overviewRulerSelectionHighlightForeground", "Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations."), !0);
const qz = E("problemsErrorIcon.foreground", _w, m("problemsErrorIconForeground", "The color used for the problems error icon.")), Gz = E("problemsWarningIcon.foreground", Ka, m("problemsWarningIconForeground", "The color used for the problems warning icon.")), Zz = E("problemsInfoIcon.foreground", Wr, m("problemsInfoIconForeground", "The color used for the problems info icon.")), Yz = E("minimap.findMatchHighlight", { light: "#d18616", dark: "#d18616", hcDark: "#AB5A00", hcLight: "#0F4A85" }, m("minimapFindMatchHighlight", "Minimap marker color for find matches."), !0);
E("minimap.selectionOccurrenceHighlight", { light: "#c9c9c9", dark: "#676767", hcDark: "#ffffff", hcLight: "#0F4A85" }, m("minimapSelectionOccurrenceHighlight", "Minimap marker color for repeating editor selections."), !0);
const wT = E("minimap.selectionHighlight", { light: "#ADD6FF", dark: "#264F78", hcDark: "#ffffff", hcLight: "#0F4A85" }, m("minimapSelectionHighlight", "Minimap marker color for the editor selection."), !0), Xz = E("minimap.infoHighlight", { dark: Wr, light: Wr, hcDark: zm, hcLight: zm }, m("minimapInfo", "Minimap marker color for infos.")), Qz = E("minimap.warningHighlight", { dark: Ka, light: Ka, hcDark: Vm, hcLight: Vm }, m("overviewRuleWarning", "Minimap marker color for warnings.")), Jz = E("minimap.errorHighlight", { dark: new j(new ze(255, 18, 18, 0.7)), light: new j(new ze(255, 18, 18, 0.7)), hcDark: new j(new ze(255, 50, 50, 1)), hcLight: "#B5200D" }, m("minimapError", "Minimap marker color for errors.")), eU = E("minimap.background", null, m("minimapBackground", "Minimap background color.")), tU = E("minimap.foregroundOpacity", j.fromHex("#000f"), m("minimapForegroundOpacity", 'Opacity of foreground elements rendered in the minimap. For example, "#000000c0" will render the elements with 75% opacity.'));
E("minimapSlider.background", Ae(qO, 0.5), m("minimapSliderBackground", "Minimap slider background color."));
E("minimapSlider.hoverBackground", Ae(GO, 0.5), m("minimapSliderHoverBackground", "Minimap slider background color when hovering."));
E("minimapSlider.activeBackground", Ae(ZO, 0.5), m("minimapSliderActiveBackground", "Minimap slider background color when clicked on."));
E("charts.foreground", Me, m("chartsForeground", "The foreground color used in charts."));
E("charts.lines", Ae(Me, 0.5), m("chartsLines", "The color used for horizontal lines in charts."));
E("charts.red", _w, m("chartsRed", "The red color used in chart visualizations."));
E("charts.blue", Wr, m("chartsBlue", "The blue color used in chart visualizations."));
E("charts.yellow", Ka, m("chartsYellow", "The yellow color used in chart visualizations."));
E("charts.orange", Yz, m("chartsOrange", "The orange color used in chart visualizations."));
E("charts.green", { dark: "#89D185", light: "#388A34", hcDark: "#89D185", hcLight: "#374e06" }, m("chartsGreen", "The green color used in chart visualizations."));
E("charts.purple", { dark: "#B180D7", light: "#652D90", hcDark: "#B180D7", hcLight: "#652D90" }, m("chartsPurple", "The purple color used in chart visualizations."));
const iU = E("input.background", { dark: "#3C3C3C", light: j.white, hcDark: j.black, hcLight: j.white }, m("inputBoxBackground", "Input box background.")), nU = E("input.foreground", Me, m("inputBoxForeground", "Input box foreground.")), sU = E("input.border", { dark: null, light: null, hcDark: Ke, hcLight: Ke }, m("inputBoxBorder", "Input box border.")), t5 = E("inputOption.activeBorder", { dark: "#007ACC", light: "#007ACC", hcDark: Ke, hcLight: Ke }, m("inputBoxActiveOptionBorder", "Border color of activated options in input fields.")), oU = E("inputOption.hoverBackground", { dark: "#5a5d5e80", light: "#b8b8b850", hcDark: null, hcLight: null }, m("inputOption.hoverBackground", "Background color of activated options in input fields.")), lI = E("inputOption.activeBackground", { dark: Ae(Br, 0.4), light: Ae(Br, 0.2), hcDark: j.transparent, hcLight: j.transparent }, m("inputOption.activeBackground", "Background hover color of options in input fields.")), i5 = E("inputOption.activeForeground", { dark: j.white, light: j.black, hcDark: Me, hcLight: Me }, m("inputOption.activeForeground", "Foreground color of activated options in input fields."));
E("input.placeholderForeground", { light: Ae(Me, 0.5), dark: Ae(Me, 0.5), hcDark: Ae(Me, 0.7), hcLight: Ae(Me, 0.7) }, m("inputPlaceholderForeground", "Input box foreground color for placeholder text."));
const rU = E("inputValidation.infoBackground", { dark: "#063B49", light: "#D6ECF2", hcDark: j.black, hcLight: j.white }, m("inputValidationInfoBackground", "Input validation background color for information severity.")), aU = E("inputValidation.infoForeground", { dark: null, light: null, hcDark: null, hcLight: Me }, m("inputValidationInfoForeground", "Input validation foreground color for information severity.")), lU = E("inputValidation.infoBorder", { dark: "#007acc", light: "#007acc", hcDark: Ke, hcLight: Ke }, m("inputValidationInfoBorder", "Input validation border color for information severity.")), cU = E("inputValidation.warningBackground", { dark: "#352A05", light: "#F6F5D2", hcDark: j.black, hcLight: j.white }, m("inputValidationWarningBackground", "Input validation background color for warning severity.")), hU = E("inputValidation.warningForeground", { dark: null, light: null, hcDark: null, hcLight: Me }, m("inputValidationWarningForeground", "Input validation foreground color for warning severity.")), dU = E("inputValidation.warningBorder", { dark: "#B89500", light: "#B89500", hcDark: Ke, hcLight: Ke }, m("inputValidationWarningBorder", "Input validation border color for warning severity.")), uU = E("inputValidation.errorBackground", { dark: "#5A1D1D", light: "#F2DEDE", hcDark: j.black, hcLight: j.white }, m("inputValidationErrorBackground", "Input validation background color for error severity.")), fU = E("inputValidation.errorForeground", { dark: null, light: null, hcDark: null, hcLight: Me }, m("inputValidationErrorForeground", "Input validation foreground color for error severity.")), gU = E("inputValidation.errorBorder", { dark: "#BE1100", light: "#BE1100", hcDark: Ke, hcLight: Ke }, m("inputValidationErrorBorder", "Input validation border color for error severity.")), bw = E("dropdown.background", { dark: "#3C3C3C", light: j.white, hcDark: j.black, hcLight: j.white }, m("dropdownBackground", "Dropdown background.")), mU = E("dropdown.listBackground", { dark: null, light: null, hcDark: j.black, hcLight: j.white }, m("dropdownListBackground", "Dropdown list background.")), cI = E("dropdown.foreground", { dark: "#F0F0F0", light: Me, hcDark: j.white, hcLight: Me }, m("dropdownForeground", "Dropdown foreground.")), hI = E("dropdown.border", { dark: bw, light: "#CECECE", hcDark: Ke, hcLight: Ke }, m("dropdownBorder", "Dropdown border.")), n5 = E("button.foreground", j.white, m("buttonForeground", "Button foreground color.")), pU = E("button.separator", Ae(n5, 0.4), m("buttonSeparator", "Button separator color.")), Cg = E("button.background", { dark: "#0E639C", light: "#007ACC", hcDark: null, hcLight: "#0F4A85" }, m("buttonBackground", "Button background color.")), _U = E("button.hoverBackground", { dark: Ko(Cg, 0.2), light: ld(Cg, 0.2), hcDark: Cg, hcLight: Cg }, m("buttonHoverBackground", "Button background color when hovering.")), bU = E("button.border", Ke, m("buttonBorder", "Button border color.")), CU = E("button.secondaryForeground", { dark: j.white, light: j.white, hcDark: j.white, hcLight: Me }, m("buttonSecondaryForeground", "Secondary button foreground color.")), RS = E("button.secondaryBackground", { dark: "#3A3D41", light: "#5F6A79", hcDark: null, hcLight: j.white }, m("buttonSecondaryBackground", "Secondary button background color.")), vU = E("button.secondaryHoverBackground", { dark: Ko(RS, 0.2), light: ld(RS, 0.2), hcDark: null, hcLight: null }, m("buttonSecondaryHoverBackground", "Secondary button background color when hovering.")), vg = E("radio.activeForeground", i5, m("radioActiveForeground", "Foreground color of active radio option.")), wU = E("radio.activeBackground", lI, m("radioBackground", "Background color of active radio option.")), yU = E("radio.activeBorder", t5, m("radioActiveBorder", "Border color of the active radio option.")), SU = E("radio.inactiveForeground", null, m("radioInactiveForeground", "Foreground color of inactive radio option.")), LU = E("radio.inactiveBackground", null, m("radioInactiveBackground", "Background color of inactive radio option.")), kU = E("radio.inactiveBorder", { light: Ae(vg, 0.2), dark: Ae(vg, 0.2), hcDark: Ae(vg, 0.4), hcLight: Ae(vg, 0.2) }, m("radioInactiveBorder", "Border color of the inactive radio option.")), xU = E("radio.inactiveHoverBackground", oU, m("radioHoverBackground", "Background color of inactive active radio option when hovering.")), DU = E("checkbox.background", bw, m("checkbox.background", "Background color of checkbox widget."));
E("checkbox.selectBackground", oo, m("checkbox.select.background", "Background color of checkbox widget when the element it's in is selected."));
const EU = E("checkbox.foreground", cI, m("checkbox.foreground", "Foreground color of checkbox widget.")), IU = E("checkbox.border", hI, m("checkbox.border", "Border color of checkbox widget."));
E("checkbox.selectBorder", DS, m("checkbox.select.border", "Border color of checkbox widget when the element it's in is selected."));
const NU = E("keybindingLabel.background", { dark: new j(new ze(128, 128, 128, 0.17)), light: new j(new ze(221, 221, 221, 0.4)), hcDark: j.transparent, hcLight: j.transparent }, m("keybindingLabelBackground", "Keybinding label background color. The keybinding label is used to represent a keyboard shortcut.")), TU = E("keybindingLabel.foreground", { dark: j.fromHex("#CCCCCC"), light: j.fromHex("#555555"), hcDark: j.white, hcLight: Me }, m("keybindingLabelForeground", "Keybinding label foreground color. The keybinding label is used to represent a keyboard shortcut.")), MU = E("keybindingLabel.border", { dark: new j(new ze(51, 51, 51, 0.6)), light: new j(new ze(204, 204, 204, 0.4)), hcDark: new j(new ze(111, 195, 223)), hcLight: Ke }, m("keybindingLabelBorder", "Keybinding label border color. The keybinding label is used to represent a keyboard shortcut.")), RU = E("keybindingLabel.bottomBorder", { dark: new j(new ze(68, 68, 68, 0.6)), light: new j(new ze(187, 187, 187, 0.4)), hcDark: new j(new ze(111, 195, 223)), hcLight: Me }, m("keybindingLabelBottomBorder", "Keybinding label border bottom color. The keybinding label is used to represent a keyboard shortcut.")), AU = E("list.focusBackground", null, m("listFocusBackground", "List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), PU = E("list.focusForeground", null, m("listFocusForeground", "List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), OU = E("list.focusOutline", { dark: Br, light: Br, hcDark: Ut, hcLight: Ut }, m("listFocusOutline", "List/Tree outline color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), FU = E("list.focusAndSelectionOutline", null, m("listFocusAndSelectionOutline", "List/Tree outline color for the focused item when the list/tree is active and selected. An active list/tree has keyboard focus, an inactive does not.")), Kh = E("list.activeSelectionBackground", { dark: "#04395E", light: "#0060C0", hcDark: null, hcLight: j.fromHex("#0F4A85").transparent(0.1) }, m("listActiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), Um = E("list.activeSelectionForeground", { dark: j.white, light: j.white, hcDark: null, hcLight: null }, m("listActiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), s5 = E("list.activeSelectionIconForeground", null, m("listActiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), BU = E("list.inactiveSelectionBackground", { dark: "#37373D", light: "#E4E6F1", hcDark: null, hcLight: j.fromHex("#0F4A85").transparent(0.1) }, m("listInactiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), WU = E("list.inactiveSelectionForeground", null, m("listInactiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), HU = E("list.inactiveSelectionIconForeground", null, m("listInactiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), VU = E("list.inactiveFocusBackground", null, m("listInactiveFocusBackground", "List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), zU = E("list.inactiveFocusOutline", null, m("listInactiveFocusOutline", "List/Tree outline color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), o5 = E("list.hoverBackground", { dark: "#2A2D2E", light: "#F0F0F0", hcDark: j.white.transparent(0.1), hcLight: j.fromHex("#0F4A85").transparent(0.1) }, m("listHoverBackground", "List/Tree background when hovering over items using the mouse.")), r5 = E("list.hoverForeground", null, m("listHoverForeground", "List/Tree foreground when hovering over items using the mouse.")), UU = E("list.dropBackground", { dark: "#062F4A", light: "#D6EBFF", hcDark: null, hcLight: null }, m("listDropBackground", "List/Tree drag and drop background when moving items over other items when using the mouse.")), $U = E("list.dropBetweenBackground", { dark: DS, light: DS, hcDark: null, hcLight: null }, m("listDropBetweenBackground", "List/Tree drag and drop border color when moving items between items when using the mouse.")), m_ = E("list.highlightForeground", { dark: "#2AAAFF", light: "#0066BF", hcDark: Br, hcLight: Br }, m("highlight", "List/Tree foreground color of the match highlights when searching inside the list/tree."));
E("list.focusHighlightForeground", { dark: m_, light: kz(Kh, m_, "#BBE7FF"), hcDark: m_, hcLight: m_ }, m("listFocusHighlightForeground", "List/Tree foreground color of the match highlights on actively focused items when searching inside the list/tree."));
E("list.invalidItemForeground", { dark: "#B89500", light: "#B89500", hcDark: "#B89500", hcLight: "#B5200D" }, m("invalidItemForeground", "List/Tree foreground color for invalid items, for example an unresolved root in explorer."));
E("list.errorForeground", { dark: "#F88070", light: "#B01011", hcDark: null, hcLight: null }, m("listErrorForeground", "Foreground color of list items containing errors."));
E("list.warningForeground", { dark: "#CCA700", light: "#855F00", hcDark: null, hcLight: null }, m("listWarningForeground", "Foreground color of list items containing warnings."));
const KU = E("listFilterWidget.background", { light: ld(oo, 0), dark: Ko(oo, 0), hcDark: oo, hcLight: oo }, m("listFilterWidgetBackground", "Background color of the type filter widget in lists and trees.")), jU = E("listFilterWidget.outline", { dark: j.transparent, light: j.transparent, hcDark: "#f38518", hcLight: "#007ACC" }, m("listFilterWidgetOutline", "Outline color of the type filter widget in lists and trees.")), qU = E("listFilterWidget.noMatchesOutline", { dark: "#BE1100", light: "#BE1100", hcDark: Ke, hcLight: Ke }, m("listFilterWidgetNoMatchesOutline", "Outline color of the type filter widget in lists and trees, when there are no matches.")), GU = E("listFilterWidget.shadow", Op, m("listFilterWidgetShadow", "Shadow color of the type filter widget in lists and trees."));
E("list.filterMatchBackground", { dark: Da, light: Da, hcDark: null, hcLight: null }, m("listFilterMatchHighlight", "Background color of the filtered match."));
E("list.filterMatchBorder", { dark: Jc, light: Jc, hcDark: Ke, hcLight: Ut }, m("listFilterMatchHighlightBorder", "Border color of the filtered match."));
E("list.deemphasizedForeground", { dark: "#8C8C8C", light: "#8E8E90", hcDark: "#A7A8A9", hcLight: "#666666" }, m("listDeemphasizedForeground", "List/Tree foreground color for items that are deemphasized."));
const a5 = E("tree.indentGuidesStroke", { dark: "#585858", light: "#a9a9a9", hcDark: "#a9a9a9", hcLight: "#a5a5a5" }, m("treeIndentGuidesStroke", "Tree stroke color for the indentation guides.")), ZU = E("tree.inactiveIndentGuidesStroke", Ae(a5, 0.4), m("treeInactiveIndentGuidesStroke", "Tree stroke color for the indentation guides that are not active.")), YU = E("tree.tableColumnsBorder", { dark: "#CCCCCC20", light: "#61616120", hcDark: null, hcLight: null }, m("tableColumnsBorder", "Table border color between columns.")), XU = E("tree.tableOddRowsBackground", { dark: Ae(Me, 0.04), light: Ae(Me, 0.04), hcDark: null, hcLight: null }, m("tableOddRowsBackgroundColor", "Background color for odd table rows."));
E("editorActionList.background", oo, m("editorActionListBackground", "Action List background color."));
E("editorActionList.foreground", pw, m("editorActionListForeground", "Action List foreground color."));
E("editorActionList.focusForeground", Um, m("editorActionListFocusForeground", "Action List foreground color for the focused item."));
E("editorActionList.focusBackground", Kh, m("editorActionListFocusBackground", "Action List background color for the focused item."));
const QU = E("menu.border", { dark: null, light: null, hcDark: Ke, hcLight: Ke }, m("menuBorder", "Border color of menus.")), JU = E("menu.foreground", cI, m("menuForeground", "Foreground color of menu items.")), e$ = E("menu.background", bw, m("menuBackground", "Background color of menu items.")), t$ = E("menu.selectionForeground", Um, m("menuSelectionForeground", "Foreground color of the selected menu item in menus.")), i$ = E("menu.selectionBackground", Kh, m("menuSelectionBackground", "Background color of the selected menu item in menus.")), n$ = E("menu.selectionBorder", { dark: null, light: null, hcDark: Ut, hcLight: Ut }, m("menuSelectionBorder", "Border color of the selected menu item in menus.")), s$ = E("menu.separatorBackground", { dark: "#606060", light: "#D4D4D4", hcDark: Ke, hcLight: Ke }, m("menuSeparatorBackground", "Color of a separator menu item in menus.")), yT = E("quickInput.background", oo, m("pickerBackground", "Quick picker background color. The quick picker widget is the container for pickers like the command palette.")), o$ = E("quickInput.foreground", pw, m("pickerForeground", "Quick picker foreground color. The quick picker widget is the container for pickers like the command palette.")), r$ = E("quickInputTitle.background", { dark: new j(new ze(255, 255, 255, 0.105)), light: new j(new ze(0, 0, 0, 0.06)), hcDark: "#000000", hcLight: j.white }, m("pickerTitleBackground", "Quick picker title background color. The quick picker widget is the container for pickers like the command palette.")), l5 = E("pickerGroup.foreground", { dark: "#3794FF", light: "#0066BF", hcDark: j.white, hcLight: "#0F4A85" }, m("pickerGroupForeground", "Quick picker color for grouping labels.")), a$ = E("pickerGroup.border", { dark: "#3F3F46", light: "#CCCEDB", hcDark: j.white, hcLight: "#0F4A85" }, m("pickerGroupBorder", "Quick picker color for grouping borders.")), ST = E("quickInput.list.focusBackground", null, "", void 0, m("quickInput.list.focusBackground deprecation", "Please use quickInputList.focusBackground instead")), AS = E("quickInputList.focusForeground", Um, m("quickInput.listFocusForeground", "Quick picker foreground color for the focused item.")), c5 = E("quickInputList.focusIconForeground", s5, m("quickInput.listFocusIconForeground", "Quick picker icon foreground color for the focused item.")), PS = E("quickInputList.focusBackground", { dark: Hm(ST, Kh), light: Hm(ST, Kh), hcDark: null, hcLight: null }, m("quickInput.listFocusBackground", "Quick picker background color for the focused item."));
E("search.resultsInfoForeground", { light: Me, dark: Ae(Me, 0.65), hcDark: Me, hcLight: Me }, m("search.resultsInfoForeground", "Color of the text in the search viewlet's completion message."));
E("searchEditor.findMatchBackground", { light: Ae(Da, 0.66), dark: Ae(Da, 0.66), hcDark: Da, hcLight: Da }, m("searchEditor.queryMatch", "Color of the Search Editor query matches."));
E("searchEditor.findMatchBorder", { light: Ae(Jc, 0.66), dark: Ae(Jc, 0.66), hcDark: Jc, hcLight: Jc }, m("searchEditor.editorFindMatchBorder", "Border color of the Search Editor query matches."));
class Cw {
  constructor(e, t) {
    this.x = e, this.y = t, this._pageCoordinatesBrand = void 0;
  }
  toClientCoordinates(e) {
    return new h5(this.x - e.scrollX, this.y - e.scrollY);
  }
}
class h5 {
  constructor(e, t) {
    this.clientX = e, this.clientY = t, this._clientCoordinatesBrand = void 0;
  }
  toPageCoordinates(e) {
    return new Cw(this.clientX + e.scrollX, this.clientY + e.scrollY);
  }
}
class l$ {
  constructor(e, t, i, n) {
    this.x = e, this.y = t, this.width = i, this.height = n, this._editorPagePositionBrand = void 0;
  }
}
class c$ {
  constructor(e, t) {
    this.x = e, this.y = t, this._positionRelativeToEditorBrand = void 0;
  }
}
function dI(s) {
  const e = ui(s);
  return new l$(e.left, e.top, e.width, e.height);
}
function uI(s, e, t) {
  const i = e.width / s.offsetWidth, n = e.height / s.offsetHeight, o = (t.x - e.x) / i, r = (t.y - e.y) / n;
  return new c$(o, r);
}
class Gl extends Uo {
  constructor(e, t, i) {
    super(fe(i), e), this._editorMouseEventBrand = void 0, this.isFromPointerCapture = t, this.pos = new Cw(this.posx, this.posy), this.editorPos = dI(i), this.relativePos = uI(i, this.editorPos, this.pos);
  }
}
class h$ {
  constructor(e) {
    this._editorViewDomNode = e;
  }
  _create(e) {
    return new Gl(e, !1, this._editorViewDomNode);
  }
  onContextMenu(e, t) {
    return z(e, "contextmenu", (i) => {
      t(this._create(i));
    });
  }
  onMouseUp(e, t) {
    return z(e, "mouseup", (i) => {
      t(this._create(i));
    });
  }
  onMouseDown(e, t) {
    return z(e, X.MOUSE_DOWN, (i) => {
      t(this._create(i));
    });
  }
  onPointerDown(e, t) {
    return z(e, X.POINTER_DOWN, (i) => {
      t(this._create(i), i.pointerId);
    });
  }
  onMouseLeave(e, t) {
    return z(e, X.MOUSE_LEAVE, (i) => {
      t(this._create(i));
    });
  }
  onMouseMove(e, t) {
    return z(e, "mousemove", (i) => t(this._create(i)));
  }
}
class d$ {
  constructor(e) {
    this._editorViewDomNode = e;
  }
  _create(e) {
    return new Gl(e, !1, this._editorViewDomNode);
  }
  onPointerUp(e, t) {
    return z(e, "pointerup", (i) => {
      t(this._create(i));
    });
  }
  onPointerDown(e, t) {
    return z(e, X.POINTER_DOWN, (i) => {
      t(this._create(i), i.pointerId);
    });
  }
  onPointerLeave(e, t) {
    return z(e, X.POINTER_LEAVE, (i) => {
      t(this._create(i));
    });
  }
  onPointerMove(e, t) {
    return z(e, "pointermove", (i) => t(this._create(i)));
  }
}
class u$ extends U {
  constructor(e) {
    super(), this._editorViewDomNode = e, this._globalPointerMoveMonitor = this._register(new Af()), this._keydownListener = null;
  }
  startMonitoring(e, t, i, n, o) {
    this._keydownListener = Zt(e.ownerDocument, "keydown", (r) => {
      r.toKeyCodeChord().isModifierKey() || this._globalPointerMoveMonitor.stopMonitoring(!0, r.browserEvent);
    }, !0), this._globalPointerMoveMonitor.startMonitoring(e, t, i, (r) => {
      n(new Gl(r, !0, this._editorViewDomNode));
    }, (r) => {
      this._keydownListener.dispose(), o(r);
    });
  }
  stopMonitoring() {
    this._globalPointerMoveMonitor.stopMonitoring(!0);
  }
}
const YC = class YC {
  constructor(e) {
    this._editor = e, this._instanceId = ++YC._idPool, this._counter = 0, this._rules = /* @__PURE__ */ new Map(), this._garbageCollectionScheduler = new ai(() => this.garbageCollect(), 1e3);
  }
  createClassNameRef(e) {
    const t = this.getOrCreateRule(e);
    return t.increaseRefCount(), {
      className: t.className,
      dispose: () => {
        t.decreaseRefCount(), this._garbageCollectionScheduler.schedule();
      }
    };
  }
  getOrCreateRule(e) {
    const t = this.computeUniqueKey(e);
    let i = this._rules.get(t);
    if (!i) {
      const n = this._counter++;
      i = new f$(t, `dyn-rule-${this._instanceId}-${n}`, qb(this._editor.getContainerDomNode()) ? this._editor.getContainerDomNode() : void 0, e), this._rules.set(t, i);
    }
    return i;
  }
  computeUniqueKey(e) {
    return JSON.stringify(e);
  }
  garbageCollect() {
    for (const e of this._rules.values())
      e.hasReferences() || (this._rules.delete(e.key), e.dispose());
  }
};
YC._idPool = 0;
let c1 = YC;
class f$ {
  constructor(e, t, i, n) {
    this.key = e, this.className = t, this.properties = n, this._referenceCount = 0, this._styleElementDisposables = new ne(), this._styleElement = Us(i, void 0, this._styleElementDisposables), this._styleElement.textContent = this.getCssText(this.className, this.properties);
  }
  getCssText(e, t) {
    let i = `.${e} {`;
    for (const n in t) {
      const o = t[n];
      let r;
      typeof o == "object" ? r = se(o.id) : r = o;
      const a = g$(n);
      i += `
	${a}: ${r};`;
    }
    return i += `
}`, i;
  }
  dispose() {
    this._styleElementDisposables.dispose(), this._styleElement = void 0;
  }
  increaseRefCount() {
    this._referenceCount++;
  }
  decreaseRefCount() {
    this._referenceCount--;
  }
  hasReferences() {
    return this._referenceCount > 0;
  }
}
function g$(s) {
  return s.replace(/(^[A-Z])/, ([e]) => e.toLowerCase()).replace(/([A-Z])/g, ([e]) => `-${e.toLowerCase()}`);
}
class Fp extends U {
  constructor() {
    super(), this._shouldRender = !0;
  }
  shouldRender() {
    return this._shouldRender;
  }
  forceShouldRender() {
    this._shouldRender = !0;
  }
  setShouldRender() {
    this._shouldRender = !0;
  }
  onDidRender() {
    this._shouldRender = !1;
  }
  // --- begin event handlers
  onCompositionStart(e) {
    return !1;
  }
  onCompositionEnd(e) {
    return !1;
  }
  onConfigurationChanged(e) {
    return !1;
  }
  onCursorStateChanged(e) {
    return !1;
  }
  onDecorationsChanged(e) {
    return !1;
  }
  onFlushed(e) {
    return !1;
  }
  onFocusChanged(e) {
    return !1;
  }
  onLanguageConfigurationChanged(e) {
    return !1;
  }
  onLineMappingChanged(e) {
    return !1;
  }
  onLinesChanged(e) {
    return !1;
  }
  onLinesDeleted(e) {
    return !1;
  }
  onLinesInserted(e) {
    return !1;
  }
  onRevealRangeRequest(e) {
    return !1;
  }
  onScrollChanged(e) {
    return !1;
  }
  onThemeChanged(e) {
    return !1;
  }
  onTokensChanged(e) {
    return !1;
  }
  onTokensColorsChanged(e) {
    return !1;
  }
  onZonesChanged(e) {
    return !1;
  }
  // --- end event handlers
  handleEvents(e) {
    let t = !1;
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      switch (o.type) {
        case 0:
          this.onCompositionStart(o) && (t = !0);
          break;
        case 1:
          this.onCompositionEnd(o) && (t = !0);
          break;
        case 2:
          this.onConfigurationChanged(o) && (t = !0);
          break;
        case 3:
          this.onCursorStateChanged(o) && (t = !0);
          break;
        case 4:
          this.onDecorationsChanged(o) && (t = !0);
          break;
        case 5:
          this.onFlushed(o) && (t = !0);
          break;
        case 6:
          this.onFocusChanged(o) && (t = !0);
          break;
        case 7:
          this.onLanguageConfigurationChanged(o) && (t = !0);
          break;
        case 8:
          this.onLineMappingChanged(o) && (t = !0);
          break;
        case 9:
          this.onLinesChanged(o) && (t = !0);
          break;
        case 10:
          this.onLinesDeleted(o) && (t = !0);
          break;
        case 11:
          this.onLinesInserted(o) && (t = !0);
          break;
        case 12:
          this.onRevealRangeRequest(o) && (t = !0);
          break;
        case 13:
          this.onScrollChanged(o) && (t = !0);
          break;
        case 15:
          this.onTokensChanged(o) && (t = !0);
          break;
        case 14:
          this.onThemeChanged(o) && (t = !0);
          break;
        case 16:
          this.onTokensColorsChanged(o) && (t = !0);
          break;
        case 17:
          this.onZonesChanged(o) && (t = !0);
          break;
        default:
          console.info("View received unknown event: "), console.info(o);
      }
    }
    t && (this._shouldRender = !0);
  }
}
class rs extends Fp {
  constructor(e) {
    super(), this._context = e, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
}
class Go {
  static write(e, t) {
    e.setAttribute("data-mprt", String(t));
  }
  static read(e) {
    const t = e.getAttribute("data-mprt");
    return t === null ? 0 : parseInt(t, 10);
  }
  static collect(e, t) {
    const i = [];
    let n = 0;
    for (; e && e !== e.ownerDocument.body && e !== t; )
      e.nodeType === e.ELEMENT_NODE && (i[n++] = this.read(e)), e = e.parentElement;
    const o = new Uint8Array(n);
    for (let r = 0; r < n; r++)
      o[r] = i[n - r - 1];
    return o;
  }
}
class m$ {
  constructor(e, t) {
    this._restrictedRenderingContextBrand = void 0, this._viewLayout = e, this.viewportData = t, this.scrollWidth = this._viewLayout.getScrollWidth(), this.scrollHeight = this._viewLayout.getScrollHeight(), this.visibleRange = this.viewportData.visibleRange, this.bigNumbersDelta = this.viewportData.bigNumbersDelta;
    const i = this._viewLayout.getCurrentViewport();
    this.scrollTop = i.top, this.scrollLeft = i.left, this.viewportWidth = i.width, this.viewportHeight = i.height;
  }
  getScrolledTopFromAbsoluteTop(e) {
    return e - this.scrollTop;
  }
  getVerticalOffsetForLineNumber(e, t) {
    return this._viewLayout.getVerticalOffsetForLineNumber(e, t);
  }
  getVerticalOffsetAfterLineNumber(e, t) {
    return this._viewLayout.getVerticalOffsetAfterLineNumber(e, t);
  }
  getDecorationsInViewport() {
    return this.viewportData.getDecorationsInViewport();
  }
}
class p$ extends m$ {
  constructor(e, t, i) {
    super(e, t), this._renderingContextBrand = void 0, this._viewLines = i;
  }
  linesVisibleRangesForRange(e, t) {
    return this._viewLines.linesVisibleRangesForRange(e, t);
  }
  visibleRangeForPosition(e) {
    return this._viewLines.visibleRangeForPosition(e);
  }
}
class _$ {
  constructor(e, t, i, n) {
    this.outsideRenderedLine = e, this.lineNumber = t, this.ranges = i, this.continuesOnNextLine = n;
  }
}
class vw {
  static from(e) {
    const t = new Array(e.length);
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      t[i] = new vw(o.left, o.width);
    }
    return t;
  }
  constructor(e, t) {
    this._horizontalRangeBrand = void 0, this.left = Math.round(e), this.width = Math.round(t);
  }
  toString() {
    return `[${this.left},${this.width}]`;
  }
}
class hh {
  constructor(e, t) {
    this._floatHorizontalRangeBrand = void 0, this.left = e, this.width = t;
  }
  toString() {
    return `[${this.left},${this.width}]`;
  }
  static compare(e, t) {
    return e.left - t.left;
  }
}
class b$ {
  constructor(e, t) {
    this.outsideRenderedLine = e, this.originalLeft = t, this.left = Math.round(this.originalLeft);
  }
}
class LT {
  constructor(e, t) {
    this.outsideRenderedLine = e, this.ranges = t;
  }
}
class rb {
  static _createRange() {
    return this._handyReadyRange || (this._handyReadyRange = document.createRange()), this._handyReadyRange;
  }
  static _detachRange(e, t) {
    e.selectNodeContents(t);
  }
  static _readClientRects(e, t, i, n, o) {
    const r = this._createRange();
    try {
      return r.setStart(e, t), r.setEnd(i, n), r.getClientRects();
    } catch {
      return null;
    } finally {
      this._detachRange(r, o);
    }
  }
  static _mergeAdjacentRanges(e) {
    if (e.length === 1)
      return e;
    e.sort(hh.compare);
    const t = [];
    let i = 0, n = e[0];
    for (let o = 1, r = e.length; o < r; o++) {
      const a = e[o];
      n.left + n.width + 0.9 >= a.left ? n.width = Math.max(n.width, a.left + a.width - n.left) : (t[i++] = n, n = a);
    }
    return t[i++] = n, t;
  }
  static _createHorizontalRangesFromClientRects(e, t, i) {
    if (!e || e.length === 0)
      return null;
    const n = [];
    for (let o = 0, r = e.length; o < r; o++) {
      const a = e[o];
      n[o] = new hh(Math.max(0, (a.left - t) / i), a.width / i);
    }
    return this._mergeAdjacentRanges(n);
  }
  static readHorizontalRanges(e, t, i, n, o, r) {
    const l = e.children.length - 1;
    if (0 > l)
      return null;
    if (t = Math.min(l, Math.max(0, t)), n = Math.min(l, Math.max(0, n)), t === n && i === o && i === 0 && !e.children[t].firstChild) {
      const u = e.children[t].getClientRects();
      return r.markDidDomLayout(), this._createHorizontalRangesFromClientRects(u, r.clientRectDeltaLeft, r.clientRectScale);
    }
    t !== n && n > 0 && o === 0 && (n--, o = 1073741824);
    let c = e.children[t].firstChild, h = e.children[n].firstChild;
    if ((!c || !h) && (!c && i === 0 && t > 0 && (c = e.children[t - 1].firstChild, i = 1073741824), !h && o === 0 && n > 0 && (h = e.children[n - 1].firstChild, o = 1073741824)), !c || !h)
      return null;
    i = Math.min(c.textContent.length, Math.max(0, i)), o = Math.min(h.textContent.length, Math.max(0, o));
    const d = this._readClientRects(c, i, h, o, r.endNode);
    return r.markDidDomLayout(), this._createHorizontalRangesFromClientRects(d, r.clientRectDeltaLeft, r.clientRectScale);
  }
}
class ro {
  constructor(e, t, i, n) {
    this.startColumn = e, this.endColumn = t, this.className = i, this.type = n, this._lineDecorationBrand = void 0;
  }
  static _equals(e, t) {
    return e.startColumn === t.startColumn && e.endColumn === t.endColumn && e.className === t.className && e.type === t.type;
  }
  static equalsArr(e, t) {
    const i = e.length, n = t.length;
    if (i !== n)
      return !1;
    for (let o = 0; o < i; o++)
      if (!ro._equals(e[o], t[o]))
        return !1;
    return !0;
  }
  static extractWrapped(e, t, i) {
    if (e.length === 0)
      return e;
    const n = t + 1, o = i + 1, r = i - t, a = [];
    let l = 0;
    for (const c of e)
      c.endColumn <= n || c.startColumn >= o || (a[l++] = new ro(Math.max(1, c.startColumn - n + 1), Math.min(r + 1, c.endColumn - n + 1), c.className, c.type));
    return a;
  }
  static filter(e, t, i, n) {
    if (e.length === 0)
      return [];
    const o = [];
    let r = 0;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a], h = c.range;
      if (h.endLineNumber < t || h.startLineNumber > t || h.isEmpty() && (c.type === 0 || c.type === 3))
        continue;
      const d = h.startLineNumber === t ? h.startColumn : i, u = h.endLineNumber === t ? h.endColumn : n;
      o[r++] = new ro(d, u, c.inlineClassName, c.type);
    }
    return o;
  }
  static _typeCompare(e, t) {
    const i = [2, 0, 1, 3];
    return i[e] - i[t];
  }
  static compare(e, t) {
    if (e.startColumn !== t.startColumn)
      return e.startColumn - t.startColumn;
    if (e.endColumn !== t.endColumn)
      return e.endColumn - t.endColumn;
    const i = ro._typeCompare(e.type, t.type);
    return i !== 0 ? i : e.className !== t.className ? e.className < t.className ? -1 : 1 : 0;
  }
}
class kT {
  constructor(e, t, i, n) {
    this.startOffset = e, this.endOffset = t, this.className = i, this.metadata = n;
  }
}
class h1 {
  constructor() {
    this.stopOffsets = [], this.classNames = [], this.metadata = [], this.count = 0;
  }
  static _metadata(e) {
    let t = 0;
    for (let i = 0, n = e.length; i < n; i++)
      t |= e[i];
    return t;
  }
  consumeLowerThan(e, t, i) {
    for (; this.count > 0 && this.stopOffsets[0] < e; ) {
      let n = 0;
      for (; n + 1 < this.count && this.stopOffsets[n] === this.stopOffsets[n + 1]; )
        n++;
      i.push(new kT(t, this.stopOffsets[n], this.classNames.join(" "), h1._metadata(this.metadata))), t = this.stopOffsets[n] + 1, this.stopOffsets.splice(0, n + 1), this.classNames.splice(0, n + 1), this.metadata.splice(0, n + 1), this.count -= n + 1;
    }
    return this.count > 0 && t < e && (i.push(new kT(t, e - 1, this.classNames.join(" "), h1._metadata(this.metadata))), t = e), t;
  }
  insert(e, t, i) {
    if (this.count === 0 || this.stopOffsets[this.count - 1] <= e)
      this.stopOffsets.push(e), this.classNames.push(t), this.metadata.push(i);
    else
      for (let n = 0; n < this.count; n++)
        if (this.stopOffsets[n] >= e) {
          this.stopOffsets.splice(n, 0, e), this.classNames.splice(n, 0, t), this.metadata.splice(n, 0, i);
          break;
        }
    this.count++;
  }
}
class C$ {
  /**
   * Normalize line decorations. Overlapping decorations will generate multiple segments
   */
  static normalize(e, t) {
    if (t.length === 0)
      return [];
    const i = [], n = new h1();
    let o = 0;
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      let c = l.startColumn, h = l.endColumn;
      const d = l.className, u = l.type === 1 ? 2 : l.type === 2 ? 4 : 0;
      if (c > 1) {
        const p = e.charCodeAt(c - 2);
        Si(p) && c--;
      }
      if (h > 1) {
        const p = e.charCodeAt(h - 2);
        Si(p) && h--;
      }
      const f = c - 1, g = h - 2;
      o = n.consumeLowerThan(f, o, i), n.count === 0 && (o = f), n.insert(g, d, u);
    }
    return n.consumeLowerThan(1073741824, o, i), i;
  }
}
let N0;
function d5() {
  return N0 || (N0 = new TextDecoder("UTF-16LE")), N0;
}
let T0;
function v$() {
  return T0 || (T0 = new TextDecoder("UTF-16BE")), T0;
}
let M0;
function u5() {
  return M0 || (M0 = C9() ? d5() : v$()), M0;
}
function w$(s, e, t) {
  const i = new Uint16Array(s.buffer, e, t);
  return t > 0 && (i[0] === 65279 || i[0] === 65534) ? y$(s, e, t) : d5().decode(i);
}
function y$(s, e, t) {
  const i = [];
  let n = 0;
  for (let o = 0; o < t; o++) {
    const r = vW(s, e);
    e += 2, i[n++] = String.fromCharCode(r);
  }
  return i.join("");
}
class ww {
  constructor(e) {
    this._capacity = e | 0, this._buffer = new Uint16Array(this._capacity), this._completedStrings = null, this._bufferLength = 0;
  }
  reset() {
    this._completedStrings = null, this._bufferLength = 0;
  }
  build() {
    return this._completedStrings !== null ? (this._flushBuffer(), this._completedStrings.join("")) : this._buildBuffer();
  }
  _buildBuffer() {
    if (this._bufferLength === 0)
      return "";
    const e = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);
    return u5().decode(e);
  }
  _flushBuffer() {
    const e = this._buildBuffer();
    this._bufferLength = 0, this._completedStrings === null ? this._completedStrings = [e] : this._completedStrings[this._completedStrings.length] = e;
  }
  /**
   * Append a char code (<2^16)
   */
  appendCharCode(e) {
    const t = this._capacity - this._bufferLength;
    t <= 1 && (t === 0 || Si(e)) && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
  }
  /**
   * Append an ASCII char code (<2^8)
   */
  appendASCIICharCode(e) {
    this._bufferLength === this._capacity && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
  }
  appendString(e) {
    const t = e.length;
    if (this._bufferLength + t >= this._capacity) {
      this._flushBuffer(), this._completedStrings[this._completedStrings.length] = e;
      return;
    }
    for (let i = 0; i < t; i++)
      this._buffer[this._bufferLength++] = e.charCodeAt(i);
  }
}
class Li {
  constructor(e, t, i, n) {
    this.endIndex = e, this.type = t, this.metadata = i, this.containsRTL = n, this._linePartBrand = void 0;
  }
  isWhitespace() {
    return !!(this.metadata & 1);
  }
  isPseudoAfter() {
    return !!(this.metadata & 4);
  }
}
let f5 = class {
  constructor(e, t) {
    this.startOffset = e, this.endOffset = t;
  }
  equals(e) {
    return this.startOffset === e.startOffset && this.endOffset === e.endOffset;
  }
};
class Bf {
  constructor(e, t, i, n, o, r, a, l, c, h, d, u, f, g, p, _, b, C, w) {
    this.useMonospaceOptimizations = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.continuesWithWrappedLine = n, this.isBasicASCII = o, this.containsRTL = r, this.fauxIndentLength = a, this.lineTokens = l, this.lineDecorations = c.sort(ro.compare), this.tabSize = h, this.startVisibleColumn = d, this.spaceWidth = u, this.stopRenderingLineAfter = p, this.renderWhitespace = _ === "all" ? 4 : _ === "boundary" ? 1 : _ === "selection" ? 2 : _ === "trailing" ? 3 : 0, this.renderControlCharacters = b, this.fontLigatures = C, this.selectionsOnLine = w && w.sort((L, k) => L.startOffset < k.startOffset ? -1 : 1);
    const v = Math.abs(g - u), S = Math.abs(f - u);
    v < S ? (this.renderSpaceWidth = g, this.renderSpaceCharCode = 11825) : (this.renderSpaceWidth = f, this.renderSpaceCharCode = 183);
  }
  sameSelection(e) {
    if (this.selectionsOnLine === null)
      return e === null;
    if (e === null || e.length !== this.selectionsOnLine.length)
      return !1;
    for (let t = 0; t < this.selectionsOnLine.length; t++)
      if (!this.selectionsOnLine[t].equals(e[t]))
        return !1;
    return !0;
  }
  equals(e) {
    return this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineContent === e.lineContent && this.continuesWithWrappedLine === e.continuesWithWrappedLine && this.isBasicASCII === e.isBasicASCII && this.containsRTL === e.containsRTL && this.fauxIndentLength === e.fauxIndentLength && this.tabSize === e.tabSize && this.startVisibleColumn === e.startVisibleColumn && this.spaceWidth === e.spaceWidth && this.renderSpaceWidth === e.renderSpaceWidth && this.renderSpaceCharCode === e.renderSpaceCharCode && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.fontLigatures === e.fontLigatures && ro.equalsArr(this.lineDecorations, e.lineDecorations) && this.lineTokens.equals(e.lineTokens) && this.sameSelection(e.selectionsOnLine);
  }
}
class g5 {
  constructor(e, t) {
    this.partIndex = e, this.charIndex = t;
  }
}
class kr {
  static getPartIndex(e) {
    return (e & 4294901760) >>> 16;
  }
  static getCharIndex(e) {
    return (e & 65535) >>> 0;
  }
  constructor(e, t) {
    this.length = e, this._data = new Uint32Array(this.length), this._horizontalOffset = new Uint32Array(this.length);
  }
  setColumnInfo(e, t, i, n) {
    const o = (t << 16 | i << 0) >>> 0;
    this._data[e - 1] = o, this._horizontalOffset[e - 1] = n;
  }
  getHorizontalOffset(e) {
    return this._horizontalOffset.length === 0 ? 0 : this._horizontalOffset[e - 1];
  }
  charOffsetToPartData(e) {
    return this.length === 0 ? 0 : e < 0 ? this._data[0] : e >= this.length ? this._data[this.length - 1] : this._data[e];
  }
  getDomPosition(e) {
    const t = this.charOffsetToPartData(e - 1), i = kr.getPartIndex(t), n = kr.getCharIndex(t);
    return new g5(i, n);
  }
  getColumn(e, t) {
    return this.partDataToCharOffset(e.partIndex, t, e.charIndex) + 1;
  }
  partDataToCharOffset(e, t, i) {
    if (this.length === 0)
      return 0;
    const n = (e << 16 | i << 0) >>> 0;
    let o = 0, r = this.length - 1;
    for (; o + 1 < r; ) {
      const p = o + r >>> 1, _ = this._data[p];
      if (_ === n)
        return p;
      _ > n ? r = p : o = p;
    }
    if (o === r)
      return o;
    const a = this._data[o], l = this._data[r];
    if (a === n)
      return o;
    if (l === n)
      return r;
    const c = kr.getPartIndex(a), h = kr.getCharIndex(a), d = kr.getPartIndex(l);
    let u;
    c !== d ? u = t : u = kr.getCharIndex(l);
    const f = i - h, g = u - i;
    return f <= g ? o : r;
  }
}
class OS {
  constructor(e, t, i) {
    this._renderLineOutputBrand = void 0, this.characterMapping = e, this.containsRTL = t, this.containsForeignElements = i;
  }
}
function fI(s, e) {
  if (s.lineContent.length === 0) {
    if (s.lineDecorations.length > 0) {
      e.appendString("<span>");
      let t = 0, i = 0, n = 0;
      for (const r of s.lineDecorations)
        (r.type === 1 || r.type === 2) && (e.appendString('<span class="'), e.appendString(r.className), e.appendString('"></span>'), r.type === 1 && (n |= 1, t++), r.type === 2 && (n |= 2, i++));
      e.appendString("</span>");
      const o = new kr(1, t + i);
      return o.setColumnInfo(1, t, 0, 0), new OS(o, !1, n);
    }
    return e.appendString("<span><span></span></span>"), new OS(
      new kr(0, 0),
      !1,
      0
      /* ForeignElementType.None */
    );
  }
  return T$(k$(s), e);
}
class S$ {
  constructor(e, t, i, n) {
    this.characterMapping = e, this.html = t, this.containsRTL = i, this.containsForeignElements = n;
  }
}
function yw(s) {
  const e = new ww(1e4), t = fI(s, e);
  return new S$(t.characterMapping, e.build(), t.containsRTL, t.containsForeignElements);
}
class L$ {
  constructor(e, t, i, n, o, r, a, l, c, h, d, u, f, g, p, _) {
    this.fontIsMonospace = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.len = n, this.isOverflowing = o, this.overflowingCharCount = r, this.parts = a, this.containsForeignElements = l, this.fauxIndentLength = c, this.tabSize = h, this.startVisibleColumn = d, this.containsRTL = u, this.spaceWidth = f, this.renderSpaceCharCode = g, this.renderWhitespace = p, this.renderControlCharacters = _;
  }
}
function k$(s) {
  const e = s.lineContent;
  let t, i, n;
  s.stopRenderingLineAfter !== -1 && s.stopRenderingLineAfter < e.length ? (t = !0, i = e.length - s.stopRenderingLineAfter, n = s.stopRenderingLineAfter) : (t = !1, i = 0, n = e.length);
  let o = x$(e, s.containsRTL, s.lineTokens, s.fauxIndentLength, n);
  s.renderControlCharacters && !s.isBasicASCII && (o = E$(e, o)), (s.renderWhitespace === 4 || s.renderWhitespace === 1 || s.renderWhitespace === 2 && s.selectionsOnLine || s.renderWhitespace === 3 && !s.continuesWithWrappedLine) && (o = I$(s, e, n, o));
  let r = 0;
  if (s.lineDecorations.length > 0) {
    for (let a = 0, l = s.lineDecorations.length; a < l; a++) {
      const c = s.lineDecorations[a];
      c.type === 3 || c.type === 1 ? r |= 1 : c.type === 2 && (r |= 2);
    }
    o = N$(e, n, o, s.lineDecorations);
  }
  return s.containsRTL || (o = D$(e, o, !s.isBasicASCII || s.fontLigatures)), new L$(s.useMonospaceOptimizations, s.canUseHalfwidthRightwardsArrow, e, n, t, i, o, r, s.fauxIndentLength, s.tabSize, s.startVisibleColumn, s.containsRTL, s.spaceWidth, s.renderSpaceCharCode, s.renderWhitespace, s.renderControlCharacters);
}
function x$(s, e, t, i, n) {
  const o = [];
  let r = 0;
  i > 0 && (o[r++] = new Li(i, "", 0, !1));
  let a = i;
  for (let l = 0, c = t.getCount(); l < c; l++) {
    const h = t.getEndOffset(l);
    if (h <= i)
      continue;
    const d = t.getClassName(l);
    if (h >= n) {
      const f = e ? km(s.substring(a, n)) : !1;
      o[r++] = new Li(n, d, 0, f);
      break;
    }
    const u = e ? km(s.substring(a, h)) : !1;
    o[r++] = new Li(h, d, 0, u), a = h;
  }
  return o;
}
function D$(s, e, t) {
  let i = 0;
  const n = [];
  let o = 0;
  if (t)
    for (let r = 0, a = e.length; r < a; r++) {
      const l = e[r], c = l.endIndex;
      if (i + 50 < c) {
        const h = l.type, d = l.metadata, u = l.containsRTL;
        let f = -1, g = i;
        for (let p = i; p < c; p++)
          s.charCodeAt(p) === 32 && (f = p), f !== -1 && p - g >= 50 && (n[o++] = new Li(f + 1, h, d, u), g = f + 1, f = -1);
        g !== c && (n[o++] = new Li(c, h, d, u));
      } else
        n[o++] = l;
      i = c;
    }
  else
    for (let r = 0, a = e.length; r < a; r++) {
      const l = e[r], c = l.endIndex, h = c - i;
      if (h > 50) {
        const d = l.type, u = l.metadata, f = l.containsRTL, g = Math.ceil(
          h / 50
          /* Constants.LongToken */
        );
        for (let p = 1; p < g; p++) {
          const _ = i + p * 50;
          n[o++] = new Li(_, d, u, f);
        }
        n[o++] = new Li(c, d, u, f);
      } else
        n[o++] = l;
      i = c;
    }
  return n;
}
function m5(s) {
  return s < 32 ? s !== 9 : s === 127 || s >= 8234 && s <= 8238 || s >= 8294 && s <= 8297 || s >= 8206 && s <= 8207 || s === 1564;
}
function E$(s, e) {
  const t = [];
  let i = new Li(0, "", 0, !1), n = 0;
  for (const o of e) {
    const r = o.endIndex;
    for (; n < r; n++) {
      const a = s.charCodeAt(n);
      m5(a) && (n > i.endIndex && (i = new Li(n, o.type, o.metadata, o.containsRTL), t.push(i)), i = new Li(n + 1, "mtkcontrol", o.metadata, !1), t.push(i));
    }
    n > i.endIndex && (i = new Li(r, o.type, o.metadata, o.containsRTL), t.push(i));
  }
  return t;
}
function I$(s, e, t, i) {
  const n = s.continuesWithWrappedLine, o = s.fauxIndentLength, r = s.tabSize, a = s.startVisibleColumn, l = s.useMonospaceOptimizations, c = s.selectionsOnLine, h = s.renderWhitespace === 1, d = s.renderWhitespace === 3, u = s.renderSpaceWidth !== s.spaceWidth, f = [];
  let g = 0, p = 0, _ = i[p].type, b = i[p].containsRTL, C = i[p].endIndex;
  const w = i.length;
  let v = !1, S = Zn(e), L;
  S === -1 ? (v = !0, S = t, L = t) : L = id(e);
  let k = !1, x = 0, I = c && c[x], K = a % r;
  for (let W = o; W < t; W++) {
    const H = e.charCodeAt(W);
    I && W >= I.endOffset && (x++, I = c && c[x]);
    let P;
    if (W < S || W > L)
      P = !0;
    else if (H === 9)
      P = !0;
    else if (H === 32)
      if (h)
        if (k)
          P = !0;
        else {
          const q = W + 1 < t ? e.charCodeAt(W + 1) : 0;
          P = q === 32 || q === 9;
        }
      else
        P = !0;
    else
      P = !1;
    if (P && c && (P = !!I && I.startOffset <= W && I.endOffset > W), P && d && (P = v || W > L), P && b && W >= S && W <= L && (P = !1), k) {
      if (!P || !l && K >= r) {
        if (u) {
          const q = g > 0 ? f[g - 1].endIndex : o;
          for (let J = q + 1; J <= W; J++)
            f[g++] = new Li(J, "mtkw", 1, !1);
        } else
          f[g++] = new Li(W, "mtkw", 1, !1);
        K = K % r;
      }
    } else
      (W === C || P && W > o) && (f[g++] = new Li(W, _, 0, b), K = K % r);
    for (H === 9 ? K = r : jl(H) ? K += 2 : K++, k = P; W === C && (p++, p < w); )
      _ = i[p].type, b = i[p].containsRTL, C = i[p].endIndex;
  }
  let B = !1;
  if (k)
    if (n && h) {
      const W = t > 0 ? e.charCodeAt(t - 1) : 0, H = t > 1 ? e.charCodeAt(t - 2) : 0;
      W === 32 && H !== 32 && H !== 9 || (B = !0);
    } else
      B = !0;
  if (B)
    if (u) {
      const W = g > 0 ? f[g - 1].endIndex : o;
      for (let H = W + 1; H <= t; H++)
        f[g++] = new Li(H, "mtkw", 1, !1);
    } else
      f[g++] = new Li(t, "mtkw", 1, !1);
  else
    f[g++] = new Li(t, _, 0, b);
  return f;
}
function N$(s, e, t, i) {
  i.sort(ro.compare);
  const n = C$.normalize(s, i), o = n.length;
  let r = 0;
  const a = [];
  let l = 0, c = 0;
  for (let d = 0, u = t.length; d < u; d++) {
    const f = t[d], g = f.endIndex, p = f.type, _ = f.metadata, b = f.containsRTL;
    for (; r < o && n[r].startOffset < g; ) {
      const C = n[r];
      if (C.startOffset > c && (c = C.startOffset, a[l++] = new Li(c, p, _, b)), C.endOffset + 1 <= g)
        c = C.endOffset + 1, a[l++] = new Li(c, p + " " + C.className, _ | C.metadata, b), r++;
      else {
        c = g, a[l++] = new Li(c, p + " " + C.className, _ | C.metadata, b);
        break;
      }
    }
    g > c && (c = g, a[l++] = new Li(c, p, _, b));
  }
  const h = t[t.length - 1].endIndex;
  if (r < o && n[r].startOffset === h)
    for (; r < o && n[r].startOffset === h; ) {
      const d = n[r];
      a[l++] = new Li(c, d.className, d.metadata, !1), r++;
    }
  return a;
}
function T$(s, e) {
  const t = s.fontIsMonospace, i = s.canUseHalfwidthRightwardsArrow, n = s.containsForeignElements, o = s.lineContent, r = s.len, a = s.isOverflowing, l = s.overflowingCharCount, c = s.parts, h = s.fauxIndentLength, d = s.tabSize, u = s.startVisibleColumn, f = s.containsRTL, g = s.spaceWidth, p = s.renderSpaceCharCode, _ = s.renderWhitespace, b = s.renderControlCharacters, C = new kr(r + 1, c.length);
  let w = !1, v = 0, S = u, L = 0, k = 0, x = 0;
  f ? e.appendString('<span dir="ltr">') : e.appendString("<span>");
  for (let I = 0, K = c.length; I < K; I++) {
    const B = c[I], W = B.endIndex, H = B.type, P = B.containsRTL, q = _ !== 0 && B.isWhitespace(), J = q && !t && (H === "mtkw" || !n), oe = v === W && B.isPseudoAfter();
    if (L = 0, e.appendString("<span "), P && e.appendString('style="unicode-bidi:isolate" '), e.appendString('class="'), e.appendString(J ? "mtkz" : H), e.appendASCIICharCode(
      34
      /* CharCode.DoubleQuote */
    ), q) {
      let ae = 0;
      {
        let re = v, be = S;
        for (; re < W; re++) {
          const At = (o.charCodeAt(re) === 9 ? d - be % d : 1) | 0;
          ae += At, re >= h && (be += At);
        }
      }
      for (J && (e.appendString(' style="width:'), e.appendString(String(g * ae)), e.appendString('px"')), e.appendASCIICharCode(
        62
        /* CharCode.GreaterThan */
      ); v < W; v++) {
        C.setColumnInfo(v + 1, I - x, L, k), x = 0;
        const re = o.charCodeAt(v);
        let be, Ce;
        if (re === 9) {
          be = d - S % d | 0, Ce = be, !i || Ce > 1 ? e.appendCharCode(8594) : e.appendCharCode(65515);
          for (let At = 2; At <= Ce; At++)
            e.appendCharCode(160);
        } else
          be = 2, Ce = 1, e.appendCharCode(p), e.appendCharCode(8204);
        L += be, k += Ce, v >= h && (S += Ce);
      }
    } else
      for (e.appendASCIICharCode(
        62
        /* CharCode.GreaterThan */
      ); v < W; v++) {
        C.setColumnInfo(v + 1, I - x, L, k), x = 0;
        const ae = o.charCodeAt(v);
        let re = 1, be = 1;
        switch (ae) {
          case 9:
            re = d - S % d, be = re;
            for (let Ce = 1; Ce <= re; Ce++)
              e.appendCharCode(160);
            break;
          case 32:
            e.appendCharCode(160);
            break;
          case 60:
            e.appendString("&lt;");
            break;
          case 62:
            e.appendString("&gt;");
            break;
          case 38:
            e.appendString("&amp;");
            break;
          case 0:
            b ? e.appendCharCode(9216) : e.appendString("&#00;");
            break;
          case 65279:
          case 8232:
          case 8233:
          case 133:
            e.appendCharCode(65533);
            break;
          default:
            jl(ae) && be++, b && ae < 32 ? e.appendCharCode(9216 + ae) : b && ae === 127 ? e.appendCharCode(9249) : b && m5(ae) ? (e.appendString("[U+"), e.appendString(M$(ae)), e.appendString("]"), re = 8, be = re) : e.appendCharCode(ae);
        }
        L += re, k += be, v >= h && (S += be);
      }
    oe ? x++ : x = 0, v >= r && !w && B.isPseudoAfter() && (w = !0, C.setColumnInfo(v + 1, I, L, k)), e.appendString("</span>");
  }
  return w || C.setColumnInfo(r + 1, c.length - 1, L, k), a && (e.appendString('<span class="mtkoverflow">'), e.appendString(m("showMore", "Show more ({0})", R$(l))), e.appendString("</span>")), e.appendString("</span>"), new OS(C, f, n);
}
function M$(s) {
  return s.toString(16).toUpperCase().padStart(4, "0");
}
function R$(s) {
  return s < 1024 ? m("overflow.chars", "{0} chars", s) : s < 1024 * 1024 ? `${(s / 1024).toFixed(1)} KB` : `${(s / 1024 / 1024).toFixed(1)} MB`;
}
var Ps;
(function(s) {
  s.DARK = "dark", s.LIGHT = "light", s.HIGH_CONTRAST_DARK = "hcDark", s.HIGH_CONTRAST_LIGHT = "hcLight";
})(Ps || (Ps = {}));
function dh(s) {
  return s === Ps.HIGH_CONTRAST_DARK || s === Ps.HIGH_CONTRAST_LIGHT;
}
function Sw(s) {
  return s === Ps.DARK || s === Ps.HIGH_CONTRAST_DARK;
}
const A$ = /* @__PURE__ */ function() {
  return Ab ? !0 : !(Rn || uo || ql);
}();
let Au = !0;
class xT {
  constructor(e, t) {
    this.themeType = t;
    const i = e.options, n = i.get(
      50
      /* EditorOption.fontInfo */
    );
    i.get(
      38
      /* EditorOption.experimentalWhitespaceRendering */
    ) === "off" ? this.renderWhitespace = i.get(
      100
      /* EditorOption.renderWhitespace */
    ) : this.renderWhitespace = "none", this.renderControlCharacters = i.get(
      95
      /* EditorOption.renderControlCharacters */
    ), this.spaceWidth = n.spaceWidth, this.middotWidth = n.middotWidth, this.wsmiddotWidth = n.wsmiddotWidth, this.useMonospaceOptimizations = n.isMonospace && !i.get(
      33
      /* EditorOption.disableMonospaceOptimizations */
    ), this.canUseHalfwidthRightwardsArrow = n.canUseHalfwidthRightwardsArrow, this.lineHeight = i.get(
      67
      /* EditorOption.lineHeight */
    ), this.stopRenderingLineAfter = i.get(
      118
      /* EditorOption.stopRenderingLineAfter */
    ), this.fontLigatures = i.get(
      51
      /* EditorOption.fontLigatures */
    );
  }
  equals(e) {
    return this.themeType === e.themeType && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineHeight === e.lineHeight && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.fontLigatures === e.fontLigatures;
  }
}
const XC = class XC {
  constructor(e) {
    this._options = e, this._isMaybeInvalid = !0, this._renderedViewLine = null;
  }
  // --- begin IVisibleLineData
  getDomNode() {
    return this._renderedViewLine && this._renderedViewLine.domNode ? this._renderedViewLine.domNode.domNode : null;
  }
  setDomNode(e) {
    if (this._renderedViewLine)
      this._renderedViewLine.domNode = st(e);
    else
      throw new Error("I have no rendered view line to set the dom node to...");
  }
  onContentChanged() {
    this._isMaybeInvalid = !0;
  }
  onTokensChanged() {
    this._isMaybeInvalid = !0;
  }
  onDecorationsChanged() {
    this._isMaybeInvalid = !0;
  }
  onOptionsChanged(e) {
    this._isMaybeInvalid = !0, this._options = e;
  }
  onSelectionChanged() {
    return dh(this._options.themeType) || this._options.renderWhitespace === "selection" ? (this._isMaybeInvalid = !0, !0) : !1;
  }
  renderLine(e, t, i, n, o) {
    if (this._isMaybeInvalid === !1)
      return !1;
    this._isMaybeInvalid = !1;
    const r = n.getViewLineRenderingData(e), a = this._options, l = ro.filter(r.inlineDecorations, e, r.minColumn, r.maxColumn);
    let c = null;
    if (dh(a.themeType) || this._options.renderWhitespace === "selection") {
      const f = n.selections;
      for (const g of f) {
        if (g.endLineNumber < e || g.startLineNumber > e)
          continue;
        const p = g.startLineNumber === e ? g.startColumn : r.minColumn, _ = g.endLineNumber === e ? g.endColumn : r.maxColumn;
        p < _ && (dh(a.themeType) && l.push(new ro(
          p,
          _,
          "inline-selected-text",
          0
          /* InlineDecorationType.Regular */
        )), this._options.renderWhitespace === "selection" && (c || (c = []), c.push(new f5(p - 1, _ - 1))));
      }
    }
    const h = new Bf(a.useMonospaceOptimizations, a.canUseHalfwidthRightwardsArrow, r.content, r.continuesWithWrappedLine, r.isBasicASCII, r.containsRTL, r.minColumn - 1, r.tokens, l, r.tabSize, r.startVisibleColumn, a.spaceWidth, a.middotWidth, a.wsmiddotWidth, a.stopRenderingLineAfter, a.renderWhitespace, a.renderControlCharacters, a.fontLigatures !== $h.OFF, c);
    if (this._renderedViewLine && this._renderedViewLine.input.equals(h))
      return !1;
    o.appendString('<div style="top:'), o.appendString(String(t)), o.appendString("px;height:"), o.appendString(String(i)), o.appendString('px;" class="'), o.appendString(XC.CLASS_NAME), o.appendString('">');
    const d = fI(h, o);
    o.appendString("</div>");
    let u = null;
    return Au && A$ && r.isBasicASCII && a.useMonospaceOptimizations && d.containsForeignElements === 0 && (u = new p_(this._renderedViewLine ? this._renderedViewLine.domNode : null, h, d.characterMapping)), u || (u = _5(this._renderedViewLine ? this._renderedViewLine.domNode : null, h, d.characterMapping, d.containsRTL, d.containsForeignElements)), this._renderedViewLine = u, !0;
  }
  layoutLine(e, t, i) {
    this._renderedViewLine && this._renderedViewLine.domNode && (this._renderedViewLine.domNode.setTop(t), this._renderedViewLine.domNode.setHeight(i));
  }
  // --- end IVisibleLineData
  getWidth(e) {
    return this._renderedViewLine ? this._renderedViewLine.getWidth(e) : 0;
  }
  getWidthIsFast() {
    return this._renderedViewLine ? this._renderedViewLine.getWidthIsFast() : !0;
  }
  needsMonospaceFontCheck() {
    return this._renderedViewLine ? this._renderedViewLine instanceof p_ : !1;
  }
  monospaceAssumptionsAreValid() {
    return this._renderedViewLine && this._renderedViewLine instanceof p_ ? this._renderedViewLine.monospaceAssumptionsAreValid() : Au;
  }
  onMonospaceAssumptionsInvalidated() {
    this._renderedViewLine && this._renderedViewLine instanceof p_ && (this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine());
  }
  getVisibleRangesForRange(e, t, i, n) {
    if (!this._renderedViewLine)
      return null;
    t = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, t)), i = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, i));
    const o = this._renderedViewLine.input.stopRenderingLineAfter;
    if (o !== -1 && t > o + 1 && i > o + 1)
      return new LT(!0, [new hh(this.getWidth(n), 0)]);
    o !== -1 && t > o + 1 && (t = o + 1), o !== -1 && i > o + 1 && (i = o + 1);
    const r = this._renderedViewLine.getVisibleRangesForRange(e, t, i, n);
    return r && r.length > 0 ? new LT(!1, r) : null;
  }
  getColumnOfNodeOffset(e, t) {
    return this._renderedViewLine ? this._renderedViewLine.getColumnOfNodeOffset(e, t) : 1;
  }
};
XC.CLASS_NAME = "view-line";
let ya = XC;
class p_ {
  constructor(e, t, i) {
    this._cachedWidth = -1, this.domNode = e, this.input = t;
    const n = Math.floor(
      t.lineContent.length / 300
      /* Constants.MaxMonospaceDistance */
    );
    if (n > 0) {
      this._keyColumnPixelOffsetCache = new Float32Array(n);
      for (let o = 0; o < n; o++)
        this._keyColumnPixelOffsetCache[o] = -1;
    } else
      this._keyColumnPixelOffsetCache = null;
    this._characterMapping = i, this._charWidth = t.spaceWidth;
  }
  getWidth(e) {
    if (!this.domNode || this.input.lineContent.length < 300) {
      const t = this._characterMapping.getHorizontalOffset(this._characterMapping.length);
      return Math.round(this._charWidth * t);
    }
    return this._cachedWidth === -1 && (this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth, e == null || e.markDidDomLayout()), this._cachedWidth;
  }
  getWidthIsFast() {
    return this.input.lineContent.length < 300 || this._cachedWidth !== -1;
  }
  monospaceAssumptionsAreValid() {
    if (!this.domNode)
      return Au;
    if (this.input.lineContent.length < 300) {
      const e = this.getWidth(null), t = this.domNode.domNode.firstChild.offsetWidth;
      Math.abs(e - t) >= 2 && (console.warn("monospace assumptions have been violated, therefore disabling monospace optimizations!"), Au = !1);
    }
    return Au;
  }
  toSlowRenderedLine() {
    return _5(
      this.domNode,
      this.input,
      this._characterMapping,
      !1,
      0
      /* ForeignElementType.None */
    );
  }
  getVisibleRangesForRange(e, t, i, n) {
    const o = this._getColumnPixelOffset(e, t, n), r = this._getColumnPixelOffset(e, i, n);
    return [new hh(o, r - o)];
  }
  _getColumnPixelOffset(e, t, i) {
    if (t <= 300) {
      const c = this._characterMapping.getHorizontalOffset(t);
      return this._charWidth * c;
    }
    const n = Math.floor(
      (t - 1) / 300
      /* Constants.MaxMonospaceDistance */
    ) - 1, o = (n + 1) * 300 + 1;
    let r = -1;
    if (this._keyColumnPixelOffsetCache && (r = this._keyColumnPixelOffsetCache[n], r === -1 && (r = this._actualReadPixelOffset(e, o, i), this._keyColumnPixelOffsetCache[n] = r)), r === -1) {
      const c = this._characterMapping.getHorizontalOffset(t);
      return this._charWidth * c;
    }
    const a = this._characterMapping.getHorizontalOffset(o), l = this._characterMapping.getHorizontalOffset(t);
    return r + this._charWidth * (l - a);
  }
  _getReadingTarget(e) {
    return e.domNode.firstChild;
  }
  _actualReadPixelOffset(e, t, i) {
    if (!this.domNode)
      return -1;
    const n = this._characterMapping.getDomPosition(t), o = rb.readHorizontalRanges(this._getReadingTarget(this.domNode), n.partIndex, n.charIndex, n.partIndex, n.charIndex, i);
    return !o || o.length === 0 ? -1 : o[0].left;
  }
  getColumnOfNodeOffset(e, t) {
    return b5(this._characterMapping, e, t);
  }
}
class p5 {
  constructor(e, t, i, n, o) {
    if (this.domNode = e, this.input = t, this._characterMapping = i, this._isWhitespaceOnly = /^\s*$/.test(t.lineContent), this._containsForeignElements = o, this._cachedWidth = -1, this._pixelOffsetCache = null, !n || this._characterMapping.length === 0) {
      this._pixelOffsetCache = new Float32Array(Math.max(2, this._characterMapping.length + 1));
      for (let r = 0, a = this._characterMapping.length; r <= a; r++)
        this._pixelOffsetCache[r] = -1;
    }
  }
  // --- Reading from the DOM methods
  _getReadingTarget(e) {
    return e.domNode.firstChild;
  }
  /**
   * Width of the line in pixels
   */
  getWidth(e) {
    return this.domNode ? (this._cachedWidth === -1 && (this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth, e == null || e.markDidDomLayout()), this._cachedWidth) : 0;
  }
  getWidthIsFast() {
    return this._cachedWidth !== -1;
  }
  /**
   * Visible ranges for a model range
   */
  getVisibleRangesForRange(e, t, i, n) {
    if (!this.domNode)
      return null;
    if (this._pixelOffsetCache !== null) {
      const o = this._readPixelOffset(this.domNode, e, t, n);
      if (o === -1)
        return null;
      const r = this._readPixelOffset(this.domNode, e, i, n);
      return r === -1 ? null : [new hh(o, r - o)];
    }
    return this._readVisibleRangesForRange(this.domNode, e, t, i, n);
  }
  _readVisibleRangesForRange(e, t, i, n, o) {
    if (i === n) {
      const r = this._readPixelOffset(e, t, i, o);
      return r === -1 ? null : [new hh(r, 0)];
    } else
      return this._readRawVisibleRangesForRange(e, i, n, o);
  }
  _readPixelOffset(e, t, i, n) {
    if (this._characterMapping.length === 0) {
      if (this._containsForeignElements === 0 || this._containsForeignElements === 2)
        return 0;
      if (this._containsForeignElements === 1)
        return this.getWidth(n);
      const o = this._getReadingTarget(e);
      return o.firstChild ? (n.markDidDomLayout(), o.firstChild.offsetWidth) : 0;
    }
    if (this._pixelOffsetCache !== null) {
      const o = this._pixelOffsetCache[i];
      if (o !== -1)
        return o;
      const r = this._actualReadPixelOffset(e, t, i, n);
      return this._pixelOffsetCache[i] = r, r;
    }
    return this._actualReadPixelOffset(e, t, i, n);
  }
  _actualReadPixelOffset(e, t, i, n) {
    if (this._characterMapping.length === 0) {
      const l = rb.readHorizontalRanges(this._getReadingTarget(e), 0, 0, 0, 0, n);
      return !l || l.length === 0 ? -1 : l[0].left;
    }
    if (i === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0)
      return this.getWidth(n);
    const o = this._characterMapping.getDomPosition(i), r = rb.readHorizontalRanges(this._getReadingTarget(e), o.partIndex, o.charIndex, o.partIndex, o.charIndex, n);
    if (!r || r.length === 0)
      return -1;
    const a = r[0].left;
    if (this.input.isBasicASCII) {
      const l = this._characterMapping.getHorizontalOffset(i), c = Math.round(this.input.spaceWidth * l);
      if (Math.abs(c - a) <= 1)
        return c;
    }
    return a;
  }
  _readRawVisibleRangesForRange(e, t, i, n) {
    if (t === 1 && i === this._characterMapping.length)
      return [new hh(0, this.getWidth(n))];
    const o = this._characterMapping.getDomPosition(t), r = this._characterMapping.getDomPosition(i);
    return rb.readHorizontalRanges(this._getReadingTarget(e), o.partIndex, o.charIndex, r.partIndex, r.charIndex, n);
  }
  /**
   * Returns the column for the text found at a specific offset inside a rendered dom node
   */
  getColumnOfNodeOffset(e, t) {
    return b5(this._characterMapping, e, t);
  }
}
class P$ extends p5 {
  _readVisibleRangesForRange(e, t, i, n, o) {
    const r = super._readVisibleRangesForRange(e, t, i, n, o);
    if (!r || r.length === 0 || i === n || i === 1 && n === this._characterMapping.length)
      return r;
    if (!this.input.containsRTL) {
      const a = this._readPixelOffset(e, t, n, o);
      if (a !== -1) {
        const l = r[r.length - 1];
        l.left < a && (l.width = a - l.left);
      }
    }
    return r;
  }
}
const _5 = /* @__PURE__ */ function() {
  return Zv ? O$ : F$;
}();
function O$(s, e, t, i, n) {
  return new P$(s, e, t, i, n);
}
function F$(s, e, t, i, n) {
  return new p5(s, e, t, i, n);
}
function b5(s, e, t) {
  const i = e.textContent.length;
  let n = -1;
  for (; e; )
    e = e.previousSibling, n++;
  return s.getColumn(new g5(n, t), i);
}
class pi {
  static _nextVisibleColumn(e, t, i) {
    return e === 9 ? pi.nextRenderTabStop(t, i) : jl(e) || gE(e) ? t + 2 : t + 1;
  }
  /**
   * Returns a visible column from a column.
   * @see {@link CursorColumns}
   */
  static visibleColumnFromColumn(e, t, i) {
    const n = Math.min(t - 1, e.length), o = e.substring(0, n), r = new Ub(o);
    let a = 0;
    for (; !r.eol(); ) {
      const l = zb(o, n, r.offset);
      r.nextGraphemeLength(), a = this._nextVisibleColumn(l, a, i);
    }
    return a;
  }
  /**
   * Returns a column from a visible column.
   * @see {@link CursorColumns}
   */
  static columnFromVisibleColumn(e, t, i) {
    if (t <= 0)
      return 1;
    const n = e.length, o = new Ub(e);
    let r = 0, a = 1;
    for (; !o.eol(); ) {
      const l = zb(e, n, o.offset);
      o.nextGraphemeLength();
      const c = this._nextVisibleColumn(l, r, i), h = o.offset + 1;
      if (c >= t) {
        const d = t - r;
        return c - t < d ? h : a;
      }
      r = c, a = h;
    }
    return n + 1;
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static nextRenderTabStop(e, t) {
    return e + t - e % t;
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static nextIndentTabStop(e, t) {
    return e + t - e % t;
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static prevRenderTabStop(e, t) {
    return Math.max(0, e - 1 - (e - 1) % t);
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static prevIndentTabStop(e, t) {
    return Math.max(0, e - 1 - (e - 1) % t);
  }
}
class $m {
  /**
   * Get the visible column at the position. If we get to a non-whitespace character first
   * or past the end of string then return -1.
   *
   * **Note** `position` and the return value are 0-based.
   */
  static whitespaceVisibleColumn(e, t, i) {
    const n = e.length;
    let o = 0, r = -1, a = -1;
    for (let l = 0; l < n; l++) {
      if (l === t)
        return [r, a, o];
      switch (o % i === 0 && (r = l, a = o), e.charCodeAt(l)) {
        case 32:
          o += 1;
          break;
        case 9:
          o = pi.nextRenderTabStop(o, i);
          break;
        default:
          return [-1, -1, -1];
      }
    }
    return t === n ? [r, a, o] : [-1, -1, -1];
  }
  /**
   * Return the position that should result from a move left, right or to the
   * nearest tab, if atomic tabs are enabled. Left and right are used for the
   * arrow key movements, nearest is used for mouse selection. It returns
   * -1 if atomic tabs are not relevant and you should fall back to normal
   * behaviour.
   *
   * **Note**: `position` and the return value are 0-based.
   */
  static atomicPosition(e, t, i, n) {
    const o = e.length, [r, a, l] = $m.whitespaceVisibleColumn(e, t, i);
    if (l === -1)
      return -1;
    let c;
    switch (n) {
      case 0:
        c = !0;
        break;
      case 1:
        c = !1;
        break;
      case 2:
        if (l % i === 0)
          return t;
        c = l % i <= i / 2;
        break;
    }
    if (c) {
      if (r === -1)
        return -1;
      let u = a;
      for (let f = r; f < o; ++f) {
        if (u === a + i)
          return r;
        switch (e.charCodeAt(f)) {
          case 32:
            u += 1;
            break;
          case 9:
            u = pi.nextRenderTabStop(u, i);
            break;
          default:
            return -1;
        }
      }
      return u === a + i ? r : -1;
    }
    const h = pi.nextRenderTabStop(l, i);
    let d = l;
    for (let u = t; u < o; u++) {
      if (d === h)
        return u;
      switch (e.charCodeAt(u)) {
        case 32:
          d += 1;
          break;
        case 9:
          d = pi.nextRenderTabStop(d, i);
          break;
        default:
          return -1;
      }
    }
    return d === h ? o : -1;
  }
}
class ll {
  constructor(e = null) {
    this.hitTarget = e, this.type = 0;
  }
}
class C5 {
  get hitTarget() {
    return this.spanNode;
  }
  constructor(e, t, i) {
    this.position = e, this.spanNode = t, this.injectedText = i, this.type = 1;
  }
}
var Nc;
(function(s) {
  function e(t, i, n) {
    const o = t.getPositionFromDOMInfo(i, n);
    return o ? new C5(o, i, null) : new ll(i);
  }
  s.createFromDOMInfo = e;
})(Nc || (Nc = {}));
class B$ {
  constructor(e, t) {
    this.lastViewCursorsRenderData = e, this.lastTextareaPosition = t;
  }
}
class nn {
  static _deduceRage(e, t = null) {
    return !t && e ? new T(e.lineNumber, e.column, e.lineNumber, e.column) : t ?? null;
  }
  static createUnknown(e, t, i) {
    return { type: 0, element: e, mouseColumn: t, position: i, range: this._deduceRage(i) };
  }
  static createTextarea(e, t) {
    return { type: 1, element: e, mouseColumn: t, position: null, range: null };
  }
  static createMargin(e, t, i, n, o, r) {
    return { type: e, element: t, mouseColumn: i, position: n, range: o, detail: r };
  }
  static createViewZone(e, t, i, n, o) {
    return { type: e, element: t, mouseColumn: i, position: n, range: this._deduceRage(n), detail: o };
  }
  static createContentText(e, t, i, n, o) {
    return { type: 6, element: e, mouseColumn: t, position: i, range: this._deduceRage(i, n), detail: o };
  }
  static createContentEmpty(e, t, i, n) {
    return { type: 7, element: e, mouseColumn: t, position: i, range: this._deduceRage(i), detail: n };
  }
  static createContentWidget(e, t, i) {
    return { type: 9, element: e, mouseColumn: t, position: null, range: null, detail: i };
  }
  static createScrollbar(e, t, i) {
    return { type: 11, element: e, mouseColumn: t, position: i, range: this._deduceRage(i) };
  }
  static createOverlayWidget(e, t, i) {
    return { type: 12, element: e, mouseColumn: t, position: null, range: null, detail: i };
  }
  static createOutsideEditor(e, t, i, n) {
    return { type: 13, element: null, mouseColumn: e, position: t, range: this._deduceRage(t), outsidePosition: i, outsideDistance: n };
  }
  static _typeToString(e) {
    return e === 1 ? "TEXTAREA" : e === 2 ? "GUTTER_GLYPH_MARGIN" : e === 3 ? "GUTTER_LINE_NUMBERS" : e === 4 ? "GUTTER_LINE_DECORATIONS" : e === 5 ? "GUTTER_VIEW_ZONE" : e === 6 ? "CONTENT_TEXT" : e === 7 ? "CONTENT_EMPTY" : e === 8 ? "CONTENT_VIEW_ZONE" : e === 9 ? "CONTENT_WIDGET" : e === 10 ? "OVERVIEW_RULER" : e === 11 ? "SCROLLBAR" : e === 12 ? "OVERLAY_WIDGET" : "UNKNOWN";
  }
  static toString(e) {
    return this._typeToString(e.type) + ": " + e.position + " - " + e.range + " - " + JSON.stringify(e.detail);
  }
}
class un {
  static isTextArea(e) {
    return e.length === 2 && e[0] === 3 && e[1] === 7;
  }
  static isChildOfViewLines(e) {
    return e.length >= 4 && e[0] === 3 && e[3] === 8;
  }
  static isStrictChildOfViewLines(e) {
    return e.length > 4 && e[0] === 3 && e[3] === 8;
  }
  static isChildOfScrollableElement(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 6;
  }
  static isChildOfMinimap(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 9;
  }
  static isChildOfContentWidgets(e) {
    return e.length >= 4 && e[0] === 3 && e[3] === 1;
  }
  static isChildOfOverflowGuard(e) {
    return e.length >= 1 && e[0] === 3;
  }
  static isChildOfOverflowingContentWidgets(e) {
    return e.length >= 1 && e[0] === 2;
  }
  static isChildOfOverlayWidgets(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 4;
  }
  static isChildOfOverflowingOverlayWidgets(e) {
    return e.length >= 1 && e[0] === 5;
  }
}
class uf {
  constructor(e, t, i) {
    this.viewModel = e.viewModel;
    const n = e.configuration.options;
    this.layoutInfo = n.get(
      146
      /* EditorOption.layoutInfo */
    ), this.viewDomNode = t.viewDomNode, this.lineHeight = n.get(
      67
      /* EditorOption.lineHeight */
    ), this.stickyTabStops = n.get(
      117
      /* EditorOption.stickyTabStops */
    ), this.typicalHalfwidthCharacterWidth = n.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, this.lastRenderData = i, this._context = e, this._viewHelper = t;
  }
  getZoneAtCoord(e) {
    return uf.getZoneAtCoord(this._context, e);
  }
  static getZoneAtCoord(e, t) {
    const i = e.viewLayout.getWhitespaceAtVerticalOffset(t);
    if (i) {
      const n = i.verticalOffset + i.height / 2, o = e.viewModel.getLineCount();
      let r = null, a, l = null;
      return i.afterLineNumber !== o && (l = new F(i.afterLineNumber + 1, 1)), i.afterLineNumber > 0 && (r = new F(i.afterLineNumber, e.viewModel.getLineMaxColumn(i.afterLineNumber))), l === null ? a = r : r === null ? a = l : t < n ? a = r : a = l, {
        viewZoneId: i.id,
        afterLineNumber: i.afterLineNumber,
        positionBefore: r,
        positionAfter: l,
        position: a
      };
    }
    return null;
  }
  getFullLineRangeAtCoord(e) {
    if (this._context.viewLayout.isAfterLines(e)) {
      const n = this._context.viewModel.getLineCount(), o = this._context.viewModel.getLineMaxColumn(n);
      return {
        range: new T(n, o, n, o),
        isAfterLines: !0
      };
    }
    const t = this._context.viewLayout.getLineNumberAtVerticalOffset(e), i = this._context.viewModel.getLineMaxColumn(t);
    return {
      range: new T(t, 1, t, i),
      isAfterLines: !1
    };
  }
  getLineNumberAtVerticalOffset(e) {
    return this._context.viewLayout.getLineNumberAtVerticalOffset(e);
  }
  isAfterLines(e) {
    return this._context.viewLayout.isAfterLines(e);
  }
  isInTopPadding(e) {
    return this._context.viewLayout.isInTopPadding(e);
  }
  isInBottomPadding(e) {
    return this._context.viewLayout.isInBottomPadding(e);
  }
  getVerticalOffsetForLineNumber(e) {
    return this._context.viewLayout.getVerticalOffsetForLineNumber(e);
  }
  findAttribute(e, t) {
    return uf._findAttribute(e, t, this._viewHelper.viewDomNode);
  }
  static _findAttribute(e, t, i) {
    for (; e && e !== e.ownerDocument.body; ) {
      if (e.hasAttribute && e.hasAttribute(t))
        return e.getAttribute(t);
      if (e === i)
        return null;
      e = e.parentNode;
    }
    return null;
  }
  getLineWidth(e) {
    return this._viewHelper.getLineWidth(e);
  }
  visibleRangeForPosition(e, t) {
    return this._viewHelper.visibleRangeForPosition(e, t);
  }
  getPositionFromDOMInfo(e, t) {
    return this._viewHelper.getPositionFromDOMInfo(e, t);
  }
  getCurrentScrollTop() {
    return this._context.viewLayout.getCurrentScrollTop();
  }
  getCurrentScrollLeft() {
    return this._context.viewLayout.getCurrentScrollLeft();
  }
}
class W$ {
  constructor(e, t, i, n) {
    this.editorPos = t, this.pos = i, this.relativePos = n, this.mouseVerticalOffset = Math.max(0, e.getCurrentScrollTop() + this.relativePos.y), this.mouseContentHorizontalOffset = e.getCurrentScrollLeft() + this.relativePos.x - e.layoutInfo.contentLeft, this.isInMarginArea = this.relativePos.x < e.layoutInfo.contentLeft && this.relativePos.x >= e.layoutInfo.glyphMarginLeft, this.isInContentArea = !this.isInMarginArea, this.mouseColumn = Math.max(0, tn._getMouseColumn(this.mouseContentHorizontalOffset, e.typicalHalfwidthCharacterWidth));
  }
}
class H$ extends W$ {
  get target() {
    return this._useHitTestTarget ? this.hitTestResult.value.hitTarget : this._eventTarget;
  }
  get targetPath() {
    return this._targetPathCacheElement !== this.target && (this._targetPathCacheElement = this.target, this._targetPathCacheValue = Go.collect(this.target, this._ctx.viewDomNode)), this._targetPathCacheValue;
  }
  constructor(e, t, i, n, o) {
    super(e, t, i, n), this.hitTestResult = new Fr(() => tn.doHitTest(this._ctx, this)), this._targetPathCacheElement = null, this._targetPathCacheValue = new Uint8Array(0), this._ctx = e, this._eventTarget = o;
    const r = !!this._eventTarget;
    this._useHitTestTarget = !r;
  }
  toString() {
    return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), relativePos(${this.relativePos.x},${this.relativePos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}
	target: ${this.target ? this.target.outerHTML : null}`;
  }
  get wouldBenefitFromHitTestTargetSwitch() {
    return !this._useHitTestTarget && this.hitTestResult.value.hitTarget !== null && this.target !== this.hitTestResult.value.hitTarget;
  }
  switchToHitTestTarget() {
    this._useHitTestTarget = !0;
  }
  _getMouseColumn(e = null) {
    return e && e.column < this._ctx.viewModel.getLineMaxColumn(e.lineNumber) ? pi.visibleColumnFromColumn(this._ctx.viewModel.getLineContent(e.lineNumber), e.column, this._ctx.viewModel.model.getOptions().tabSize) + 1 : this.mouseColumn;
  }
  fulfillUnknown(e = null) {
    return nn.createUnknown(this.target, this._getMouseColumn(e), e);
  }
  fulfillTextarea() {
    return nn.createTextarea(this.target, this._getMouseColumn());
  }
  fulfillMargin(e, t, i, n) {
    return nn.createMargin(e, this.target, this._getMouseColumn(t), t, i, n);
  }
  fulfillViewZone(e, t, i) {
    return nn.createViewZone(e, this.target, this._getMouseColumn(t), t, i);
  }
  fulfillContentText(e, t, i) {
    return nn.createContentText(this.target, this._getMouseColumn(e), e, t, i);
  }
  fulfillContentEmpty(e, t) {
    return nn.createContentEmpty(this.target, this._getMouseColumn(e), e, t);
  }
  fulfillContentWidget(e) {
    return nn.createContentWidget(this.target, this._getMouseColumn(), e);
  }
  fulfillScrollbar(e) {
    return nn.createScrollbar(this.target, this._getMouseColumn(e), e);
  }
  fulfillOverlayWidget(e) {
    return nn.createOverlayWidget(this.target, this._getMouseColumn(), e);
  }
}
const DT = { isAfterLines: !0 };
function R0(s) {
  return {
    isAfterLines: !1,
    horizontalDistanceToText: s
  };
}
class tn {
  constructor(e, t) {
    this._context = e, this._viewHelper = t;
  }
  mouseTargetIsWidget(e) {
    const t = e.target, i = Go.collect(t, this._viewHelper.viewDomNode);
    return !!(un.isChildOfContentWidgets(i) || un.isChildOfOverflowingContentWidgets(i) || un.isChildOfOverlayWidgets(i) || un.isChildOfOverflowingOverlayWidgets(i));
  }
  createMouseTarget(e, t, i, n, o) {
    const r = new uf(this._context, this._viewHelper, e), a = new H$(r, t, i, n, o);
    try {
      const l = tn._createMouseTarget(r, a);
      if (l.type === 6 && r.stickyTabStops && l.position !== null) {
        const c = tn._snapToSoftTabBoundary(l.position, r.viewModel), h = T.fromPositions(c, c).plusRange(l.range);
        return a.fulfillContentText(c, h, l.detail);
      }
      return l;
    } catch {
      return a.fulfillUnknown();
    }
  }
  static _createMouseTarget(e, t) {
    if (t.target === null)
      return t.fulfillUnknown();
    const i = t;
    let n = null;
    return !un.isChildOfOverflowGuard(t.targetPath) && !un.isChildOfOverflowingContentWidgets(t.targetPath) && !un.isChildOfOverflowingOverlayWidgets(t.targetPath) && (n = n || t.fulfillUnknown()), n = n || tn._hitTestContentWidget(e, i), n = n || tn._hitTestOverlayWidget(e, i), n = n || tn._hitTestMinimap(e, i), n = n || tn._hitTestScrollbarSlider(e, i), n = n || tn._hitTestViewZone(e, i), n = n || tn._hitTestMargin(e, i), n = n || tn._hitTestViewCursor(e, i), n = n || tn._hitTestTextArea(e, i), n = n || tn._hitTestViewLines(e, i), n = n || tn._hitTestScrollbar(e, i), n || t.fulfillUnknown();
  }
  static _hitTestContentWidget(e, t) {
    if (un.isChildOfContentWidgets(t.targetPath) || un.isChildOfOverflowingContentWidgets(t.targetPath)) {
      const i = e.findAttribute(t.target, "widgetId");
      return i ? t.fulfillContentWidget(i) : t.fulfillUnknown();
    }
    return null;
  }
  static _hitTestOverlayWidget(e, t) {
    if (un.isChildOfOverlayWidgets(t.targetPath) || un.isChildOfOverflowingOverlayWidgets(t.targetPath)) {
      const i = e.findAttribute(t.target, "widgetId");
      return i ? t.fulfillOverlayWidget(i) : t.fulfillUnknown();
    }
    return null;
  }
  static _hitTestViewCursor(e, t) {
    if (t.target) {
      const i = e.lastRenderData.lastViewCursorsRenderData;
      for (const n of i)
        if (t.target === n.domNode)
          return t.fulfillContentText(n.position, null, { mightBeForeignElement: !1, injectedText: null });
    }
    if (t.isInContentArea) {
      const i = e.lastRenderData.lastViewCursorsRenderData, n = t.mouseContentHorizontalOffset, o = t.mouseVerticalOffset;
      for (const r of i) {
        if (n < r.contentLeft || n > r.contentLeft + r.width)
          continue;
        const a = e.getVerticalOffsetForLineNumber(r.position.lineNumber);
        if (a <= o && o <= a + r.height)
          return t.fulfillContentText(r.position, null, { mightBeForeignElement: !1, injectedText: null });
      }
    }
    return null;
  }
  static _hitTestViewZone(e, t) {
    const i = e.getZoneAtCoord(t.mouseVerticalOffset);
    if (i) {
      const n = t.isInContentArea ? 8 : 5;
      return t.fulfillViewZone(n, i.position, i);
    }
    return null;
  }
  static _hitTestTextArea(e, t) {
    return un.isTextArea(t.targetPath) ? e.lastRenderData.lastTextareaPosition ? t.fulfillContentText(e.lastRenderData.lastTextareaPosition, null, { mightBeForeignElement: !1, injectedText: null }) : t.fulfillTextarea() : null;
  }
  static _hitTestMargin(e, t) {
    if (t.isInMarginArea) {
      const i = e.getFullLineRangeAtCoord(t.mouseVerticalOffset), n = i.range.getStartPosition();
      let o = Math.abs(t.relativePos.x);
      const r = {
        isAfterLines: i.isAfterLines,
        glyphMarginLeft: e.layoutInfo.glyphMarginLeft,
        glyphMarginWidth: e.layoutInfo.glyphMarginWidth,
        lineNumbersWidth: e.layoutInfo.lineNumbersWidth,
        offsetX: o
      };
      if (o -= e.layoutInfo.glyphMarginLeft, o <= e.layoutInfo.glyphMarginWidth) {
        const a = e.viewModel.coordinatesConverter.convertViewPositionToModelPosition(i.range.getStartPosition()), l = e.viewModel.glyphLanes.getLanesAtLine(a.lineNumber);
        return r.glyphMarginLane = l[Math.floor(o / e.lineHeight)], t.fulfillMargin(2, n, i.range, r);
      }
      return o -= e.layoutInfo.glyphMarginWidth, o <= e.layoutInfo.lineNumbersWidth ? t.fulfillMargin(3, n, i.range, r) : (o -= e.layoutInfo.lineNumbersWidth, t.fulfillMargin(4, n, i.range, r));
    }
    return null;
  }
  static _hitTestViewLines(e, t) {
    if (!un.isChildOfViewLines(t.targetPath))
      return null;
    if (e.isInTopPadding(t.mouseVerticalOffset))
      return t.fulfillContentEmpty(new F(1, 1), DT);
    if (e.isAfterLines(t.mouseVerticalOffset) || e.isInBottomPadding(t.mouseVerticalOffset)) {
      const n = e.viewModel.getLineCount(), o = e.viewModel.getLineMaxColumn(n);
      return t.fulfillContentEmpty(new F(n, o), DT);
    }
    if (un.isStrictChildOfViewLines(t.targetPath)) {
      const n = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset);
      if (e.viewModel.getLineLength(n) === 0) {
        const r = e.getLineWidth(n), a = R0(t.mouseContentHorizontalOffset - r);
        return t.fulfillContentEmpty(new F(n, 1), a);
      }
      const o = e.getLineWidth(n);
      if (t.mouseContentHorizontalOffset >= o) {
        const r = R0(t.mouseContentHorizontalOffset - o), a = new F(n, e.viewModel.getLineMaxColumn(n));
        return t.fulfillContentEmpty(a, r);
      }
    }
    const i = t.hitTestResult.value;
    return i.type === 1 ? tn.createMouseTargetFromHitTestPosition(e, t, i.spanNode, i.position, i.injectedText) : t.wouldBenefitFromHitTestTargetSwitch ? (t.switchToHitTestTarget(), this._createMouseTarget(e, t)) : t.fulfillUnknown();
  }
  static _hitTestMinimap(e, t) {
    if (un.isChildOfMinimap(t.targetPath)) {
      const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.viewModel.getLineMaxColumn(i);
      return t.fulfillScrollbar(new F(i, n));
    }
    return null;
  }
  static _hitTestScrollbarSlider(e, t) {
    if (un.isChildOfScrollableElement(t.targetPath) && t.target && t.target.nodeType === 1) {
      const i = t.target.className;
      if (i && /\b(slider|scrollbar)\b/.test(i)) {
        const n = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), o = e.viewModel.getLineMaxColumn(n);
        return t.fulfillScrollbar(new F(n, o));
      }
    }
    return null;
  }
  static _hitTestScrollbar(e, t) {
    if (un.isChildOfScrollableElement(t.targetPath)) {
      const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.viewModel.getLineMaxColumn(i);
      return t.fulfillScrollbar(new F(i, n));
    }
    return null;
  }
  getMouseColumn(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    ), n = this._context.viewLayout.getCurrentScrollLeft() + e.x - i.contentLeft;
    return tn._getMouseColumn(n, t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth);
  }
  static _getMouseColumn(e, t) {
    return e < 0 ? 1 : Math.round(e / t) + 1;
  }
  static createMouseTargetFromHitTestPosition(e, t, i, n, o) {
    const r = n.lineNumber, a = n.column, l = e.getLineWidth(r);
    if (t.mouseContentHorizontalOffset > l) {
      const b = R0(t.mouseContentHorizontalOffset - l);
      return t.fulfillContentEmpty(n, b);
    }
    const c = e.visibleRangeForPosition(r, a);
    if (!c)
      return t.fulfillUnknown(n);
    const h = c.left;
    if (Math.abs(t.mouseContentHorizontalOffset - h) < 1)
      return t.fulfillContentText(n, null, { mightBeForeignElement: !!o, injectedText: o });
    const d = [];
    if (d.push({ offset: c.left, column: a }), a > 1) {
      const b = e.visibleRangeForPosition(r, a - 1);
      b && d.push({ offset: b.left, column: a - 1 });
    }
    const u = e.viewModel.getLineMaxColumn(r);
    if (a < u) {
      const b = e.visibleRangeForPosition(r, a + 1);
      b && d.push({ offset: b.left, column: a + 1 });
    }
    d.sort((b, C) => b.offset - C.offset);
    const f = t.pos.toClientCoordinates(fe(e.viewDomNode)), g = i.getBoundingClientRect(), p = g.left <= f.clientX && f.clientX <= g.right;
    let _ = null;
    for (let b = 1; b < d.length; b++) {
      const C = d[b - 1], w = d[b];
      if (C.offset <= t.mouseContentHorizontalOffset && t.mouseContentHorizontalOffset <= w.offset) {
        _ = new T(r, C.column, r, w.column);
        const v = Math.abs(C.offset - t.mouseContentHorizontalOffset), S = Math.abs(w.offset - t.mouseContentHorizontalOffset);
        n = v < S ? new F(r, C.column) : new F(r, w.column);
        break;
      }
    }
    return t.fulfillContentText(n, _, { mightBeForeignElement: !p || !!o, injectedText: o });
  }
  /**
   * Most probably WebKit browsers and Edge
   */
  static _doHitTestWithCaretRangeFromPoint(e, t) {
    const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.getVerticalOffsetForLineNumber(i), o = n + e.lineHeight;
    if (!(i === e.viewModel.getLineCount() && t.mouseVerticalOffset > o)) {
      const a = Math.floor((n + o) / 2);
      let l = t.pos.y + (a - t.mouseVerticalOffset);
      l <= t.editorPos.y && (l = t.editorPos.y + 1), l >= t.editorPos.y + t.editorPos.height && (l = t.editorPos.y + t.editorPos.height - 1);
      const c = new Cw(t.pos.x, l), h = this._actualDoHitTestWithCaretRangeFromPoint(e, c.toClientCoordinates(fe(e.viewDomNode)));
      if (h.type === 1)
        return h;
    }
    return this._actualDoHitTestWithCaretRangeFromPoint(e, t.pos.toClientCoordinates(fe(e.viewDomNode)));
  }
  static _actualDoHitTestWithCaretRangeFromPoint(e, t) {
    const i = of(e.viewDomNode);
    let n;
    if (i ? typeof i.caretRangeFromPoint > "u" ? n = V$(i, t.clientX, t.clientY) : n = i.caretRangeFromPoint(t.clientX, t.clientY) : n = e.viewDomNode.ownerDocument.caretRangeFromPoint(t.clientX, t.clientY), !n || !n.startContainer)
      return new ll();
    const o = n.startContainer;
    if (o.nodeType === o.TEXT_NODE) {
      const r = o.parentNode, a = r ? r.parentNode : null, l = a ? a.parentNode : null;
      return (l && l.nodeType === l.ELEMENT_NODE ? l.className : null) === ya.CLASS_NAME ? Nc.createFromDOMInfo(e, r, n.startOffset) : new ll(o.parentNode);
    } else if (o.nodeType === o.ELEMENT_NODE) {
      const r = o.parentNode, a = r ? r.parentNode : null;
      return (a && a.nodeType === a.ELEMENT_NODE ? a.className : null) === ya.CLASS_NAME ? Nc.createFromDOMInfo(e, o, o.textContent.length) : new ll(o);
    }
    return new ll();
  }
  /**
   * Most probably Gecko
   */
  static _doHitTestWithCaretPositionFromPoint(e, t) {
    const i = e.viewDomNode.ownerDocument.caretPositionFromPoint(t.clientX, t.clientY);
    if (i.offsetNode.nodeType === i.offsetNode.TEXT_NODE) {
      const n = i.offsetNode.parentNode, o = n ? n.parentNode : null, r = o ? o.parentNode : null;
      return (r && r.nodeType === r.ELEMENT_NODE ? r.className : null) === ya.CLASS_NAME ? Nc.createFromDOMInfo(e, i.offsetNode.parentNode, i.offset) : new ll(i.offsetNode.parentNode);
    }
    if (i.offsetNode.nodeType === i.offsetNode.ELEMENT_NODE) {
      const n = i.offsetNode.parentNode, o = n && n.nodeType === n.ELEMENT_NODE ? n.className : null, r = n ? n.parentNode : null, a = r && r.nodeType === r.ELEMENT_NODE ? r.className : null;
      if (o === ya.CLASS_NAME) {
        const l = i.offsetNode.childNodes[Math.min(i.offset, i.offsetNode.childNodes.length - 1)];
        if (l)
          return Nc.createFromDOMInfo(e, l, 0);
      } else if (a === ya.CLASS_NAME)
        return Nc.createFromDOMInfo(e, i.offsetNode, 0);
    }
    return new ll(i.offsetNode);
  }
  static _snapToSoftTabBoundary(e, t) {
    const i = t.getLineContent(e.lineNumber), { tabSize: n } = t.model.getOptions(), o = $m.atomicPosition(
      i,
      e.column - 1,
      n,
      2
      /* Direction.Nearest */
    );
    return o !== -1 ? new F(e.lineNumber, o + 1) : e;
  }
  static doHitTest(e, t) {
    let i = new ll();
    if (typeof e.viewDomNode.ownerDocument.caretRangeFromPoint == "function" ? i = this._doHitTestWithCaretRangeFromPoint(e, t) : e.viewDomNode.ownerDocument.caretPositionFromPoint && (i = this._doHitTestWithCaretPositionFromPoint(e, t.pos.toClientCoordinates(fe(e.viewDomNode)))), i.type === 1) {
      const n = e.viewModel.getInjectedTextAt(i.position), o = e.viewModel.normalizePosition(
        i.position,
        2
        /* PositionAffinity.None */
      );
      (n || !o.equals(i.position)) && (i = new C5(o, i.spanNode, n));
    }
    return i;
  }
}
function V$(s, e, t) {
  const i = document.createRange();
  let n = s.elementFromPoint(e, t);
  if (n !== null) {
    for (; n && n.firstChild && n.firstChild.nodeType !== n.firstChild.TEXT_NODE && n.lastChild && n.lastChild.firstChild; )
      n = n.lastChild;
    const o = n.getBoundingClientRect(), r = fe(n), a = r.getComputedStyle(n, null).getPropertyValue("font-style"), l = r.getComputedStyle(n, null).getPropertyValue("font-variant"), c = r.getComputedStyle(n, null).getPropertyValue("font-weight"), h = r.getComputedStyle(n, null).getPropertyValue("font-size"), d = r.getComputedStyle(n, null).getPropertyValue("line-height"), u = r.getComputedStyle(n, null).getPropertyValue("font-family"), f = `${a} ${l} ${c} ${h}/${d} ${u}`, g = n.innerText;
    let p = o.left, _ = 0, b;
    if (e > o.left + o.width)
      _ = g.length;
    else {
      const C = FS.getInstance();
      for (let w = 0; w < g.length + 1; w++) {
        if (b = C.getCharWidth(g.charAt(w), f) / 2, p += b, e < p) {
          _ = w;
          break;
        }
        p += b;
      }
    }
    i.setStart(n.firstChild, _), i.setEnd(n.firstChild, _);
  }
  return i;
}
const jc = class jc {
  static getInstance() {
    return jc._INSTANCE || (jc._INSTANCE = new jc()), jc._INSTANCE;
  }
  constructor() {
    this._cache = {}, this._canvas = document.createElement("canvas");
  }
  getCharWidth(e, t) {
    const i = e + t;
    if (this._cache[i])
      return this._cache[i];
    const n = this._canvas.getContext("2d");
    n.font = t;
    const r = n.measureText(e).width;
    return this._cache[i] = r, r;
  }
};
jc._INSTANCE = null;
let FS = jc;
class Ue extends T {
  constructor(e, t, i, n) {
    super(e, t, i, n), this.selectionStartLineNumber = e, this.selectionStartColumn = t, this.positionLineNumber = i, this.positionColumn = n;
  }
  /**
   * Transform to a human-readable representation.
   */
  toString() {
    return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
  }
  /**
   * Test if equals other selection.
   */
  equalsSelection(e) {
    return Ue.selectionsEqual(this, e);
  }
  /**
   * Test if the two selections are equal.
   */
  static selectionsEqual(e, t) {
    return e.selectionStartLineNumber === t.selectionStartLineNumber && e.selectionStartColumn === t.selectionStartColumn && e.positionLineNumber === t.positionLineNumber && e.positionColumn === t.positionColumn;
  }
  /**
   * Get directions (LTR or RTL).
   */
  getDirection() {
    return this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn ? 0 : 1;
  }
  /**
   * Create a new selection with a different `positionLineNumber` and `positionColumn`.
   */
  setEndPosition(e, t) {
    return this.getDirection() === 0 ? new Ue(this.startLineNumber, this.startColumn, e, t) : new Ue(e, t, this.startLineNumber, this.startColumn);
  }
  /**
   * Get the position at `positionLineNumber` and `positionColumn`.
   */
  getPosition() {
    return new F(this.positionLineNumber, this.positionColumn);
  }
  /**
   * Get the position at the start of the selection.
  */
  getSelectionStart() {
    return new F(this.selectionStartLineNumber, this.selectionStartColumn);
  }
  /**
   * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
   */
  setStartPosition(e, t) {
    return this.getDirection() === 0 ? new Ue(e, t, this.endLineNumber, this.endColumn) : new Ue(this.endLineNumber, this.endColumn, e, t);
  }
  // ----
  /**
   * Create a `Selection` from one or two positions
   */
  static fromPositions(e, t = e) {
    return new Ue(e.lineNumber, e.column, t.lineNumber, t.column);
  }
  /**
   * Creates a `Selection` from a range, given a direction.
   */
  static fromRange(e, t) {
    return t === 0 ? new Ue(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : new Ue(e.endLineNumber, e.endColumn, e.startLineNumber, e.startColumn);
  }
  /**
   * Create a `Selection` from an `ISelection`.
   */
  static liftSelection(e) {
    return new Ue(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
  }
  /**
   * `a` equals `b`.
   */
  static selectionsArrEqual(e, t) {
    if (e && !t || !e && t)
      return !1;
    if (!e && !t)
      return !0;
    if (e.length !== t.length)
      return !1;
    for (let i = 0, n = e.length; i < n; i++)
      if (!this.selectionsEqual(e[i], t[i]))
        return !1;
    return !0;
  }
  /**
   * Test if `obj` is an `ISelection`.
   */
  static isISelection(e) {
    return e && typeof e.selectionStartLineNumber == "number" && typeof e.selectionStartColumn == "number" && typeof e.positionLineNumber == "number" && typeof e.positionColumn == "number";
  }
  /**
   * Create with a direction.
   */
  static createWithDirection(e, t, i, n, o) {
    return o === 0 ? new Ue(e, t, i, n) : new Ue(i, n, e, t);
  }
}
class gI extends Fp {
  constructor(e, t, i) {
    super(), this._mouseLeaveMonitor = null, this._context = e, this.viewController = t, this.viewHelper = i, this.mouseTargetFactory = new tn(this._context, i), this._mouseDownOperation = this._register(new z$(this._context, this.viewController, this.viewHelper, this.mouseTargetFactory, (r, a) => this._createMouseTarget(r, a), (r) => this._getMouseColumn(r))), this.lastMouseLeaveTime = -1, this._height = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    ).height;
    const n = new h$(this.viewHelper.viewDomNode);
    this._register(n.onContextMenu(this.viewHelper.viewDomNode, (r) => this._onContextMenu(r, !0))), this._register(n.onMouseMove(this.viewHelper.viewDomNode, (r) => {
      this._onMouseMove(r), this._mouseLeaveMonitor || (this._mouseLeaveMonitor = z(this.viewHelper.viewDomNode.ownerDocument, "mousemove", (a) => {
        this.viewHelper.viewDomNode.contains(a.target) || this._onMouseLeave(new Gl(a, !1, this.viewHelper.viewDomNode));
      }));
    })), this._register(n.onMouseUp(this.viewHelper.viewDomNode, (r) => this._onMouseUp(r))), this._register(n.onMouseLeave(this.viewHelper.viewDomNode, (r) => this._onMouseLeave(r)));
    let o = 0;
    this._register(n.onPointerDown(this.viewHelper.viewDomNode, (r, a) => {
      o = a;
    })), this._register(z(this.viewHelper.viewDomNode, X.POINTER_UP, (r) => {
      this._mouseDownOperation.onPointerUp();
    })), this._register(n.onMouseDown(this.viewHelper.viewDomNode, (r) => this._onMouseDown(r, o))), this._setupMouseWheelZoomListener(), this._context.addEventHandler(this);
  }
  _setupMouseWheelZoomListener() {
    const e = i1.INSTANCE;
    let t = 0, i = pl.getZoomLevel(), n = !1, o = 0;
    const r = (l) => {
      if (this.viewController.emitMouseWheel(l), !this._context.configuration.options.get(
        76
        /* EditorOption.mouseWheelZoom */
      ))
        return;
      const c = new Hh(l);
      if (e.acceptStandardWheelEvent(c), e.isPhysicalMouseWheel()) {
        if (a(l)) {
          const h = pl.getZoomLevel(), d = c.deltaY > 0 ? 1 : -1;
          pl.setZoomLevel(h + d), c.preventDefault(), c.stopPropagation();
        }
      } else
        Date.now() - t > 50 && (i = pl.getZoomLevel(), n = a(l), o = 0), t = Date.now(), o += c.deltaY, n && (pl.setZoomLevel(i + o / 5), c.preventDefault(), c.stopPropagation());
    };
    this._register(z(this.viewHelper.viewDomNode, X.MOUSE_WHEEL, r, { capture: !0, passive: !1 }));
    function a(l) {
      return $e ? (l.metaKey || l.ctrlKey) && !l.shiftKey && !l.altKey : l.ctrlKey && !l.metaKey && !l.shiftKey && !l.altKey;
    }
  }
  dispose() {
    this._context.removeEventHandler(this), this._mouseLeaveMonitor && (this._mouseLeaveMonitor.dispose(), this._mouseLeaveMonitor = null), super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    if (e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    )) {
      const t = this._context.configuration.options.get(
        146
        /* EditorOption.layoutInfo */
      ).height;
      this._height !== t && (this._height = t, this._mouseDownOperation.onHeightChanged());
    }
    return !1;
  }
  onCursorStateChanged(e) {
    return this._mouseDownOperation.onCursorStateChanged(e), !1;
  }
  onFocusChanged(e) {
    return !1;
  }
  // --- end event handlers
  getTargetAtClientPoint(e, t) {
    const n = new h5(e, t).toPageCoordinates(fe(this.viewHelper.viewDomNode)), o = dI(this.viewHelper.viewDomNode);
    if (n.y < o.y || n.y > o.y + o.height || n.x < o.x || n.x > o.x + o.width)
      return null;
    const r = uI(this.viewHelper.viewDomNode, o, n);
    return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), o, n, r, null);
  }
  _createMouseTarget(e, t) {
    let i = e.target;
    if (!this.viewHelper.viewDomNode.contains(i)) {
      const n = of(this.viewHelper.viewDomNode);
      n && (i = n.elementsFromPoint(e.posx, e.posy).find((o) => this.viewHelper.viewDomNode.contains(o)));
    }
    return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), e.editorPos, e.pos, e.relativePos, t ? i : null);
  }
  _getMouseColumn(e) {
    return this.mouseTargetFactory.getMouseColumn(e.relativePos);
  }
  _onContextMenu(e, t) {
    this.viewController.emitContextMenu({
      event: e,
      target: this._createMouseTarget(e, t)
    });
  }
  _onMouseMove(e) {
    this.mouseTargetFactory.mouseTargetIsWidget(e) || e.preventDefault(), !(this._mouseDownOperation.isActive() || e.timestamp < this.lastMouseLeaveTime) && this.viewController.emitMouseMove({
      event: e,
      target: this._createMouseTarget(e, !0)
    });
  }
  _onMouseLeave(e) {
    this._mouseLeaveMonitor && (this._mouseLeaveMonitor.dispose(), this._mouseLeaveMonitor = null), this.lastMouseLeaveTime = (/* @__PURE__ */ new Date()).getTime(), this.viewController.emitMouseLeave({
      event: e,
      target: null
    });
  }
  _onMouseUp(e) {
    this.viewController.emitMouseUp({
      event: e,
      target: this._createMouseTarget(e, !0)
    });
  }
  _onMouseDown(e, t) {
    const i = this._createMouseTarget(e, !0), n = i.type === 6 || i.type === 7, o = i.type === 2 || i.type === 3 || i.type === 4, r = i.type === 3, a = this._context.configuration.options.get(
      110
      /* EditorOption.selectOnLineNumbers */
    ), l = i.type === 8 || i.type === 5, c = i.type === 9;
    let h = e.leftButton || e.middleButton;
    $e && e.leftButton && e.ctrlKey && (h = !1);
    const d = () => {
      e.preventDefault(), this.viewHelper.focusTextArea();
    };
    if (h && (n || r && a))
      d(), this._mouseDownOperation.start(i.type, e, t);
    else if (o)
      e.preventDefault();
    else if (l) {
      const u = i.detail;
      h && this.viewHelper.shouldSuppressMouseDownOnViewZone(u.viewZoneId) && (d(), this._mouseDownOperation.start(i.type, e, t), e.preventDefault());
    } else c && this.viewHelper.shouldSuppressMouseDownOnWidget(i.detail) && (d(), e.preventDefault());
    this.viewController.emitMouseDown({
      event: e,
      target: i
    });
  }
}
class z$ extends U {
  constructor(e, t, i, n, o, r) {
    super(), this._context = e, this._viewController = t, this._viewHelper = i, this._mouseTargetFactory = n, this._createMouseTarget = o, this._getMouseColumn = r, this._mouseMoveMonitor = this._register(new u$(this._viewHelper.viewDomNode)), this._topBottomDragScrolling = this._register(new U$(this._context, this._viewHelper, this._mouseTargetFactory, (a, l, c) => this._dispatchMouse(a, l, c))), this._mouseState = new BS(), this._currentSelection = new Ue(1, 1, 1, 1), this._isActive = !1, this._lastMouseEvent = null;
  }
  dispose() {
    super.dispose();
  }
  isActive() {
    return this._isActive;
  }
  _onMouseDownThenMove(e) {
    this._lastMouseEvent = e, this._mouseState.setModifiers(e);
    const t = this._findMousePosition(e, !1);
    t && (this._mouseState.isDragAndDrop ? this._viewController.emitMouseDrag({
      event: e,
      target: t
    }) : t.type === 13 && (t.outsidePosition === "above" || t.outsidePosition === "below") ? this._topBottomDragScrolling.start(t, e) : (this._topBottomDragScrolling.stop(), this._dispatchMouse(
      t,
      !0,
      1
      /* NavigationCommandRevealType.Minimal */
    )));
  }
  start(e, t, i) {
    this._lastMouseEvent = t, this._mouseState.setStartedOnLineNumbers(
      e === 3
      /* MouseTargetType.GUTTER_LINE_NUMBERS */
    ), this._mouseState.setStartButtons(t), this._mouseState.setModifiers(t);
    const n = this._findMousePosition(t, !0);
    if (!n || !n.position)
      return;
    this._mouseState.trySetCount(t.detail, n.position), t.detail = this._mouseState.count;
    const o = this._context.configuration.options;
    if (!o.get(
      92
      /* EditorOption.readOnly */
    ) && o.get(
      35
      /* EditorOption.dragAndDrop */
    ) && !o.get(
      22
      /* EditorOption.columnSelection */
    ) && !this._mouseState.altKey && t.detail < 2 && !this._isActive && !this._currentSelection.isEmpty() && n.type === 6 && n.position && this._currentSelection.containsPosition(n.position)) {
      this._mouseState.isDragAndDrop = !0, this._isActive = !0, this._mouseMoveMonitor.startMonitoring(this._viewHelper.viewLinesDomNode, i, t.buttons, (r) => this._onMouseDownThenMove(r), (r) => {
        const a = this._findMousePosition(this._lastMouseEvent, !1);
        ma(r) ? this._viewController.emitMouseDropCanceled() : this._viewController.emitMouseDrop({
          event: this._lastMouseEvent,
          target: a ? this._createMouseTarget(this._lastMouseEvent, !0) : null
          // Ignoring because position is unknown, e.g., Content View Zone
        }), this._stop();
      });
      return;
    }
    this._mouseState.isDragAndDrop = !1, this._dispatchMouse(
      n,
      t.shiftKey,
      1
      /* NavigationCommandRevealType.Minimal */
    ), this._isActive || (this._isActive = !0, this._mouseMoveMonitor.startMonitoring(this._viewHelper.viewLinesDomNode, i, t.buttons, (r) => this._onMouseDownThenMove(r), () => this._stop()));
  }
  _stop() {
    this._isActive = !1, this._topBottomDragScrolling.stop();
  }
  onHeightChanged() {
    this._mouseMoveMonitor.stopMonitoring();
  }
  onPointerUp() {
    this._mouseMoveMonitor.stopMonitoring();
  }
  onCursorStateChanged(e) {
    this._currentSelection = e.selections[0];
  }
  _getPositionOutsideEditor(e) {
    const t = e.editorPos, i = this._context.viewModel, n = this._context.viewLayout, o = this._getMouseColumn(e);
    if (e.posy < t.y) {
      const a = t.y - e.posy, l = Math.max(n.getCurrentScrollTop() - a, 0), c = uf.getZoneAtCoord(this._context, l);
      if (c) {
        const d = this._helpPositionJumpOverViewZone(c);
        if (d)
          return nn.createOutsideEditor(o, d, "above", a);
      }
      const h = n.getLineNumberAtVerticalOffset(l);
      return nn.createOutsideEditor(o, new F(h, 1), "above", a);
    }
    if (e.posy > t.y + t.height) {
      const a = e.posy - t.y - t.height, l = n.getCurrentScrollTop() + e.relativePos.y, c = uf.getZoneAtCoord(this._context, l);
      if (c) {
        const d = this._helpPositionJumpOverViewZone(c);
        if (d)
          return nn.createOutsideEditor(o, d, "below", a);
      }
      const h = n.getLineNumberAtVerticalOffset(l);
      return nn.createOutsideEditor(o, new F(h, i.getLineMaxColumn(h)), "below", a);
    }
    const r = n.getLineNumberAtVerticalOffset(n.getCurrentScrollTop() + e.relativePos.y);
    if (e.posx < t.x) {
      const a = t.x - e.posx;
      return nn.createOutsideEditor(o, new F(r, 1), "left", a);
    }
    if (e.posx > t.x + t.width) {
      const a = e.posx - t.x - t.width;
      return nn.createOutsideEditor(o, new F(r, i.getLineMaxColumn(r)), "right", a);
    }
    return null;
  }
  _findMousePosition(e, t) {
    const i = this._getPositionOutsideEditor(e);
    if (i)
      return i;
    const n = this._createMouseTarget(e, t);
    if (!n.position)
      return null;
    if (n.type === 8 || n.type === 5) {
      const r = this._helpPositionJumpOverViewZone(n.detail);
      if (r)
        return nn.createViewZone(n.type, n.element, n.mouseColumn, r, n.detail);
    }
    return n;
  }
  _helpPositionJumpOverViewZone(e) {
    const t = new F(this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn), i = e.positionBefore, n = e.positionAfter;
    return i && n ? i.isBefore(t) ? i : n : null;
  }
  _dispatchMouse(e, t, i) {
    e.position && this._viewController.dispatchMouse({
      position: e.position,
      mouseColumn: e.mouseColumn,
      startedOnLineNumbers: this._mouseState.startedOnLineNumbers,
      revealType: i,
      inSelectionMode: t,
      mouseDownCount: this._mouseState.count,
      altKey: this._mouseState.altKey,
      ctrlKey: this._mouseState.ctrlKey,
      metaKey: this._mouseState.metaKey,
      shiftKey: this._mouseState.shiftKey,
      leftButton: this._mouseState.leftButton,
      middleButton: this._mouseState.middleButton,
      onInjectedText: e.type === 6 && e.detail.injectedText !== null
    });
  }
}
class U$ extends U {
  constructor(e, t, i, n) {
    super(), this._context = e, this._viewHelper = t, this._mouseTargetFactory = i, this._dispatchMouse = n, this._operation = null;
  }
  dispose() {
    super.dispose(), this.stop();
  }
  start(e, t) {
    this._operation ? this._operation.setPosition(e, t) : this._operation = new $$(this._context, this._viewHelper, this._mouseTargetFactory, this._dispatchMouse, e, t);
  }
  stop() {
    this._operation && (this._operation.dispose(), this._operation = null);
  }
}
class $$ extends U {
  constructor(e, t, i, n, o, r) {
    super(), this._context = e, this._viewHelper = t, this._mouseTargetFactory = i, this._dispatchMouse = n, this._position = o, this._mouseEvent = r, this._lastTime = Date.now(), this._animationFrameDisposable = ns(fe(r.browserEvent), () => this._execute());
  }
  dispose() {
    this._animationFrameDisposable.dispose(), super.dispose();
  }
  setPosition(e, t) {
    this._position = e, this._mouseEvent = t;
  }
  /**
   * update internal state and return elapsed ms since last time
   */
  _tick() {
    const e = Date.now(), t = e - this._lastTime;
    return this._lastTime = e, t;
  }
  /**
   * get the number of lines per second to auto-scroll
   */
  _getScrollSpeed() {
    const e = this._context.configuration.options.get(
      67
      /* EditorOption.lineHeight */
    ), t = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    ).height / e, i = this._position.outsideDistance / e;
    return i <= 1.5 ? Math.max(30, t * (1 + i)) : i <= 3 ? Math.max(60, t * (2 + i)) : Math.max(200, t * (7 + i));
  }
  _execute() {
    const e = this._context.configuration.options.get(
      67
      /* EditorOption.lineHeight */
    ), t = this._getScrollSpeed(), i = this._tick(), n = t * (i / 1e3) * e, o = this._position.outsidePosition === "above" ? -n : n;
    this._context.viewModel.viewLayout.deltaScrollNow(0, o), this._viewHelper.renderNow();
    const r = this._context.viewLayout.getLinesViewportData(), a = this._position.outsidePosition === "above" ? r.startLineNumber : r.endLineNumber;
    let l;
    {
      const c = dI(this._viewHelper.viewDomNode), h = this._context.configuration.options.get(
        146
        /* EditorOption.layoutInfo */
      ).horizontalScrollbarHeight, d = new Cw(this._mouseEvent.pos.x, c.y + c.height - h - 0.1), u = uI(this._viewHelper.viewDomNode, c, d);
      l = this._mouseTargetFactory.createMouseTarget(this._viewHelper.getLastRenderData(), c, d, u, null);
    }
    (!l.position || l.position.lineNumber !== a) && (this._position.outsidePosition === "above" ? l = nn.createOutsideEditor(this._position.mouseColumn, new F(a, 1), "above", this._position.outsideDistance) : l = nn.createOutsideEditor(this._position.mouseColumn, new F(a, this._context.viewModel.getLineMaxColumn(a)), "below", this._position.outsideDistance)), this._dispatchMouse(
      l,
      !0,
      2
      /* NavigationCommandRevealType.None */
    ), this._animationFrameDisposable = ns(fe(l.element), () => this._execute());
  }
}
const QC = class QC {
  // ms
  get altKey() {
    return this._altKey;
  }
  get ctrlKey() {
    return this._ctrlKey;
  }
  get metaKey() {
    return this._metaKey;
  }
  get shiftKey() {
    return this._shiftKey;
  }
  get leftButton() {
    return this._leftButton;
  }
  get middleButton() {
    return this._middleButton;
  }
  get startedOnLineNumbers() {
    return this._startedOnLineNumbers;
  }
  constructor() {
    this._altKey = !1, this._ctrlKey = !1, this._metaKey = !1, this._shiftKey = !1, this._leftButton = !1, this._middleButton = !1, this._startedOnLineNumbers = !1, this._lastMouseDownPosition = null, this._lastMouseDownPositionEqualCount = 0, this._lastMouseDownCount = 0, this._lastSetMouseDownCountTime = 0, this.isDragAndDrop = !1;
  }
  get count() {
    return this._lastMouseDownCount;
  }
  setModifiers(e) {
    this._altKey = e.altKey, this._ctrlKey = e.ctrlKey, this._metaKey = e.metaKey, this._shiftKey = e.shiftKey;
  }
  setStartButtons(e) {
    this._leftButton = e.leftButton, this._middleButton = e.middleButton;
  }
  setStartedOnLineNumbers(e) {
    this._startedOnLineNumbers = e;
  }
  trySetCount(e, t) {
    const i = (/* @__PURE__ */ new Date()).getTime();
    i - this._lastSetMouseDownCountTime > QC.CLEAR_MOUSE_DOWN_COUNT_TIME && (e = 1), this._lastSetMouseDownCountTime = i, e > this._lastMouseDownCount + 1 && (e = this._lastMouseDownCount + 1), this._lastMouseDownPosition && this._lastMouseDownPosition.equals(t) ? this._lastMouseDownPositionEqualCount++ : this._lastMouseDownPositionEqualCount = 1, this._lastMouseDownPosition = t, this._lastMouseDownCount = Math.min(e, this._lastMouseDownPositionEqualCount);
  }
};
QC.CLEAR_MOUSE_DOWN_COUNT_TIME = 400;
let BS = QC;
const vu = class vu {
  constructor(e, t, i, n, o) {
    this.value = e, this.selectionStart = t, this.selectionEnd = i, this.selection = n, this.newlineCountBeforeSelection = o;
  }
  toString() {
    return `[ <${this.value}>, selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}]`;
  }
  static readFromTextArea(e, t) {
    const i = e.getValue(), n = e.getSelectionStart(), o = e.getSelectionEnd();
    let r;
    if (t) {
      const a = i.substring(0, n), l = t.value.substring(0, t.selectionStart);
      a === l && (r = t.newlineCountBeforeSelection);
    }
    return new vu(i, n, o, null, r);
  }
  collapseSelection() {
    return this.selectionStart === this.value.length ? this : new vu(this.value, this.value.length, this.value.length, null, void 0);
  }
  writeToTextArea(e, t, i) {
    t.setValue(e, this.value), i && t.setSelectionRange(e, this.selectionStart, this.selectionEnd);
  }
  deduceEditorPosition(e) {
    var n, o, r, a;
    if (e <= this.selectionStart) {
      const l = this.value.substring(e, this.selectionStart);
      return this._finishDeduceEditorPosition(((n = this.selection) == null ? void 0 : n.getStartPosition()) ?? null, l, -1);
    }
    if (e >= this.selectionEnd) {
      const l = this.value.substring(this.selectionEnd, e);
      return this._finishDeduceEditorPosition(((o = this.selection) == null ? void 0 : o.getEndPosition()) ?? null, l, 1);
    }
    const t = this.value.substring(this.selectionStart, e);
    if (t.indexOf("…") === -1)
      return this._finishDeduceEditorPosition(((r = this.selection) == null ? void 0 : r.getStartPosition()) ?? null, t, 1);
    const i = this.value.substring(e, this.selectionEnd);
    return this._finishDeduceEditorPosition(((a = this.selection) == null ? void 0 : a.getEndPosition()) ?? null, i, -1);
  }
  _finishDeduceEditorPosition(e, t, i) {
    let n = 0, o = -1;
    for (; (o = t.indexOf(`
`, o + 1)) !== -1; )
      n++;
    return [e, i * t.length, n];
  }
  static deduceInput(e, t, i) {
    if (!e)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    const n = Math.min(Vb(e.value, t.value), e.selectionStart, t.selectionStart), o = Math.min(Vy(e.value, t.value), e.value.length - e.selectionEnd, t.value.length - t.selectionEnd);
    e.value.substring(n, e.value.length - o);
    const r = t.value.substring(n, t.value.length - o), a = e.selectionStart - n, l = e.selectionEnd - n, c = t.selectionStart - n, h = t.selectionEnd - n;
    if (c === h) {
      const u = e.selectionStart - n;
      return {
        text: r,
        replacePrevCharCnt: u,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    }
    const d = l - a;
    return {
      text: r,
      replacePrevCharCnt: d,
      replaceNextCharCnt: 0,
      positionDelta: 0
    };
  }
  static deduceAndroidCompositionInput(e, t) {
    if (!e)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    if (e.value === t.value)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: t.selectionEnd - e.selectionEnd
      };
    const i = Math.min(Vb(e.value, t.value), e.selectionEnd), n = Math.min(Vy(e.value, t.value), e.value.length - e.selectionEnd), o = e.value.substring(i, e.value.length - n), r = t.value.substring(i, t.value.length - n);
    e.selectionStart - i;
    const a = e.selectionEnd - i;
    t.selectionStart - i;
    const l = t.selectionEnd - i;
    return {
      text: r,
      replacePrevCharCnt: a,
      replaceNextCharCnt: o.length - a,
      positionDelta: l - r.length
    };
  }
};
vu.EMPTY = new vu("", 0, 0, null, void 0);
let sn = vu;
class eu {
  static _getPageOfLine(e, t) {
    return Math.floor((e - 1) / t);
  }
  static _getRangeForPage(e, t) {
    const i = e * t, n = i + 1, o = i + t;
    return new T(n, 1, o + 1, 1);
  }
  static fromEditorSelection(e, t, i, n) {
    const r = eu._getPageOfLine(t.startLineNumber, i), a = eu._getRangeForPage(r, i), l = eu._getPageOfLine(t.endLineNumber, i), c = eu._getRangeForPage(l, i);
    let h = a.intersectRanges(new T(1, 1, t.startLineNumber, t.startColumn));
    if (n && e.getValueLengthInRange(
      h,
      1
      /* EndOfLinePreference.LF */
    ) > 500) {
      const b = e.modifyPosition(h.getEndPosition(), -500);
      h = T.fromPositions(b, h.getEndPosition());
    }
    const d = e.getValueInRange(
      h,
      1
      /* EndOfLinePreference.LF */
    ), u = e.getLineCount(), f = e.getLineMaxColumn(u);
    let g = c.intersectRanges(new T(t.endLineNumber, t.endColumn, u, f));
    if (n && e.getValueLengthInRange(
      g,
      1
      /* EndOfLinePreference.LF */
    ) > 500) {
      const b = e.modifyPosition(g.getStartPosition(), 500);
      g = T.fromPositions(g.getStartPosition(), b);
    }
    const p = e.getValueInRange(
      g,
      1
      /* EndOfLinePreference.LF */
    );
    let _;
    if (r === l || r + 1 === l)
      _ = e.getValueInRange(
        t,
        1
        /* EndOfLinePreference.LF */
      );
    else {
      const b = a.intersectRanges(t), C = c.intersectRanges(t);
      _ = e.getValueInRange(
        b,
        1
        /* EndOfLinePreference.LF */
      ) + "…" + e.getValueInRange(
        C,
        1
        /* EndOfLinePreference.LF */
      );
    }
    return n && _.length > 2 * 500 && (_ = _.substring(0, 500) + "…" + _.substring(_.length - 500, _.length)), new sn(d + _ + p, d.length, d.length + _.length, t, h.endLineNumber - h.startLineNumber);
  }
}
var K$ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, ET = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, d1;
(function(s) {
  s.Tap = "-monaco-textarea-synthetic-tap";
})(d1 || (d1 = {}));
const JC = class JC {
  constructor() {
    this._lastState = null;
  }
  set(e, t) {
    this._lastState = { lastCopiedValue: e, data: t };
  }
  get(e) {
    return this._lastState && this._lastState.lastCopiedValue === e ? this._lastState.data : (this._lastState = null, null);
  }
};
JC.INSTANCE = new JC();
let u1 = JC;
class j$ {
  constructor() {
    this._lastTypeTextLength = 0;
  }
  handleCompositionUpdate(e) {
    e = e || "";
    const t = {
      text: e,
      replacePrevCharCnt: this._lastTypeTextLength,
      replaceNextCharCnt: 0,
      positionDelta: 0
    };
    return this._lastTypeTextLength = e.length, t;
  }
}
let WS = class extends U {
  get textAreaState() {
    return this._textAreaState;
  }
  constructor(e, t, i, n, o, r) {
    super(), this._host = e, this._textArea = t, this._OS = i, this._browser = n, this._accessibilityService = o, this._logService = r, this._onFocus = this._register(new A()), this.onFocus = this._onFocus.event, this._onBlur = this._register(new A()), this.onBlur = this._onBlur.event, this._onKeyDown = this._register(new A()), this.onKeyDown = this._onKeyDown.event, this._onKeyUp = this._register(new A()), this.onKeyUp = this._onKeyUp.event, this._onCut = this._register(new A()), this.onCut = this._onCut.event, this._onPaste = this._register(new A()), this.onPaste = this._onPaste.event, this._onType = this._register(new A()), this.onType = this._onType.event, this._onCompositionStart = this._register(new A()), this.onCompositionStart = this._onCompositionStart.event, this._onCompositionUpdate = this._register(new A()), this.onCompositionUpdate = this._onCompositionUpdate.event, this._onCompositionEnd = this._register(new A()), this.onCompositionEnd = this._onCompositionEnd.event, this._onSelectionChangeRequest = this._register(new A()), this.onSelectionChangeRequest = this._onSelectionChangeRequest.event, this._asyncFocusGainWriteScreenReaderContent = this._register(new Hs()), this._asyncTriggerCut = this._register(new ai(() => this._onCut.fire(), 0)), this._textAreaState = sn.EMPTY, this._selectionChangeListener = null, this._accessibilityService.isScreenReaderOptimized() && this.writeNativeTextAreaContent("ctor"), this._register(ee.runAndSubscribe(this._accessibilityService.onDidChangeScreenReaderOptimized, () => {
      this._accessibilityService.isScreenReaderOptimized() && !this._asyncFocusGainWriteScreenReaderContent.value ? this._asyncFocusGainWriteScreenReaderContent.value = this._register(new ai(() => this.writeNativeTextAreaContent("asyncFocusGain"), 0)) : this._asyncFocusGainWriteScreenReaderContent.clear();
    })), this._hasFocus = !1, this._currentComposition = null;
    let a = null;
    this._register(this._textArea.onKeyDown((l) => {
      const c = new Dt(l);
      (c.keyCode === 114 || this._currentComposition && c.keyCode === 1) && c.stopPropagation(), c.equals(
        9
        /* KeyCode.Escape */
      ) && c.preventDefault(), a = c, this._onKeyDown.fire(c);
    })), this._register(this._textArea.onKeyUp((l) => {
      const c = new Dt(l);
      this._onKeyUp.fire(c);
    })), this._register(this._textArea.onCompositionStart((l) => {
      const c = new j$();
      if (this._currentComposition) {
        this._currentComposition = c;
        return;
      }
      if (this._currentComposition = c, this._OS === 2 && a && a.equals(
        114
        /* KeyCode.KEY_IN_COMPOSITION */
      ) && this._textAreaState.selectionStart === this._textAreaState.selectionEnd && this._textAreaState.selectionStart > 0 && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === l.data && (a.code === "ArrowRight" || a.code === "ArrowLeft")) {
        c.handleCompositionUpdate("x"), this._onCompositionStart.fire({ data: l.data });
        return;
      }
      if (this._browser.isAndroid) {
        this._onCompositionStart.fire({ data: l.data });
        return;
      }
      this._onCompositionStart.fire({ data: l.data });
    })), this._register(this._textArea.onCompositionUpdate((l) => {
      const c = this._currentComposition;
      if (!c)
        return;
      if (this._browser.isAndroid) {
        const d = sn.readFromTextArea(this._textArea, this._textAreaState), u = sn.deduceAndroidCompositionInput(this._textAreaState, d);
        this._textAreaState = d, this._onType.fire(u), this._onCompositionUpdate.fire(l);
        return;
      }
      const h = c.handleCompositionUpdate(l.data);
      this._textAreaState = sn.readFromTextArea(this._textArea, this._textAreaState), this._onType.fire(h), this._onCompositionUpdate.fire(l);
    })), this._register(this._textArea.onCompositionEnd((l) => {
      const c = this._currentComposition;
      if (!c)
        return;
      if (this._currentComposition = null, this._browser.isAndroid) {
        const d = sn.readFromTextArea(this._textArea, this._textAreaState), u = sn.deduceAndroidCompositionInput(this._textAreaState, d);
        this._textAreaState = d, this._onType.fire(u), this._onCompositionEnd.fire();
        return;
      }
      const h = c.handleCompositionUpdate(l.data);
      this._textAreaState = sn.readFromTextArea(this._textArea, this._textAreaState), this._onType.fire(h), this._onCompositionEnd.fire();
    })), this._register(this._textArea.onInput((l) => {
      if (this._textArea.setIgnoreSelectionChangeTime("received input event"), this._currentComposition)
        return;
      const c = sn.readFromTextArea(this._textArea, this._textAreaState), h = sn.deduceInput(
        this._textAreaState,
        c,
        /*couldBeEmojiInput*/
        this._OS === 2
        /* OperatingSystem.Macintosh */
      );
      h.replacePrevCharCnt === 0 && h.text.length === 1 && (Si(h.text.charCodeAt(0)) || h.text.charCodeAt(0) === 127) || (this._textAreaState = c, (h.text !== "" || h.replacePrevCharCnt !== 0 || h.replaceNextCharCnt !== 0 || h.positionDelta !== 0) && this._onType.fire(h));
    })), this._register(this._textArea.onCut((l) => {
      this._textArea.setIgnoreSelectionChangeTime("received cut event"), this._ensureClipboardGetsEditorSelection(l), this._asyncTriggerCut.schedule();
    })), this._register(this._textArea.onCopy((l) => {
      this._ensureClipboardGetsEditorSelection(l);
    })), this._register(this._textArea.onPaste((l) => {
      if (this._textArea.setIgnoreSelectionChangeTime("received paste event"), l.preventDefault(), !l.clipboardData)
        return;
      let [c, h] = IT.getTextData(l.clipboardData);
      c && (h = h || u1.INSTANCE.get(c), this._onPaste.fire({
        text: c,
        metadata: h
      }));
    })), this._register(this._textArea.onFocus(() => {
      const l = this._hasFocus;
      this._setHasFocus(!0), this._accessibilityService.isScreenReaderOptimized() && this._browser.isSafari && !l && this._hasFocus && (this._asyncFocusGainWriteScreenReaderContent.value || (this._asyncFocusGainWriteScreenReaderContent.value = new ai(() => this.writeNativeTextAreaContent("asyncFocusGain"), 0)), this._asyncFocusGainWriteScreenReaderContent.value.schedule());
    })), this._register(this._textArea.onBlur(() => {
      this._currentComposition && (this._currentComposition = null, this.writeNativeTextAreaContent("blurWithoutCompositionEnd"), this._onCompositionEnd.fire()), this._setHasFocus(!1);
    })), this._register(this._textArea.onSyntheticTap(() => {
      this._browser.isAndroid && this._currentComposition && (this._currentComposition = null, this.writeNativeTextAreaContent("tapWithoutCompositionEnd"), this._onCompositionEnd.fire());
    }));
  }
  _installSelectionChangeListener() {
    let e = 0;
    return z(this._textArea.ownerDocument, "selectionchange", (t) => {
      if (Ll.onSelectionChange(), !this._hasFocus || this._currentComposition || !this._browser.isChrome)
        return;
      const i = Date.now(), n = i - e;
      if (e = i, n < 5)
        return;
      const o = i - this._textArea.getIgnoreSelectionChangeTime();
      if (this._textArea.resetSelectionChangeTime(), o < 100 || !this._textAreaState.selection)
        return;
      const r = this._textArea.getValue();
      if (this._textAreaState.value !== r)
        return;
      const a = this._textArea.getSelectionStart(), l = this._textArea.getSelectionEnd();
      if (this._textAreaState.selectionStart === a && this._textAreaState.selectionEnd === l)
        return;
      const c = this._textAreaState.deduceEditorPosition(a), h = this._host.deduceModelPosition(c[0], c[1], c[2]), d = this._textAreaState.deduceEditorPosition(l), u = this._host.deduceModelPosition(d[0], d[1], d[2]), f = new Ue(h.lineNumber, h.column, u.lineNumber, u.column);
      this._onSelectionChangeRequest.fire(f);
    });
  }
  dispose() {
    super.dispose(), this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null);
  }
  focusTextArea() {
    this._setHasFocus(!0), this.refreshFocusState();
  }
  isFocused() {
    return this._hasFocus;
  }
  refreshFocusState() {
    this._setHasFocus(this._textArea.hasFocus());
  }
  _setHasFocus(e) {
    this._hasFocus !== e && (this._hasFocus = e, this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null), this._hasFocus && (this._selectionChangeListener = this._installSelectionChangeListener()), this._hasFocus && this.writeNativeTextAreaContent("focusgain"), this._hasFocus ? this._onFocus.fire() : this._onBlur.fire());
  }
  _setAndWriteTextAreaState(e, t) {
    this._hasFocus || (t = t.collapseSelection()), t.writeToTextArea(e, this._textArea, this._hasFocus), this._textAreaState = t;
  }
  writeNativeTextAreaContent(e) {
    !this._accessibilityService.isScreenReaderOptimized() && e === "render" || this._currentComposition || (this._logService.trace(`writeTextAreaState(reason: ${e})`), this._setAndWriteTextAreaState(e, this._host.getScreenReaderContent()));
  }
  _ensureClipboardGetsEditorSelection(e) {
    const t = this._host.getDataToCopy(), i = {
      version: 1,
      isFromEmptySelection: t.isFromEmptySelection,
      multicursorText: t.multicursorText,
      mode: t.mode
    };
    u1.INSTANCE.set(
      // When writing "LINE\r\n" to the clipboard and then pasting,
      // Firefox pastes "LINE\n", so let's work around this quirk
      this._browser.isFirefox ? t.text.replace(/\r\n/g, `
`) : t.text,
      i
    ), e.preventDefault(), e.clipboardData && IT.setTextData(e.clipboardData, t.text, t.html, i);
  }
};
WS = K$([
  ET(4, Ks),
  ET(5, Co)
], WS);
const IT = {
  getTextData(s) {
    const e = s.getData(wa.text);
    let t = null;
    const i = s.getData("vscode-editor-data");
    if (typeof i == "string")
      try {
        t = JSON.parse(i), t.version !== 1 && (t = null);
      } catch {
      }
    return e.length === 0 && t === null && s.files.length > 0 ? [Array.prototype.slice.call(s.files, 0).map((o) => o.name).join(`
`), null] : [e, t];
  },
  setTextData(s, e, t, i) {
    s.setData(wa.text, e), typeof t == "string" && s.setData("text/html", t), s.setData("vscode-editor-data", JSON.stringify(i));
  }
};
class q$ extends U {
  get ownerDocument() {
    return this._actual.ownerDocument;
  }
  constructor(e) {
    super(), this._actual = e, this.onKeyDown = this._register(new He(this._actual, "keydown")).event, this.onKeyUp = this._register(new He(this._actual, "keyup")).event, this.onCompositionStart = this._register(new He(this._actual, "compositionstart")).event, this.onCompositionUpdate = this._register(new He(this._actual, "compositionupdate")).event, this.onCompositionEnd = this._register(new He(this._actual, "compositionend")).event, this.onBeforeInput = this._register(new He(this._actual, "beforeinput")).event, this.onInput = this._register(new He(this._actual, "input")).event, this.onCut = this._register(new He(this._actual, "cut")).event, this.onCopy = this._register(new He(this._actual, "copy")).event, this.onPaste = this._register(new He(this._actual, "paste")).event, this.onFocus = this._register(new He(this._actual, "focus")).event, this.onBlur = this._register(new He(this._actual, "blur")).event, this._onSyntheticTap = this._register(new A()), this.onSyntheticTap = this._onSyntheticTap.event, this._ignoreSelectionChangeTime = 0, this._register(this.onKeyDown(() => Ll.onKeyDown())), this._register(this.onBeforeInput(() => Ll.onBeforeInput())), this._register(this.onInput(() => Ll.onInput())), this._register(this.onKeyUp(() => Ll.onKeyUp())), this._register(z(this._actual, d1.Tap, () => this._onSyntheticTap.fire()));
  }
  hasFocus() {
    const e = of(this._actual);
    return e ? e.activeElement === this._actual : this._actual.isConnected ? Gi() === this._actual : !1;
  }
  setIgnoreSelectionChangeTime(e) {
    this._ignoreSelectionChangeTime = Date.now();
  }
  getIgnoreSelectionChangeTime() {
    return this._ignoreSelectionChangeTime;
  }
  resetSelectionChangeTime() {
    this._ignoreSelectionChangeTime = 0;
  }
  getValue() {
    return this._actual.value;
  }
  setValue(e, t) {
    const i = this._actual;
    i.value !== t && (this.setIgnoreSelectionChangeTime("setValue"), i.value = t);
  }
  getSelectionStart() {
    return this._actual.selectionDirection === "backward" ? this._actual.selectionEnd : this._actual.selectionStart;
  }
  getSelectionEnd() {
    return this._actual.selectionDirection === "backward" ? this._actual.selectionStart : this._actual.selectionEnd;
  }
  setSelectionRange(e, t, i) {
    const n = this._actual;
    let o = null;
    const r = of(n);
    r ? o = r.activeElement : o = Gi();
    const a = fe(o), l = o === n, c = n.selectionStart, h = n.selectionEnd;
    if (l && c === t && h === i) {
      uo && a.parent !== a && n.focus();
      return;
    }
    if (l) {
      this.setIgnoreSelectionChangeTime("setSelectionRange"), n.setSelectionRange(t, i), uo && a.parent !== a && n.focus();
      return;
    }
    try {
      const d = eB(n);
      this.setIgnoreSelectionChangeTime("setSelectionRange"), n.focus(), n.setSelectionRange(t, i), tB(n, d);
    } catch {
    }
  }
}
class G$ extends gI {
  constructor(e, t, i) {
    super(e, t, i), this._register(ln.addTarget(this.viewHelper.linesContentDomNode)), this._register(z(this.viewHelper.linesContentDomNode, vt.Tap, (o) => this.onTap(o))), this._register(z(this.viewHelper.linesContentDomNode, vt.Change, (o) => this.onChange(o))), this._register(z(this.viewHelper.linesContentDomNode, vt.Contextmenu, (o) => this._onContextMenu(new Gl(o, !1, this.viewHelper.viewDomNode), !1))), this._lastPointerType = "mouse", this._register(z(this.viewHelper.linesContentDomNode, "pointerdown", (o) => {
      const r = o.pointerType;
      if (r === "mouse") {
        this._lastPointerType = "mouse";
        return;
      } else r === "touch" ? this._lastPointerType = "touch" : this._lastPointerType = "pen";
    }));
    const n = new d$(this.viewHelper.viewDomNode);
    this._register(n.onPointerMove(this.viewHelper.viewDomNode, (o) => this._onMouseMove(o))), this._register(n.onPointerUp(this.viewHelper.viewDomNode, (o) => this._onMouseUp(o))), this._register(n.onPointerLeave(this.viewHelper.viewDomNode, (o) => this._onMouseLeave(o))), this._register(n.onPointerDown(this.viewHelper.viewDomNode, (o, r) => this._onMouseDown(o, r)));
  }
  onTap(e) {
    !e.initialTarget || !this.viewHelper.linesContentDomNode.contains(e.initialTarget) || (e.preventDefault(), this.viewHelper.focusTextArea(), this._dispatchGesture(
      e,
      /*inSelectionMode*/
      !1
    ));
  }
  onChange(e) {
    this._lastPointerType === "touch" && this._context.viewModel.viewLayout.deltaScrollNow(-e.translationX, -e.translationY), this._lastPointerType === "pen" && this._dispatchGesture(
      e,
      /*inSelectionMode*/
      !0
    );
  }
  _dispatchGesture(e, t) {
    const i = this._createMouseTarget(new Gl(e, !1, this.viewHelper.viewDomNode), !1);
    i.position && this.viewController.dispatchMouse({
      position: i.position,
      mouseColumn: i.position.column,
      startedOnLineNumbers: !1,
      revealType: 1,
      mouseDownCount: e.tapCount,
      inSelectionMode: t,
      altKey: !1,
      ctrlKey: !1,
      metaKey: !1,
      shiftKey: !1,
      leftButton: !1,
      middleButton: !1,
      onInjectedText: i.type === 6 && i.detail.injectedText !== null
    });
  }
  _onMouseDown(e, t) {
    e.browserEvent.pointerType !== "touch" && super._onMouseDown(e, t);
  }
}
class Z$ extends gI {
  constructor(e, t, i) {
    super(e, t, i), this._register(ln.addTarget(this.viewHelper.linesContentDomNode)), this._register(z(this.viewHelper.linesContentDomNode, vt.Tap, (n) => this.onTap(n))), this._register(z(this.viewHelper.linesContentDomNode, vt.Change, (n) => this.onChange(n))), this._register(z(this.viewHelper.linesContentDomNode, vt.Contextmenu, (n) => this._onContextMenu(new Gl(n, !1, this.viewHelper.viewDomNode), !1)));
  }
  onTap(e) {
    e.preventDefault(), this.viewHelper.focusTextArea();
    const t = this._createMouseTarget(new Gl(e, !1, this.viewHelper.viewDomNode), !1);
    if (t.position) {
      const i = document.createEvent("CustomEvent");
      i.initEvent(d1.Tap, !1, !0), this.viewHelper.dispatchTextAreaEvent(i), this.viewController.moveTo(
        t.position,
        1
        /* NavigationCommandRevealType.Minimal */
      );
    }
  }
  onChange(e) {
    this._context.viewModel.viewLayout.deltaScrollNow(-e.translationX, -e.translationY);
  }
}
class Y$ extends U {
  constructor(e, t, i) {
    super(), (Kl || S9 && KP) && vE.pointerEvents ? this.handler = this._register(new G$(e, t, i)) : pt.TouchEvent ? this.handler = this._register(new Z$(e, t, i)) : this.handler = this._register(new gI(e, t, i));
  }
  getTargetAtClientPoint(e, t) {
    return this.handler.getTargetAtClientPoint(e, t);
  }
}
class cd extends Fp {
}
const wn = Be("themeService");
function Ts(s) {
  return { id: s };
}
function HS(s) {
  switch (s) {
    case Ps.DARK:
      return "vs-dark";
    case Ps.HIGH_CONTRAST_DARK:
      return "hc-black";
    case Ps.HIGH_CONTRAST_LIGHT:
      return "hc-light";
    default:
      return "vs";
  }
}
const v5 = {
  ThemingContribution: "base.contributions.theming"
};
class X$ {
  constructor() {
    this.themingParticipants = [], this.themingParticipants = [], this.onThemingParticipantAddedEmitter = new A();
  }
  onColorThemeChange(e) {
    return this.themingParticipants.push(e), this.onThemingParticipantAddedEmitter.fire(e), _e(() => {
      const t = this.themingParticipants.indexOf(e);
      this.themingParticipants.splice(t, 1);
    });
  }
  getThemingParticipants() {
    return this.themingParticipants;
  }
}
const w5 = new X$();
Mi.add(v5.ThemingContribution, w5);
function tr(s) {
  return w5.onColorThemeChange(s);
}
class Q$ extends U {
  constructor(e) {
    super(), this.themeService = e, this.theme = e.getColorTheme(), this._register(this.themeService.onDidColorThemeChange((t) => this.onThemeChange(t)));
  }
  onThemeChange(e) {
    this.theme = e, this.updateStyles();
  }
  updateStyles() {
  }
}
const y5 = E("editor.lineHighlightBackground", null, m("lineHighlight", "Background color for the highlight of line at the cursor position.")), NT = E("editor.lineHighlightBorder", { dark: "#282828", light: "#eeeeee", hcDark: "#f38518", hcLight: Ke }, m("lineHighlightBorderBox", "Background color for the border around the line at the cursor position."));
E("editor.rangeHighlightBackground", { dark: "#ffffff0b", light: "#fdff0033", hcDark: null, hcLight: null }, m("rangeHighlight", "Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations."), !0);
E("editor.rangeHighlightBorder", { dark: null, light: null, hcDark: Ut, hcLight: Ut }, m("rangeHighlightBorder", "Background color of the border around highlighted ranges."));
E("editor.symbolHighlightBackground", { dark: Da, light: Da, hcDark: null, hcLight: null }, m("symbolHighlight", "Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations."), !0);
E("editor.symbolHighlightBorder", { dark: null, light: null, hcDark: Ut, hcLight: Ut }, m("symbolHighlightBorder", "Background color of the border around highlighted symbols."));
const Lw = E("editorCursor.foreground", { dark: "#AEAFAD", light: j.black, hcDark: j.white, hcLight: "#0F4A85" }, m("caret", "Color of the editor cursor.")), mI = E("editorCursor.background", null, m("editorCursorBackground", "The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.")), S5 = E("editorMultiCursor.primary.foreground", Lw, m("editorMultiCursorPrimaryForeground", "Color of the primary editor cursor when multiple cursors are present.")), J$ = E("editorMultiCursor.primary.background", mI, m("editorMultiCursorPrimaryBackground", "The background color of the primary editor cursor when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.")), L5 = E("editorMultiCursor.secondary.foreground", Lw, m("editorMultiCursorSecondaryForeground", "Color of secondary editor cursors when multiple cursors are present.")), eK = E("editorMultiCursor.secondary.background", mI, m("editorMultiCursorSecondaryBackground", "The background color of secondary editor cursors when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.")), pI = E("editorWhitespace.foreground", { dark: "#e3e4e229", light: "#33333333", hcDark: "#e3e4e229", hcLight: "#CCCCCC" }, m("editorWhitespaces", "Color of whitespace characters in the editor.")), tK = E("editorLineNumber.foreground", { dark: "#858585", light: "#237893", hcDark: j.white, hcLight: "#292929" }, m("editorLineNumbers", "Color of editor line numbers.")), iK = E("editorIndentGuide.background", pI, m("editorIndentGuides", "Color of the editor indentation guides."), !1, m("deprecatedEditorIndentGuides", "'editorIndentGuide.background' is deprecated. Use 'editorIndentGuide.background1' instead.")), nK = E("editorIndentGuide.activeBackground", pI, m("editorActiveIndentGuide", "Color of the active editor indentation guides."), !1, m("deprecatedEditorActiveIndentGuide", "'editorIndentGuide.activeBackground' is deprecated. Use 'editorIndentGuide.activeBackground1' instead.")), Bp = E("editorIndentGuide.background1", iK, m("editorIndentGuides1", "Color of the editor indentation guides (1).")), sK = E("editorIndentGuide.background2", "#00000000", m("editorIndentGuides2", "Color of the editor indentation guides (2).")), oK = E("editorIndentGuide.background3", "#00000000", m("editorIndentGuides3", "Color of the editor indentation guides (3).")), rK = E("editorIndentGuide.background4", "#00000000", m("editorIndentGuides4", "Color of the editor indentation guides (4).")), aK = E("editorIndentGuide.background5", "#00000000", m("editorIndentGuides5", "Color of the editor indentation guides (5).")), lK = E("editorIndentGuide.background6", "#00000000", m("editorIndentGuides6", "Color of the editor indentation guides (6).")), Wp = E("editorIndentGuide.activeBackground1", nK, m("editorActiveIndentGuide1", "Color of the active editor indentation guides (1).")), cK = E("editorIndentGuide.activeBackground2", "#00000000", m("editorActiveIndentGuide2", "Color of the active editor indentation guides (2).")), hK = E("editorIndentGuide.activeBackground3", "#00000000", m("editorActiveIndentGuide3", "Color of the active editor indentation guides (3).")), dK = E("editorIndentGuide.activeBackground4", "#00000000", m("editorActiveIndentGuide4", "Color of the active editor indentation guides (4).")), uK = E("editorIndentGuide.activeBackground5", "#00000000", m("editorActiveIndentGuide5", "Color of the active editor indentation guides (5).")), fK = E("editorIndentGuide.activeBackground6", "#00000000", m("editorActiveIndentGuide6", "Color of the active editor indentation guides (6).")), gK = E("editorActiveLineNumber.foreground", { dark: "#c6c6c6", light: "#0B216F", hcDark: Ut, hcLight: Ut }, m("editorActiveLineNumber", "Color of editor active line number"), !1, m("deprecatedEditorActiveLineNumber", "Id is deprecated. Use 'editorLineNumber.activeForeground' instead."));
E("editorLineNumber.activeForeground", gK, m("editorActiveLineNumber", "Color of editor active line number"));
const mK = E("editorLineNumber.dimmedForeground", null, m("editorDimmedLineNumber", "Color of the final editor line when editor.renderFinalNewline is set to dimmed."));
E("editorRuler.foreground", { dark: "#5A5A5A", light: j.lightgrey, hcDark: j.white, hcLight: "#292929" }, m("editorRuler", "Color of the editor rulers."));
E("editorCodeLens.foreground", { dark: "#999999", light: "#919191", hcDark: "#999999", hcLight: "#292929" }, m("editorCodeLensForeground", "Foreground color of editor CodeLens"));
E("editorBracketMatch.background", { dark: "#0064001a", light: "#0064001a", hcDark: "#0064001a", hcLight: "#0000" }, m("editorBracketMatchBackground", "Background color behind matching brackets"));
E("editorBracketMatch.border", { dark: "#888", light: "#B9B9B9", hcDark: Ke, hcLight: Ke }, m("editorBracketMatchBorder", "Color for matching brackets boxes"));
const pK = E("editorOverviewRuler.border", { dark: "#7f7f7f4d", light: "#7f7f7f4d", hcDark: "#7f7f7f4d", hcLight: "#666666" }, m("editorOverviewRulerBorder", "Color of the overview ruler border.")), _K = E("editorOverviewRuler.background", null, m("editorOverviewRulerBackground", "Background color of the editor overview ruler."));
E("editorGutter.background", po, m("editorGutter", "Background color of the editor gutter. The gutter contains the glyph margins and the line numbers."));
E("editorUnnecessaryCode.border", { dark: null, light: null, hcDark: j.fromHex("#fff").transparent(0.8), hcLight: Ke }, m("unnecessaryCodeBorder", "Border color of unnecessary (unused) source code in the editor."));
const bK = E("editorUnnecessaryCode.opacity", { dark: j.fromHex("#000a"), light: j.fromHex("#0007"), hcDark: null, hcLight: null }, m("unnecessaryCodeOpacity", `Opacity of unnecessary (unused) source code in the editor. For example, "#000000c0" will render the code with 75% opacity. For high contrast themes, use the  'editorUnnecessaryCode.border' theme color to underline unnecessary code instead of fading it out.`));
E("editorGhostText.border", { dark: null, light: null, hcDark: j.fromHex("#fff").transparent(0.8), hcLight: j.fromHex("#292929").transparent(0.8) }, m("editorGhostTextBorder", "Border color of ghost text in the editor."));
E("editorGhostText.foreground", { dark: j.fromHex("#ffffff56"), light: j.fromHex("#0007"), hcDark: null, hcLight: null }, m("editorGhostTextForeground", "Foreground color of the ghost text in the editor."));
E("editorGhostText.background", null, m("editorGhostTextBackground", "Background color of the ghost text in the editor."));
const CK = new j(new ze(0, 122, 204, 0.6));
E("editorOverviewRuler.rangeHighlightForeground", CK, m("overviewRulerRangeHighlight", "Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations."), !0);
const vK = E("editorOverviewRuler.errorForeground", { dark: new j(new ze(255, 18, 18, 0.7)), light: new j(new ze(255, 18, 18, 0.7)), hcDark: new j(new ze(255, 50, 50, 1)), hcLight: "#B5200D" }, m("overviewRuleError", "Overview ruler marker color for errors.")), wK = E("editorOverviewRuler.warningForeground", { dark: Ka, light: Ka, hcDark: Vm, hcLight: Vm }, m("overviewRuleWarning", "Overview ruler marker color for warnings.")), yK = E("editorOverviewRuler.infoForeground", { dark: Wr, light: Wr, hcDark: zm, hcLight: zm }, m("overviewRuleInfo", "Overview ruler marker color for infos.")), k5 = E("editorBracketHighlight.foreground1", { dark: "#FFD700", light: "#0431FAFF", hcDark: "#FFD700", hcLight: "#0431FAFF" }, m("editorBracketHighlightForeground1", "Foreground color of brackets (1). Requires enabling bracket pair colorization.")), x5 = E("editorBracketHighlight.foreground2", { dark: "#DA70D6", light: "#319331FF", hcDark: "#DA70D6", hcLight: "#319331FF" }, m("editorBracketHighlightForeground2", "Foreground color of brackets (2). Requires enabling bracket pair colorization.")), D5 = E("editorBracketHighlight.foreground3", { dark: "#179FFF", light: "#7B3814FF", hcDark: "#87CEFA", hcLight: "#7B3814FF" }, m("editorBracketHighlightForeground3", "Foreground color of brackets (3). Requires enabling bracket pair colorization.")), E5 = E("editorBracketHighlight.foreground4", "#00000000", m("editorBracketHighlightForeground4", "Foreground color of brackets (4). Requires enabling bracket pair colorization.")), I5 = E("editorBracketHighlight.foreground5", "#00000000", m("editorBracketHighlightForeground5", "Foreground color of brackets (5). Requires enabling bracket pair colorization.")), N5 = E("editorBracketHighlight.foreground6", "#00000000", m("editorBracketHighlightForeground6", "Foreground color of brackets (6). Requires enabling bracket pair colorization.")), SK = E("editorBracketHighlight.unexpectedBracket.foreground", { dark: new j(new ze(255, 18, 18, 0.8)), light: new j(new ze(255, 18, 18, 0.8)), hcDark: "new Color(new RGBA(255, 50, 50, 1))", hcLight: "#B5200D" }, m("editorBracketHighlightUnexpectedBracketForeground", "Foreground color of unexpected brackets.")), LK = E("editorBracketPairGuide.background1", "#00000000", m("editorBracketPairGuide.background1", "Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.")), kK = E("editorBracketPairGuide.background2", "#00000000", m("editorBracketPairGuide.background2", "Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.")), xK = E("editorBracketPairGuide.background3", "#00000000", m("editorBracketPairGuide.background3", "Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.")), DK = E("editorBracketPairGuide.background4", "#00000000", m("editorBracketPairGuide.background4", "Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.")), EK = E("editorBracketPairGuide.background5", "#00000000", m("editorBracketPairGuide.background5", "Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.")), IK = E("editorBracketPairGuide.background6", "#00000000", m("editorBracketPairGuide.background6", "Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.")), NK = E("editorBracketPairGuide.activeBackground1", "#00000000", m("editorBracketPairGuide.activeBackground1", "Background color of active bracket pair guides (1). Requires enabling bracket pair guides.")), TK = E("editorBracketPairGuide.activeBackground2", "#00000000", m("editorBracketPairGuide.activeBackground2", "Background color of active bracket pair guides (2). Requires enabling bracket pair guides.")), MK = E("editorBracketPairGuide.activeBackground3", "#00000000", m("editorBracketPairGuide.activeBackground3", "Background color of active bracket pair guides (3). Requires enabling bracket pair guides.")), RK = E("editorBracketPairGuide.activeBackground4", "#00000000", m("editorBracketPairGuide.activeBackground4", "Background color of active bracket pair guides (4). Requires enabling bracket pair guides.")), AK = E("editorBracketPairGuide.activeBackground5", "#00000000", m("editorBracketPairGuide.activeBackground5", "Background color of active bracket pair guides (5). Requires enabling bracket pair guides.")), PK = E("editorBracketPairGuide.activeBackground6", "#00000000", m("editorBracketPairGuide.activeBackground6", "Background color of active bracket pair guides (6). Requires enabling bracket pair guides."));
E("editorUnicodeHighlight.border", Ka, m("editorUnicodeHighlight.border", "Border color used to highlight unicode characters."));
E("editorUnicodeHighlight.background", Nz, m("editorUnicodeHighlight.background", "Background color used to highlight unicode characters."));
tr((s, e) => {
  const t = s.getColor(po), i = s.getColor(y5), n = i && !i.isTransparent() ? i : t;
  n && e.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${n}; }`);
});
const ev = class ev extends cd {
  constructor(e) {
    super(), this._context = e, this._readConfig(), this._lastCursorModelPosition = new F(1, 1), this._renderResult = null, this._activeLineNumber = 1, this._context.addEventHandler(this);
  }
  _readConfig() {
    const e = this._context.configuration.options;
    this._lineHeight = e.get(
      67
      /* EditorOption.lineHeight */
    );
    const t = e.get(
      68
      /* EditorOption.lineNumbers */
    );
    this._renderLineNumbers = t.renderType, this._renderCustomLineNumbers = t.renderFn, this._renderFinalNewline = e.get(
      96
      /* EditorOption.renderFinalNewline */
    );
    const i = e.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._lineNumbersLeft = i.lineNumbersLeft, this._lineNumbersWidth = i.lineNumbersWidth;
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    return this._readConfig(), !0;
  }
  onCursorStateChanged(e) {
    const t = e.selections[0].getPosition();
    this._lastCursorModelPosition = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(t);
    let i = !1;
    return this._activeLineNumber !== t.lineNumber && (this._activeLineNumber = t.lineNumber, i = !0), (this._renderLineNumbers === 2 || this._renderLineNumbers === 3) && (i = !0), i;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onDecorationsChanged(e) {
    return e.affectsLineNumber;
  }
  // --- end event handlers
  _getLineRenderLineNumber(e) {
    const t = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new F(e, 1));
    if (t.column !== 1)
      return "";
    const i = t.lineNumber;
    if (this._renderCustomLineNumbers)
      return this._renderCustomLineNumbers(i);
    if (this._renderLineNumbers === 2) {
      const n = Math.abs(this._lastCursorModelPosition.lineNumber - i);
      return n === 0 ? '<span class="relative-current-line-number">' + i + "</span>" : String(n);
    }
    if (this._renderLineNumbers === 3) {
      if (this._lastCursorModelPosition.lineNumber === i || i % 10 === 0)
        return String(i);
      const n = this._context.viewModel.getLineCount();
      return i === n ? String(i) : "";
    }
    return String(i);
  }
  prepareRender(e) {
    if (this._renderLineNumbers === 0) {
      this._renderResult = null;
      return;
    }
    const t = Rn ? this._lineHeight % 2 === 0 ? " lh-even" : " lh-odd" : "", i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber, o = this._context.viewModel.getDecorationsInViewport(e.visibleRange).filter((c) => !!c.options.lineNumberClassName);
    o.sort((c, h) => T.compareRangesUsingEnds(c.range, h.range));
    let r = 0;
    const a = this._context.viewModel.getLineCount(), l = [];
    for (let c = i; c <= n; c++) {
      const h = c - i;
      let d = this._getLineRenderLineNumber(c), u = "";
      for (; r < o.length && o[r].range.endLineNumber < c; )
        r++;
      for (let f = r; f < o.length; f++) {
        const { range: g, options: p } = o[f];
        g.startLineNumber <= c && (u += " " + p.lineNumberClassName);
      }
      if (!d && !u) {
        l[h] = "";
        continue;
      }
      c === a && this._context.viewModel.getLineLength(c) === 0 && (this._renderFinalNewline === "off" && (d = ""), this._renderFinalNewline === "dimmed" && (u += " dimmed-line-number")), c === this._activeLineNumber && (u += " active-line-number"), l[h] = `<div class="${ev.CLASS_NAME}${t}${u}" style="left:${this._lineNumbersLeft}px;width:${this._lineNumbersWidth}px;">${d}</div>`;
    }
    this._renderResult = l;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
};
ev.CLASS_NAME = "line-numbers";
let f1 = ev;
tr((s, e) => {
  const t = s.getColor(tK), i = s.getColor(mK);
  i ? e.addRule(`.monaco-editor .line-numbers.dimmed-line-number { color: ${i}; }`) : t && e.addRule(`.monaco-editor .line-numbers.dimmed-line-number { color: ${t.transparent(0.4)}; }`);
});
const wu = class wu extends rs {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._canUseLayerHinting = !t.get(
      32
      /* EditorOption.disableLayerHinting */
    ), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._domNode = st(document.createElement("div")), this._domNode.setClassName(wu.OUTER_CLASS_NAME), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._glyphMarginBackgroundDomNode = st(document.createElement("div")), this._glyphMarginBackgroundDomNode.setClassName(wu.CLASS_NAME), this._domNode.appendChild(this._glyphMarginBackgroundDomNode);
  }
  dispose() {
    super.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._canUseLayerHinting = !t.get(
      32
      /* EditorOption.disableLayerHinting */
    ), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollTopChanged;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setLayerHinting(this._canUseLayerHinting), this._domNode.setContain("strict");
    const t = e.scrollTop - e.bigNumbersDelta;
    this._domNode.setTop(-t);
    const i = Math.min(e.scrollHeight, 1e6);
    this._domNode.setHeight(i), this._domNode.setWidth(this._contentLeft), this._glyphMarginBackgroundDomNode.setLeft(this._glyphMarginLeft), this._glyphMarginBackgroundDomNode.setWidth(this._glyphMarginWidth), this._glyphMarginBackgroundDomNode.setHeight(i);
  }
};
wu.CLASS_NAME = "glyph-margin", wu.OUTER_CLASS_NAME = "margin";
let g1 = wu;
function m1(s) {
  return s < 0 ? 0 : s > 255 ? 255 : s | 0;
}
function Ed(s) {
  return s < 0 ? 0 : s > 4294967295 ? 4294967295 : s | 0;
}
class Hp {
  constructor(e) {
    const t = m1(e);
    this._defaultValue = t, this._asciiMap = Hp._createAsciiMap(t), this._map = /* @__PURE__ */ new Map();
  }
  static _createAsciiMap(e) {
    const t = new Uint8Array(256);
    return t.fill(e), t;
  }
  set(e, t) {
    const i = m1(t);
    e >= 0 && e < 256 ? this._asciiMap[e] = i : this._map.set(e, i);
  }
  get(e) {
    return e >= 0 && e < 256 ? this._asciiMap[e] : this._map.get(e) || this._defaultValue;
  }
  clear() {
    this._asciiMap.fill(this._defaultValue), this._map.clear();
  }
}
class OK extends Hp {
  constructor(e, t) {
    super(
      0
      /* WordCharacterClass.Regular */
    ), this._segmenter = null, this._cachedLine = null, this._cachedSegments = [], this.intlSegmenterLocales = t, this.intlSegmenterLocales.length > 0 ? this._segmenter = new Intl.Segmenter(this.intlSegmenterLocales, { granularity: "word" }) : this._segmenter = null;
    for (let i = 0, n = e.length; i < n; i++)
      this.set(
        e.charCodeAt(i),
        2
        /* WordCharacterClass.WordSeparator */
      );
    this.set(
      32,
      1
      /* WordCharacterClass.Whitespace */
    ), this.set(
      9,
      1
      /* WordCharacterClass.Whitespace */
    );
  }
  findPrevIntlWordBeforeOrAtOffset(e, t) {
    let i = null;
    for (const n of this._getIntlSegmenterWordsOnLine(e)) {
      if (n.index > t)
        break;
      i = n;
    }
    return i;
  }
  findNextIntlWordAtOrAfterOffset(e, t) {
    for (const i of this._getIntlSegmenterWordsOnLine(e))
      if (!(i.index < t))
        return i;
    return null;
  }
  _getIntlSegmenterWordsOnLine(e) {
    return this._segmenter ? this._cachedLine === e ? this._cachedSegments : (this._cachedLine = e, this._cachedSegments = this._filterWordSegments(this._segmenter.segment(e)), this._cachedSegments) : [];
  }
  _filterWordSegments(e) {
    const t = [];
    for (const i of e)
      this._isWordLike(i) && t.push(i);
    return t;
  }
  _isWordLike(e) {
    return !!e.isWordLike;
  }
}
const TT = new Mf(10);
function ff(s, e) {
  const t = `${s}/${e.join(",")}`;
  let i = TT.get(t);
  return i || (i = new OK(s, e), TT.set(t, i)), i;
}
const Pu = "monaco-mouse-cursor-text";
let T5 = class {
  constructor() {
    this._tokenizationSupports = /* @__PURE__ */ new Map(), this._factories = /* @__PURE__ */ new Map(), this._onDidChange = new A(), this.onDidChange = this._onDidChange.event, this._colorMap = null;
  }
  handleChange(e) {
    this._onDidChange.fire({
      changedLanguages: e,
      changedColorMap: !1
    });
  }
  register(e, t) {
    return this._tokenizationSupports.set(e, t), this.handleChange([e]), _e(() => {
      this._tokenizationSupports.get(e) === t && (this._tokenizationSupports.delete(e), this.handleChange([e]));
    });
  }
  get(e) {
    return this._tokenizationSupports.get(e) || null;
  }
  registerFactory(e, t) {
    var n;
    (n = this._factories.get(e)) == null || n.dispose();
    const i = new FK(this, e, t);
    return this._factories.set(e, i), _e(() => {
      const o = this._factories.get(e);
      !o || o !== i || (this._factories.delete(e), o.dispose());
    });
  }
  async getOrCreate(e) {
    const t = this.get(e);
    if (t)
      return t;
    const i = this._factories.get(e);
    return !i || i.isResolved ? null : (await i.resolve(), this.get(e));
  }
  isResolved(e) {
    if (this.get(e))
      return !0;
    const i = this._factories.get(e);
    return !!(!i || i.isResolved);
  }
  setColorMap(e) {
    this._colorMap = e, this._onDidChange.fire({
      changedLanguages: Array.from(this._tokenizationSupports.keys()),
      changedColorMap: !0
    });
  }
  getColorMap() {
    return this._colorMap;
  }
  getDefaultBackground() {
    return this._colorMap && this._colorMap.length > 2 ? this._colorMap[
      2
      /* ColorId.DefaultBackground */
    ] : null;
  }
};
class FK extends U {
  get isResolved() {
    return this._isResolved;
  }
  constructor(e, t, i) {
    super(), this._registry = e, this._languageId = t, this._factory = i, this._isDisposed = !1, this._resolvePromise = null, this._isResolved = !1;
  }
  dispose() {
    this._isDisposed = !0, super.dispose();
  }
  async resolve() {
    return this._resolvePromise || (this._resolvePromise = this._create()), this._resolvePromise;
  }
  async _create() {
    const e = await this._factory.tokenizationSupport;
    this._isResolved = !0, e && !this._isDisposed && this._register(this._registry.register(this._languageId, e));
  }
}
let Km = class {
  constructor(e, t, i) {
    this.offset = e, this.type = t, this.language = i, this._tokenBrand = void 0;
  }
  toString() {
    return "(" + this.offset + ", " + this.type + ")";
  }
};
class _I {
  constructor(e, t) {
    this.tokens = e, this.endState = t, this._tokenizationResultBrand = void 0;
  }
}
class kw {
  constructor(e, t) {
    this.tokens = e, this.endState = t, this._encodedTokenizationResultBrand = void 0;
  }
}
var jn;
(function(s) {
  s[s.Increase = 0] = "Increase", s[s.Decrease = 1] = "Decrease";
})(jn || (jn = {}));
var MT;
(function(s) {
  const e = /* @__PURE__ */ new Map();
  e.set(0, ie.symbolMethod), e.set(1, ie.symbolFunction), e.set(2, ie.symbolConstructor), e.set(3, ie.symbolField), e.set(4, ie.symbolVariable), e.set(5, ie.symbolClass), e.set(6, ie.symbolStruct), e.set(7, ie.symbolInterface), e.set(8, ie.symbolModule), e.set(9, ie.symbolProperty), e.set(10, ie.symbolEvent), e.set(11, ie.symbolOperator), e.set(12, ie.symbolUnit), e.set(13, ie.symbolValue), e.set(15, ie.symbolEnum), e.set(14, ie.symbolConstant), e.set(15, ie.symbolEnum), e.set(16, ie.symbolEnumMember), e.set(17, ie.symbolKeyword), e.set(27, ie.symbolSnippet), e.set(18, ie.symbolText), e.set(19, ie.symbolColor), e.set(20, ie.symbolFile), e.set(21, ie.symbolReference), e.set(22, ie.symbolCustomColor), e.set(23, ie.symbolFolder), e.set(24, ie.symbolTypeParameter), e.set(25, ie.account), e.set(26, ie.issues);
  function t(o) {
    let r = e.get(o);
    return r || (console.info("No codicon found for CompletionItemKind " + o), r = ie.symbolProperty), r;
  }
  s.toIcon = t;
  const i = /* @__PURE__ */ new Map();
  i.set(
    "method",
    0
    /* CompletionItemKind.Method */
  ), i.set(
    "function",
    1
    /* CompletionItemKind.Function */
  ), i.set(
    "constructor",
    2
    /* CompletionItemKind.Constructor */
  ), i.set(
    "field",
    3
    /* CompletionItemKind.Field */
  ), i.set(
    "variable",
    4
    /* CompletionItemKind.Variable */
  ), i.set(
    "class",
    5
    /* CompletionItemKind.Class */
  ), i.set(
    "struct",
    6
    /* CompletionItemKind.Struct */
  ), i.set(
    "interface",
    7
    /* CompletionItemKind.Interface */
  ), i.set(
    "module",
    8
    /* CompletionItemKind.Module */
  ), i.set(
    "property",
    9
    /* CompletionItemKind.Property */
  ), i.set(
    "event",
    10
    /* CompletionItemKind.Event */
  ), i.set(
    "operator",
    11
    /* CompletionItemKind.Operator */
  ), i.set(
    "unit",
    12
    /* CompletionItemKind.Unit */
  ), i.set(
    "value",
    13
    /* CompletionItemKind.Value */
  ), i.set(
    "constant",
    14
    /* CompletionItemKind.Constant */
  ), i.set(
    "enum",
    15
    /* CompletionItemKind.Enum */
  ), i.set(
    "enum-member",
    16
    /* CompletionItemKind.EnumMember */
  ), i.set(
    "enumMember",
    16
    /* CompletionItemKind.EnumMember */
  ), i.set(
    "keyword",
    17
    /* CompletionItemKind.Keyword */
  ), i.set(
    "snippet",
    27
    /* CompletionItemKind.Snippet */
  ), i.set(
    "text",
    18
    /* CompletionItemKind.Text */
  ), i.set(
    "color",
    19
    /* CompletionItemKind.Color */
  ), i.set(
    "file",
    20
    /* CompletionItemKind.File */
  ), i.set(
    "reference",
    21
    /* CompletionItemKind.Reference */
  ), i.set(
    "customcolor",
    22
    /* CompletionItemKind.Customcolor */
  ), i.set(
    "folder",
    23
    /* CompletionItemKind.Folder */
  ), i.set(
    "type-parameter",
    24
    /* CompletionItemKind.TypeParameter */
  ), i.set(
    "typeParameter",
    24
    /* CompletionItemKind.TypeParameter */
  ), i.set(
    "account",
    25
    /* CompletionItemKind.User */
  ), i.set(
    "issue",
    26
    /* CompletionItemKind.Issue */
  );
  function n(o, r) {
    let a = i.get(o);
    return typeof a > "u" && !r && (a = 9), a;
  }
  s.fromString = n;
})(MT || (MT = {}));
var VS;
(function(s) {
  s[s.Automatic = 0] = "Automatic", s[s.Explicit = 1] = "Explicit";
})(VS || (VS = {}));
class BK {
  constructor(e, t, i, n) {
    this.range = e, this.text = t, this.completionKind = i, this.isSnippetText = n;
  }
  equals(e) {
    return T.lift(this.range).equalsRange(e.range) && this.text === e.text && this.completionKind === e.completionKind && this.isSnippetText === e.isSnippetText;
  }
}
var RT;
(function(s) {
  s[s.Automatic = 0] = "Automatic", s[s.PasteAs = 1] = "PasteAs";
})(RT || (RT = {}));
var AT;
(function(s) {
  s[s.Invoke = 1] = "Invoke", s[s.TriggerCharacter = 2] = "TriggerCharacter", s[s.ContentChange = 3] = "ContentChange";
})(AT || (AT = {}));
var PT;
(function(s) {
  s[s.Text = 0] = "Text", s[s.Read = 1] = "Read", s[s.Write = 2] = "Write";
})(PT || (PT = {}));
function WK(s) {
  return s && we.isUri(s.uri) && T.isIRange(s.range) && (T.isIRange(s.originSelectionRange) || T.isIRange(s.targetSelectionRange));
}
m("Array", "array"), m("Boolean", "boolean"), m("Class", "class"), m("Constant", "constant"), m("Constructor", "constructor"), m("Enum", "enumeration"), m("EnumMember", "enumeration member"), m("Event", "event"), m("Field", "field"), m("File", "file"), m("Function", "function"), m("Interface", "interface"), m("Key", "key"), m("Method", "method"), m("Module", "module"), m("Namespace", "namespace"), m("Null", "null"), m("Number", "number"), m("Object", "object"), m("Operator", "operator"), m("Package", "package"), m("Property", "property"), m("String", "string"), m("Struct", "struct"), m("TypeParameter", "type parameter"), m("Variable", "variable");
var zS;
(function(s) {
  const e = /* @__PURE__ */ new Map();
  e.set(0, ie.symbolFile), e.set(1, ie.symbolModule), e.set(2, ie.symbolNamespace), e.set(3, ie.symbolPackage), e.set(4, ie.symbolClass), e.set(5, ie.symbolMethod), e.set(6, ie.symbolProperty), e.set(7, ie.symbolField), e.set(8, ie.symbolConstructor), e.set(9, ie.symbolEnum), e.set(10, ie.symbolInterface), e.set(11, ie.symbolFunction), e.set(12, ie.symbolVariable), e.set(13, ie.symbolConstant), e.set(14, ie.symbolString), e.set(15, ie.symbolNumber), e.set(16, ie.symbolBoolean), e.set(17, ie.symbolArray), e.set(18, ie.symbolObject), e.set(19, ie.symbolKey), e.set(20, ie.symbolNull), e.set(21, ie.symbolEnumMember), e.set(22, ie.symbolStruct), e.set(23, ie.symbolEvent), e.set(24, ie.symbolOperator), e.set(25, ie.symbolTypeParameter);
  function t(i) {
    let n = e.get(i);
    return n || (console.info("No codicon found for SymbolKind " + i), n = ie.symbolProperty), n;
  }
  s.toIcon = t;
})(zS || (zS = {}));
const Xs = class Xs {
  /**
   * Returns a {@link FoldingRangeKind} for the given value.
   *
   * @param value of the kind.
   */
  static fromValue(e) {
    switch (e) {
      case "comment":
        return Xs.Comment;
      case "imports":
        return Xs.Imports;
      case "region":
        return Xs.Region;
    }
    return new Xs(e);
  }
  /**
   * Creates a new {@link FoldingRangeKind}.
   *
   * @param value of the kind.
   */
  constructor(e) {
    this.value = e;
  }
};
Xs.Comment = new Xs("comment"), Xs.Imports = new Xs("imports"), Xs.Region = new Xs("region");
let US = Xs;
var OT;
(function(s) {
  s[s.AIGenerated = 1] = "AIGenerated";
})(OT || (OT = {}));
var FT;
(function(s) {
  s[s.Invoke = 0] = "Invoke", s[s.Automatic = 1] = "Automatic";
})(FT || (FT = {}));
var $S;
(function(s) {
  function e(t) {
    return !t || typeof t != "object" ? !1 : typeof t.id == "string" && typeof t.title == "string";
  }
  s.is = e;
})($S || ($S = {}));
var p1;
(function(s) {
  s[s.Type = 1] = "Type", s[s.Parameter = 2] = "Parameter";
})(p1 || (p1 = {}));
class HK {
  constructor(e) {
    this.createSupport = e, this._tokenizationSupport = null;
  }
  dispose() {
    this._tokenizationSupport && this._tokenizationSupport.then((e) => {
      e && e.dispose();
    });
  }
  get tokenizationSupport() {
    return this._tokenizationSupport || (this._tokenizationSupport = this.createSupport()), this._tokenizationSupport;
  }
}
const ii = new T5(), KS = new T5();
var BT;
(function(s) {
  s[s.Invoke = 0] = "Invoke", s[s.Automatic = 1] = "Automatic";
})(BT || (BT = {}));
class VK {
  constructor() {
    this._onDidChange = new A(), this.onDidChange = this._onDidChange.event, this._enabled = !0;
  }
  get enabled() {
    return this._enabled;
  }
  /**
   * Enable IME
   */
  enable() {
    this._enabled = !0, this._onDidChange.fire();
  }
  /**
   * Disable IME
   */
  disable() {
    this._enabled = !1, this._onDidChange.fire();
  }
}
const Fg = new VK(), Lt = Be("keybindingService");
var zK = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, WT = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class UK {
  constructor(e, t, i, n, o) {
    this._context = e, this.modelLineNumber = t, this.distanceToModelLineStart = i, this.widthOfHiddenLineTextBefore = n, this.distanceToModelLineEnd = o, this._visibleTextAreaBrand = void 0, this.startPosition = null, this.endPosition = null, this.visibleTextareaStart = null, this.visibleTextareaEnd = null, this._previousPresentation = null;
  }
  prepareRender(e) {
    const t = new F(this.modelLineNumber, this.distanceToModelLineStart + 1), i = new F(this.modelLineNumber, this._context.viewModel.model.getLineMaxColumn(this.modelLineNumber) - this.distanceToModelLineEnd);
    this.startPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(t), this.endPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(i), this.startPosition.lineNumber === this.endPosition.lineNumber ? (this.visibleTextareaStart = e.visibleRangeForPosition(this.startPosition), this.visibleTextareaEnd = e.visibleRangeForPosition(this.endPosition)) : (this.visibleTextareaStart = null, this.visibleTextareaEnd = null);
  }
  definePresentation(e) {
    return this._previousPresentation || (e ? this._previousPresentation = e : this._previousPresentation = {
      foreground: 1,
      italic: !1,
      bold: !1,
      underline: !1,
      strikethrough: !1
    }), this._previousPresentation;
  }
}
const A0 = uo;
let jS = class extends rs {
  constructor(e, t, i, n, o) {
    super(e), this._keybindingService = n, this._instantiationService = o, this._primaryCursorPosition = new F(1, 1), this._primaryCursorVisibleRange = null, this._viewController = t, this._visibleRangeProvider = i, this._scrollLeft = 0, this._scrollTop = 0;
    const r = this._context.configuration.options, a = r.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._setAccessibilityOptions(r), this._contentLeft = a.contentLeft, this._contentWidth = a.contentWidth, this._contentHeight = a.height, this._fontInfo = r.get(
      50
      /* EditorOption.fontInfo */
    ), this._lineHeight = r.get(
      67
      /* EditorOption.lineHeight */
    ), this._emptySelectionClipboard = r.get(
      37
      /* EditorOption.emptySelectionClipboard */
    ), this._copyWithSyntaxHighlighting = r.get(
      25
      /* EditorOption.copyWithSyntaxHighlighting */
    ), this._visibleTextArea = null, this._selections = [new Ue(1, 1, 1, 1)], this._modelSelections = [new Ue(1, 1, 1, 1)], this._lastRenderPosition = null, this.textArea = st(document.createElement("textarea")), Go.write(
      this.textArea,
      7
      /* PartFingerprint.TextArea */
    ), this.textArea.setClassName(`inputarea ${Pu}`), this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off");
    const { tabSize: l } = this._context.viewModel.model.getOptions();
    this.textArea.domNode.style.tabSize = `${l * this._fontInfo.spaceWidth}px`, this.textArea.setAttribute("autocorrect", "off"), this.textArea.setAttribute("autocapitalize", "off"), this.textArea.setAttribute("autocomplete", "off"), this.textArea.setAttribute("spellcheck", "false"), this.textArea.setAttribute("aria-label", this._getAriaLabel(r)), this.textArea.setAttribute("aria-required", r.get(
      5
      /* EditorOption.ariaRequired */
    ) ? "true" : "false"), this.textArea.setAttribute("tabindex", String(r.get(
      125
      /* EditorOption.tabIndex */
    ))), this.textArea.setAttribute("role", "textbox"), this.textArea.setAttribute("aria-roledescription", m("editor", "editor")), this.textArea.setAttribute("aria-multiline", "true"), this.textArea.setAttribute("aria-autocomplete", r.get(
      92
      /* EditorOption.readOnly */
    ) ? "none" : "both"), this._ensureReadOnlyAttribute(), this.textAreaCover = st(document.createElement("div")), this.textAreaCover.setPosition("absolute");
    const c = {
      getLineCount: () => this._context.viewModel.getLineCount(),
      getLineMaxColumn: (u) => this._context.viewModel.getLineMaxColumn(u),
      getValueInRange: (u, f) => this._context.viewModel.getValueInRange(u, f),
      getValueLengthInRange: (u, f) => this._context.viewModel.getValueLengthInRange(u, f),
      modifyPosition: (u, f) => this._context.viewModel.modifyPosition(u, f)
    }, h = {
      getDataToCopy: () => {
        const u = this._context.viewModel.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, es), f = this._context.viewModel.model.getEOL(), g = this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty(), p = Array.isArray(u) ? u : null, _ = Array.isArray(u) ? u.join(f) : u;
        let b, C = null;
        if (this._copyWithSyntaxHighlighting && _.length < 65536) {
          const w = this._context.viewModel.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);
          w && (b = w.html, C = w.mode);
        }
        return {
          isFromEmptySelection: g,
          multicursorText: p,
          text: _,
          html: b,
          mode: C
        };
      },
      getScreenReaderContent: () => {
        if (this._accessibilitySupport === 1) {
          const u = this._selections[0];
          if ($e && u.isEmpty()) {
            const g = u.getStartPosition();
            let p = this._getWordBeforePosition(g);
            if (p.length === 0 && (p = this._getCharacterBeforePosition(g)), p.length > 0)
              return new sn(p, p.length, p.length, T.fromPositions(g), 0);
          }
          if ($e && !u.isEmpty() && c.getValueLengthInRange(
            u,
            0
            /* EndOfLinePreference.TextDefined */
          ) < 500) {
            const g = c.getValueInRange(
              u,
              0
              /* EndOfLinePreference.TextDefined */
            );
            return new sn(g, 0, g.length, u, 0);
          }
          if (ql && !u.isEmpty()) {
            const g = "vscode-placeholder";
            return new sn(g, 0, g.length, null, void 0);
          }
          return sn.EMPTY;
        }
        if (w2) {
          const u = this._selections[0];
          if (u.isEmpty()) {
            const f = u.getStartPosition(), [g, p] = this._getAndroidWordAtPosition(f);
            if (g.length > 0)
              return new sn(g, p, p, T.fromPositions(f), 0);
          }
          return sn.EMPTY;
        }
        return eu.fromEditorSelection(
          c,
          this._selections[0],
          this._accessibilityPageSize,
          this._accessibilitySupport === 0
          /* AccessibilitySupport.Unknown */
        );
      },
      deduceModelPosition: (u, f, g) => this._context.viewModel.deduceModelPositionRelativeToViewPosition(u, f, g)
    }, d = this._register(new q$(this.textArea.domNode));
    this._textAreaInput = this._register(this._instantiationService.createInstance(WS, h, d, bs, {
      isAndroid: w2,
      isChrome: Ip,
      isFirefox: uo,
      isSafari: ql
    })), this._register(this._textAreaInput.onKeyDown((u) => {
      this._viewController.emitKeyDown(u);
    })), this._register(this._textAreaInput.onKeyUp((u) => {
      this._viewController.emitKeyUp(u);
    })), this._register(this._textAreaInput.onPaste((u) => {
      let f = !1, g = null, p = null;
      u.metadata && (f = this._emptySelectionClipboard && !!u.metadata.isFromEmptySelection, g = typeof u.metadata.multicursorText < "u" ? u.metadata.multicursorText : null, p = u.metadata.mode), this._viewController.paste(u.text, f, g, p);
    })), this._register(this._textAreaInput.onCut(() => {
      this._viewController.cut();
    })), this._register(this._textAreaInput.onType((u) => {
      u.replacePrevCharCnt || u.replaceNextCharCnt || u.positionDelta ? this._viewController.compositionType(u.text, u.replacePrevCharCnt, u.replaceNextCharCnt, u.positionDelta) : this._viewController.type(u.text);
    })), this._register(this._textAreaInput.onSelectionChangeRequest((u) => {
      this._viewController.setSelection(u);
    })), this._register(this._textAreaInput.onCompositionStart((u) => {
      const f = this.textArea.domNode, g = this._modelSelections[0], { distanceToModelLineStart: p, widthOfHiddenTextBefore: _ } = (() => {
        const C = f.value.substring(0, Math.min(f.selectionStart, f.selectionEnd)), w = C.lastIndexOf(`
`), v = C.substring(w + 1), S = v.lastIndexOf("	"), L = v.length - S - 1, k = g.getStartPosition(), x = Math.min(k.column - 1, L), I = k.column - 1 - x, K = v.substring(0, v.length - x), { tabSize: B } = this._context.viewModel.model.getOptions(), W = $K(this.textArea.domNode.ownerDocument, K, this._fontInfo, B);
        return { distanceToModelLineStart: I, widthOfHiddenTextBefore: W };
      })(), { distanceToModelLineEnd: b } = (() => {
        const C = f.value.substring(Math.max(f.selectionStart, f.selectionEnd)), w = C.indexOf(`
`), v = w === -1 ? C : C.substring(0, w), S = v.indexOf("	"), L = S === -1 ? v.length : v.length - S - 1, k = g.getEndPosition(), x = Math.min(this._context.viewModel.model.getLineMaxColumn(k.lineNumber) - k.column, L);
        return { distanceToModelLineEnd: this._context.viewModel.model.getLineMaxColumn(k.lineNumber) - k.column - x };
      })();
      this._context.viewModel.revealRange(
        "keyboard",
        !0,
        T.fromPositions(this._selections[0].getStartPosition()),
        0,
        1
        /* ScrollType.Immediate */
      ), this._visibleTextArea = new UK(this._context, g.startLineNumber, p, _, b), this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off"), this._visibleTextArea.prepareRender(this._visibleRangeProvider), this._render(), this.textArea.setClassName(`inputarea ${Pu} ime-input`), this._viewController.compositionStart(), this._context.viewModel.onCompositionStart();
    })), this._register(this._textAreaInput.onCompositionUpdate((u) => {
      this._visibleTextArea && (this._visibleTextArea.prepareRender(this._visibleRangeProvider), this._render());
    })), this._register(this._textAreaInput.onCompositionEnd(() => {
      this._visibleTextArea = null, this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off"), this._render(), this.textArea.setClassName(`inputarea ${Pu}`), this._viewController.compositionEnd(), this._context.viewModel.onCompositionEnd();
    })), this._register(this._textAreaInput.onFocus(() => {
      this._context.viewModel.setHasFocus(!0);
    })), this._register(this._textAreaInput.onBlur(() => {
      this._context.viewModel.setHasFocus(!1);
    })), this._register(Fg.onDidChange(() => {
      this._ensureReadOnlyAttribute();
    }));
  }
  writeScreenReaderContent(e) {
    this._textAreaInput.writeNativeTextAreaContent(e);
  }
  dispose() {
    super.dispose();
  }
  _getAndroidWordAtPosition(e) {
    const t = '`~!@#$%^&*()-=+[{]}\\|;:",.<>/?', i = this._context.viewModel.getLineContent(e.lineNumber), n = ff(t, []);
    let o = !0, r = e.column, a = !0, l = e.column, c = 0;
    for (; c < 50 && (o || a); ) {
      if (o && r <= 1 && (o = !1), o) {
        const h = i.charCodeAt(r - 2);
        n.get(h) !== 0 ? o = !1 : r--;
      }
      if (a && l > i.length && (a = !1), a) {
        const h = i.charCodeAt(l - 1);
        n.get(h) !== 0 ? a = !1 : l++;
      }
      c++;
    }
    return [i.substring(r - 1, l - 1), e.column - r];
  }
  _getWordBeforePosition(e) {
    const t = this._context.viewModel.getLineContent(e.lineNumber), i = ff(this._context.configuration.options.get(
      132
      /* EditorOption.wordSeparators */
    ), []);
    let n = e.column, o = 0;
    for (; n > 1; ) {
      const r = t.charCodeAt(n - 2);
      if (i.get(r) !== 0 || o > 50)
        return t.substring(n - 1, e.column - 1);
      o++, n--;
    }
    return t.substring(0, e.column - 1);
  }
  _getCharacterBeforePosition(e) {
    if (e.column > 1) {
      const i = this._context.viewModel.getLineContent(e.lineNumber).charAt(e.column - 2);
      if (!Si(i.charCodeAt(0)))
        return i;
    }
    return "";
  }
  _getAriaLabel(e) {
    var i, n, o;
    if (e.get(
      2
      /* EditorOption.accessibilitySupport */
    ) === 1) {
      const r = (i = this._keybindingService.lookupKeybinding("editor.action.toggleScreenReaderAccessibilityMode")) == null ? void 0 : i.getAriaLabel(), a = (n = this._keybindingService.lookupKeybinding("workbench.action.showCommands")) == null ? void 0 : n.getAriaLabel(), l = (o = this._keybindingService.lookupKeybinding("workbench.action.openGlobalKeybindings")) == null ? void 0 : o.getAriaLabel(), c = m("accessibilityModeOff", "The editor is not accessible at this time.");
      return r ? m("accessibilityOffAriaLabel", "{0} To enable screen reader optimized mode, use {1}", c, r) : a ? m("accessibilityOffAriaLabelNoKb", "{0} To enable screen reader optimized mode, open the quick pick with {1} and run the command Toggle Screen Reader Accessibility Mode, which is currently not triggerable via keyboard.", c, a) : l ? m("accessibilityOffAriaLabelNoKbs", "{0} Please assign a keybinding for the command Toggle Screen Reader Accessibility Mode by accessing the keybindings editor with {1} and run it.", c, l) : c;
    }
    return e.get(
      4
      /* EditorOption.ariaLabel */
    );
  }
  _setAccessibilityOptions(e) {
    this._accessibilitySupport = e.get(
      2
      /* EditorOption.accessibilitySupport */
    );
    const t = e.get(
      3
      /* EditorOption.accessibilityPageSize */
    );
    this._accessibilitySupport === 2 && t === ad.accessibilityPageSize.defaultValue ? this._accessibilityPageSize = 500 : this._accessibilityPageSize = t;
    const n = e.get(
      146
      /* EditorOption.layoutInfo */
    ).wrappingColumn;
    if (n !== -1 && this._accessibilitySupport !== 1) {
      const o = e.get(
        50
        /* EditorOption.fontInfo */
      );
      this._textAreaWrapping = !0, this._textAreaWidth = Math.round(n * o.typicalHalfwidthCharacterWidth);
    } else
      this._textAreaWrapping = !1, this._textAreaWidth = A0 ? 0 : 1;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._setAccessibilityOptions(t), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._contentHeight = i.height, this._fontInfo = t.get(
      50
      /* EditorOption.fontInfo */
    ), this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._emptySelectionClipboard = t.get(
      37
      /* EditorOption.emptySelectionClipboard */
    ), this._copyWithSyntaxHighlighting = t.get(
      25
      /* EditorOption.copyWithSyntaxHighlighting */
    ), this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off");
    const { tabSize: n } = this._context.viewModel.model.getOptions();
    return this.textArea.domNode.style.tabSize = `${n * this._fontInfo.spaceWidth}px`, this.textArea.setAttribute("aria-label", this._getAriaLabel(t)), this.textArea.setAttribute("aria-required", t.get(
      5
      /* EditorOption.ariaRequired */
    ) ? "true" : "false"), this.textArea.setAttribute("tabindex", String(t.get(
      125
      /* EditorOption.tabIndex */
    ))), (e.hasChanged(
      34
      /* EditorOption.domReadOnly */
    ) || e.hasChanged(
      92
      /* EditorOption.readOnly */
    )) && this._ensureReadOnlyAttribute(), e.hasChanged(
      2
      /* EditorOption.accessibilitySupport */
    ) && this._textAreaInput.writeNativeTextAreaContent("strategy changed"), !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections.slice(0), this._modelSelections = e.modelSelections.slice(0), this._textAreaInput.writeNativeTextAreaContent("selection changed"), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return this._scrollLeft = e.scrollLeft, this._scrollTop = e.scrollTop, !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  // --- begin view API
  isFocused() {
    return this._textAreaInput.isFocused();
  }
  focusTextArea() {
    this._textAreaInput.focusTextArea();
  }
  getLastRenderData() {
    return this._lastRenderPosition;
  }
  setAriaOptions(e) {
    e.activeDescendant ? (this.textArea.setAttribute("aria-haspopup", "true"), this.textArea.setAttribute("aria-autocomplete", "list"), this.textArea.setAttribute("aria-activedescendant", e.activeDescendant)) : (this.textArea.setAttribute("aria-haspopup", "false"), this.textArea.setAttribute("aria-autocomplete", "both"), this.textArea.removeAttribute("aria-activedescendant")), e.role && this.textArea.setAttribute("role", e.role);
  }
  // --- end view API
  _ensureReadOnlyAttribute() {
    const e = this._context.configuration.options;
    !Fg.enabled || e.get(
      34
      /* EditorOption.domReadOnly */
    ) && e.get(
      92
      /* EditorOption.readOnly */
    ) ? this.textArea.setAttribute("readonly", "true") : this.textArea.removeAttribute("readonly");
  }
  prepareRender(e) {
    var t;
    this._primaryCursorPosition = new F(this._selections[0].positionLineNumber, this._selections[0].positionColumn), this._primaryCursorVisibleRange = e.visibleRangeForPosition(this._primaryCursorPosition), (t = this._visibleTextArea) == null || t.prepareRender(e);
  }
  render(e) {
    this._textAreaInput.writeNativeTextAreaContent("render"), this._render();
  }
  _render() {
    if (this._visibleTextArea) {
      const i = this._visibleTextArea.visibleTextareaStart, n = this._visibleTextArea.visibleTextareaEnd, o = this._visibleTextArea.startPosition, r = this._visibleTextArea.endPosition;
      if (o && r && i && n && n.left >= this._scrollLeft && i.left <= this._scrollLeft + this._contentWidth) {
        const a = this._context.viewLayout.getVerticalOffsetForLineNumber(this._primaryCursorPosition.lineNumber) - this._scrollTop, l = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));
        let c = this._visibleTextArea.widthOfHiddenLineTextBefore, h = this._contentLeft + i.left - this._scrollLeft, d = n.left - i.left + 1;
        if (h < this._contentLeft) {
          const b = this._contentLeft - h;
          h += b, c += b, d -= b;
        }
        d > this._contentWidth && (d = this._contentWidth);
        const u = this._context.viewModel.getViewLineData(o.lineNumber), f = u.tokens.findTokenIndexAtOffset(o.column - 1), g = u.tokens.findTokenIndexAtOffset(r.column - 1), p = f === g, _ = this._visibleTextArea.definePresentation(p ? u.tokens.getPresentation(f) : null);
        this.textArea.domNode.scrollTop = l * this._lineHeight, this.textArea.domNode.scrollLeft = c, this._doRender({
          lastRenderPosition: null,
          top: a,
          left: h,
          width: d,
          height: this._lineHeight,
          useCover: !1,
          color: (ii.getColorMap() || [])[_.foreground],
          italic: _.italic,
          bold: _.bold,
          underline: _.underline,
          strikethrough: _.strikethrough
        });
      }
      return;
    }
    if (!this._primaryCursorVisibleRange) {
      this._renderAtTopLeft();
      return;
    }
    const e = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;
    if (e < this._contentLeft || e > this._contentLeft + this._contentWidth) {
      this._renderAtTopLeft();
      return;
    }
    const t = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;
    if (t < 0 || t > this._contentHeight) {
      this._renderAtTopLeft();
      return;
    }
    if ($e || this._accessibilitySupport === 2) {
      this._doRender({
        lastRenderPosition: this._primaryCursorPosition,
        top: t,
        left: this._textAreaWrapping ? this._contentLeft : e,
        width: this._textAreaWidth,
        height: this._lineHeight,
        useCover: !1
      }), this.textArea.domNode.scrollLeft = this._primaryCursorVisibleRange.left;
      const i = this._textAreaInput.textAreaState.newlineCountBeforeSelection ?? this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));
      this.textArea.domNode.scrollTop = i * this._lineHeight;
      return;
    }
    this._doRender({
      lastRenderPosition: this._primaryCursorPosition,
      top: t,
      left: this._textAreaWrapping ? this._contentLeft : e,
      width: this._textAreaWidth,
      height: A0 ? 0 : 1,
      useCover: !1
    });
  }
  _newlinecount(e) {
    let t = 0, i = -1;
    do {
      if (i = e.indexOf(`
`, i + 1), i === -1)
        break;
      t++;
    } while (!0);
    return t;
  }
  _renderAtTopLeft() {
    this._doRender({
      lastRenderPosition: null,
      top: 0,
      left: 0,
      width: this._textAreaWidth,
      height: A0 ? 0 : 1,
      useCover: !0
    });
  }
  _doRender(e) {
    this._lastRenderPosition = e.lastRenderPosition;
    const t = this.textArea, i = this.textAreaCover;
    Zi(t, this._fontInfo), t.setTop(e.top), t.setLeft(e.left), t.setWidth(e.width), t.setHeight(e.height), t.setColor(e.color ? j.Format.CSS.formatHex(e.color) : ""), t.setFontStyle(e.italic ? "italic" : ""), e.bold && t.setFontWeight("bold"), t.setTextDecoration(`${e.underline ? " underline" : ""}${e.strikethrough ? " line-through" : ""}`), i.setTop(e.useCover ? e.top : 0), i.setLeft(e.useCover ? e.left : 0), i.setWidth(e.useCover ? e.width : 0), i.setHeight(e.useCover ? e.height : 0);
    const n = this._context.configuration.options;
    n.get(
      57
      /* EditorOption.glyphMargin */
    ) ? i.setClassName("monaco-editor-background textAreaCover " + g1.OUTER_CLASS_NAME) : n.get(
      68
      /* EditorOption.lineNumbers */
    ).renderType !== 0 ? i.setClassName("monaco-editor-background textAreaCover " + f1.CLASS_NAME) : i.setClassName("monaco-editor-background textAreaCover");
  }
};
jS = zK([
  WT(3, Lt),
  WT(4, Pe)
], jS);
function $K(s, e, t, i) {
  if (e.length === 0)
    return 0;
  const n = s.createElement("div");
  n.style.position = "absolute", n.style.top = "-50000px", n.style.width = "50000px";
  const o = s.createElement("span");
  Zi(o, t), o.style.whiteSpace = "pre", o.style.tabSize = `${i * t.spaceWidth}px`, o.append(e), n.appendChild(o), s.body.appendChild(n);
  const r = o.offsetWidth;
  return n.remove(), r;
}
function eh(s, e) {
  const t = s.getCount(), i = s.findTokenIndexAtOffset(e), n = s.getLanguageId(i);
  let o = i;
  for (; o + 1 < t && s.getLanguageId(o + 1) === n; )
    o++;
  let r = i;
  for (; r > 0 && s.getLanguageId(r - 1) === n; )
    r--;
  return new KK(s, n, r, o + 1, s.getStartOffset(r), s.getEndOffset(o));
}
class KK {
  constructor(e, t, i, n, o, r) {
    this._scopedLineTokensBrand = void 0, this._actual = e, this.languageId = t, this._firstTokenIndex = i, this._lastTokenIndex = n, this.firstCharOffset = o, this._lastCharOffset = r, this.languageIdCodec = e.languageIdCodec;
  }
  getLineContent() {
    return this._actual.getLineContent().substring(this.firstCharOffset, this._lastCharOffset);
  }
  getLineLength() {
    return this._lastCharOffset - this.firstCharOffset;
  }
  getActualLineContentBefore(e) {
    return this._actual.getLineContent().substring(0, this.firstCharOffset + e);
  }
  getTokenCount() {
    return this._lastTokenIndex - this._firstTokenIndex;
  }
  findTokenIndexAtOffset(e) {
    return this._actual.findTokenIndexAtOffset(e + this.firstCharOffset) - this._firstTokenIndex;
  }
  getStandardTokenType(e) {
    return this._actual.getStandardTokenType(e + this._firstTokenIndex);
  }
  toIViewLineTokens() {
    return this._actual.sliceAndInflate(this.firstCharOffset, this._lastCharOffset, 0);
  }
}
function fr(s) {
  return (s & 3) !== 0;
}
function jK(s, e, t) {
  let i = 0;
  for (let o = 0; o < s.length; o++)
    s.charAt(o) === "	" ? i = pi.nextIndentTabStop(i, e) : i++;
  let n = "";
  if (!t) {
    const o = Math.floor(i / e);
    i = i % e;
    for (let r = 0; r < o; r++)
      n += "	";
  }
  for (let o = 0; o < i; o++)
    n += " ";
  return n;
}
function M5(s, e, t) {
  let i = Zn(s);
  return i === -1 && (i = s.length), jK(s.substring(0, i), e, t) + s.substring(i);
}
const qK = () => !0, GK = () => !1, ZK = (s) => s === " " || s === "	";
class Id {
  static shouldRecreate(e) {
    return e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    ) || e.hasChanged(
      132
      /* EditorOption.wordSeparators */
    ) || e.hasChanged(
      37
      /* EditorOption.emptySelectionClipboard */
    ) || e.hasChanged(
      77
      /* EditorOption.multiCursorMergeOverlapping */
    ) || e.hasChanged(
      79
      /* EditorOption.multiCursorPaste */
    ) || e.hasChanged(
      80
      /* EditorOption.multiCursorLimit */
    ) || e.hasChanged(
      6
      /* EditorOption.autoClosingBrackets */
    ) || e.hasChanged(
      7
      /* EditorOption.autoClosingComments */
    ) || e.hasChanged(
      11
      /* EditorOption.autoClosingQuotes */
    ) || e.hasChanged(
      9
      /* EditorOption.autoClosingDelete */
    ) || e.hasChanged(
      10
      /* EditorOption.autoClosingOvertype */
    ) || e.hasChanged(
      14
      /* EditorOption.autoSurround */
    ) || e.hasChanged(
      129
      /* EditorOption.useTabStops */
    ) || e.hasChanged(
      50
      /* EditorOption.fontInfo */
    ) || e.hasChanged(
      92
      /* EditorOption.readOnly */
    ) || e.hasChanged(
      131
      /* EditorOption.wordSegmenterLocales */
    );
  }
  constructor(e, t, i, n) {
    this.languageConfigurationService = n, this._cursorMoveConfigurationBrand = void 0, this._languageId = e;
    const o = i.options, r = o.get(
      146
      /* EditorOption.layoutInfo */
    ), a = o.get(
      50
      /* EditorOption.fontInfo */
    );
    this.readOnly = o.get(
      92
      /* EditorOption.readOnly */
    ), this.tabSize = t.tabSize, this.indentSize = t.indentSize, this.insertSpaces = t.insertSpaces, this.stickyTabStops = o.get(
      117
      /* EditorOption.stickyTabStops */
    ), this.lineHeight = a.lineHeight, this.typicalHalfwidthCharacterWidth = a.typicalHalfwidthCharacterWidth, this.pageSize = Math.max(1, Math.floor(r.height / this.lineHeight) - 2), this.useTabStops = o.get(
      129
      /* EditorOption.useTabStops */
    ), this.wordSeparators = o.get(
      132
      /* EditorOption.wordSeparators */
    ), this.emptySelectionClipboard = o.get(
      37
      /* EditorOption.emptySelectionClipboard */
    ), this.copyWithSyntaxHighlighting = o.get(
      25
      /* EditorOption.copyWithSyntaxHighlighting */
    ), this.multiCursorMergeOverlapping = o.get(
      77
      /* EditorOption.multiCursorMergeOverlapping */
    ), this.multiCursorPaste = o.get(
      79
      /* EditorOption.multiCursorPaste */
    ), this.multiCursorLimit = o.get(
      80
      /* EditorOption.multiCursorLimit */
    ), this.autoClosingBrackets = o.get(
      6
      /* EditorOption.autoClosingBrackets */
    ), this.autoClosingComments = o.get(
      7
      /* EditorOption.autoClosingComments */
    ), this.autoClosingQuotes = o.get(
      11
      /* EditorOption.autoClosingQuotes */
    ), this.autoClosingDelete = o.get(
      9
      /* EditorOption.autoClosingDelete */
    ), this.autoClosingOvertype = o.get(
      10
      /* EditorOption.autoClosingOvertype */
    ), this.autoSurround = o.get(
      14
      /* EditorOption.autoSurround */
    ), this.autoIndent = o.get(
      12
      /* EditorOption.autoIndent */
    ), this.wordSegmenterLocales = o.get(
      131
      /* EditorOption.wordSegmenterLocales */
    ), this.surroundingPairs = {}, this._electricChars = null, this.shouldAutoCloseBefore = {
      quote: this._getShouldAutoClose(e, this.autoClosingQuotes, !0),
      comment: this._getShouldAutoClose(e, this.autoClosingComments, !1),
      bracket: this._getShouldAutoClose(e, this.autoClosingBrackets, !1)
    }, this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(e).getAutoClosingPairs();
    const l = this.languageConfigurationService.getLanguageConfiguration(e).getSurroundingPairs();
    if (l)
      for (const h of l)
        this.surroundingPairs[h.open] = h.close;
    const c = this.languageConfigurationService.getLanguageConfiguration(e).comments;
    this.blockCommentStartToken = (c == null ? void 0 : c.blockCommentStartToken) ?? null;
  }
  get electricChars() {
    var e;
    if (!this._electricChars) {
      this._electricChars = {};
      const t = (e = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter) == null ? void 0 : e.getElectricCharacters();
      if (t)
        for (const i of t)
          this._electricChars[i] = !0;
    }
    return this._electricChars;
  }
  /**
   * Should return opening bracket type to match indentation with
   */
  onElectricCharacter(e, t, i) {
    const n = eh(t, i - 1), o = this.languageConfigurationService.getLanguageConfiguration(n.languageId).electricCharacter;
    return o ? o.onElectricCharacter(e, n, i - n.firstCharOffset) : null;
  }
  normalizeIndentation(e) {
    return M5(e, this.indentSize, this.insertSpaces);
  }
  _getShouldAutoClose(e, t, i) {
    switch (t) {
      case "beforeWhitespace":
        return ZK;
      case "languageDefined":
        return this._getLanguageDefinedShouldAutoClose(e, i);
      case "always":
        return qK;
      case "never":
        return GK;
    }
  }
  _getLanguageDefinedShouldAutoClose(e, t) {
    const i = this.languageConfigurationService.getLanguageConfiguration(e).getAutoCloseBeforeSet(t);
    return (n) => i.indexOf(n) !== -1;
  }
  /**
   * Returns a visible column from a column.
   * @see {@link CursorColumns}
   */
  visibleColumnFromColumn(e, t) {
    return pi.visibleColumnFromColumn(e.getLineContent(t.lineNumber), t.column, this.tabSize);
  }
  /**
   * Returns a visible column from a column.
   * @see {@link CursorColumns}
   */
  columnFromVisibleColumn(e, t, i) {
    const n = pi.columnFromVisibleColumn(e.getLineContent(t), i, this.tabSize), o = e.getLineMinColumn(t);
    if (n < o)
      return o;
    const r = e.getLineMaxColumn(t);
    return n > r ? r : n;
  }
}
class Ve {
  static fromModelState(e) {
    return new YK(e);
  }
  static fromViewState(e) {
    return new XK(e);
  }
  static fromModelSelection(e) {
    const t = Ue.liftSelection(e), i = new Ei(T.fromPositions(t.getSelectionStart()), 0, 0, t.getPosition(), 0);
    return Ve.fromModelState(i);
  }
  static fromModelSelections(e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++)
      t[i] = this.fromModelSelection(e[i]);
    return t;
  }
  constructor(e, t) {
    this._cursorStateBrand = void 0, this.modelState = e, this.viewState = t;
  }
  equals(e) {
    return this.viewState.equals(e.viewState) && this.modelState.equals(e.modelState);
  }
}
class YK {
  constructor(e) {
    this.modelState = e, this.viewState = null;
  }
}
class XK {
  constructor(e) {
    this.modelState = null, this.viewState = e;
  }
}
class Ei {
  constructor(e, t, i, n, o) {
    this.selectionStart = e, this.selectionStartKind = t, this.selectionStartLeftoverVisibleColumns = i, this.position = n, this.leftoverVisibleColumns = o, this._singleCursorStateBrand = void 0, this.selection = Ei._computeSelection(this.selectionStart, this.position);
  }
  equals(e) {
    return this.selectionStartLeftoverVisibleColumns === e.selectionStartLeftoverVisibleColumns && this.leftoverVisibleColumns === e.leftoverVisibleColumns && this.selectionStartKind === e.selectionStartKind && this.position.equals(e.position) && this.selectionStart.equalsRange(e.selectionStart);
  }
  hasSelection() {
    return !this.selection.isEmpty() || !this.selectionStart.isEmpty();
  }
  move(e, t, i, n) {
    return e ? new Ei(this.selectionStart, this.selectionStartKind, this.selectionStartLeftoverVisibleColumns, new F(t, i), n) : new Ei(new T(t, i, t, i), 0, n, new F(t, i), n);
  }
  static _computeSelection(e, t) {
    return e.isEmpty() || !t.isBeforeOrEqual(e.getStartPosition()) ? Ue.fromPositions(e.getStartPosition(), t) : Ue.fromPositions(e.getEndPosition(), t);
  }
}
class Pn {
  constructor(e, t, i) {
    this._editOperationResultBrand = void 0, this.type = e, this.commands = t, this.shouldPushStackElementBefore = i.shouldPushStackElementBefore, this.shouldPushStackElementAfter = i.shouldPushStackElementAfter;
  }
}
function Zl(s) {
  return s === "'" || s === '"' || s === "`";
}
class Tc {
  static columnSelect(e, t, i, n, o, r) {
    const a = Math.abs(o - i) + 1, l = i > o, c = n > r, h = n < r, d = [];
    for (let u = 0; u < a; u++) {
      const f = i + (l ? -u : u), g = e.columnFromVisibleColumn(t, f, n), p = e.columnFromVisibleColumn(t, f, r), _ = e.visibleColumnFromColumn(t, new F(f, g)), b = e.visibleColumnFromColumn(t, new F(f, p));
      h && (_ > r || b < n) || c && (b > n || _ < r) || d.push(new Ei(new T(f, g, f, g), 0, 0, new F(f, p), 0));
    }
    if (d.length === 0)
      for (let u = 0; u < a; u++) {
        const f = i + (l ? -u : u), g = t.getLineMaxColumn(f);
        d.push(new Ei(new T(f, g, f, g), 0, 0, new F(f, g), 0));
      }
    return {
      viewStates: d,
      reversed: l,
      fromLineNumber: i,
      fromVisualColumn: n,
      toLineNumber: o,
      toVisualColumn: r
    };
  }
  static columnSelectLeft(e, t, i) {
    let n = i.toViewVisualColumn;
    return n > 0 && n--, Tc.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, n);
  }
  static columnSelectRight(e, t, i) {
    let n = 0;
    const o = Math.min(i.fromViewLineNumber, i.toViewLineNumber), r = Math.max(i.fromViewLineNumber, i.toViewLineNumber);
    for (let l = o; l <= r; l++) {
      const c = t.getLineMaxColumn(l), h = e.visibleColumnFromColumn(t, new F(l, c));
      n = Math.max(n, h);
    }
    let a = i.toViewVisualColumn;
    return a < n && a++, this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, a);
  }
  static columnSelectUp(e, t, i, n) {
    const o = n ? e.pageSize : 1, r = Math.max(1, i.toViewLineNumber - o);
    return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, r, i.toViewVisualColumn);
  }
  static columnSelectDown(e, t, i, n) {
    const o = n ? e.pageSize : 1, r = Math.min(t.getLineCount(), i.toViewLineNumber + o);
    return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, r, i.toViewVisualColumn);
  }
}
class qn {
  constructor(e, t, i = !1) {
    this._range = e, this._text = t, this.insertsAutoWhitespace = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return Ue.fromPositions(n.getEndPosition());
  }
}
class ab {
  constructor(e, t, i = !1) {
    this._range = e, this._text = t, this.insertsAutoWhitespace = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return Ue.fromPositions(n.getStartPosition());
  }
}
class _1 {
  constructor(e, t, i, n, o = !1) {
    this._range = e, this._text = t, this._columnDeltaOffset = n, this._lineNumberDeltaOffset = i, this.insertsAutoWhitespace = o;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return Ue.fromPositions(n.getEndPosition().delta(this._lineNumberDeltaOffset, this._columnDeltaOffset));
  }
}
class QK {
  constructor(e, t, i, n = !1) {
    this._range = e, this._text = t, this._initialSelection = i, this._forceMoveMarkers = n, this._selectionId = null;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text, this._forceMoveMarkers), this._selectionId = t.trackSelection(this._initialSelection);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this._selectionId);
  }
}
class P0 {
  constructor(e, t, i) {
    this._cursorPositionBrand = void 0, this.lineNumber = e, this.column = t, this.leftoverVisibleColumns = i;
  }
}
class ht {
  static leftPosition(e, t) {
    if (t.column > e.getLineMinColumn(t.lineNumber))
      return t.delta(void 0, -h4(e.getLineContent(t.lineNumber), t.column - 1));
    if (t.lineNumber > 1) {
      const i = t.lineNumber - 1;
      return new F(i, e.getLineMaxColumn(i));
    } else
      return t;
  }
  static leftPositionAtomicSoftTabs(e, t, i) {
    if (t.column <= e.getLineIndentColumn(t.lineNumber)) {
      const n = e.getLineMinColumn(t.lineNumber), o = e.getLineContent(t.lineNumber), r = $m.atomicPosition(
        o,
        t.column - 1,
        i,
        0
        /* Direction.Left */
      );
      if (r !== -1 && r + 1 >= n)
        return new F(t.lineNumber, r + 1);
    }
    return this.leftPosition(e, t);
  }
  static left(e, t, i) {
    const n = e.stickyTabStops ? ht.leftPositionAtomicSoftTabs(t, i, e.tabSize) : ht.leftPosition(t, i);
    return new P0(n.lineNumber, n.column, 0);
  }
  /**
   * @param noOfColumns Must be either `1`
   * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).
  */
  static moveLeft(e, t, i, n, o) {
    let r, a;
    if (i.hasSelection() && !n)
      r = i.selection.startLineNumber, a = i.selection.startColumn;
    else {
      const l = i.position.delta(void 0, -(o - 1)), c = t.normalizePosition(
        ht.clipPositionColumn(l, t),
        0
        /* PositionAffinity.Left */
      ), h = ht.left(e, t, c);
      r = h.lineNumber, a = h.column;
    }
    return i.move(n, r, a, 0);
  }
  /**
   * Adjusts the column so that it is within min/max of the line.
  */
  static clipPositionColumn(e, t) {
    return new F(e.lineNumber, ht.clipRange(e.column, t.getLineMinColumn(e.lineNumber), t.getLineMaxColumn(e.lineNumber)));
  }
  static clipRange(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  static rightPosition(e, t, i) {
    return i < e.getLineMaxColumn(t) ? i = i + uE(e.getLineContent(t), i - 1) : t < e.getLineCount() && (t = t + 1, i = e.getLineMinColumn(t)), new F(t, i);
  }
  static rightPositionAtomicSoftTabs(e, t, i, n, o) {
    if (i < e.getLineIndentColumn(t)) {
      const r = e.getLineContent(t), a = $m.atomicPosition(
        r,
        i - 1,
        n,
        1
        /* Direction.Right */
      );
      if (a !== -1)
        return new F(t, a + 1);
    }
    return this.rightPosition(e, t, i);
  }
  static right(e, t, i) {
    const n = e.stickyTabStops ? ht.rightPositionAtomicSoftTabs(t, i.lineNumber, i.column, e.tabSize, e.indentSize) : ht.rightPosition(t, i.lineNumber, i.column);
    return new P0(n.lineNumber, n.column, 0);
  }
  static moveRight(e, t, i, n, o) {
    let r, a;
    if (i.hasSelection() && !n)
      r = i.selection.endLineNumber, a = i.selection.endColumn;
    else {
      const l = i.position.delta(void 0, o - 1), c = t.normalizePosition(
        ht.clipPositionColumn(l, t),
        1
        /* PositionAffinity.Right */
      ), h = ht.right(e, t, c);
      r = h.lineNumber, a = h.column;
    }
    return i.move(n, r, a, 0);
  }
  static vertical(e, t, i, n, o, r, a, l) {
    const c = pi.visibleColumnFromColumn(t.getLineContent(i), n, e.tabSize) + o, h = t.getLineCount(), d = i === 1 && n === 1, u = i === h && n === t.getLineMaxColumn(i), f = r < i ? d : u;
    if (i = r, i < 1 ? (i = 1, a ? n = t.getLineMinColumn(i) : n = Math.min(t.getLineMaxColumn(i), n)) : i > h ? (i = h, a ? n = t.getLineMaxColumn(i) : n = Math.min(t.getLineMaxColumn(i), n)) : n = e.columnFromVisibleColumn(t, i, c), f ? o = 0 : o = c - pi.visibleColumnFromColumn(t.getLineContent(i), n, e.tabSize), l !== void 0) {
      const g = new F(i, n), p = t.normalizePosition(g, l);
      o = o + (n - p.column), i = p.lineNumber, n = p.column;
    }
    return new P0(i, n, o);
  }
  static down(e, t, i, n, o, r, a) {
    return this.vertical(
      e,
      t,
      i,
      n,
      o,
      i + r,
      a,
      4
      /* PositionAffinity.RightOfInjectedText */
    );
  }
  static moveDown(e, t, i, n, o) {
    let r, a;
    i.hasSelection() && !n ? (r = i.selection.endLineNumber, a = i.selection.endColumn) : (r = i.position.lineNumber, a = i.position.column);
    let l = 0, c;
    do
      if (c = ht.down(e, t, r + l, a, i.leftoverVisibleColumns, o, !0), t.normalizePosition(
        new F(c.lineNumber, c.column),
        2
        /* PositionAffinity.None */
      ).lineNumber > r)
        break;
    while (l++ < 10 && r + l < t.getLineCount());
    return i.move(n, c.lineNumber, c.column, c.leftoverVisibleColumns);
  }
  static translateDown(e, t, i) {
    const n = i.selection, o = ht.down(e, t, n.selectionStartLineNumber, n.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, !1), r = ht.down(e, t, n.positionLineNumber, n.positionColumn, i.leftoverVisibleColumns, 1, !1);
    return new Ei(new T(o.lineNumber, o.column, o.lineNumber, o.column), 0, o.leftoverVisibleColumns, new F(r.lineNumber, r.column), r.leftoverVisibleColumns);
  }
  static up(e, t, i, n, o, r, a) {
    return this.vertical(
      e,
      t,
      i,
      n,
      o,
      i - r,
      a,
      3
      /* PositionAffinity.LeftOfInjectedText */
    );
  }
  static moveUp(e, t, i, n, o) {
    let r, a;
    i.hasSelection() && !n ? (r = i.selection.startLineNumber, a = i.selection.startColumn) : (r = i.position.lineNumber, a = i.position.column);
    const l = ht.up(e, t, r, a, i.leftoverVisibleColumns, o, !0);
    return i.move(n, l.lineNumber, l.column, l.leftoverVisibleColumns);
  }
  static translateUp(e, t, i) {
    const n = i.selection, o = ht.up(e, t, n.selectionStartLineNumber, n.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, !1), r = ht.up(e, t, n.positionLineNumber, n.positionColumn, i.leftoverVisibleColumns, 1, !1);
    return new Ei(new T(o.lineNumber, o.column, o.lineNumber, o.column), 0, o.leftoverVisibleColumns, new F(r.lineNumber, r.column), r.leftoverVisibleColumns);
  }
  static _isBlankLine(e, t) {
    return e.getLineFirstNonWhitespaceColumn(t) === 0;
  }
  static moveToPrevBlankLine(e, t, i, n) {
    let o = i.position.lineNumber;
    for (; o > 1 && this._isBlankLine(t, o); )
      o--;
    for (; o > 1 && !this._isBlankLine(t, o); )
      o--;
    return i.move(n, o, t.getLineMinColumn(o), 0);
  }
  static moveToNextBlankLine(e, t, i, n) {
    const o = t.getLineCount();
    let r = i.position.lineNumber;
    for (; r < o && this._isBlankLine(t, r); )
      r++;
    for (; r < o && !this._isBlankLine(t, r); )
      r++;
    return i.move(n, r, t.getLineMinColumn(r), 0);
  }
  static moveToBeginningOfLine(e, t, i, n) {
    const o = i.position.lineNumber, r = t.getLineMinColumn(o), a = t.getLineFirstNonWhitespaceColumn(o) || r;
    let l;
    return i.position.column === a ? l = r : l = a, i.move(n, o, l, 0);
  }
  static moveToEndOfLine(e, t, i, n, o) {
    const r = i.position.lineNumber, a = t.getLineMaxColumn(r);
    return i.move(n, r, a, o ? 1073741824 - a : 0);
  }
  static moveToBeginningOfBuffer(e, t, i, n) {
    return i.move(n, 1, 1, 0);
  }
  static moveToEndOfBuffer(e, t, i, n) {
    const o = t.getLineCount(), r = t.getLineMaxColumn(o);
    return i.move(n, o, r, 0);
  }
}
class jh {
  static deleteRight(e, t, i, n) {
    const o = [];
    let r = e !== 3;
    for (let a = 0, l = n.length; a < l; a++) {
      const c = n[a];
      let h = c;
      if (h.isEmpty()) {
        const d = c.getPosition(), u = ht.right(t, i, d);
        h = new T(u.lineNumber, u.column, d.lineNumber, d.column);
      }
      if (h.isEmpty()) {
        o[a] = null;
        continue;
      }
      h.startLineNumber !== h.endLineNumber && (r = !0), o[a] = new qn(h, "");
    }
    return [r, o];
  }
  static isAutoClosingPairDelete(e, t, i, n, o, r, a) {
    if (t === "never" && i === "never" || e === "never")
      return !1;
    for (let l = 0, c = r.length; l < c; l++) {
      const h = r[l], d = h.getPosition();
      if (!h.isEmpty())
        return !1;
      const u = o.getLineContent(d.lineNumber);
      if (d.column < 2 || d.column >= u.length + 1)
        return !1;
      const f = u.charAt(d.column - 2), g = n.get(f);
      if (!g)
        return !1;
      if (Zl(f)) {
        if (i === "never")
          return !1;
      } else if (t === "never")
        return !1;
      const p = u.charAt(d.column - 1);
      let _ = !1;
      for (const b of g)
        b.open === f && b.close === p && (_ = !0);
      if (!_)
        return !1;
      if (e === "auto") {
        let b = !1;
        for (let C = 0, w = a.length; C < w; C++) {
          const v = a[C];
          if (d.lineNumber === v.startLineNumber && d.column === v.startColumn) {
            b = !0;
            break;
          }
        }
        if (!b)
          return !1;
      }
    }
    return !0;
  }
  static _runAutoClosingPairDelete(e, t, i) {
    const n = [];
    for (let o = 0, r = i.length; o < r; o++) {
      const a = i[o].getPosition(), l = new T(a.lineNumber, a.column - 1, a.lineNumber, a.column + 1);
      n[o] = new qn(l, "");
    }
    return [!0, n];
  }
  static deleteLeft(e, t, i, n, o) {
    if (this.isAutoClosingPairDelete(t.autoClosingDelete, t.autoClosingBrackets, t.autoClosingQuotes, t.autoClosingPairs.autoClosingPairsOpenByEnd, i, n, o))
      return this._runAutoClosingPairDelete(t, i, n);
    const r = [];
    let a = e !== 2;
    for (let l = 0, c = n.length; l < c; l++) {
      const h = jh.getDeleteRange(n[l], i, t);
      if (h.isEmpty()) {
        r[l] = null;
        continue;
      }
      h.startLineNumber !== h.endLineNumber && (a = !0), r[l] = new qn(h, "");
    }
    return [a, r];
  }
  static getDeleteRange(e, t, i) {
    if (!e.isEmpty())
      return e;
    const n = e.getPosition();
    if (i.useTabStops && n.column > 1) {
      const o = t.getLineContent(n.lineNumber), r = Zn(o), a = r === -1 ? (
        /* entire string is whitespace */
        o.length + 1
      ) : r + 1;
      if (n.column <= a) {
        const l = i.visibleColumnFromColumn(t, n), c = pi.prevIndentTabStop(l, i.indentSize), h = i.columnFromVisibleColumn(t, n.lineNumber, c);
        return new T(n.lineNumber, h, n.lineNumber, n.column);
      }
    }
    return T.fromPositions(jh.getPositionAfterDeleteLeft(n, t), n);
  }
  static getPositionAfterDeleteLeft(e, t) {
    if (e.column > 1) {
      const i = S8(e.column - 1, t.getLineContent(e.lineNumber));
      return e.with(void 0, i + 1);
    } else if (e.lineNumber > 1) {
      const i = e.lineNumber - 1;
      return new F(i, t.getLineMaxColumn(i));
    } else
      return e;
  }
  static cut(e, t, i) {
    const n = [];
    let o = null;
    i.sort((r, a) => F.compare(r.getStartPosition(), a.getEndPosition()));
    for (let r = 0, a = i.length; r < a; r++) {
      const l = i[r];
      if (l.isEmpty())
        if (e.emptySelectionClipboard) {
          const c = l.getPosition();
          let h, d, u, f;
          c.lineNumber < t.getLineCount() ? (h = c.lineNumber, d = 1, u = c.lineNumber + 1, f = 1) : c.lineNumber > 1 && (o == null ? void 0 : o.endLineNumber) !== c.lineNumber ? (h = c.lineNumber - 1, d = t.getLineMaxColumn(c.lineNumber - 1), u = c.lineNumber, f = t.getLineMaxColumn(c.lineNumber)) : (h = c.lineNumber, d = 1, u = c.lineNumber, f = t.getLineMaxColumn(c.lineNumber));
          const g = new T(h, d, u, f);
          o = g, g.isEmpty() ? n[r] = null : n[r] = new qn(g, "");
        } else
          n[r] = null;
      else
        n[r] = new qn(l, "");
    }
    return new Pn(0, n, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
}
class Jt {
  static _createWord(e, t, i, n, o) {
    return { start: n, end: o, wordType: t, nextCharClass: i };
  }
  static _createIntlWord(e, t) {
    return { start: e.index, end: e.index + e.segment.length, wordType: 1, nextCharClass: t };
  }
  static _findPreviousWordOnLine(e, t, i) {
    const n = t.getLineContent(i.lineNumber);
    return this._doFindPreviousWordOnLine(n, e, i);
  }
  static _doFindPreviousWordOnLine(e, t, i) {
    let n = 0;
    const o = t.findPrevIntlWordBeforeOrAtOffset(e, i.column - 2);
    for (let r = i.column - 2; r >= 0; r--) {
      const a = e.charCodeAt(r), l = t.get(a);
      if (o && r === o.index)
        return this._createIntlWord(o, l);
      if (l === 0) {
        if (n === 2)
          return this._createWord(e, n, l, r + 1, this._findEndOfWord(e, t, n, r + 1));
        n = 1;
      } else if (l === 2) {
        if (n === 1)
          return this._createWord(e, n, l, r + 1, this._findEndOfWord(e, t, n, r + 1));
        n = 2;
      } else if (l === 1 && n !== 0)
        return this._createWord(e, n, l, r + 1, this._findEndOfWord(e, t, n, r + 1));
    }
    return n !== 0 ? this._createWord(e, n, 1, 0, this._findEndOfWord(e, t, n, 0)) : null;
  }
  static _findEndOfWord(e, t, i, n) {
    const o = t.findNextIntlWordAtOrAfterOffset(e, n), r = e.length;
    for (let a = n; a < r; a++) {
      const l = e.charCodeAt(a), c = t.get(l);
      if (o && a === o.index + o.segment.length || c === 1 || i === 1 && c === 2 || i === 2 && c === 0)
        return a;
    }
    return r;
  }
  static _findNextWordOnLine(e, t, i) {
    const n = t.getLineContent(i.lineNumber);
    return this._doFindNextWordOnLine(n, e, i);
  }
  static _doFindNextWordOnLine(e, t, i) {
    let n = 0;
    const o = e.length, r = t.findNextIntlWordAtOrAfterOffset(e, i.column - 1);
    for (let a = i.column - 1; a < o; a++) {
      const l = e.charCodeAt(a), c = t.get(l);
      if (r && a === r.index)
        return this._createIntlWord(r, c);
      if (c === 0) {
        if (n === 2)
          return this._createWord(e, n, c, this._findStartOfWord(e, t, n, a - 1), a);
        n = 1;
      } else if (c === 2) {
        if (n === 1)
          return this._createWord(e, n, c, this._findStartOfWord(e, t, n, a - 1), a);
        n = 2;
      } else if (c === 1 && n !== 0)
        return this._createWord(e, n, c, this._findStartOfWord(e, t, n, a - 1), a);
    }
    return n !== 0 ? this._createWord(e, n, 1, this._findStartOfWord(e, t, n, o - 1), o) : null;
  }
  static _findStartOfWord(e, t, i, n) {
    const o = t.findPrevIntlWordBeforeOrAtOffset(e, n);
    for (let r = n; r >= 0; r--) {
      const a = e.charCodeAt(r), l = t.get(a);
      if (o && r === o.index)
        return r;
      if (l === 1 || i === 1 && l === 2 || i === 2 && l === 0)
        return r + 1;
    }
    return 0;
  }
  static moveWordLeft(e, t, i, n, o) {
    let r = i.lineNumber, a = i.column;
    a === 1 && r > 1 && (r = r - 1, a = t.getLineMaxColumn(r));
    let l = Jt._findPreviousWordOnLine(e, t, new F(r, a));
    if (n === 0)
      return new F(r, l ? l.start + 1 : 1);
    if (n === 1)
      return !o && l && l.wordType === 2 && l.end - l.start === 1 && l.nextCharClass === 0 && (l = Jt._findPreviousWordOnLine(e, t, new F(r, l.start + 1))), new F(r, l ? l.start + 1 : 1);
    if (n === 3) {
      for (; l && l.wordType === 2; )
        l = Jt._findPreviousWordOnLine(e, t, new F(r, l.start + 1));
      return new F(r, l ? l.start + 1 : 1);
    }
    return l && a <= l.end + 1 && (l = Jt._findPreviousWordOnLine(e, t, new F(r, l.start + 1))), new F(r, l ? l.end + 1 : 1);
  }
  static _moveWordPartLeft(e, t) {
    const i = t.lineNumber, n = e.getLineMaxColumn(i);
    if (t.column === 1)
      return i > 1 ? new F(i - 1, e.getLineMaxColumn(i - 1)) : t;
    const o = e.getLineContent(i);
    for (let r = t.column - 1; r > 1; r--) {
      const a = o.charCodeAt(r - 2), l = o.charCodeAt(r - 1);
      if (a === 95 && l !== 95)
        return new F(i, r);
      if (a === 45 && l !== 45)
        return new F(i, r);
      if ((Gd(a) || n_(a)) && dl(l))
        return new F(i, r);
      if (dl(a) && dl(l) && r + 1 < n) {
        const c = o.charCodeAt(r);
        if (Gd(c) || n_(c))
          return new F(i, r);
      }
    }
    return new F(i, 1);
  }
  static moveWordRight(e, t, i, n) {
    let o = i.lineNumber, r = i.column, a = !1;
    r === t.getLineMaxColumn(o) && o < t.getLineCount() && (a = !0, o = o + 1, r = 1);
    let l = Jt._findNextWordOnLine(e, t, new F(o, r));
    if (n === 2)
      l && l.wordType === 2 && l.end - l.start === 1 && l.nextCharClass === 0 && (l = Jt._findNextWordOnLine(e, t, new F(o, l.end + 1))), l ? r = l.end + 1 : r = t.getLineMaxColumn(o);
    else if (n === 3) {
      for (a && (r = 0); l && (l.wordType === 2 || l.start + 1 <= r); )
        l = Jt._findNextWordOnLine(e, t, new F(o, l.end + 1));
      l ? r = l.start + 1 : r = t.getLineMaxColumn(o);
    } else
      l && !a && r >= l.start + 1 && (l = Jt._findNextWordOnLine(e, t, new F(o, l.end + 1))), l ? r = l.start + 1 : r = t.getLineMaxColumn(o);
    return new F(o, r);
  }
  static _moveWordPartRight(e, t) {
    const i = t.lineNumber, n = e.getLineMaxColumn(i);
    if (t.column === n)
      return i < e.getLineCount() ? new F(i + 1, 1) : t;
    const o = e.getLineContent(i);
    for (let r = t.column + 1; r < n; r++) {
      const a = o.charCodeAt(r - 2), l = o.charCodeAt(r - 1);
      if (a !== 95 && l === 95)
        return new F(i, r);
      if (a !== 45 && l === 45)
        return new F(i, r);
      if ((Gd(a) || n_(a)) && dl(l))
        return new F(i, r);
      if (dl(a) && dl(l) && r + 1 < n) {
        const c = o.charCodeAt(r);
        if (Gd(c) || n_(c))
          return new F(i, r);
      }
    }
    return new F(i, n);
  }
  static _deleteWordLeftWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), n = t.column - 2, o = id(i, n);
    return o + 1 < n ? new T(t.lineNumber, o + 2, t.lineNumber, t.column) : null;
  }
  static deleteWordLeft(e, t) {
    const i = e.wordSeparators, n = e.model, o = e.selection, r = e.whitespaceHeuristics;
    if (!o.isEmpty())
      return o;
    if (jh.isAutoClosingPairDelete(e.autoClosingDelete, e.autoClosingBrackets, e.autoClosingQuotes, e.autoClosingPairs.autoClosingPairsOpenByEnd, e.model, [e.selection], e.autoClosedCharacters)) {
      const d = e.selection.getPosition();
      return new T(d.lineNumber, d.column - 1, d.lineNumber, d.column + 1);
    }
    const a = new F(o.positionLineNumber, o.positionColumn);
    let l = a.lineNumber, c = a.column;
    if (l === 1 && c === 1)
      return null;
    if (r) {
      const d = this._deleteWordLeftWhitespace(n, a);
      if (d)
        return d;
    }
    let h = Jt._findPreviousWordOnLine(i, n, a);
    return t === 0 ? h ? c = h.start + 1 : c > 1 ? c = 1 : (l--, c = n.getLineMaxColumn(l)) : (h && c <= h.end + 1 && (h = Jt._findPreviousWordOnLine(i, n, new F(l, h.start + 1))), h ? c = h.end + 1 : c > 1 ? c = 1 : (l--, c = n.getLineMaxColumn(l))), new T(l, c, a.lineNumber, a.column);
  }
  static deleteInsideWord(e, t, i) {
    if (!i.isEmpty())
      return i;
    const n = new F(i.positionLineNumber, i.positionColumn), o = this._deleteInsideWordWhitespace(t, n);
    return o || this._deleteInsideWordDetermineDeleteRange(e, t, n);
  }
  static _charAtIsWhitespace(e, t) {
    const i = e.charCodeAt(t);
    return i === 32 || i === 9;
  }
  static _deleteInsideWordWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), n = i.length;
    if (n === 0)
      return null;
    let o = Math.max(t.column - 2, 0);
    if (!this._charAtIsWhitespace(i, o))
      return null;
    let r = Math.min(t.column - 1, n - 1);
    if (!this._charAtIsWhitespace(i, r))
      return null;
    for (; o > 0 && this._charAtIsWhitespace(i, o - 1); )
      o--;
    for (; r + 1 < n && this._charAtIsWhitespace(i, r + 1); )
      r++;
    return new T(t.lineNumber, o + 1, t.lineNumber, r + 2);
  }
  static _deleteInsideWordDetermineDeleteRange(e, t, i) {
    const n = t.getLineContent(i.lineNumber), o = n.length;
    if (o === 0)
      return i.lineNumber > 1 ? new T(i.lineNumber - 1, t.getLineMaxColumn(i.lineNumber - 1), i.lineNumber, 1) : i.lineNumber < t.getLineCount() ? new T(i.lineNumber, 1, i.lineNumber + 1, 1) : new T(i.lineNumber, 1, i.lineNumber, 1);
    const r = (d) => d.start + 1 <= i.column && i.column <= d.end + 1, a = (d, u) => (d = Math.min(d, i.column), u = Math.max(u, i.column), new T(i.lineNumber, d, i.lineNumber, u)), l = (d) => {
      let u = d.start + 1, f = d.end + 1, g = !1;
      for (; f - 1 < o && this._charAtIsWhitespace(n, f - 1); )
        g = !0, f++;
      if (!g)
        for (; u > 1 && this._charAtIsWhitespace(n, u - 2); )
          u--;
      return a(u, f);
    }, c = Jt._findPreviousWordOnLine(e, t, i);
    if (c && r(c))
      return l(c);
    const h = Jt._findNextWordOnLine(e, t, i);
    return h && r(h) ? l(h) : c && h ? a(c.end + 1, h.start + 1) : c ? a(c.start + 1, c.end + 1) : h ? a(h.start + 1, h.end + 1) : a(1, o + 1);
  }
  static _deleteWordPartLeft(e, t) {
    if (!t.isEmpty())
      return t;
    const i = t.getPosition(), n = Jt._moveWordPartLeft(e, i);
    return new T(i.lineNumber, i.column, n.lineNumber, n.column);
  }
  static _findFirstNonWhitespaceChar(e, t) {
    const i = e.length;
    for (let n = t; n < i; n++) {
      const o = e.charAt(n);
      if (o !== " " && o !== "	")
        return n;
    }
    return i;
  }
  static _deleteWordRightWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), n = t.column - 1, o = this._findFirstNonWhitespaceChar(i, n);
    return n + 1 < o ? new T(t.lineNumber, t.column, t.lineNumber, o + 1) : null;
  }
  static deleteWordRight(e, t) {
    const i = e.wordSeparators, n = e.model, o = e.selection, r = e.whitespaceHeuristics;
    if (!o.isEmpty())
      return o;
    const a = new F(o.positionLineNumber, o.positionColumn);
    let l = a.lineNumber, c = a.column;
    const h = n.getLineCount(), d = n.getLineMaxColumn(l);
    if (l === h && c === d)
      return null;
    if (r) {
      const f = this._deleteWordRightWhitespace(n, a);
      if (f)
        return f;
    }
    let u = Jt._findNextWordOnLine(i, n, a);
    return t === 2 ? u ? c = u.end + 1 : c < d || l === h ? c = d : (l++, u = Jt._findNextWordOnLine(i, n, new F(l, 1)), u ? c = u.start + 1 : c = n.getLineMaxColumn(l)) : (u && c >= u.start + 1 && (u = Jt._findNextWordOnLine(i, n, new F(l, u.end + 1))), u ? c = u.start + 1 : c < d || l === h ? c = d : (l++, u = Jt._findNextWordOnLine(i, n, new F(l, 1)), u ? c = u.start + 1 : c = n.getLineMaxColumn(l))), new T(l, c, a.lineNumber, a.column);
  }
  static _deleteWordPartRight(e, t) {
    if (!t.isEmpty())
      return t;
    const i = t.getPosition(), n = Jt._moveWordPartRight(e, i);
    return new T(i.lineNumber, i.column, n.lineNumber, n.column);
  }
  static _createWordAtPosition(e, t, i) {
    const n = new T(t, i.start + 1, t, i.end + 1);
    return {
      word: e.getValueInRange(n),
      startColumn: n.startColumn,
      endColumn: n.endColumn
    };
  }
  static getWordAtPosition(e, t, i, n) {
    const o = ff(t, i), r = Jt._findPreviousWordOnLine(o, e, n);
    if (r && r.wordType === 1 && r.start <= n.column - 1 && n.column - 1 <= r.end)
      return Jt._createWordAtPosition(e, n.lineNumber, r);
    const a = Jt._findNextWordOnLine(o, e, n);
    return a && a.wordType === 1 && a.start <= n.column - 1 && n.column - 1 <= a.end ? Jt._createWordAtPosition(e, n.lineNumber, a) : null;
  }
  static word(e, t, i, n, o) {
    const r = ff(e.wordSeparators, e.wordSegmenterLocales), a = Jt._findPreviousWordOnLine(r, t, o), l = Jt._findNextWordOnLine(r, t, o);
    if (!n) {
      let f, g;
      return a && a.wordType === 1 && a.start <= o.column - 1 && o.column - 1 <= a.end ? (f = a.start + 1, g = a.end + 1) : l && l.wordType === 1 && l.start <= o.column - 1 && o.column - 1 <= l.end ? (f = l.start + 1, g = l.end + 1) : (a ? f = a.end + 1 : f = 1, l ? g = l.start + 1 : g = t.getLineMaxColumn(o.lineNumber)), new Ei(new T(o.lineNumber, f, o.lineNumber, g), 1, 0, new F(o.lineNumber, g), 0);
    }
    let c, h;
    a && a.wordType === 1 && a.start < o.column - 1 && o.column - 1 < a.end ? (c = a.start + 1, h = a.end + 1) : l && l.wordType === 1 && l.start < o.column - 1 && o.column - 1 < l.end ? (c = l.start + 1, h = l.end + 1) : (c = o.column, h = o.column);
    const d = o.lineNumber;
    let u;
    if (i.selectionStart.containsPosition(o))
      u = i.selectionStart.endColumn;
    else if (o.isBeforeOrEqual(i.selectionStart.getStartPosition())) {
      u = c;
      const f = new F(d, u);
      i.selectionStart.containsPosition(f) && (u = i.selectionStart.endColumn);
    } else {
      u = h;
      const f = new F(d, u);
      i.selectionStart.containsPosition(f) && (u = i.selectionStart.startColumn);
    }
    return i.move(!0, d, u, 0);
  }
}
class Qi {
  static addCursorDown(e, t, i) {
    const n = [];
    let o = 0;
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      n[o++] = new Ve(l.modelState, l.viewState), i ? n[o++] = Ve.fromModelState(ht.translateDown(e.cursorConfig, e.model, l.modelState)) : n[o++] = Ve.fromViewState(ht.translateDown(e.cursorConfig, e, l.viewState));
    }
    return n;
  }
  static addCursorUp(e, t, i) {
    const n = [];
    let o = 0;
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      n[o++] = new Ve(l.modelState, l.viewState), i ? n[o++] = Ve.fromModelState(ht.translateUp(e.cursorConfig, e.model, l.modelState)) : n[o++] = Ve.fromViewState(ht.translateUp(e.cursorConfig, e, l.viewState));
    }
    return n;
  }
  static moveToBeginningOfLine(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o];
      n[o] = this._moveToLineStart(e, a, i);
    }
    return n;
  }
  static _moveToLineStart(e, t, i) {
    const n = t.viewState.position.column, o = t.modelState.position.column, r = n === o, a = t.viewState.position.lineNumber, l = e.getLineFirstNonWhitespaceColumn(a);
    return !r && !(n === l) ? this._moveToLineStartByView(e, t, i) : this._moveToLineStartByModel(e, t, i);
  }
  static _moveToLineStartByView(e, t, i) {
    return Ve.fromViewState(ht.moveToBeginningOfLine(e.cursorConfig, e, t.viewState, i));
  }
  static _moveToLineStartByModel(e, t, i) {
    return Ve.fromModelState(ht.moveToBeginningOfLine(e.cursorConfig, e.model, t.modelState, i));
  }
  static moveToEndOfLine(e, t, i, n) {
    const o = [];
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      o[r] = this._moveToLineEnd(e, l, i, n);
    }
    return o;
  }
  static _moveToLineEnd(e, t, i, n) {
    const o = t.viewState.position, r = e.getLineMaxColumn(o.lineNumber), a = o.column === r, l = t.modelState.position, c = e.model.getLineMaxColumn(l.lineNumber), h = r - o.column === c - l.column;
    return a || h ? this._moveToLineEndByModel(e, t, i, n) : this._moveToLineEndByView(e, t, i, n);
  }
  static _moveToLineEndByView(e, t, i, n) {
    return Ve.fromViewState(ht.moveToEndOfLine(e.cursorConfig, e, t.viewState, i, n));
  }
  static _moveToLineEndByModel(e, t, i, n) {
    return Ve.fromModelState(ht.moveToEndOfLine(e.cursorConfig, e.model, t.modelState, i, n));
  }
  static expandLineSelection(e, t) {
    const i = [];
    for (let n = 0, o = t.length; n < o; n++) {
      const r = t[n], a = r.modelState.selection.startLineNumber, l = e.model.getLineCount();
      let c = r.modelState.selection.endLineNumber, h;
      c === l ? h = e.model.getLineMaxColumn(l) : (c++, h = 1), i[n] = Ve.fromModelState(new Ei(new T(a, 1, a, 1), 0, 0, new F(c, h), 0));
    }
    return i;
  }
  static moveToBeginningOfBuffer(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o];
      n[o] = Ve.fromModelState(ht.moveToBeginningOfBuffer(e.cursorConfig, e.model, a.modelState, i));
    }
    return n;
  }
  static moveToEndOfBuffer(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o];
      n[o] = Ve.fromModelState(ht.moveToEndOfBuffer(e.cursorConfig, e.model, a.modelState, i));
    }
    return n;
  }
  static selectAll(e, t) {
    const i = e.model.getLineCount(), n = e.model.getLineMaxColumn(i);
    return Ve.fromModelState(new Ei(new T(1, 1, 1, 1), 0, 0, new F(i, n), 0));
  }
  static line(e, t, i, n, o) {
    const r = e.model.validatePosition(n), a = o ? e.coordinatesConverter.validateViewPosition(new F(o.lineNumber, o.column), r) : e.coordinatesConverter.convertModelPositionToViewPosition(r);
    if (!i) {
      const c = e.model.getLineCount();
      let h = r.lineNumber + 1, d = 1;
      return h > c && (h = c, d = e.model.getLineMaxColumn(h)), Ve.fromModelState(new Ei(new T(r.lineNumber, 1, h, d), 2, 0, new F(h, d), 0));
    }
    const l = t.modelState.selectionStart.getStartPosition().lineNumber;
    if (r.lineNumber < l)
      return Ve.fromViewState(t.viewState.move(!0, a.lineNumber, 1, 0));
    if (r.lineNumber > l) {
      const c = e.getLineCount();
      let h = a.lineNumber + 1, d = 1;
      return h > c && (h = c, d = e.getLineMaxColumn(h)), Ve.fromViewState(t.viewState.move(!0, h, d, 0));
    } else {
      const c = t.modelState.selectionStart.getEndPosition();
      return Ve.fromModelState(t.modelState.move(!0, c.lineNumber, c.column, 0));
    }
  }
  static word(e, t, i, n) {
    const o = e.model.validatePosition(n);
    return Ve.fromModelState(Jt.word(e.cursorConfig, e.model, t.modelState, i, o));
  }
  static cancelSelection(e, t) {
    if (!t.modelState.hasSelection())
      return new Ve(t.modelState, t.viewState);
    const i = t.viewState.position.lineNumber, n = t.viewState.position.column;
    return Ve.fromViewState(new Ei(new T(i, n, i, n), 0, 0, new F(i, n), 0));
  }
  static moveTo(e, t, i, n, o) {
    if (i) {
      if (t.modelState.selectionStartKind === 1)
        return this.word(e, t, i, n);
      if (t.modelState.selectionStartKind === 2)
        return this.line(e, t, i, n, o);
    }
    const r = e.model.validatePosition(n), a = o ? e.coordinatesConverter.validateViewPosition(new F(o.lineNumber, o.column), r) : e.coordinatesConverter.convertModelPositionToViewPosition(r);
    return Ve.fromViewState(t.viewState.move(i, a.lineNumber, a.column, 0));
  }
  static simpleMove(e, t, i, n, o, r) {
    switch (i) {
      case 0:
        return r === 4 ? this._moveHalfLineLeft(e, t, n) : this._moveLeft(e, t, n, o);
      case 1:
        return r === 4 ? this._moveHalfLineRight(e, t, n) : this._moveRight(e, t, n, o);
      case 2:
        return r === 2 ? this._moveUpByViewLines(e, t, n, o) : this._moveUpByModelLines(e, t, n, o);
      case 3:
        return r === 2 ? this._moveDownByViewLines(e, t, n, o) : this._moveDownByModelLines(e, t, n, o);
      case 4:
        return r === 2 ? t.map((a) => Ve.fromViewState(ht.moveToPrevBlankLine(e.cursorConfig, e, a.viewState, n))) : t.map((a) => Ve.fromModelState(ht.moveToPrevBlankLine(e.cursorConfig, e.model, a.modelState, n)));
      case 5:
        return r === 2 ? t.map((a) => Ve.fromViewState(ht.moveToNextBlankLine(e.cursorConfig, e, a.viewState, n))) : t.map((a) => Ve.fromModelState(ht.moveToNextBlankLine(e.cursorConfig, e.model, a.modelState, n)));
      case 6:
        return this._moveToViewMinColumn(e, t, n);
      case 7:
        return this._moveToViewFirstNonWhitespaceColumn(e, t, n);
      case 8:
        return this._moveToViewCenterColumn(e, t, n);
      case 9:
        return this._moveToViewMaxColumn(e, t, n);
      case 10:
        return this._moveToViewLastNonWhitespaceColumn(e, t, n);
      default:
        return null;
    }
  }
  static viewportMove(e, t, i, n, o) {
    const r = e.getCompletelyVisibleViewRange(), a = e.coordinatesConverter.convertViewRangeToModelRange(r);
    switch (i) {
      case 11: {
        const l = this._firstLineNumberInRange(e.model, a, o), c = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], n, l, c)];
      }
      case 13: {
        const l = this._lastLineNumberInRange(e.model, a, o), c = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], n, l, c)];
      }
      case 12: {
        const l = Math.round((a.startLineNumber + a.endLineNumber) / 2), c = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], n, l, c)];
      }
      case 14: {
        const l = [];
        for (let c = 0, h = t.length; c < h; c++) {
          const d = t[c];
          l[c] = this.findPositionInViewportIfOutside(e, d, r, n);
        }
        return l;
      }
      default:
        return null;
    }
  }
  static findPositionInViewportIfOutside(e, t, i, n) {
    const o = t.viewState.position.lineNumber;
    if (i.startLineNumber <= o && o <= i.endLineNumber - 1)
      return new Ve(t.modelState, t.viewState);
    {
      let r;
      o > i.endLineNumber - 1 ? r = i.endLineNumber - 1 : o < i.startLineNumber ? r = i.startLineNumber : r = o;
      const a = ht.vertical(e.cursorConfig, e, o, t.viewState.position.column, t.viewState.leftoverVisibleColumns, r, !1);
      return Ve.fromViewState(t.viewState.move(n, a.lineNumber, a.column, a.leftoverVisibleColumns));
    }
  }
  /**
   * Find the nth line start included in the range (from the start).
   */
  static _firstLineNumberInRange(e, t, i) {
    let n = t.startLineNumber;
    return t.startColumn !== e.getLineMinColumn(n) && n++, Math.min(t.endLineNumber, n + i - 1);
  }
  /**
   * Find the nth line start included in the range (from the end).
   */
  static _lastLineNumberInRange(e, t, i) {
    let n = t.startLineNumber;
    return t.startColumn !== e.getLineMinColumn(n) && n++, Math.max(n, t.endLineNumber - i + 1);
  }
  static _moveLeft(e, t, i, n) {
    return t.map((o) => Ve.fromViewState(ht.moveLeft(e.cursorConfig, e, o.viewState, i, n)));
  }
  static _moveHalfLineLeft(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = Math.round(e.getLineLength(l) / 2);
      n[o] = Ve.fromViewState(ht.moveLeft(e.cursorConfig, e, a.viewState, i, c));
    }
    return n;
  }
  static _moveRight(e, t, i, n) {
    return t.map((o) => Ve.fromViewState(ht.moveRight(e.cursorConfig, e, o.viewState, i, n)));
  }
  static _moveHalfLineRight(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = Math.round(e.getLineLength(l) / 2);
      n[o] = Ve.fromViewState(ht.moveRight(e.cursorConfig, e, a.viewState, i, c));
    }
    return n;
  }
  static _moveDownByViewLines(e, t, i, n) {
    const o = [];
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      o[r] = Ve.fromViewState(ht.moveDown(e.cursorConfig, e, l.viewState, i, n));
    }
    return o;
  }
  static _moveDownByModelLines(e, t, i, n) {
    const o = [];
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      o[r] = Ve.fromModelState(ht.moveDown(e.cursorConfig, e.model, l.modelState, i, n));
    }
    return o;
  }
  static _moveUpByViewLines(e, t, i, n) {
    const o = [];
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      o[r] = Ve.fromViewState(ht.moveUp(e.cursorConfig, e, l.viewState, i, n));
    }
    return o;
  }
  static _moveUpByModelLines(e, t, i, n) {
    const o = [];
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      o[r] = Ve.fromModelState(ht.moveUp(e.cursorConfig, e.model, l.modelState, i, n));
    }
    return o;
  }
  static _moveToViewPosition(e, t, i, n, o) {
    return Ve.fromViewState(t.viewState.move(i, n, o, 0));
  }
  static _moveToModelPosition(e, t, i, n, o) {
    return Ve.fromModelState(t.modelState.move(i, n, o, 0));
  }
  static _moveToViewMinColumn(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = e.getLineMinColumn(l);
      n[o] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
  static _moveToViewFirstNonWhitespaceColumn(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = e.getLineFirstNonWhitespaceColumn(l);
      n[o] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
  static _moveToViewCenterColumn(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = Math.round((e.getLineMaxColumn(l) + e.getLineMinColumn(l)) / 2);
      n[o] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
  static _moveToViewMaxColumn(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = e.getLineMaxColumn(l);
      n[o] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
  static _moveToViewLastNonWhitespaceColumn(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = e.getLineLastNonWhitespaceColumn(l);
      n[o] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
}
var b1;
(function(s) {
  const e = function(i) {
    if (!Wi(i))
      return !1;
    const n = i;
    return !(!Ss(n.to) || !As(n.select) && !o4(n.select) || !As(n.by) && !Ss(n.by) || !As(n.value) && !If(n.value));
  };
  s.metadata = {
    description: "Move cursor to a logical position in the view",
    args: [
      {
        name: "Cursor move argument object",
        description: `Property-value pairs that can be passed through this argument:
					* 'to': A mandatory logical position value providing where to move the cursor.
						\`\`\`
						'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',
						'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'
						'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'
						'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'
						\`\`\`
					* 'by': Unit to move. Default is computed based on 'to' value.
						\`\`\`
						'line', 'wrappedLine', 'character', 'halfLine'
						\`\`\`
					* 'value': Number of units to move. Default is '1'.
					* 'select': If 'true' makes the selection. Default is 'false'.
				`,
        constraint: e,
        schema: {
          type: "object",
          required: ["to"],
          properties: {
            to: {
              type: "string",
              enum: ["left", "right", "up", "down", "prevBlankLine", "nextBlankLine", "wrappedLineStart", "wrappedLineEnd", "wrappedLineColumnCenter", "wrappedLineFirstNonWhitespaceCharacter", "wrappedLineLastNonWhitespaceCharacter", "viewPortTop", "viewPortCenter", "viewPortBottom", "viewPortIfOutside"]
            },
            by: {
              type: "string",
              enum: ["line", "wrappedLine", "character", "halfLine"]
            },
            value: {
              type: "number",
              default: 1
            },
            select: {
              type: "boolean",
              default: !1
            }
          }
        }
      }
    ]
  }, s.RawDirection = {
    Left: "left",
    Right: "right",
    Up: "up",
    Down: "down",
    PrevBlankLine: "prevBlankLine",
    NextBlankLine: "nextBlankLine",
    WrappedLineStart: "wrappedLineStart",
    WrappedLineFirstNonWhitespaceCharacter: "wrappedLineFirstNonWhitespaceCharacter",
    WrappedLineColumnCenter: "wrappedLineColumnCenter",
    WrappedLineEnd: "wrappedLineEnd",
    WrappedLineLastNonWhitespaceCharacter: "wrappedLineLastNonWhitespaceCharacter",
    ViewPortTop: "viewPortTop",
    ViewPortCenter: "viewPortCenter",
    ViewPortBottom: "viewPortBottom",
    ViewPortIfOutside: "viewPortIfOutside"
  }, s.RawUnit = {
    Line: "line",
    WrappedLine: "wrappedLine",
    Character: "character",
    HalfLine: "halfLine"
  };
  function t(i) {
    if (!i.to)
      return null;
    let n;
    switch (i.to) {
      case s.RawDirection.Left:
        n = 0;
        break;
      case s.RawDirection.Right:
        n = 1;
        break;
      case s.RawDirection.Up:
        n = 2;
        break;
      case s.RawDirection.Down:
        n = 3;
        break;
      case s.RawDirection.PrevBlankLine:
        n = 4;
        break;
      case s.RawDirection.NextBlankLine:
        n = 5;
        break;
      case s.RawDirection.WrappedLineStart:
        n = 6;
        break;
      case s.RawDirection.WrappedLineFirstNonWhitespaceCharacter:
        n = 7;
        break;
      case s.RawDirection.WrappedLineColumnCenter:
        n = 8;
        break;
      case s.RawDirection.WrappedLineEnd:
        n = 9;
        break;
      case s.RawDirection.WrappedLineLastNonWhitespaceCharacter:
        n = 10;
        break;
      case s.RawDirection.ViewPortTop:
        n = 11;
        break;
      case s.RawDirection.ViewPortBottom:
        n = 13;
        break;
      case s.RawDirection.ViewPortCenter:
        n = 12;
        break;
      case s.RawDirection.ViewPortIfOutside:
        n = 14;
        break;
      default:
        return null;
    }
    let o = 0;
    switch (i.by) {
      case s.RawUnit.Line:
        o = 1;
        break;
      case s.RawUnit.WrappedLine:
        o = 2;
        break;
      case s.RawUnit.Character:
        o = 3;
        break;
      case s.RawUnit.HalfLine:
        o = 4;
        break;
    }
    return {
      direction: n,
      unit: o,
      select: !!i.select,
      value: i.value || 1
    };
  }
  s.parse = t;
})(b1 || (b1 = {}));
var pn;
(function(s) {
  s[s.None = 0] = "None", s[s.Indent = 1] = "Indent", s[s.IndentOutdent = 2] = "IndentOutdent", s[s.Outdent = 3] = "Outdent";
})(pn || (pn = {}));
class O0 {
  constructor(e) {
    if (this._neutralCharacter = null, this._neutralCharacterSearched = !1, this.open = e.open, this.close = e.close, this._inString = !0, this._inComment = !0, this._inRegEx = !0, Array.isArray(e.notIn))
      for (let t = 0, i = e.notIn.length; t < i; t++)
        switch (e.notIn[t]) {
          case "string":
            this._inString = !1;
            break;
          case "comment":
            this._inComment = !1;
            break;
          case "regex":
            this._inRegEx = !1;
            break;
        }
  }
  isOK(e) {
    switch (e) {
      case 0:
        return !0;
      case 1:
        return this._inComment;
      case 2:
        return this._inString;
      case 3:
        return this._inRegEx;
    }
  }
  shouldAutoClose(e, t) {
    if (e.getTokenCount() === 0)
      return !0;
    const i = e.findTokenIndexAtOffset(t - 2), n = e.getStandardTokenType(i);
    return this.isOK(n);
  }
  _findNeutralCharacterInRange(e, t) {
    for (let i = e; i <= t; i++) {
      const n = String.fromCharCode(i);
      if (!this.open.includes(n) && !this.close.includes(n))
        return n;
    }
    return null;
  }
  /**
   * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close
   */
  findNeutralCharacter() {
    return this._neutralCharacterSearched || (this._neutralCharacterSearched = !0, this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(
      48,
      57
      /* CharCode.Digit9 */
    )), this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(
      97,
      122
      /* CharCode.z */
    )), this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(
      65,
      90
      /* CharCode.Z */
    ))), this._neutralCharacter;
  }
}
class JK {
  constructor(e) {
    this.autoClosingPairsOpenByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsOpenByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseSingleChar = /* @__PURE__ */ new Map();
    for (const t of e)
      Jf(this.autoClosingPairsOpenByStart, t.open.charAt(0), t), Jf(this.autoClosingPairsOpenByEnd, t.open.charAt(t.open.length - 1), t), Jf(this.autoClosingPairsCloseByStart, t.close.charAt(0), t), Jf(this.autoClosingPairsCloseByEnd, t.close.charAt(t.close.length - 1), t), t.close.length === 1 && t.open.length === 1 && Jf(this.autoClosingPairsCloseSingleChar, t.close, t);
  }
}
function Jf(s, e, t) {
  s.has(e) ? s.get(e).push(t) : s.set(e, [t]);
}
const yu = class yu {
  constructor(e) {
    if (e.autoClosingPairs ? this._autoClosingPairs = e.autoClosingPairs.map((t) => new O0(t)) : e.brackets ? this._autoClosingPairs = e.brackets.map((t) => new O0({ open: t[0], close: t[1] })) : this._autoClosingPairs = [], e.__electricCharacterSupport && e.__electricCharacterSupport.docComment) {
      const t = e.__electricCharacterSupport.docComment;
      this._autoClosingPairs.push(new O0({ open: t.open, close: t.close || "" }));
    }
    this._autoCloseBeforeForQuotes = typeof e.autoCloseBefore == "string" ? e.autoCloseBefore : yu.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES, this._autoCloseBeforeForBrackets = typeof e.autoCloseBefore == "string" ? e.autoCloseBefore : yu.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS, this._surroundingPairs = e.surroundingPairs || this._autoClosingPairs;
  }
  getAutoClosingPairs() {
    return this._autoClosingPairs;
  }
  getAutoCloseBeforeSet(e) {
    return e ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets;
  }
  getSurroundingPairs() {
    return this._surroundingPairs;
  }
};
yu.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = `;:.,=}])> 
	`, yu.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = `'"\`;:.,=}])> 
	`;
let qS = yu;
class C1 {
  constructor(e, t, i, n, o, r) {
    this._richEditBracketBrand = void 0, this.languageId = e, this.index = t, this.open = i, this.close = n, this.forwardRegex = o, this.reversedRegex = r, this._openSet = C1._toSet(this.open), this._closeSet = C1._toSet(this.close);
  }
  /**
   * Check if the provided `text` is an open bracket in this group.
   */
  isOpen(e) {
    return this._openSet.has(e);
  }
  /**
   * Check if the provided `text` is a close bracket in this group.
   */
  isClose(e) {
    return this._closeSet.has(e);
  }
  static _toSet(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of e)
      t.add(i);
    return t;
  }
}
function ej(s) {
  const e = s.length;
  s = s.map((r) => [r[0].toLowerCase(), r[1].toLowerCase()]);
  const t = [];
  for (let r = 0; r < e; r++)
    t[r] = r;
  const i = (r, a) => {
    const [l, c] = r, [h, d] = a;
    return l === h || l === d || c === h || c === d;
  }, n = (r, a) => {
    const l = Math.min(r, a), c = Math.max(r, a);
    for (let h = 0; h < e; h++)
      t[h] === c && (t[h] = l);
  };
  for (let r = 0; r < e; r++) {
    const a = s[r];
    for (let l = r + 1; l < e; l++) {
      const c = s[l];
      i(a, c) && n(t[r], t[l]);
    }
  }
  const o = [];
  for (let r = 0; r < e; r++) {
    const a = [], l = [];
    for (let c = 0; c < e; c++)
      if (t[c] === r) {
        const [h, d] = s[c];
        a.push(h), l.push(d);
      }
    a.length > 0 && o.push({
      open: a,
      close: l
    });
  }
  return o;
}
class tj {
  constructor(e, t) {
    this._richEditBracketsBrand = void 0;
    const i = ej(t);
    this.brackets = i.map((n, o) => new C1(e, o, n.open, n.close, ij(n.open, n.close, i, o), nj(n.open, n.close, i, o))), this.forwardRegex = sj(this.brackets), this.reversedRegex = oj(this.brackets), this.textIsBracket = {}, this.textIsOpenBracket = {}, this.maxBracketLength = 0;
    for (const n of this.brackets) {
      for (const o of n.open)
        this.textIsBracket[o] = n, this.textIsOpenBracket[o] = !0, this.maxBracketLength = Math.max(this.maxBracketLength, o.length);
      for (const o of n.close)
        this.textIsBracket[o] = n, this.textIsOpenBracket[o] = !1, this.maxBracketLength = Math.max(this.maxBracketLength, o.length);
    }
  }
}
function R5(s, e, t, i) {
  for (let n = 0, o = e.length; n < o; n++) {
    if (n === t)
      continue;
    const r = e[n];
    for (const a of r.open)
      a.indexOf(s) >= 0 && i.push(a);
    for (const a of r.close)
      a.indexOf(s) >= 0 && i.push(a);
  }
}
function A5(s, e) {
  return s.length - e.length;
}
function xw(s) {
  if (s.length <= 1)
    return s;
  const e = [], t = /* @__PURE__ */ new Set();
  for (const i of s)
    t.has(i) || (e.push(i), t.add(i));
  return e;
}
function ij(s, e, t, i) {
  let n = [];
  n = n.concat(s), n = n.concat(e);
  for (let o = 0, r = n.length; o < r; o++)
    R5(n[o], t, i, n);
  return n = xw(n), n.sort(A5), n.reverse(), Vp(n);
}
function nj(s, e, t, i) {
  let n = [];
  n = n.concat(s), n = n.concat(e);
  for (let o = 0, r = n.length; o < r; o++)
    R5(n[o], t, i, n);
  return n = xw(n), n.sort(A5), n.reverse(), Vp(n.map(bI));
}
function sj(s) {
  let e = [];
  for (const t of s) {
    for (const i of t.open)
      e.push(i);
    for (const i of t.close)
      e.push(i);
  }
  return e = xw(e), Vp(e);
}
function oj(s) {
  let e = [];
  for (const t of s) {
    for (const i of t.open)
      e.push(i);
    for (const i of t.close)
      e.push(i);
  }
  return e = xw(e), Vp(e.map(bI));
}
function rj(s) {
  const e = /^[\w ]+$/.test(s);
  return s = za(s), e ? `\\b${s}\\b` : s;
}
function Vp(s, e) {
  const t = `(${s.map(rj).join(")|(")})`;
  return c4(t, !0, e);
}
const bI = /* @__PURE__ */ function() {
  function s(i) {
    const n = new Uint16Array(i.length);
    let o = 0;
    for (let r = i.length - 1; r >= 0; r--)
      n[o++] = i.charCodeAt(r);
    return u5().decode(n);
  }
  let e = null, t = null;
  return function(n) {
    return e !== n && (e = n, t = s(e)), t;
  };
}();
class Ys {
  static _findPrevBracketInText(e, t, i, n) {
    const o = i.match(e);
    if (!o)
      return null;
    const r = i.length - (o.index || 0), a = o[0].length, l = n + r;
    return new T(t, l - a + 1, t, l + 1);
  }
  static findPrevBracketInRange(e, t, i, n, o) {
    const a = bI(i).substring(i.length - o, i.length - n);
    return this._findPrevBracketInText(e, t, a, n);
  }
  static findNextBracketInText(e, t, i, n) {
    const o = i.match(e);
    if (!o)
      return null;
    const r = o.index || 0, a = o[0].length;
    if (a === 0)
      return null;
    const l = n + r;
    return new T(t, l + 1, t, l + 1 + a);
  }
  static findNextBracketInRange(e, t, i, n, o) {
    const r = i.substring(n, o);
    return this.findNextBracketInText(e, t, r, n);
  }
}
class aj {
  constructor(e) {
    this._richEditBrackets = e;
  }
  getElectricCharacters() {
    const e = [];
    if (this._richEditBrackets)
      for (const t of this._richEditBrackets.brackets)
        for (const i of t.close) {
          const n = i.charAt(i.length - 1);
          e.push(n);
        }
    return zh(e);
  }
  onElectricCharacter(e, t, i) {
    if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0)
      return null;
    const n = t.findTokenIndexAtOffset(i - 1);
    if (fr(t.getStandardTokenType(n)))
      return null;
    const o = this._richEditBrackets.reversedRegex, r = t.getLineContent().substring(0, i - 1) + e, a = Ys.findPrevBracketInRange(o, 1, r, 0, r.length);
    if (!a)
      return null;
    const l = r.substring(a.startColumn - 1, a.endColumn - 1).toLowerCase();
    if (this._richEditBrackets.textIsOpenBracket[l])
      return null;
    const h = t.getActualLineContentBefore(a.startColumn - 1);
    return /^\s*$/.test(h) ? {
      matchOpenBracket: l
    } : null;
  }
}
function __(s) {
  return s.global && (s.lastIndex = 0), !0;
}
class lj {
  constructor(e) {
    this._indentationRules = e;
  }
  shouldIncrease(e) {
    return !!(this._indentationRules && this._indentationRules.increaseIndentPattern && __(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(e));
  }
  shouldDecrease(e) {
    return !!(this._indentationRules && this._indentationRules.decreaseIndentPattern && __(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(e));
  }
  shouldIndentNextLine(e) {
    return !!(this._indentationRules && this._indentationRules.indentNextLinePattern && __(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(e));
  }
  shouldIgnore(e) {
    return !!(this._indentationRules && this._indentationRules.unIndentedLinePattern && __(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(e));
  }
  getIndentMetadata(e) {
    let t = 0;
    return this.shouldIncrease(e) && (t += 1), this.shouldDecrease(e) && (t += 2), this.shouldIndentNextLine(e) && (t += 4), this.shouldIgnore(e) && (t += 8), t;
  }
}
class tu {
  constructor(e) {
    e = e || {}, e.brackets = e.brackets || [
      ["(", ")"],
      ["{", "}"],
      ["[", "]"]
    ], this._brackets = [], e.brackets.forEach((t) => {
      const i = tu._createOpenBracketRegExp(t[0]), n = tu._createCloseBracketRegExp(t[1]);
      i && n && this._brackets.push({
        open: t[0],
        openRegExp: i,
        close: t[1],
        closeRegExp: n
      });
    }), this._regExpRules = e.onEnterRules || [];
  }
  onEnter(e, t, i, n) {
    if (e >= 3)
      for (let o = 0, r = this._regExpRules.length; o < r; o++) {
        const a = this._regExpRules[o];
        if ([{
          reg: a.beforeText,
          text: i
        }, {
          reg: a.afterText,
          text: n
        }, {
          reg: a.previousLineText,
          text: t
        }].every((c) => c.reg ? (c.reg.lastIndex = 0, c.reg.test(c.text)) : !0))
          return a.action;
      }
    if (e >= 2 && i.length > 0 && n.length > 0)
      for (let o = 0, r = this._brackets.length; o < r; o++) {
        const a = this._brackets[o];
        if (a.openRegExp.test(i) && a.closeRegExp.test(n))
          return { indentAction: pn.IndentOutdent };
      }
    if (e >= 2 && i.length > 0) {
      for (let o = 0, r = this._brackets.length; o < r; o++)
        if (this._brackets[o].openRegExp.test(i))
          return { indentAction: pn.Indent };
    }
    return null;
  }
  static _createOpenBracketRegExp(e) {
    let t = za(e);
    return /\B/.test(t.charAt(0)) || (t = "\\b" + t), t += "\\s*$", tu._safeRegExp(t);
  }
  static _createCloseBracketRegExp(e) {
    let t = za(e);
    return /\B/.test(t.charAt(t.length - 1)) || (t = t + "\\b"), t = "^\\s*" + t, tu._safeRegExp(t);
  }
  static _safeRegExp(e) {
    try {
      return new RegExp(e);
    } catch (t) {
      return Je(t), null;
    }
  }
}
const gt = Be("configurationService");
function GS(s, e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const i in s)
    P5(t, i, s[i], e);
  return t;
}
function P5(s, e, t, i) {
  const n = e.split("."), o = n.pop();
  let r = s;
  for (let a = 0; a < n.length; a++) {
    const l = n[a];
    let c = r[l];
    switch (typeof c) {
      case "undefined":
        c = r[l] = /* @__PURE__ */ Object.create(null);
        break;
      case "object":
        if (c === null) {
          i(`Ignoring ${e} as ${n.slice(0, a + 1).join(".")} is null`);
          return;
        }
        break;
      default:
        i(`Ignoring ${e} as ${n.slice(0, a + 1).join(".")} is ${JSON.stringify(c)}`);
        return;
    }
    r = c;
  }
  if (typeof r == "object" && r !== null)
    try {
      r[o] = t;
    } catch {
      i(`Ignoring ${e} as ${n.join(".")} is ${JSON.stringify(r)}`);
    }
  else
    i(`Ignoring ${e} as ${n.join(".")} is ${JSON.stringify(r)}`);
}
function cj(s, e) {
  const t = e.split(".");
  O5(s, t);
}
function O5(s, e) {
  const t = e.shift();
  if (e.length === 0) {
    delete s[t];
    return;
  }
  if (Object.keys(s).indexOf(t) !== -1) {
    const i = s[t];
    typeof i == "object" && !Array.isArray(i) && (O5(i, e), Object.keys(i).length === 0 && delete s[t]);
  }
}
function HT(s, e, t) {
  function i(r, a) {
    let l = r;
    for (const c of a) {
      if (typeof l != "object" || l === null)
        return;
      l = l[c];
    }
    return l;
  }
  const n = e.split("."), o = i(s, n);
  return typeof o > "u" ? t : o;
}
function hj(s) {
  return s.replace(/[\[\]]/g, "");
}
const hd = {
  Configuration: "base.contributions.configuration"
}, b_ = "vscode://schemas/settings/resourceLanguage", VT = Mi.as(gw.JSONContribution);
class dj {
  constructor() {
    this.registeredConfigurationDefaults = [], this.overrideIdentifiers = /* @__PURE__ */ new Set(), this._onDidSchemaChange = new A(), this._onDidUpdateConfiguration = new A(), this.configurationDefaultsOverrides = /* @__PURE__ */ new Map(), this.defaultLanguageConfigurationOverridesNode = {
      id: "defaultOverrides",
      title: m("defaultLanguageConfigurationOverrides.title", "Default Language Configuration Overrides"),
      properties: {}
    }, this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode], this.resourceLanguageSettingsSchema = {
      properties: {},
      patternProperties: {},
      additionalProperties: !0,
      allowTrailingCommas: !0,
      allowComments: !0
    }, this.configurationProperties = {}, this.policyConfigurations = /* @__PURE__ */ new Map(), this.excludedConfigurationProperties = {}, VT.registerSchema(b_, this.resourceLanguageSettingsSchema), this.registerOverridePropertyPatternKey();
  }
  registerConfiguration(e, t = !0) {
    this.registerConfigurations([e], t);
  }
  registerConfigurations(e, t = !0) {
    const i = /* @__PURE__ */ new Set();
    this.doRegisterConfigurations(e, t, i), VT.registerSchema(b_, this.resourceLanguageSettingsSchema), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: i });
  }
  registerDefaultConfigurations(e) {
    const t = /* @__PURE__ */ new Set();
    this.doRegisterDefaultConfigurations(e, t), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: t, defaultsOverrides: !0 });
  }
  doRegisterDefaultConfigurations(e, t) {
    this.registeredConfigurationDefaults.push(...e);
    const i = [];
    for (const { overrides: n, source: o } of e)
      for (const r in n) {
        t.add(r);
        const a = this.configurationDefaultsOverrides.get(r) ?? this.configurationDefaultsOverrides.set(r, { configurationDefaultOverrides: [] }).get(r), l = n[r];
        if (a.configurationDefaultOverrides.push({ value: l, source: o }), Yl.test(r)) {
          const c = this.mergeDefaultConfigurationsForOverrideIdentifier(r, l, o, a.configurationDefaultOverrideValue);
          if (!c)
            continue;
          a.configurationDefaultOverrideValue = c, this.updateDefaultOverrideProperty(r, c, o), i.push(...v1(r));
        } else {
          const c = this.mergeDefaultConfigurationsForConfigurationProperty(r, l, o, a.configurationDefaultOverrideValue);
          if (!c)
            continue;
          a.configurationDefaultOverrideValue = c;
          const h = this.configurationProperties[r];
          h && (this.updatePropertyDefaultValue(r, h), this.updateSchema(r, h));
        }
      }
    this.doRegisterOverrideIdentifiers(i);
  }
  updateDefaultOverrideProperty(e, t, i) {
    const n = {
      type: "object",
      default: t.value,
      description: m("defaultLanguageConfiguration.description", "Configure settings to be overridden for the {0} language.", hj(e)),
      $ref: b_,
      defaultDefaultValue: t.value,
      source: i,
      defaultValueSource: i
    };
    this.configurationProperties[e] = n, this.defaultLanguageConfigurationOverridesNode.properties[e] = n;
  }
  mergeDefaultConfigurationsForOverrideIdentifier(e, t, i, n) {
    const o = (n == null ? void 0 : n.value) || {}, r = (n == null ? void 0 : n.source) ?? /* @__PURE__ */ new Map();
    if (!(r instanceof Map)) {
      console.error("objectConfigurationSources is not a Map");
      return;
    }
    for (const a of Object.keys(t)) {
      const l = t[a];
      if (Wi(l) && (As(o[a]) || Wi(o[a]))) {
        if (o[a] = { ...o[a] ?? {}, ...l }, i)
          for (const h in l)
            r.set(`${a}.${h}`, i);
      } else
        o[a] = l, i ? r.set(a, i) : r.delete(a);
    }
    return { value: o, source: r };
  }
  mergeDefaultConfigurationsForConfigurationProperty(e, t, i, n) {
    const o = this.configurationProperties[e], r = (n == null ? void 0 : n.value) ?? (o == null ? void 0 : o.defaultDefaultValue);
    let a = i;
    if (Wi(t) && (o !== void 0 && o.type === "object" || o === void 0 && (As(r) || Wi(r)))) {
      if (a = (n == null ? void 0 : n.source) ?? /* @__PURE__ */ new Map(), !(a instanceof Map)) {
        console.error("defaultValueSource is not a Map");
        return;
      }
      for (const c in t)
        i && a.set(`${e}.${c}`, i);
      t = { ...Wi(r) ? r : {}, ...t };
    }
    return { value: t, source: a };
  }
  registerOverrideIdentifiers(e) {
    this.doRegisterOverrideIdentifiers(e), this._onDidSchemaChange.fire();
  }
  doRegisterOverrideIdentifiers(e) {
    for (const t of e)
      this.overrideIdentifiers.add(t);
    this.updateOverridePropertyPatternKey();
  }
  doRegisterConfigurations(e, t, i) {
    e.forEach((n) => {
      this.validateAndRegisterProperties(n, t, n.extensionInfo, n.restrictedProperties, void 0, i), this.configurationContributors.push(n), this.registerJSONConfiguration(n);
    });
  }
  validateAndRegisterProperties(e, t = !0, i, n, o = 3, r) {
    var c;
    o = ms(e.scope) ? o : e.scope;
    const a = e.properties;
    if (a)
      for (const h in a) {
        const d = a[h];
        if (t && gj(h, d)) {
          delete a[h];
          continue;
        }
        if (d.source = i, d.defaultDefaultValue = a[h].default, this.updatePropertyDefaultValue(h, d), Yl.test(h) ? d.scope = void 0 : (d.scope = ms(d.scope) ? o : d.scope, d.restricted = ms(d.restricted) ? !!(n != null && n.includes(h)) : d.restricted), a[h].hasOwnProperty("included") && !a[h].included) {
          this.excludedConfigurationProperties[h] = a[h], delete a[h];
          continue;
        } else
          this.configurationProperties[h] = a[h], (c = a[h].policy) != null && c.name && this.policyConfigurations.set(a[h].policy.name, h);
        !a[h].deprecationMessage && a[h].markdownDeprecationMessage && (a[h].deprecationMessage = a[h].markdownDeprecationMessage), r.add(h);
      }
    const l = e.allOf;
    if (l)
      for (const h of l)
        this.validateAndRegisterProperties(h, t, i, n, o, r);
  }
  getConfigurationProperties() {
    return this.configurationProperties;
  }
  getPolicyConfigurations() {
    return this.policyConfigurations;
  }
  registerJSONConfiguration(e) {
    const t = (i) => {
      const n = i.properties;
      if (n)
        for (const r in n)
          this.updateSchema(r, n[r]);
      const o = i.allOf;
      o == null || o.forEach(t);
    };
    t(e);
  }
  updateSchema(e, t) {
    switch (t.scope) {
      case 1:
        break;
      case 2:
        break;
      case 6:
        break;
      case 3:
        break;
      case 4:
        break;
      case 5:
        this.resourceLanguageSettingsSchema.properties[e] = t;
        break;
    }
  }
  updateOverridePropertyPatternKey() {
    for (const e of this.overrideIdentifiers.values()) {
      const t = `[${e}]`, i = {
        type: "object",
        description: m("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."),
        errorMessage: m("overrideSettings.errorMessage", "This setting does not support per-language configuration."),
        $ref: b_
      };
      this.updatePropertyDefaultValue(t, i);
    }
  }
  registerOverridePropertyPatternKey() {
    m("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."), m("overrideSettings.errorMessage", "This setting does not support per-language configuration."), this._onDidSchemaChange.fire();
  }
  updatePropertyDefaultValue(e, t) {
    var r;
    const i = (r = this.configurationDefaultsOverrides.get(e)) == null ? void 0 : r.configurationDefaultOverrideValue;
    let n, o;
    i && (!t.disallowConfigurationDefault || !i.source) && (n = i.value, o = i.source), As(n) && (n = t.defaultDefaultValue, o = void 0), As(n) && (n = fj(t.type)), t.default = n, t.defaultValueSource = o;
  }
}
const F5 = "\\[([^\\]]+)\\]", zT = new RegExp(F5, "g"), uj = `^(${F5})+$`, Yl = new RegExp(uj);
function v1(s) {
  const e = [];
  if (Yl.test(s)) {
    let t = zT.exec(s);
    for (; t != null && t.length; ) {
      const i = t[1].trim();
      i && e.push(i), t = zT.exec(s);
    }
  }
  return zh(e);
}
function fj(s) {
  switch (Array.isArray(s) ? s[0] : s) {
    case "boolean":
      return !1;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "array":
      return [];
    case "object":
      return {};
    default:
      return null;
  }
}
const lb = new dj();
Mi.add(hd.Configuration, lb);
function gj(s, e) {
  var t, i, n, o;
  return s.trim() ? Yl.test(s) ? m("config.property.languageDefault", "Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.", s) : lb.getConfigurationProperties()[s] !== void 0 ? m("config.property.duplicate", "Cannot register '{0}'. This property is already registered.", s) : (t = e.policy) != null && t.name && lb.getPolicyConfigurations().get((i = e.policy) == null ? void 0 : i.name) !== void 0 ? m("config.policy.duplicate", "Cannot register '{0}'. The associated policy {1} is already registered with {2}.", s, (n = e.policy) == null ? void 0 : n.name, lb.getPolicyConfigurations().get((o = e.policy) == null ? void 0 : o.name)) : null : m("config.property.empty", "Cannot register an empty property");
}
const mj = {
  ModesRegistry: "editor.modesRegistry"
};
class pj {
  constructor() {
    this._onDidChangeLanguages = new A(), this.onDidChangeLanguages = this._onDidChangeLanguages.event, this._languages = [];
  }
  registerLanguage(e) {
    return this._languages.push(e), this._onDidChangeLanguages.fire(void 0), {
      dispose: () => {
        for (let t = 0, i = this._languages.length; t < i; t++)
          if (this._languages[t] === e) {
            this._languages.splice(t, 1);
            return;
          }
      }
    };
  }
  getLanguages() {
    return this._languages;
  }
}
const gf = new pj();
Mi.add(mj.ModesRegistry, gf);
const Fs = "plaintext", _j = ".txt";
gf.registerLanguage({
  id: Fs,
  extensions: [_j],
  aliases: [m("plainText.alias", "Plain Text"), "text"],
  mimetypes: [wa.text]
});
Mi.as(hd.Configuration).registerDefaultConfigurations([{
  overrides: {
    "[plaintext]": {
      "editor.unicodeHighlight.ambiguousCharacters": !1,
      "editor.unicodeHighlight.invisibleCharacters": !1
    }
  }
}]);
class bj {
  constructor(e, t) {
    this.languageId = e;
    const i = t.brackets ? UT(t.brackets) : [], n = new f2((a) => {
      const l = /* @__PURE__ */ new Set();
      return {
        info: new Cj(this, a, l),
        closing: l
      };
    }), o = new f2((a) => {
      const l = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
      return {
        info: new vj(this, a, l, c),
        opening: l,
        openingColorized: c
      };
    });
    for (const [a, l] of i) {
      const c = n.get(a), h = o.get(l);
      c.closing.add(h.info), h.opening.add(c.info);
    }
    const r = t.colorizedBracketPairs ? UT(t.colorizedBracketPairs) : i.filter((a) => !(a[0] === "<" && a[1] === ">"));
    for (const [a, l] of r) {
      const c = n.get(a), h = o.get(l);
      c.closing.add(h.info), h.openingColorized.add(c.info), h.opening.add(c.info);
    }
    this._openingBrackets = new Map([...n.cachedValues].map(([a, l]) => [a, l.info])), this._closingBrackets = new Map([...o.cachedValues].map(([a, l]) => [a, l.info]));
  }
  /**
   * No two brackets have the same bracket text.
  */
  get openingBrackets() {
    return [...this._openingBrackets.values()];
  }
  /**
   * No two brackets have the same bracket text.
  */
  get closingBrackets() {
    return [...this._closingBrackets.values()];
  }
  getOpeningBracketInfo(e) {
    return this._openingBrackets.get(e);
  }
  getClosingBracketInfo(e) {
    return this._closingBrackets.get(e);
  }
  getBracketInfo(e) {
    return this.getOpeningBracketInfo(e) || this.getClosingBracketInfo(e);
  }
  getBracketRegExp(e) {
    const t = Array.from([...this._openingBrackets.keys(), ...this._closingBrackets.keys()]);
    return Vp(t, e);
  }
}
function UT(s) {
  return s.filter(([e, t]) => e !== "" && t !== "");
}
class B5 {
  constructor(e, t) {
    this.config = e, this.bracketText = t;
  }
  get languageId() {
    return this.config.languageId;
  }
}
class Cj extends B5 {
  constructor(e, t, i) {
    super(e, t), this.openedBrackets = i, this.isOpeningBracket = !0;
  }
}
class vj extends B5 {
  constructor(e, t, i, n) {
    super(e, t), this.openingBrackets = i, this.openingColorizedBrackets = n, this.isOpeningBracket = !1;
  }
  /**
   * Checks if this bracket closes the given other bracket.
   * If the bracket infos come from different configurations, this method will return false.
  */
  closes(e) {
    return e.config !== this.config ? !1 : this.openingBrackets.has(e);
  }
  closesColorized(e) {
    return e.config !== this.config ? !1 : this.openingColorizedBrackets.has(e);
  }
  getOpeningBrackets() {
    return [...this.openingBrackets];
  }
}
var wj = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, $T = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class F0 {
  constructor(e) {
    this.languageId = e;
  }
  affects(e) {
    return this.languageId ? this.languageId === e : !0;
  }
}
const ir = Be("languageConfigurationService");
let ZS = class extends U {
  constructor(e, t) {
    super(), this.configurationService = e, this.languageService = t, this._registry = this._register(new kj()), this.onDidChangeEmitter = this._register(new A()), this.onDidChange = this.onDidChangeEmitter.event, this.configurations = /* @__PURE__ */ new Map();
    const i = new Set(Object.values(YS));
    this._register(this.configurationService.onDidChangeConfiguration((n) => {
      const o = n.change.keys.some((a) => i.has(a)), r = n.change.overrides.filter(([a, l]) => l.some((c) => i.has(c))).map(([a]) => a);
      if (o)
        this.configurations.clear(), this.onDidChangeEmitter.fire(new F0(void 0));
      else
        for (const a of r)
          this.languageService.isRegisteredLanguageId(a) && (this.configurations.delete(a), this.onDidChangeEmitter.fire(new F0(a)));
    })), this._register(this._registry.onDidChange((n) => {
      this.configurations.delete(n.languageId), this.onDidChangeEmitter.fire(new F0(n.languageId));
    }));
  }
  register(e, t, i) {
    return this._registry.register(e, t, i);
  }
  getLanguageConfiguration(e) {
    let t = this.configurations.get(e);
    return t || (t = yj(e, this._registry, this.configurationService, this.languageService), this.configurations.set(e, t)), t;
  }
};
ZS = wj([
  $T(0, gt),
  $T(1, ci)
], ZS);
function yj(s, e, t, i) {
  let n = e.getLanguageConfiguration(s);
  if (!n) {
    if (!i.isRegisteredLanguageId(s))
      return new Ou(s, {});
    n = new Ou(s, {});
  }
  const o = Sj(n.languageId, t), r = H5([n.underlyingConfig, o]);
  return new Ou(n.languageId, r);
}
const YS = {
  brackets: "editor.language.brackets",
  colorizedBracketPairs: "editor.language.colorizedBracketPairs"
};
function Sj(s, e) {
  const t = e.getValue(YS.brackets, {
    overrideIdentifier: s
  }), i = e.getValue(YS.colorizedBracketPairs, {
    overrideIdentifier: s
  });
  return {
    brackets: KT(t),
    colorizedBracketPairs: KT(i)
  };
}
function KT(s) {
  if (Array.isArray(s))
    return s.map((e) => {
      if (!(!Array.isArray(e) || e.length !== 2))
        return [e[0], e[1]];
    }).filter((e) => !!e);
}
function W5(s, e, t) {
  const i = s.getLineContent(e);
  let n = gn(i);
  return n.length > t - 1 && (n = n.substring(0, t - 1)), n;
}
class Lj {
  constructor(e) {
    this.languageId = e, this._resolved = null, this._entries = [], this._order = 0, this._resolved = null;
  }
  register(e, t) {
    const i = new jT(e, t, ++this._order);
    return this._entries.push(i), this._resolved = null, _e(() => {
      for (let n = 0; n < this._entries.length; n++)
        if (this._entries[n] === i) {
          this._entries.splice(n, 1), this._resolved = null;
          break;
        }
    });
  }
  getResolvedConfiguration() {
    if (!this._resolved) {
      const e = this._resolve();
      e && (this._resolved = new Ou(this.languageId, e));
    }
    return this._resolved;
  }
  _resolve() {
    return this._entries.length === 0 ? null : (this._entries.sort(jT.cmp), H5(this._entries.map((e) => e.configuration)));
  }
}
function H5(s) {
  let e = {
    comments: void 0,
    brackets: void 0,
    wordPattern: void 0,
    indentationRules: void 0,
    onEnterRules: void 0,
    autoClosingPairs: void 0,
    surroundingPairs: void 0,
    autoCloseBefore: void 0,
    folding: void 0,
    colorizedBracketPairs: void 0,
    __electricCharacterSupport: void 0
  };
  for (const t of s)
    e = {
      comments: t.comments || e.comments,
      brackets: t.brackets || e.brackets,
      wordPattern: t.wordPattern || e.wordPattern,
      indentationRules: t.indentationRules || e.indentationRules,
      onEnterRules: t.onEnterRules || e.onEnterRules,
      autoClosingPairs: t.autoClosingPairs || e.autoClosingPairs,
      surroundingPairs: t.surroundingPairs || e.surroundingPairs,
      autoCloseBefore: t.autoCloseBefore || e.autoCloseBefore,
      folding: t.folding || e.folding,
      colorizedBracketPairs: t.colorizedBracketPairs || e.colorizedBracketPairs,
      __electricCharacterSupport: t.__electricCharacterSupport || e.__electricCharacterSupport
    };
  return e;
}
class jT {
  constructor(e, t, i) {
    this.configuration = e, this.priority = t, this.order = i;
  }
  static cmp(e, t) {
    return e.priority === t.priority ? e.order - t.order : e.priority - t.priority;
  }
}
class qT {
  constructor(e) {
    this.languageId = e;
  }
}
class kj extends U {
  constructor() {
    super(), this._entries = /* @__PURE__ */ new Map(), this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, this._register(this.register(Fs, {
      brackets: [
        ["(", ")"],
        ["[", "]"],
        ["{", "}"]
      ],
      surroundingPairs: [
        { open: "{", close: "}" },
        { open: "[", close: "]" },
        { open: "(", close: ")" },
        { open: "<", close: ">" },
        { open: '"', close: '"' },
        { open: "'", close: "'" },
        { open: "`", close: "`" }
      ],
      colorizedBracketPairs: [],
      folding: {
        offSide: !0
      }
    }, 0));
  }
  /**
   * @param priority Use a higher number for higher priority
   */
  register(e, t, i = 0) {
    let n = this._entries.get(e);
    n || (n = new Lj(e), this._entries.set(e, n));
    const o = n.register(t, i);
    return this._onDidChange.fire(new qT(e)), _e(() => {
      o.dispose(), this._onDidChange.fire(new qT(e));
    });
  }
  getLanguageConfiguration(e) {
    const t = this._entries.get(e);
    return (t == null ? void 0 : t.getResolvedConfiguration()) || null;
  }
}
class Ou {
  constructor(e, t) {
    this.languageId = e, this.underlyingConfig = t, this._brackets = null, this._electricCharacter = null, this._onEnterSupport = this.underlyingConfig.brackets || this.underlyingConfig.indentationRules || this.underlyingConfig.onEnterRules ? new tu(this.underlyingConfig) : null, this.comments = Ou._handleComments(this.underlyingConfig), this.characterPair = new qS(this.underlyingConfig), this.wordDefinition = this.underlyingConfig.wordPattern || tI, this.indentationRules = this.underlyingConfig.indentationRules, this.underlyingConfig.indentationRules ? this.indentRulesSupport = new lj(this.underlyingConfig.indentationRules) : this.indentRulesSupport = null, this.foldingRules = this.underlyingConfig.folding || {}, this.bracketsNew = new bj(e, this.underlyingConfig);
  }
  getWordDefinition() {
    return iI(this.wordDefinition);
  }
  get brackets() {
    return !this._brackets && this.underlyingConfig.brackets && (this._brackets = new tj(this.languageId, this.underlyingConfig.brackets)), this._brackets;
  }
  get electricCharacter() {
    return this._electricCharacter || (this._electricCharacter = new aj(this.brackets)), this._electricCharacter;
  }
  onEnter(e, t, i, n) {
    return this._onEnterSupport ? this._onEnterSupport.onEnter(e, t, i, n) : null;
  }
  getAutoClosingPairs() {
    return new JK(this.characterPair.getAutoClosingPairs());
  }
  getAutoCloseBeforeSet(e) {
    return this.characterPair.getAutoCloseBeforeSet(e);
  }
  getSurroundingPairs() {
    return this.characterPair.getSurroundingPairs();
  }
  static _handleComments(e) {
    const t = e.comments;
    if (!t)
      return null;
    const i = {};
    if (t.lineComment && (i.lineCommentToken = t.lineComment), t.blockComment) {
      const [n, o] = t.blockComment;
      i.blockCommentStartToken = n, i.blockCommentEndToken = o;
    }
    return i;
  }
}
Ze(
  ir,
  ZS,
  1
  /* InstantiationType.Delayed */
);
class Bo {
  static getLanguageId(e) {
    return (e & 255) >>> 0;
  }
  static getTokenType(e) {
    return (e & 768) >>> 8;
  }
  static containsBalancedBrackets(e) {
    return (e & 1024) !== 0;
  }
  static getFontStyle(e) {
    return (e & 30720) >>> 11;
  }
  static getForeground(e) {
    return (e & 16744448) >>> 15;
  }
  static getBackground(e) {
    return (e & 4278190080) >>> 24;
  }
  static getClassNameFromMetadata(e) {
    let i = "mtk" + this.getForeground(e);
    const n = this.getFontStyle(e);
    return n & 1 && (i += " mtki"), n & 2 && (i += " mtkb"), n & 4 && (i += " mtku"), n & 8 && (i += " mtks"), i;
  }
  static getInlineStyleFromMetadata(e, t) {
    const i = this.getForeground(e), n = this.getFontStyle(e);
    let o = `color: ${t[i]};`;
    n & 1 && (o += "font-style: italic;"), n & 2 && (o += "font-weight: bold;");
    let r = "";
    return n & 4 && (r += " underline"), n & 8 && (r += " line-through"), r && (o += `text-decoration:${r};`), o;
  }
  static getPresentationFromMetadata(e) {
    const t = this.getForeground(e), i = this.getFontStyle(e);
    return {
      foreground: t,
      italic: !!(i & 1),
      bold: !!(i & 2),
      underline: !!(i & 4),
      strikethrough: !!(i & 8)
    };
  }
}
const ua = class ua {
  static createEmpty(e, t) {
    const i = ua.defaultTokenMetadata, n = new Uint32Array(2);
    return n[0] = e.length, n[1] = i, new ua(n, e, t);
  }
  static createFromTextAndMetadata(e, t) {
    let i = 0, n = "";
    const o = new Array();
    for (const { text: r, metadata: a } of e)
      o.push(i + r.length, a), i += r.length, n += r;
    return new ua(new Uint32Array(o), n, t);
  }
  constructor(e, t, i) {
    this._lineTokensBrand = void 0, this._tokens = e, this._tokensCount = this._tokens.length >>> 1, this._text = t, this.languageIdCodec = i;
  }
  equals(e) {
    return e instanceof ua ? this.slicedEquals(e, 0, this._tokensCount) : !1;
  }
  slicedEquals(e, t, i) {
    if (this._text !== e._text || this._tokensCount !== e._tokensCount)
      return !1;
    const n = t << 1, o = n + (i << 1);
    for (let r = n; r < o; r++)
      if (this._tokens[r] !== e._tokens[r])
        return !1;
    return !0;
  }
  getLineContent() {
    return this._text;
  }
  getCount() {
    return this._tokensCount;
  }
  getStartOffset(e) {
    return e > 0 ? this._tokens[e - 1 << 1] : 0;
  }
  getMetadata(e) {
    return this._tokens[(e << 1) + 1];
  }
  getLanguageId(e) {
    const t = this._tokens[(e << 1) + 1], i = Bo.getLanguageId(t);
    return this.languageIdCodec.decodeLanguageId(i);
  }
  getStandardTokenType(e) {
    const t = this._tokens[(e << 1) + 1];
    return Bo.getTokenType(t);
  }
  getForeground(e) {
    const t = this._tokens[(e << 1) + 1];
    return Bo.getForeground(t);
  }
  getClassName(e) {
    const t = this._tokens[(e << 1) + 1];
    return Bo.getClassNameFromMetadata(t);
  }
  getInlineStyle(e, t) {
    const i = this._tokens[(e << 1) + 1];
    return Bo.getInlineStyleFromMetadata(i, t);
  }
  getPresentation(e) {
    const t = this._tokens[(e << 1) + 1];
    return Bo.getPresentationFromMetadata(t);
  }
  getEndOffset(e) {
    return this._tokens[e << 1];
  }
  /**
   * Find the token containing offset `offset`.
   * @param offset The search offset
   * @return The index of the token containing the offset.
   */
  findTokenIndexAtOffset(e) {
    return ua.findIndexInTokensArray(this._tokens, e);
  }
  inflate() {
    return this;
  }
  sliceAndInflate(e, t, i) {
    return new CI(this, e, t, i);
  }
  static convertToEndOffset(e, t) {
    const n = (e.length >>> 1) - 1;
    for (let o = 0; o < n; o++)
      e[o << 1] = e[o + 1 << 1];
    e[n << 1] = t;
  }
  static findIndexInTokensArray(e, t) {
    if (e.length <= 2)
      return 0;
    let i = 0, n = (e.length >>> 1) - 1;
    for (; i < n; ) {
      const o = i + Math.floor((n - i) / 2), r = e[o << 1];
      if (r === t)
        return o + 1;
      r < t ? i = o + 1 : r > t && (n = o);
    }
    return i;
  }
  /**
   * @pure
   * @param insertTokens Must be sorted by offset.
  */
  withInserted(e) {
    if (e.length === 0)
      return this;
    let t = 0, i = 0, n = "";
    const o = new Array();
    let r = 0;
    for (; ; ) {
      const a = t < this._tokensCount ? this._tokens[t << 1] : -1, l = i < e.length ? e[i] : null;
      if (a !== -1 && (l === null || a <= l.offset)) {
        n += this._text.substring(r, a);
        const c = this._tokens[(t << 1) + 1];
        o.push(n.length, c), t++, r = a;
      } else if (l) {
        if (l.offset > r) {
          n += this._text.substring(r, l.offset);
          const c = this._tokens[(t << 1) + 1];
          o.push(n.length, c), r = l.offset;
        }
        n += l.text, o.push(n.length, l.tokenMetadata), i++;
      } else
        break;
    }
    return new ua(new Uint32Array(o), n, this.languageIdCodec);
  }
  getTokenText(e) {
    const t = this.getStartOffset(e), i = this.getEndOffset(e);
    return this._text.substring(t, i);
  }
  forEach(e) {
    const t = this.getCount();
    for (let i = 0; i < t; i++)
      e(i);
  }
};
ua.defaultTokenMetadata = (32768 | 2 << 24) >>> 0;
let Ti = ua;
class CI {
  constructor(e, t, i, n) {
    this._source = e, this._startOffset = t, this._endOffset = i, this._deltaOffset = n, this._firstTokenIndex = e.findTokenIndexAtOffset(t), this.languageIdCodec = e.languageIdCodec, this._tokensCount = 0;
    for (let o = this._firstTokenIndex, r = e.getCount(); o < r && !(e.getStartOffset(o) >= i); o++)
      this._tokensCount++;
  }
  getMetadata(e) {
    return this._source.getMetadata(this._firstTokenIndex + e);
  }
  getLanguageId(e) {
    return this._source.getLanguageId(this._firstTokenIndex + e);
  }
  getLineContent() {
    return this._source.getLineContent().substring(this._startOffset, this._endOffset);
  }
  equals(e) {
    return e instanceof CI ? this._startOffset === e._startOffset && this._endOffset === e._endOffset && this._deltaOffset === e._deltaOffset && this._source.slicedEquals(e._source, this._firstTokenIndex, this._tokensCount) : !1;
  }
  getCount() {
    return this._tokensCount;
  }
  getStandardTokenType(e) {
    return this._source.getStandardTokenType(this._firstTokenIndex + e);
  }
  getForeground(e) {
    return this._source.getForeground(this._firstTokenIndex + e);
  }
  getEndOffset(e) {
    const t = this._source.getEndOffset(this._firstTokenIndex + e);
    return Math.min(this._endOffset, t) - this._startOffset + this._deltaOffset;
  }
  getClassName(e) {
    return this._source.getClassName(this._firstTokenIndex + e);
  }
  getInlineStyle(e, t) {
    return this._source.getInlineStyle(this._firstTokenIndex + e, t);
  }
  getPresentation(e) {
    return this._source.getPresentation(this._firstTokenIndex + e);
  }
  findTokenIndexAtOffset(e) {
    return this._source.findTokenIndexAtOffset(e + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
  }
  getTokenText(e) {
    const t = this._firstTokenIndex + e, i = this._source.getStartOffset(t), n = this._source.getEndOffset(t);
    let o = this._source.getTokenText(t);
    return i < this._startOffset && (o = o.substring(this._startOffset - i)), n > this._endOffset && (o = o.substring(0, o.length - (n - this._endOffset))), o;
  }
  forEach(e) {
    for (let t = 0; t < this.getCount(); t++)
      e(t);
  }
}
class xj {
  constructor(e, t, i) {
    this._indentRulesSupport = t, this._indentationLineProcessor = new V5(e, i);
  }
  /**
   * Apply the new indentation and return whether the indentation level should be increased after the given line number
   */
  shouldIncrease(e, t) {
    const i = this._indentationLineProcessor.getProcessedLine(e, t);
    return this._indentRulesSupport.shouldIncrease(i);
  }
  /**
   * Apply the new indentation and return whether the indentation level should be decreased after the given line number
   */
  shouldDecrease(e, t) {
    const i = this._indentationLineProcessor.getProcessedLine(e, t);
    return this._indentRulesSupport.shouldDecrease(i);
  }
  /**
   * Apply the new indentation and return whether the indentation level should remain unchanged at the given line number
   */
  shouldIgnore(e, t) {
    const i = this._indentationLineProcessor.getProcessedLine(e, t);
    return this._indentRulesSupport.shouldIgnore(i);
  }
  /**
   * Apply the new indentation and return whether the indentation level should increase on the line after the given line number
   */
  shouldIndentNextLine(e, t) {
    const i = this._indentationLineProcessor.getProcessedLine(e, t);
    return this._indentRulesSupport.shouldIndentNextLine(i);
  }
}
class vI {
  constructor(e, t) {
    this.model = e, this.indentationLineProcessor = new V5(e, t);
  }
  /**
   * Returns the processed text, stripped from the language configuration brackets within the string, comment and regex tokens, around the given range
   */
  getProcessedTokenContextAroundRange(e) {
    const t = this._getProcessedTokensBeforeRange(e), i = this._getProcessedTokensAfterRange(e), n = this._getProcessedPreviousLineTokens(e);
    return { beforeRangeProcessedTokens: t, afterRangeProcessedTokens: i, previousLineProcessedTokens: n };
  }
  _getProcessedTokensBeforeRange(e) {
    this.model.tokenization.forceTokenization(e.startLineNumber);
    const t = this.model.tokenization.getLineTokens(e.startLineNumber), i = eh(t, e.startColumn - 1);
    let n;
    if (wI(this.model, e.getStartPosition())) {
      const r = e.startColumn - 1 - i.firstCharOffset, a = i.firstCharOffset, l = a + r;
      n = t.sliceAndInflate(a, l, 0);
    } else {
      const r = e.startColumn - 1;
      n = t.sliceAndInflate(0, r, 0);
    }
    return this.indentationLineProcessor.getProcessedTokens(n);
  }
  _getProcessedTokensAfterRange(e) {
    const t = e.isEmpty() ? e.getStartPosition() : e.getEndPosition();
    this.model.tokenization.forceTokenization(t.lineNumber);
    const i = this.model.tokenization.getLineTokens(t.lineNumber), n = eh(i, t.column - 1), o = t.column - 1 - n.firstCharOffset, r = n.firstCharOffset + o, a = n.firstCharOffset + n.getLineLength(), l = i.sliceAndInflate(r, a, 0);
    return this.indentationLineProcessor.getProcessedTokens(l);
  }
  _getProcessedPreviousLineTokens(e) {
    const t = (f) => {
      this.model.tokenization.forceTokenization(f);
      const g = this.model.tokenization.getLineTokens(f), p = this.model.getLineMaxColumn(f) - 1;
      return eh(g, p);
    };
    this.model.tokenization.forceTokenization(e.startLineNumber);
    const i = this.model.tokenization.getLineTokens(e.startLineNumber), n = eh(i, e.startColumn - 1), o = Ti.createEmpty("", n.languageIdCodec), r = e.startLineNumber - 1;
    if (r === 0 || !(n.firstCharOffset === 0))
      return o;
    const c = t(r);
    if (!(n.languageId === c.languageId))
      return o;
    const d = c.toIViewLineTokens();
    return this.indentationLineProcessor.getProcessedTokens(d);
  }
}
class V5 {
  constructor(e, t) {
    this.model = e, this.languageConfigurationService = t;
  }
  /**
   * Get the processed line for the given line number and potentially adjust the indentation level.
   * Remove the language configuration brackets from the regex, string and comment tokens.
   */
  getProcessedLine(e, t) {
    var r, a;
    const i = (l, c) => {
      const h = gn(l);
      return c + l.substring(h.length);
    };
    (a = (r = this.model.tokenization).forceTokenization) == null || a.call(r, e);
    const n = this.model.tokenization.getLineTokens(e);
    let o = this.getProcessedTokens(n).getLineContent();
    return t !== void 0 && (o = i(o, t)), o;
  }
  /**
   * Process the line with the given tokens, remove the language configuration brackets from the regex, string and comment tokens.
   */
  getProcessedTokens(e) {
    const t = (l) => l === 2 || l === 3 || l === 1, i = e.getLanguageId(0), o = this.languageConfigurationService.getLanguageConfiguration(i).bracketsNew.getBracketRegExp({ global: !0 }), r = [];
    return e.forEach((l) => {
      const c = e.getStandardTokenType(l);
      let h = e.getTokenText(l);
      t(c) && (h = h.replace(o, ""));
      const d = e.getMetadata(l);
      r.push({ text: h, metadata: d });
    }), Ti.createFromTextAndMetadata(r, e.languageIdCodec);
  }
}
function wI(s, e) {
  s.tokenization.forceTokenization(e.lineNumber);
  const t = s.tokenization.getLineTokens(e.lineNumber), i = eh(t, e.column - 1), n = i.firstCharOffset === 0, o = t.getLanguageId(0) === i.languageId;
  return !n && !o;
}
function yI(s, e, t, i) {
  e.tokenization.forceTokenization(t.startLineNumber);
  const n = e.getLanguageIdAtPosition(t.startLineNumber, t.startColumn), o = i.getLanguageConfiguration(n);
  if (!o)
    return null;
  const a = new vI(e, i).getProcessedTokenContextAroundRange(t), l = a.previousLineProcessedTokens.getLineContent(), c = a.beforeRangeProcessedTokens.getLineContent(), h = a.afterRangeProcessedTokens.getLineContent(), d = o.onEnter(s, l, c, h);
  if (!d)
    return null;
  const u = d.indentAction;
  let f = d.appendText;
  const g = d.removeText || 0;
  f ? u === pn.Indent && (f = "	" + f) : u === pn.Indent || u === pn.IndentOutdent ? f = "	" : f = "";
  let p = W5(e, t.startLineNumber, t.startColumn);
  return g && (p = p.substring(0, p.length - g)), {
    indentAction: u,
    appendText: f,
    removeText: g,
    indentation: p
  };
}
var Dj = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Ej = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, cb;
const B0 = /* @__PURE__ */ Object.create(null);
function mc(s, e) {
  if (e <= 0)
    return "";
  B0[s] || (B0[s] = ["", s]);
  const t = B0[s];
  for (let i = t.length; i <= e; i++)
    t[i] = t[i - 1] + s;
  return t[e];
}
let qh = cb = class {
  static unshiftIndent(e, t, i, n, o) {
    const r = pi.visibleColumnFromColumn(e, t, i);
    if (o) {
      const a = mc(" ", n), c = pi.prevIndentTabStop(r, n) / n;
      return mc(a, c);
    } else {
      const a = "	", c = pi.prevRenderTabStop(r, i) / i;
      return mc(a, c);
    }
  }
  static shiftIndent(e, t, i, n, o) {
    const r = pi.visibleColumnFromColumn(e, t, i);
    if (o) {
      const a = mc(" ", n), c = pi.nextIndentTabStop(r, n) / n;
      return mc(a, c);
    } else {
      const a = "	", c = pi.nextRenderTabStop(r, i) / i;
      return mc(a, c);
    }
  }
  constructor(e, t, i) {
    this._languageConfigurationService = i, this._opts = t, this._selection = e, this._selectionId = null, this._useLastEditRangeForCursorEndPosition = !1, this._selectionStartColumnStaysPut = !1;
  }
  _addEditOperation(e, t, i) {
    this._useLastEditRangeForCursorEndPosition ? e.addTrackedEditOperation(t, i) : e.addEditOperation(t, i);
  }
  getEditOperations(e, t) {
    const i = this._selection.startLineNumber;
    let n = this._selection.endLineNumber;
    this._selection.endColumn === 1 && i !== n && (n = n - 1);
    const { tabSize: o, indentSize: r, insertSpaces: a } = this._opts, l = i === n;
    if (this._opts.useTabStops) {
      this._selection.isEmpty() && /^\s*$/.test(e.getLineContent(i)) && (this._useLastEditRangeForCursorEndPosition = !0);
      let c = 0, h = 0;
      for (let d = i; d <= n; d++, c = h) {
        h = 0;
        const u = e.getLineContent(d);
        let f = Zn(u);
        if (this._opts.isUnshift && (u.length === 0 || f === 0) || !l && !this._opts.isUnshift && u.length === 0)
          continue;
        if (f === -1 && (f = u.length), d > 1 && pi.visibleColumnFromColumn(u, f + 1, o) % r !== 0 && e.tokenization.isCheapToTokenize(d - 1)) {
          const _ = yI(this._opts.autoIndent, e, new T(d - 1, e.getLineMaxColumn(d - 1), d - 1, e.getLineMaxColumn(d - 1)), this._languageConfigurationService);
          if (_) {
            if (h = c, _.appendText)
              for (let b = 0, C = _.appendText.length; b < C && h < r && _.appendText.charCodeAt(b) === 32; b++)
                h++;
            _.removeText && (h = Math.max(0, h - _.removeText));
            for (let b = 0; b < h && !(f === 0 || u.charCodeAt(f - 1) !== 32); b++)
              f--;
          }
        }
        if (this._opts.isUnshift && f === 0)
          continue;
        let g;
        this._opts.isUnshift ? g = cb.unshiftIndent(u, f + 1, o, r, a) : g = cb.shiftIndent(u, f + 1, o, r, a), this._addEditOperation(t, new T(d, 1, d, f + 1), g), d === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn <= f + 1);
      }
    } else {
      !this._opts.isUnshift && this._selection.isEmpty() && e.getLineLength(i) === 0 && (this._useLastEditRangeForCursorEndPosition = !0);
      const c = a ? mc(" ", r) : "	";
      for (let h = i; h <= n; h++) {
        const d = e.getLineContent(h);
        let u = Zn(d);
        if (!(this._opts.isUnshift && (d.length === 0 || u === 0)) && !(!l && !this._opts.isUnshift && d.length === 0) && (u === -1 && (u = d.length), !(this._opts.isUnshift && u === 0)))
          if (this._opts.isUnshift) {
            u = Math.min(u, r);
            for (let f = 0; f < u; f++)
              if (d.charCodeAt(f) === 9) {
                u = f + 1;
                break;
              }
            this._addEditOperation(t, new T(h, 1, h, u + 1), "");
          } else
            this._addEditOperation(t, new T(h, 1, h, 1), c), h === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn === 1);
      }
    }
    this._selectionId = t.trackSelection(this._selection);
  }
  computeCursorState(e, t) {
    if (this._useLastEditRangeForCursorEndPosition) {
      const n = t.getInverseEditOperations()[0];
      return new Ue(n.range.endLineNumber, n.range.endColumn, n.range.endLineNumber, n.range.endColumn);
    }
    const i = t.getTrackedSelection(this._selectionId);
    if (this._selectionStartColumnStaysPut) {
      const n = this._selection.startColumn;
      return i.startColumn <= n ? i : i.getDirection() === 0 ? new Ue(i.startLineNumber, n, i.endLineNumber, i.endColumn) : new Ue(i.endLineNumber, i.endColumn, i.startLineNumber, n);
    }
    return i;
  }
};
qh = cb = Dj([
  Ej(2, ir)
], qh);
class Ij {
  constructor(e, t, i) {
    this._range = e, this._charBeforeSelection = t, this._charAfterSelection = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(new T(this._range.startLineNumber, this._range.startColumn, this._range.startLineNumber, this._range.startColumn), this._charBeforeSelection), t.addTrackedEditOperation(new T(this._range.endLineNumber, this._range.endColumn, this._range.endLineNumber, this._range.endColumn), this._charAfterSelection);
  }
  computeCursorState(e, t) {
    const i = t.getInverseEditOperations(), n = i[0].range, o = i[1].range;
    return new Ue(n.endLineNumber, n.endColumn, o.endLineNumber, o.endColumn - this._charAfterSelection.length);
  }
}
class Nj {
  constructor(e, t, i) {
    this._position = e, this._text = t, this._charAfter = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(new T(this._position.lineNumber, this._position.column, this._position.lineNumber, this._position.column), this._text + this._charAfter);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return new Ue(n.endLineNumber, n.startColumn, n.endLineNumber, n.endColumn - this._charAfter.length);
  }
}
function Tj(s, e, t) {
  const i = s.tokenization.getLanguageIdAtPosition(e, 0);
  if (e > 1) {
    let n, o = -1;
    for (n = e - 1; n >= 1; n--) {
      if (s.tokenization.getLanguageIdAtPosition(n, 0) !== i)
        return o;
      const r = s.getLineContent(n);
      if (t.shouldIgnore(n) || /^\s+$/.test(r) || r === "") {
        o = n;
        continue;
      }
      return n;
    }
  }
  return -1;
}
function w1(s, e, t, i = !0, n) {
  if (s < 4)
    return null;
  const o = n.getLanguageConfiguration(e.tokenization.getLanguageId()).indentRulesSupport;
  if (!o)
    return null;
  const r = new xj(e, o, n);
  if (t <= 1)
    return {
      indentation: "",
      action: null
    };
  for (let l = t - 1; l > 0 && e.getLineContent(l) === ""; l--)
    if (l === 1)
      return {
        indentation: "",
        action: null
      };
  const a = Tj(e, t, r);
  if (a < 0)
    return null;
  if (a < 1)
    return {
      indentation: "",
      action: null
    };
  if (r.shouldIncrease(a) || r.shouldIndentNextLine(a)) {
    const l = e.getLineContent(a);
    return {
      indentation: gn(l),
      action: pn.Indent,
      line: a
    };
  } else if (r.shouldDecrease(a)) {
    const l = e.getLineContent(a);
    return {
      indentation: gn(l),
      action: null,
      line: a
    };
  } else {
    if (a === 1)
      return {
        indentation: gn(e.getLineContent(a)),
        action: null,
        line: a
      };
    const l = a - 1, c = o.getIndentMetadata(e.getLineContent(l));
    if (!(c & 3) && c & 4) {
      let h = 0;
      for (let d = l - 1; d > 0; d--)
        if (!r.shouldIndentNextLine(d)) {
          h = d;
          break;
        }
      return {
        indentation: gn(e.getLineContent(h + 1)),
        action: null,
        line: h + 1
      };
    }
    if (i)
      return {
        indentation: gn(e.getLineContent(a)),
        action: null,
        line: a
      };
    for (let h = a; h > 0; h--) {
      if (r.shouldIncrease(h))
        return {
          indentation: gn(e.getLineContent(h)),
          action: pn.Indent,
          line: h
        };
      if (r.shouldIndentNextLine(h)) {
        let d = 0;
        for (let u = h - 1; u > 0; u--)
          if (!r.shouldIndentNextLine(h)) {
            d = u;
            break;
          }
        return {
          indentation: gn(e.getLineContent(d + 1)),
          action: null,
          line: d + 1
        };
      } else if (r.shouldDecrease(h))
        return {
          indentation: gn(e.getLineContent(h)),
          action: null,
          line: h
        };
    }
    return {
      indentation: gn(e.getLineContent(1)),
      action: null,
      line: 1
    };
  }
}
function Mj(s, e, t, i, n) {
  if (s < 4)
    return null;
  const o = e.getLanguageIdAtPosition(t.startLineNumber, t.startColumn), r = n.getLanguageConfiguration(o).indentRulesSupport;
  if (!r)
    return null;
  e.tokenization.forceTokenization(t.startLineNumber);
  const l = new vI(e, n).getProcessedTokenContextAroundRange(t), c = l.afterRangeProcessedTokens, h = l.beforeRangeProcessedTokens, d = gn(h.getLineContent()), u = Aj(e, t.startLineNumber, h), f = wI(e, t.getStartPosition()), g = e.getLineContent(t.startLineNumber), p = gn(g), _ = w1(s, u, t.startLineNumber + 1, void 0, n);
  if (!_) {
    const C = f ? p : d;
    return {
      beforeEnter: C,
      afterEnter: C
    };
  }
  let b = f ? p : _.indentation;
  return _.action === pn.Indent && (b = i.shiftIndent(b)), r.shouldDecrease(c.getLineContent()) && (b = i.unshiftIndent(b)), {
    beforeEnter: f ? p : d,
    afterEnter: b
  };
}
function Rj(s, e, t, i, n, o) {
  const r = s.autoIndent;
  if (r < 4 || wI(e, t.getStartPosition()))
    return null;
  const l = e.getLanguageIdAtPosition(t.startLineNumber, t.startColumn), c = o.getLanguageConfiguration(l).indentRulesSupport;
  if (!c)
    return null;
  const d = new vI(e, o).getProcessedTokenContextAroundRange(t), u = d.beforeRangeProcessedTokens.getLineContent(), f = d.afterRangeProcessedTokens.getLineContent(), g = u + f, p = u + i + f;
  if (!c.shouldDecrease(g) && c.shouldDecrease(p)) {
    const b = w1(r, e, t.startLineNumber, !1, o);
    if (!b)
      return null;
    let C = b.indentation;
    return b.action !== pn.Indent && (C = n.unshiftIndent(C)), C;
  }
  const _ = t.startLineNumber - 1;
  if (_ > 0) {
    const b = e.getLineContent(_);
    if (c.shouldIndentNextLine(b) && c.shouldIncrease(p)) {
      const C = w1(r, e, t.startLineNumber, !1, o), w = C == null ? void 0 : C.indentation;
      if (w !== void 0) {
        const v = e.getLineContent(t.startLineNumber), S = gn(v), k = n.shiftIndent(w) === S, x = /^\s*$/.test(g), I = s.autoClosingPairs.autoClosingPairsOpenByEnd.get(i), B = I && I.length > 0 && x;
        if (k && B)
          return w;
      }
    }
  }
  return null;
}
function Aj(s, e, t) {
  return {
    tokenization: {
      getLineTokens: (n) => n === e ? t : s.tokenization.getLineTokens(n),
      getLanguageId: () => s.getLanguageId(),
      getLanguageIdAtPosition: (n, o) => s.getLanguageIdAtPosition(n, o)
    },
    getLineContent: (n) => n === e ? t.getLineContent() : s.getLineContent(n)
  };
}
class Pj {
  static getEdits(e, t, i, n, o) {
    if (!o && this._isAutoIndentType(e, t, i)) {
      const r = [];
      for (const l of i) {
        const c = this._findActualIndentationForSelection(e, t, l, n);
        if (c === null)
          return;
        r.push({ selection: l, indentation: c });
      }
      const a = XS.getAutoClosingPairClose(e, t, i, n, !1);
      return this._getIndentationAndAutoClosingPairEdits(e, t, r, n, a);
    }
  }
  static _isAutoIndentType(e, t, i) {
    if (e.autoIndent < 4)
      return !1;
    for (let n = 0, o = i.length; n < o; n++)
      if (!t.tokenization.isCheapToTokenize(i[n].getEndPosition().lineNumber))
        return !1;
    return !0;
  }
  static _findActualIndentationForSelection(e, t, i, n) {
    const o = Rj(e, t, i, n, {
      shiftIndent: (a) => kI(e, a),
      unshiftIndent: (a) => y1(e, a)
    }, e.languageConfigurationService);
    if (o === null)
      return null;
    const r = W5(t, i.startLineNumber, i.startColumn);
    return o === e.normalizeIndentation(r) ? null : o;
  }
  static _getIndentationAndAutoClosingPairEdits(e, t, i, n, o) {
    const r = i.map(({ selection: l, indentation: c }) => {
      if (o !== null) {
        const h = this._getEditFromIndentationAndSelection(e, t, c, l, n, !1);
        return new jj(h, l, n, o);
      } else {
        const h = this._getEditFromIndentationAndSelection(e, t, c, l, n, !0);
        return yc(h.range, h.text, !1);
      }
    }), a = { shouldPushStackElementBefore: !0, shouldPushStackElementAfter: !1 };
    return new Pn(4, r, a);
  }
  static _getEditFromIndentationAndSelection(e, t, i, n, o, r = !0) {
    const a = n.startLineNumber, l = t.getLineFirstNonWhitespaceColumn(a);
    let c = e.normalizeIndentation(i);
    if (l !== 0) {
      const d = t.getLineContent(a);
      c += d.substring(l - 1, n.startColumn - 1);
    }
    return c += r ? o : "", { range: new T(a, 1, n.endLineNumber, n.endColumn), text: c };
  }
}
class Oj {
  static getEdits(e, t, i, n, o, r) {
    if (U5(t, i, n, o, r))
      return this._runAutoClosingOvertype(e, n, r);
  }
  static _runAutoClosingOvertype(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const l = t[o].getPosition(), c = new T(l.lineNumber, l.column, l.lineNumber, l.column + 1);
      n[o] = new qn(c, i);
    }
    return new Pn(4, n, {
      shouldPushStackElementBefore: Dw(
        e,
        4
        /* EditOperationType.TypingOther */
      ),
      shouldPushStackElementAfter: !1
    });
  }
}
class Fj {
  static getEdits(e, t, i, n, o) {
    if (U5(e, t, i, n, o)) {
      const r = i.map((a) => new qn(new T(a.positionLineNumber, a.positionColumn, a.positionLineNumber, a.positionColumn + 1), "", !1));
      return new Pn(4, r, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
  }
}
class XS {
  static getEdits(e, t, i, n, o, r) {
    if (!r) {
      const a = this.getAutoClosingPairClose(e, t, i, n, o);
      if (a !== null)
        return this._runAutoClosingOpenCharType(i, n, o, a);
    }
  }
  static _runAutoClosingOpenCharType(e, t, i, n) {
    const o = [];
    for (let r = 0, a = e.length; r < a; r++) {
      const l = e[r];
      o[r] = new Kj(l, t, !i, n);
    }
    return new Pn(4, o, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !1
    });
  }
  static getAutoClosingPairClose(e, t, i, n, o) {
    for (const g of i)
      if (!g.isEmpty())
        return null;
    const r = i.map((g) => {
      const p = g.getPosition();
      return o ? { lineNumber: p.lineNumber, beforeColumn: p.column - n.length, afterColumn: p.column } : { lineNumber: p.lineNumber, beforeColumn: p.column, afterColumn: p.column };
    }), a = this._findAutoClosingPairOpen(e, t, r.map((g) => new F(g.lineNumber, g.beforeColumn)), n);
    if (!a)
      return null;
    let l, c;
    if (Zl(n) ? (l = e.autoClosingQuotes, c = e.shouldAutoCloseBefore.quote) : (e.blockCommentStartToken ? a.open.includes(e.blockCommentStartToken) : !1) ? (l = e.autoClosingComments, c = e.shouldAutoCloseBefore.comment) : (l = e.autoClosingBrackets, c = e.shouldAutoCloseBefore.bracket), l === "never")
      return null;
    const d = this._findContainedAutoClosingPair(e, a), u = d ? d.close : "";
    let f = !0;
    for (const g of r) {
      const { lineNumber: p, beforeColumn: _, afterColumn: b } = g, C = t.getLineContent(p), w = C.substring(0, _ - 1), v = C.substring(b - 1);
      if (v.startsWith(u) || (f = !1), v.length > 0) {
        const x = v.charAt(0);
        if (!this._isBeforeClosingBrace(e, v) && !c(x))
          return null;
      }
      if (a.open.length === 1 && (n === "'" || n === '"') && l !== "always") {
        const x = ff(e.wordSeparators, []);
        if (w.length > 0) {
          const I = w.charCodeAt(w.length - 1);
          if (x.get(I) === 0)
            return null;
        }
      }
      if (!t.tokenization.isCheapToTokenize(p))
        return null;
      t.tokenization.forceTokenization(p);
      const S = t.tokenization.getLineTokens(p), L = eh(S, _ - 1);
      if (!a.shouldAutoClose(L, _ - L.firstCharOffset))
        return null;
      const k = a.findNeutralCharacter();
      if (k) {
        const x = t.tokenization.getTokenTypeIfInsertingCharacter(p, _, k);
        if (!a.isOK(x))
          return null;
      }
    }
    return f ? a.close.substring(0, a.close.length - u.length) : a.close;
  }
  /**
   * Find another auto-closing pair that is contained by the one passed in.
   *
   * e.g. when having [(,)] and [(*,*)] as auto-closing pairs
   * this method will find [(,)] as a containment pair for [(*,*)]
   */
  static _findContainedAutoClosingPair(e, t) {
    if (t.open.length <= 1)
      return null;
    const i = t.close.charAt(t.close.length - 1), n = e.autoClosingPairs.autoClosingPairsCloseByEnd.get(i) || [];
    let o = null;
    for (const r of n)
      r.open !== t.open && t.open.includes(r.open) && t.close.endsWith(r.close) && (!o || r.open.length > o.open.length) && (o = r);
    return o;
  }
  /**
   * Determine if typing `ch` at all `positions` in the `model` results in an
   * auto closing open sequence being typed.
   *
   * Auto closing open sequences can consist of multiple characters, which
   * can lead to ambiguities. In such a case, the longest auto-closing open
   * sequence is returned.
   */
  static _findAutoClosingPairOpen(e, t, i, n) {
    const o = e.autoClosingPairs.autoClosingPairsOpenByEnd.get(n);
    if (!o)
      return null;
    let r = null;
    for (const a of o)
      if (r === null || a.open.length > r.open.length) {
        let l = !0;
        for (const c of i)
          if (t.getValueInRange(new T(c.lineNumber, c.column - a.open.length + 1, c.lineNumber, c.column)) + n !== a.open) {
            l = !1;
            break;
          }
        l && (r = a);
      }
    return r;
  }
  static _isBeforeClosingBrace(e, t) {
    const i = t.charAt(0), n = e.autoClosingPairs.autoClosingPairsOpenByStart.get(i) || [], o = e.autoClosingPairs.autoClosingPairsCloseByStart.get(i) || [], r = n.some((l) => t.startsWith(l.open)), a = o.some((l) => t.startsWith(l.close));
    return !r && a;
  }
}
class Bj {
  static getEdits(e, t, i, n, o) {
    if (!o && this._isSurroundSelectionType(e, t, i, n))
      return this._runSurroundSelectionType(e, i, n);
  }
  static _runSurroundSelectionType(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = e.surroundingPairs[i];
      n[o] = new Ij(a, i, l);
    }
    return new Pn(0, n, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _isSurroundSelectionType(e, t, i, n) {
    if (!$5(e, n) || !e.surroundingPairs.hasOwnProperty(n))
      return !1;
    const o = Zl(n);
    for (const r of i) {
      if (r.isEmpty())
        return !1;
      let a = !0;
      for (let l = r.startLineNumber; l <= r.endLineNumber; l++) {
        const c = t.getLineContent(l), h = l === r.startLineNumber ? r.startColumn - 1 : 0, d = l === r.endLineNumber ? r.endColumn - 1 : c.length, u = c.substring(h, d);
        if (/[^ \t]/.test(u)) {
          a = !1;
          break;
        }
      }
      if (a)
        return !1;
      if (o && r.startLineNumber === r.endLineNumber && r.startColumn + 1 === r.endColumn) {
        const l = t.getValueInRange(r);
        if (Zl(l))
          return !1;
      }
    }
    return !0;
  }
}
class Wj {
  static getEdits(e, t, i, n, o, r) {
    if (!r && this._isTypeInterceptorElectricChar(t, i, n)) {
      const a = this._typeInterceptorElectricChar(e, t, i, n[0], o);
      if (a)
        return a;
    }
  }
  static _isTypeInterceptorElectricChar(e, t, i) {
    return !!(i.length === 1 && t.tokenization.isCheapToTokenize(i[0].getEndPosition().lineNumber));
  }
  static _typeInterceptorElectricChar(e, t, i, n, o) {
    if (!t.electricChars.hasOwnProperty(o) || !n.isEmpty())
      return null;
    const r = n.getPosition();
    i.tokenization.forceTokenization(r.lineNumber);
    const a = i.tokenization.getLineTokens(r.lineNumber);
    let l;
    try {
      l = t.onElectricCharacter(o, a, r.column);
    } catch (c) {
      return Je(c), null;
    }
    if (!l)
      return null;
    if (l.matchOpenBracket) {
      const c = (a.getLineContent() + o).lastIndexOf(l.matchOpenBracket) + 1, h = i.bracketPairs.findMatchingBracketUp(
        l.matchOpenBracket,
        {
          lineNumber: r.lineNumber,
          column: c
        },
        500
        /* give at most 500ms to compute */
      );
      if (h) {
        if (h.startLineNumber === r.lineNumber)
          return null;
        const d = i.getLineContent(h.startLineNumber), u = gn(d), f = t.normalizeIndentation(u), g = i.getLineContent(r.lineNumber), p = i.getLineFirstNonWhitespaceColumn(r.lineNumber) || r.column, _ = g.substring(p - 1, r.column - 1), b = f + _ + o, C = new T(r.lineNumber, 1, r.lineNumber, r.column), w = new qn(C, b);
        return new Pn(LI(b, e), [w], {
          shouldPushStackElementBefore: !1,
          shouldPushStackElementAfter: !0
        });
      }
    }
    return null;
  }
}
class Hj {
  static getEdits(e, t, i) {
    const n = [];
    for (let r = 0, a = t.length; r < a; r++)
      n[r] = new qn(t[r], i);
    const o = LI(i, e);
    return new Pn(o, n, {
      shouldPushStackElementBefore: Dw(e, o),
      shouldPushStackElementAfter: !1
    });
  }
}
class z5 {
  static getEdits(e, t, i, n, o) {
    if (!o && n === `
`) {
      const r = [];
      for (let a = 0, l = i.length; a < l; a++)
        r[a] = this._enter(e, t, !1, i[a]);
      return new Pn(4, r, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
  }
  static _enter(e, t, i, n) {
    if (e.autoIndent === 0)
      return yc(n, `
`, i);
    if (!t.tokenization.isCheapToTokenize(n.getStartPosition().lineNumber) || e.autoIndent === 1) {
      const l = t.getLineContent(n.startLineNumber), c = gn(l).substring(0, n.startColumn - 1);
      return yc(n, `
` + e.normalizeIndentation(c), i);
    }
    const o = yI(e.autoIndent, t, n, e.languageConfigurationService);
    if (o) {
      if (o.indentAction === pn.None)
        return yc(n, `
` + e.normalizeIndentation(o.indentation + o.appendText), i);
      if (o.indentAction === pn.Indent)
        return yc(n, `
` + e.normalizeIndentation(o.indentation + o.appendText), i);
      if (o.indentAction === pn.IndentOutdent) {
        const l = e.normalizeIndentation(o.indentation), c = e.normalizeIndentation(o.indentation + o.appendText), h = `
` + c + `
` + l;
        return i ? new ab(n, h, !0) : new _1(n, h, -1, c.length - l.length, !0);
      } else if (o.indentAction === pn.Outdent) {
        const l = y1(e, o.indentation);
        return yc(n, `
` + e.normalizeIndentation(l + o.appendText), i);
      }
    }
    const r = t.getLineContent(n.startLineNumber), a = gn(r).substring(0, n.startColumn - 1);
    if (e.autoIndent >= 4) {
      const l = Mj(e.autoIndent, t, n, {
        unshiftIndent: (c) => y1(e, c),
        shiftIndent: (c) => kI(e, c),
        normalizeIndentation: (c) => e.normalizeIndentation(c)
      }, e.languageConfigurationService);
      if (l) {
        let c = e.visibleColumnFromColumn(t, n.getEndPosition());
        const h = n.endColumn, d = t.getLineContent(n.endLineNumber), u = Zn(d);
        if (u >= 0 ? n = n.setEndPosition(n.endLineNumber, Math.max(n.endColumn, u + 1)) : n = n.setEndPosition(n.endLineNumber, t.getLineMaxColumn(n.endLineNumber)), i)
          return new ab(n, `
` + e.normalizeIndentation(l.afterEnter), !0);
        {
          let f = 0;
          return h <= u + 1 && (e.insertSpaces || (c = Math.ceil(c / e.indentSize)), f = Math.min(c + 1 - e.normalizeIndentation(l.afterEnter).length - 1, 0)), new _1(n, `
` + e.normalizeIndentation(l.afterEnter), 0, f, !0);
        }
      }
    }
    return yc(n, `
` + e.normalizeIndentation(a), i);
  }
  static lineInsertBefore(e, t, i) {
    if (t === null || i === null)
      return [];
    const n = [];
    for (let o = 0, r = i.length; o < r; o++) {
      let a = i[o].positionLineNumber;
      if (a === 1)
        n[o] = new ab(new T(1, 1, 1, 1), `
`);
      else {
        a--;
        const l = t.getLineMaxColumn(a);
        n[o] = this._enter(e, t, !1, new T(a, l, a, l));
      }
    }
    return n;
  }
  static lineInsertAfter(e, t, i) {
    if (t === null || i === null)
      return [];
    const n = [];
    for (let o = 0, r = i.length; o < r; o++) {
      const a = i[o].positionLineNumber, l = t.getLineMaxColumn(a);
      n[o] = this._enter(e, t, !1, new T(a, l, a, l));
    }
    return n;
  }
  static lineBreakInsert(e, t, i) {
    const n = [];
    for (let o = 0, r = i.length; o < r; o++)
      n[o] = this._enter(e, t, !0, i[o]);
    return n;
  }
}
class Vj {
  static getEdits(e, t, i, n, o, r) {
    const a = this._distributePasteToCursors(e, i, n, o, r);
    return a ? (i = i.sort(T.compareRangesUsingStarts), this._distributedPaste(e, t, i, a)) : this._simplePaste(e, t, i, n, o);
  }
  static _distributePasteToCursors(e, t, i, n, o) {
    if (n || t.length === 1)
      return null;
    if (o && o.length === t.length)
      return o;
    if (e.multiCursorPaste === "spread") {
      i.charCodeAt(i.length - 1) === 10 && (i = i.substring(0, i.length - 1)), i.charCodeAt(i.length - 1) === 13 && (i = i.substring(0, i.length - 1));
      const r = td(i);
      if (r.length === t.length)
        return r;
    }
    return null;
  }
  static _distributedPaste(e, t, i, n) {
    const o = [];
    for (let r = 0, a = i.length; r < a; r++)
      o[r] = new qn(i[r], n[r]);
    return new Pn(0, o, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _simplePaste(e, t, i, n, o) {
    const r = [];
    for (let a = 0, l = i.length; a < l; a++) {
      const c = i[a], h = c.getPosition();
      if (o && !c.isEmpty() && (o = !1), o && n.indexOf(`
`) !== n.length - 1 && (o = !1), o) {
        const d = new T(h.lineNumber, 1, h.lineNumber, 1);
        r[a] = new QK(d, n, c, !0);
      } else
        r[a] = new qn(c, n);
    }
    return new Pn(0, r, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
}
class zj {
  static getEdits(e, t, i, n, o, r, a, l) {
    const c = n.map((h) => this._compositionType(i, h, o, r, a, l));
    return new Pn(4, c, {
      shouldPushStackElementBefore: Dw(
        e,
        4
        /* EditOperationType.TypingOther */
      ),
      shouldPushStackElementAfter: !1
    });
  }
  static _compositionType(e, t, i, n, o, r) {
    if (!t.isEmpty())
      return null;
    const a = t.getPosition(), l = Math.max(1, a.column - n), c = Math.min(e.getLineMaxColumn(a.lineNumber), a.column + o), h = new T(a.lineNumber, l, a.lineNumber, c);
    return e.getValueInRange(h) === i && r === 0 ? null : new _1(h, i, 0, r);
  }
}
class Uj {
  static getEdits(e, t, i) {
    const n = [];
    for (let r = 0, a = t.length; r < a; r++)
      n[r] = new qn(t[r], i);
    const o = LI(i, e);
    return new Pn(o, n, {
      shouldPushStackElementBefore: Dw(e, o),
      shouldPushStackElementAfter: !1
    });
  }
}
class $j {
  static getCommands(e, t, i) {
    const n = [];
    for (let o = 0, r = i.length; o < r; o++) {
      const a = i[o];
      if (a.isEmpty()) {
        const l = t.getLineContent(a.startLineNumber);
        if (/^\s*$/.test(l) && t.tokenization.isCheapToTokenize(a.startLineNumber)) {
          let c = this._goodIndentForLine(e, t, a.startLineNumber);
          c = c || "	";
          const h = e.normalizeIndentation(c);
          if (!l.startsWith(h)) {
            n[o] = new qn(new T(a.startLineNumber, 1, a.startLineNumber, l.length + 1), h, !0);
            continue;
          }
        }
        n[o] = this._replaceJumpToNextIndent(e, t, a, !0);
      } else {
        if (a.startLineNumber === a.endLineNumber) {
          const l = t.getLineMaxColumn(a.startLineNumber);
          if (a.startColumn !== 1 || a.endColumn !== l) {
            n[o] = this._replaceJumpToNextIndent(e, t, a, !1);
            continue;
          }
        }
        n[o] = new qh(a, {
          isUnshift: !1,
          tabSize: e.tabSize,
          indentSize: e.indentSize,
          insertSpaces: e.insertSpaces,
          useTabStops: e.useTabStops,
          autoIndent: e.autoIndent
        }, e.languageConfigurationService);
      }
    }
    return n;
  }
  static _goodIndentForLine(e, t, i) {
    let n = null, o = "";
    const r = w1(e.autoIndent, t, i, !1, e.languageConfigurationService);
    if (r)
      n = r.action, o = r.indentation;
    else if (i > 1) {
      let a;
      for (a = i - 1; a >= 1; a--) {
        const h = t.getLineContent(a);
        if (id(h) >= 0)
          break;
      }
      if (a < 1)
        return null;
      const l = t.getLineMaxColumn(a), c = yI(e.autoIndent, t, new T(a, l, a, l), e.languageConfigurationService);
      c && (o = c.indentation + c.appendText);
    }
    return n && (n === pn.Indent && (o = kI(e, o)), n === pn.Outdent && (o = y1(e, o)), o = e.normalizeIndentation(o)), o || null;
  }
  static _replaceJumpToNextIndent(e, t, i, n) {
    let o = "";
    const r = i.getStartPosition();
    if (e.insertSpaces) {
      const a = e.visibleColumnFromColumn(t, r), l = e.indentSize, c = l - a % l;
      for (let h = 0; h < c; h++)
        o += " ";
    } else
      o = "	";
    return new qn(i, o, n);
  }
}
class SI extends _1 {
  constructor(e, t, i, n, o, r) {
    super(e, t, i, n), this._openCharacter = o, this._closeCharacter = r, this.closeCharacterRange = null, this.enclosingRange = null;
  }
  _computeCursorStateWithRange(e, t, i) {
    return this.closeCharacterRange = new T(t.startLineNumber, t.endColumn - this._closeCharacter.length, t.endLineNumber, t.endColumn), this.enclosingRange = new T(t.startLineNumber, t.endColumn - this._openCharacter.length - this._closeCharacter.length, t.endLineNumber, t.endColumn), super.computeCursorState(e, i);
  }
}
class Kj extends SI {
  constructor(e, t, i, n) {
    const o = (i ? t : "") + n, r = 0, a = -n.length;
    super(e, o, r, a, t, n);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return this._computeCursorStateWithRange(e, n, t);
  }
}
class jj extends SI {
  constructor(e, t, i, n) {
    const o = i + n, r = 0, a = i.length;
    super(t, o, r, a, i, n), this._autoIndentationEdit = e, this._autoClosingEdit = { range: t, text: o };
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._autoIndentationEdit.range, this._autoIndentationEdit.text), t.addTrackedEditOperation(this._autoClosingEdit.range, this._autoClosingEdit.text);
  }
  computeCursorState(e, t) {
    const i = t.getInverseEditOperations();
    if (i.length !== 2)
      throw new Error("There should be two inverse edit operations!");
    const n = i[0].range, o = i[1].range, r = n.plusRange(o);
    return this._computeCursorStateWithRange(e, r, t);
  }
}
function LI(s, e) {
  return s === " " ? e === 5 || e === 6 ? 6 : 5 : 4;
}
function Dw(s, e) {
  return ZT(s) && !ZT(e) ? !0 : s === 5 ? !1 : GT(s) !== GT(e);
}
function GT(s) {
  return s === 6 || s === 5 ? "space" : s;
}
function ZT(s) {
  return s === 4 || s === 5 || s === 6;
}
function U5(s, e, t, i, n) {
  if (s.autoClosingOvertype === "never" || !s.autoClosingPairs.autoClosingPairsCloseSingleChar.has(n))
    return !1;
  for (let o = 0, r = t.length; o < r; o++) {
    const a = t[o];
    if (!a.isEmpty())
      return !1;
    const l = a.getPosition(), c = e.getLineContent(l.lineNumber);
    if (c.charAt(l.column - 1) !== n)
      return !1;
    const d = Zl(n);
    if ((l.column > 2 ? c.charCodeAt(l.column - 2) : 0) === 92 && d)
      return !1;
    if (s.autoClosingOvertype === "auto") {
      let f = !1;
      for (let g = 0, p = i.length; g < p; g++) {
        const _ = i[g];
        if (l.lineNumber === _.startLineNumber && l.column === _.startColumn) {
          f = !0;
          break;
        }
      }
      if (!f)
        return !1;
    }
  }
  return !0;
}
function yc(s, e, t) {
  return t ? new ab(s, e, !0) : new qn(s, e, !0);
}
function kI(s, e, t) {
  return t = t || 1, qh.shiftIndent(e, e.length + t, s.tabSize, s.indentSize, s.insertSpaces);
}
function y1(s, e, t) {
  return t = t || 1, qh.unshiftIndent(e, e.length + t, s.tabSize, s.indentSize, s.insertSpaces);
}
function $5(s, e) {
  return Zl(e) ? s.autoSurround === "quotes" || s.autoSurround === "languageDefined" : s.autoSurround === "brackets" || s.autoSurround === "languageDefined";
}
class Mc {
  static indent(e, t, i) {
    if (t === null || i === null)
      return [];
    const n = [];
    for (let o = 0, r = i.length; o < r; o++)
      n[o] = new qh(i[o], {
        isUnshift: !1,
        tabSize: e.tabSize,
        indentSize: e.indentSize,
        insertSpaces: e.insertSpaces,
        useTabStops: e.useTabStops,
        autoIndent: e.autoIndent
      }, e.languageConfigurationService);
    return n;
  }
  static outdent(e, t, i) {
    const n = [];
    for (let o = 0, r = i.length; o < r; o++)
      n[o] = new qh(i[o], {
        isUnshift: !0,
        tabSize: e.tabSize,
        indentSize: e.indentSize,
        insertSpaces: e.insertSpaces,
        useTabStops: e.useTabStops,
        autoIndent: e.autoIndent
      }, e.languageConfigurationService);
    return n;
  }
  static paste(e, t, i, n, o, r) {
    return Vj.getEdits(e, t, i, n, o, r);
  }
  static tab(e, t, i) {
    return $j.getCommands(e, t, i);
  }
  static compositionType(e, t, i, n, o, r, a, l) {
    return zj.getEdits(e, t, i, n, o, r, a, l);
  }
  /**
   * This is very similar with typing, but the character is already in the text buffer!
   */
  static compositionEndWithInterceptors(e, t, i, n, o, r) {
    if (!n)
      return null;
    let a = null;
    for (const u of n)
      if (a === null)
        a = u.insertedText;
      else if (a !== u.insertedText)
        return null;
    if (!a || a.length !== 1)
      return null;
    const l = a;
    let c = !1;
    for (const u of n)
      if (u.deletedText.length !== 0) {
        c = !0;
        break;
      }
    if (c) {
      if (!$5(t, l) || !t.surroundingPairs.hasOwnProperty(l))
        return null;
      const u = Zl(l);
      for (const p of n)
        if (p.deletedSelectionStart !== 0 || p.deletedSelectionEnd !== p.deletedText.length || /^[ \t]+$/.test(p.deletedText) || u && Zl(p.deletedText))
          return null;
      const f = [];
      for (const p of o) {
        if (!p.isEmpty())
          return null;
        f.push(p.getPosition());
      }
      if (f.length !== n.length)
        return null;
      const g = [];
      for (let p = 0, _ = f.length; p < _; p++)
        g.push(new Nj(f[p], n[p].deletedText, t.surroundingPairs[l]));
      return new Pn(4, g, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
    const h = Fj.getEdits(t, i, o, r, l);
    if (h !== void 0)
      return h;
    const d = XS.getEdits(t, i, o, l, !0, !1);
    return d !== void 0 ? d : null;
  }
  static typeWithInterceptors(e, t, i, n, o, r, a) {
    const l = z5.getEdits(i, n, o, a, e);
    if (l !== void 0)
      return l;
    const c = Pj.getEdits(i, n, o, a, e);
    if (c !== void 0)
      return c;
    const h = Oj.getEdits(t, i, n, o, r, a);
    if (h !== void 0)
      return h;
    const d = XS.getEdits(i, n, o, a, !1, e);
    if (d !== void 0)
      return d;
    const u = Bj.getEdits(i, n, o, a, e);
    if (u !== void 0)
      return u;
    const f = Wj.getEdits(t, i, n, o, a, e);
    return f !== void 0 ? f : Hj.getEdits(t, o, a);
  }
  static typeWithoutInterceptors(e, t, i, n, o) {
    return Uj.getEdits(e, n, o);
  }
}
class qj {
  constructor(e, t, i, n, o, r) {
    this.deletedText = e, this.deletedSelectionStart = t, this.deletedSelectionEnd = i, this.insertedText = n, this.insertedSelectionStart = o, this.insertedSelectionEnd = r;
  }
}
const tt = 0;
class Ht extends jo {
  runEditorCommand(e, t, i) {
    const n = t._getViewModel();
    n && this.runCoreEditorCommand(n, i || {});
  }
}
var Pi;
(function(s) {
  const e = function(i) {
    if (!Wi(i))
      return !1;
    const n = i;
    return !(!Ss(n.to) || !As(n.by) && !Ss(n.by) || !As(n.value) && !If(n.value) || !As(n.revealCursor) && !o4(n.revealCursor));
  };
  s.metadata = {
    description: "Scroll editor in the given direction",
    args: [
      {
        name: "Editor scroll argument object",
        description: "Property-value pairs that can be passed through this argument:\n					* 'to': A mandatory direction value.\n						```\n						'up', 'down'\n						```\n					* 'by': Unit to move. Default is computed based on 'to' value.\n						```\n						'line', 'wrappedLine', 'page', 'halfPage', 'editor'\n						```\n					* 'value': Number of units to move. Default is '1'.\n					* 'revealCursor': If 'true' reveals the cursor if it is outside view port.\n				",
        constraint: e,
        schema: {
          type: "object",
          required: ["to"],
          properties: {
            to: {
              type: "string",
              enum: ["up", "down"]
            },
            by: {
              type: "string",
              enum: ["line", "wrappedLine", "page", "halfPage", "editor"]
            },
            value: {
              type: "number",
              default: 1
            },
            revealCursor: {
              type: "boolean"
            }
          }
        }
      }
    ]
  }, s.RawDirection = {
    Up: "up",
    Right: "right",
    Down: "down",
    Left: "left"
  }, s.RawUnit = {
    Line: "line",
    WrappedLine: "wrappedLine",
    Page: "page",
    HalfPage: "halfPage",
    Editor: "editor",
    Column: "column"
  };
  function t(i) {
    let n;
    switch (i.to) {
      case s.RawDirection.Up:
        n = 1;
        break;
      case s.RawDirection.Right:
        n = 2;
        break;
      case s.RawDirection.Down:
        n = 3;
        break;
      case s.RawDirection.Left:
        n = 4;
        break;
      default:
        return null;
    }
    let o;
    switch (i.by) {
      case s.RawUnit.Line:
        o = 1;
        break;
      case s.RawUnit.WrappedLine:
        o = 2;
        break;
      case s.RawUnit.Page:
        o = 3;
        break;
      case s.RawUnit.HalfPage:
        o = 4;
        break;
      case s.RawUnit.Editor:
        o = 5;
        break;
      case s.RawUnit.Column:
        o = 6;
        break;
      default:
        o = 2;
    }
    const r = Math.floor(i.value || 1), a = !!i.revealCursor;
    return {
      direction: n,
      unit: o,
      value: r,
      revealCursor: a,
      select: !!i.select
    };
  }
  s.parse = t;
})(Pi || (Pi = {}));
var iu;
(function(s) {
  const e = function(t) {
    if (!Wi(t))
      return !1;
    const i = t;
    return !(!If(i.lineNumber) && !Ss(i.lineNumber) || !As(i.at) && !Ss(i.at));
  };
  s.metadata = {
    description: "Reveal the given line at the given logical position",
    args: [
      {
        name: "Reveal line argument object",
        description: "Property-value pairs that can be passed through this argument:\n					* 'lineNumber': A mandatory line number value.\n					* 'at': Logical position at which line has to be revealed.\n						```\n						'top', 'center', 'bottom'\n						```\n				",
        constraint: e,
        schema: {
          type: "object",
          required: ["lineNumber"],
          properties: {
            lineNumber: {
              type: ["number", "string"]
            },
            at: {
              type: "string",
              enum: ["top", "center", "bottom"]
            }
          }
        }
      }
    ]
  }, s.RawAtArgument = {
    Top: "top",
    Center: "center",
    Bottom: "bottom"
  };
})(iu || (iu = {}));
class QS {
  constructor(e) {
    e.addImplementation(1e4, "code-editor", (t, i) => {
      const n = t.get(Tt).getFocusedCodeEditor();
      return n && n.hasTextFocus() ? this._runEditorCommand(t, n, i) : !1;
    }), e.addImplementation(1e3, "generic-dom-input-textarea", (t, i) => {
      const n = Gi();
      return n && ["input", "textarea"].indexOf(n.tagName.toLowerCase()) >= 0 ? (this.runDOMCommand(n), !0) : !1;
    }), e.addImplementation(0, "generic-dom", (t, i) => {
      const n = t.get(Tt).getActiveCodeEditor();
      return n ? (n.focus(), this._runEditorCommand(t, n, i)) : !1;
    });
  }
  _runEditorCommand(e, t, i) {
    const n = this.runEditorCommand(e, t, i);
    return n || !0;
  }
}
var Ci;
(function(s) {
  class e extends Ht {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      if (!w.position)
        return;
      C.model.pushStackElement(), C.setCursorStates(w.source, 3, [
        Qi.moveTo(C, C.getPrimaryCursorState(), this._inSelectionMode, w.position, w.viewPosition)
      ]) && w.revealType !== 2 && C.revealAllCursors(w.source, !0, !0);
    }
  }
  s.MoveTo = Le(new e({
    id: "_moveTo",
    inSelectionMode: !1,
    precondition: void 0
  })), s.MoveToSelect = Le(new e({
    id: "_moveToSelect",
    inSelectionMode: !0,
    precondition: void 0
  }));
  class t extends Ht {
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement();
      const v = this._getColumnSelectResult(C, C.getPrimaryCursorState(), C.getCursorColumnSelectData(), w);
      v !== null && (C.setCursorStates(w.source, 3, v.viewStates.map((S) => Ve.fromViewState(S))), C.setCursorColumnSelectData({
        isReal: !0,
        fromViewLineNumber: v.fromLineNumber,
        fromViewVisualColumn: v.fromVisualColumn,
        toViewLineNumber: v.toLineNumber,
        toViewVisualColumn: v.toVisualColumn
      }), v.reversed ? C.revealTopMostCursor(w.source) : C.revealBottomMostCursor(w.source));
    }
  }
  s.ColumnSelect = Le(new class extends t {
    constructor() {
      super({
        id: "columnSelect",
        precondition: void 0
      });
    }
    _getColumnSelectResult(b, C, w, v) {
      if (typeof v.position > "u" || typeof v.viewPosition > "u" || typeof v.mouseColumn > "u")
        return null;
      const S = b.model.validatePosition(v.position), L = b.coordinatesConverter.validateViewPosition(new F(v.viewPosition.lineNumber, v.viewPosition.column), S), k = v.doColumnSelect ? w.fromViewLineNumber : L.lineNumber, x = v.doColumnSelect ? w.fromViewVisualColumn : v.mouseColumn - 1;
      return Tc.columnSelect(b.cursorConfig, b, k, x, L.lineNumber, v.mouseColumn - 1);
    }
  }()), s.CursorColumnSelectLeft = Le(new class extends t {
    constructor() {
      super({
        id: "cursorColumnSelectLeft",
        precondition: void 0,
        kbOpts: {
          weight: tt,
          kbExpr: Z.textInputFocus,
          primary: 3599,
          linux: { primary: 0 }
        }
      });
    }
    _getColumnSelectResult(b, C, w, v) {
      return Tc.columnSelectLeft(b.cursorConfig, b, w);
    }
  }()), s.CursorColumnSelectRight = Le(new class extends t {
    constructor() {
      super({
        id: "cursorColumnSelectRight",
        precondition: void 0,
        kbOpts: {
          weight: tt,
          kbExpr: Z.textInputFocus,
          primary: 3601,
          linux: { primary: 0 }
        }
      });
    }
    _getColumnSelectResult(b, C, w, v) {
      return Tc.columnSelectRight(b.cursorConfig, b, w);
    }
  }());
  class i extends t {
    constructor(C) {
      super(C), this._isPaged = C.isPaged;
    }
    _getColumnSelectResult(C, w, v, S) {
      return Tc.columnSelectUp(C.cursorConfig, C, v, this._isPaged);
    }
  }
  s.CursorColumnSelectUp = Le(new i({
    isPaged: !1,
    id: "cursorColumnSelectUp",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 3600,
      linux: { primary: 0 }
    }
  })), s.CursorColumnSelectPageUp = Le(new i({
    isPaged: !0,
    id: "cursorColumnSelectPageUp",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 3595,
      linux: { primary: 0 }
    }
  }));
  class n extends t {
    constructor(C) {
      super(C), this._isPaged = C.isPaged;
    }
    _getColumnSelectResult(C, w, v, S) {
      return Tc.columnSelectDown(C.cursorConfig, C, v, this._isPaged);
    }
  }
  s.CursorColumnSelectDown = Le(new n({
    isPaged: !1,
    id: "cursorColumnSelectDown",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 3602,
      linux: { primary: 0 }
    }
  })), s.CursorColumnSelectPageDown = Le(new n({
    isPaged: !0,
    id: "cursorColumnSelectPageDown",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 3596,
      linux: { primary: 0 }
    }
  }));
  class o extends Ht {
    constructor() {
      super({
        id: "cursorMove",
        precondition: void 0,
        metadata: b1.metadata
      });
    }
    runCoreEditorCommand(C, w) {
      const v = b1.parse(w);
      v && this._runCursorMove(C, w.source, v);
    }
    _runCursorMove(C, w, v) {
      C.model.pushStackElement(), C.setCursorStates(w, 3, o._move(C, C.getCursorStates(), v)), C.revealAllCursors(w, !0);
    }
    static _move(C, w, v) {
      const S = v.select, L = v.value;
      switch (v.direction) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
          return Qi.simpleMove(C, w, v.direction, S, L, v.unit);
        case 11:
        case 13:
        case 12:
        case 14:
          return Qi.viewportMove(C, w, v.direction, S, L);
        default:
          return null;
      }
    }
  }
  s.CursorMoveImpl = o, s.CursorMove = Le(new o());
  class r extends Ht {
    constructor(C) {
      super(C), this._staticArgs = C.args;
    }
    runCoreEditorCommand(C, w) {
      let v = this._staticArgs;
      this._staticArgs.value === -1 && (v = {
        direction: this._staticArgs.direction,
        unit: this._staticArgs.unit,
        select: this._staticArgs.select,
        value: w.pageSize || C.cursorConfig.pageSize
      }), C.model.pushStackElement(), C.setCursorStates(w.source, 3, Qi.simpleMove(C, C.getCursorStates(), v.direction, v.select, v.value, v.unit)), C.revealAllCursors(w.source, !0);
    }
  }
  s.CursorLeft = Le(new r({
    args: {
      direction: 0,
      unit: 0,
      select: !1,
      value: 1
    },
    id: "cursorLeft",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 15,
      mac: { primary: 15, secondary: [
        288
        /* KeyCode.KeyB */
      ] }
    }
  })), s.CursorLeftSelect = Le(new r({
    args: {
      direction: 0,
      unit: 0,
      select: !0,
      value: 1
    },
    id: "cursorLeftSelect",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 1039
      /* KeyCode.LeftArrow */
    }
  })), s.CursorRight = Le(new r({
    args: {
      direction: 1,
      unit: 0,
      select: !1,
      value: 1
    },
    id: "cursorRight",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 17,
      mac: { primary: 17, secondary: [
        292
        /* KeyCode.KeyF */
      ] }
    }
  })), s.CursorRightSelect = Le(new r({
    args: {
      direction: 1,
      unit: 0,
      select: !0,
      value: 1
    },
    id: "cursorRightSelect",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 1041
      /* KeyCode.RightArrow */
    }
  })), s.CursorUp = Le(new r({
    args: {
      direction: 2,
      unit: 2,
      select: !1,
      value: 1
    },
    id: "cursorUp",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 16,
      mac: { primary: 16, secondary: [
        302
        /* KeyCode.KeyP */
      ] }
    }
  })), s.CursorUpSelect = Le(new r({
    args: {
      direction: 2,
      unit: 2,
      select: !0,
      value: 1
    },
    id: "cursorUpSelect",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 1040,
      secondary: [
        3088
        /* KeyCode.UpArrow */
      ],
      mac: {
        primary: 1040
        /* KeyCode.UpArrow */
      },
      linux: {
        primary: 1040
        /* KeyCode.UpArrow */
      }
    }
  })), s.CursorPageUp = Le(new r({
    args: {
      direction: 2,
      unit: 2,
      select: !1,
      value: -1
      /* Constants.PAGE_SIZE_MARKER */
    },
    id: "cursorPageUp",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 11
      /* KeyCode.PageUp */
    }
  })), s.CursorPageUpSelect = Le(new r({
    args: {
      direction: 2,
      unit: 2,
      select: !0,
      value: -1
      /* Constants.PAGE_SIZE_MARKER */
    },
    id: "cursorPageUpSelect",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 1035
      /* KeyCode.PageUp */
    }
  })), s.CursorDown = Le(new r({
    args: {
      direction: 3,
      unit: 2,
      select: !1,
      value: 1
    },
    id: "cursorDown",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 18,
      mac: { primary: 18, secondary: [
        300
        /* KeyCode.KeyN */
      ] }
    }
  })), s.CursorDownSelect = Le(new r({
    args: {
      direction: 3,
      unit: 2,
      select: !0,
      value: 1
    },
    id: "cursorDownSelect",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 1042,
      secondary: [
        3090
        /* KeyCode.DownArrow */
      ],
      mac: {
        primary: 1042
        /* KeyCode.DownArrow */
      },
      linux: {
        primary: 1042
        /* KeyCode.DownArrow */
      }
    }
  })), s.CursorPageDown = Le(new r({
    args: {
      direction: 3,
      unit: 2,
      select: !1,
      value: -1
      /* Constants.PAGE_SIZE_MARKER */
    },
    id: "cursorPageDown",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 12
      /* KeyCode.PageDown */
    }
  })), s.CursorPageDownSelect = Le(new r({
    args: {
      direction: 3,
      unit: 2,
      select: !0,
      value: -1
      /* Constants.PAGE_SIZE_MARKER */
    },
    id: "cursorPageDownSelect",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 1036
      /* KeyCode.PageDown */
    }
  })), s.CreateCursor = Le(new class extends Ht {
    constructor() {
      super({
        id: "createCursor",
        precondition: void 0
      });
    }
    runCoreEditorCommand(b, C) {
      if (!C.position)
        return;
      let w;
      C.wholeLine ? w = Qi.line(b, b.getPrimaryCursorState(), !1, C.position, C.viewPosition) : w = Qi.moveTo(b, b.getPrimaryCursorState(), !1, C.position, C.viewPosition);
      const v = b.getCursorStates();
      if (v.length > 1) {
        const S = w.modelState ? w.modelState.position : null, L = w.viewState ? w.viewState.position : null;
        for (let k = 0, x = v.length; k < x; k++) {
          const I = v[k];
          if (!(S && !I.modelState.selection.containsPosition(S)) && !(L && !I.viewState.selection.containsPosition(L))) {
            v.splice(k, 1), b.model.pushStackElement(), b.setCursorStates(C.source, 3, v);
            return;
          }
        }
      }
      v.push(w), b.model.pushStackElement(), b.setCursorStates(C.source, 3, v);
    }
  }()), s.LastCursorMoveToSelect = Le(new class extends Ht {
    constructor() {
      super({
        id: "_lastCursorMoveToSelect",
        precondition: void 0
      });
    }
    runCoreEditorCommand(b, C) {
      if (!C.position)
        return;
      const w = b.getLastAddedCursorIndex(), v = b.getCursorStates(), S = v.slice(0);
      S[w] = Qi.moveTo(b, v[w], !0, C.position, C.viewPosition), b.model.pushStackElement(), b.setCursorStates(C.source, 3, S);
    }
  }());
  class a extends Ht {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement(), C.setCursorStates(w.source, 3, Qi.moveToBeginningOfLine(C, C.getCursorStates(), this._inSelectionMode)), C.revealAllCursors(w.source, !0);
    }
  }
  s.CursorHome = Le(new a({
    inSelectionMode: !1,
    id: "cursorHome",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 14,
      mac: { primary: 14, secondary: [
        2063
        /* KeyCode.LeftArrow */
      ] }
    }
  })), s.CursorHomeSelect = Le(new a({
    inSelectionMode: !0,
    id: "cursorHomeSelect",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 1038,
      mac: { primary: 1038, secondary: [
        3087
        /* KeyCode.LeftArrow */
      ] }
    }
  }));
  class l extends Ht {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement(), C.setCursorStates(w.source, 3, this._exec(C.getCursorStates())), C.revealAllCursors(w.source, !0);
    }
    _exec(C) {
      const w = [];
      for (let v = 0, S = C.length; v < S; v++) {
        const L = C[v], k = L.modelState.position.lineNumber;
        w[v] = Ve.fromModelState(L.modelState.move(this._inSelectionMode, k, 1, 0));
      }
      return w;
    }
  }
  s.CursorLineStart = Le(new l({
    inSelectionMode: !1,
    id: "cursorLineStart",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 0,
      mac: {
        primary: 287
        /* KeyCode.KeyA */
      }
    }
  })), s.CursorLineStartSelect = Le(new l({
    inSelectionMode: !0,
    id: "cursorLineStartSelect",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 0,
      mac: {
        primary: 1311
        /* KeyCode.KeyA */
      }
    }
  }));
  class c extends Ht {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement(), C.setCursorStates(w.source, 3, Qi.moveToEndOfLine(C, C.getCursorStates(), this._inSelectionMode, w.sticky || !1)), C.revealAllCursors(w.source, !0);
    }
  }
  s.CursorEnd = Le(new c({
    inSelectionMode: !1,
    id: "cursorEnd",
    precondition: void 0,
    kbOpts: {
      args: { sticky: !1 },
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 13,
      mac: { primary: 13, secondary: [
        2065
        /* KeyCode.RightArrow */
      ] }
    },
    metadata: {
      description: "Go to End",
      args: [{
        name: "args",
        schema: {
          type: "object",
          properties: {
            sticky: {
              description: m("stickydesc", "Stick to the end even when going to longer lines"),
              type: "boolean",
              default: !1
            }
          }
        }
      }]
    }
  })), s.CursorEndSelect = Le(new c({
    inSelectionMode: !0,
    id: "cursorEndSelect",
    precondition: void 0,
    kbOpts: {
      args: { sticky: !1 },
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 1037,
      mac: { primary: 1037, secondary: [
        3089
        /* KeyCode.RightArrow */
      ] }
    },
    metadata: {
      description: "Select to End",
      args: [{
        name: "args",
        schema: {
          type: "object",
          properties: {
            sticky: {
              description: m("stickydesc", "Stick to the end even when going to longer lines"),
              type: "boolean",
              default: !1
            }
          }
        }
      }]
    }
  }));
  class h extends Ht {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement(), C.setCursorStates(w.source, 3, this._exec(C, C.getCursorStates())), C.revealAllCursors(w.source, !0);
    }
    _exec(C, w) {
      const v = [];
      for (let S = 0, L = w.length; S < L; S++) {
        const k = w[S], x = k.modelState.position.lineNumber, I = C.model.getLineMaxColumn(x);
        v[S] = Ve.fromModelState(k.modelState.move(this._inSelectionMode, x, I, 0));
      }
      return v;
    }
  }
  s.CursorLineEnd = Le(new h({
    inSelectionMode: !1,
    id: "cursorLineEnd",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 0,
      mac: {
        primary: 291
        /* KeyCode.KeyE */
      }
    }
  })), s.CursorLineEndSelect = Le(new h({
    inSelectionMode: !0,
    id: "cursorLineEndSelect",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 0,
      mac: {
        primary: 1315
        /* KeyCode.KeyE */
      }
    }
  }));
  class d extends Ht {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement(), C.setCursorStates(w.source, 3, Qi.moveToBeginningOfBuffer(C, C.getCursorStates(), this._inSelectionMode)), C.revealAllCursors(w.source, !0);
    }
  }
  s.CursorTop = Le(new d({
    inSelectionMode: !1,
    id: "cursorTop",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 2062,
      mac: {
        primary: 2064
        /* KeyCode.UpArrow */
      }
    }
  })), s.CursorTopSelect = Le(new d({
    inSelectionMode: !0,
    id: "cursorTopSelect",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 3086,
      mac: {
        primary: 3088
        /* KeyCode.UpArrow */
      }
    }
  }));
  class u extends Ht {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      C.model.pushStackElement(), C.setCursorStates(w.source, 3, Qi.moveToEndOfBuffer(C, C.getCursorStates(), this._inSelectionMode)), C.revealAllCursors(w.source, !0);
    }
  }
  s.CursorBottom = Le(new u({
    inSelectionMode: !1,
    id: "cursorBottom",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 2061,
      mac: {
        primary: 2066
        /* KeyCode.DownArrow */
      }
    }
  })), s.CursorBottomSelect = Le(new u({
    inSelectionMode: !0,
    id: "cursorBottomSelect",
    precondition: void 0,
    kbOpts: {
      weight: tt,
      kbExpr: Z.textInputFocus,
      primary: 3085,
      mac: {
        primary: 3090
        /* KeyCode.DownArrow */
      }
    }
  }));
  class f extends Ht {
    constructor() {
      super({
        id: "editorScroll",
        precondition: void 0,
        metadata: Pi.metadata
      });
    }
    determineScrollMethod(C) {
      const w = [
        6
        /* EditorScroll_.Unit.Column */
      ], v = [
        1,
        2,
        3,
        4,
        5,
        6
        /* EditorScroll_.Unit.Column */
      ], S = [
        4,
        2
        /* EditorScroll_.Direction.Right */
      ], L = [
        1,
        3
        /* EditorScroll_.Direction.Down */
      ];
      return w.includes(C.unit) && S.includes(C.direction) ? this._runHorizontalEditorScroll.bind(this) : v.includes(C.unit) && L.includes(C.direction) ? this._runVerticalEditorScroll.bind(this) : null;
    }
    runCoreEditorCommand(C, w) {
      const v = Pi.parse(w);
      if (!v)
        return;
      const S = this.determineScrollMethod(v);
      S && S(C, w.source, v);
    }
    _runVerticalEditorScroll(C, w, v) {
      const S = this._computeDesiredScrollTop(C, v);
      if (v.revealCursor) {
        const L = C.getCompletelyVisibleViewRangeAtScrollTop(S);
        C.setCursorStates(w, 3, [
          Qi.findPositionInViewportIfOutside(C, C.getPrimaryCursorState(), L, v.select)
        ]);
      }
      C.viewLayout.setScrollPosition(
        { scrollTop: S },
        0
        /* ScrollType.Smooth */
      );
    }
    _computeDesiredScrollTop(C, w) {
      if (w.unit === 1) {
        const L = C.viewLayout.getFutureViewport(), k = C.getCompletelyVisibleViewRangeAtScrollTop(L.top), x = C.coordinatesConverter.convertViewRangeToModelRange(k);
        let I;
        w.direction === 1 ? I = Math.max(1, x.startLineNumber - w.value) : I = Math.min(C.model.getLineCount(), x.startLineNumber + w.value);
        const K = C.coordinatesConverter.convertModelPositionToViewPosition(new F(I, 1));
        return C.viewLayout.getVerticalOffsetForLineNumber(K.lineNumber);
      }
      if (w.unit === 5) {
        let L = 0;
        return w.direction === 3 && (L = C.model.getLineCount() - C.cursorConfig.pageSize), C.viewLayout.getVerticalOffsetForLineNumber(L);
      }
      let v;
      w.unit === 3 ? v = C.cursorConfig.pageSize * w.value : w.unit === 4 ? v = Math.round(C.cursorConfig.pageSize / 2) * w.value : v = w.value;
      const S = (w.direction === 1 ? -1 : 1) * v;
      return C.viewLayout.getCurrentScrollTop() + S * C.cursorConfig.lineHeight;
    }
    _runHorizontalEditorScroll(C, w, v) {
      const S = this._computeDesiredScrollLeft(C, v);
      C.viewLayout.setScrollPosition(
        { scrollLeft: S },
        0
        /* ScrollType.Smooth */
      );
    }
    _computeDesiredScrollLeft(C, w) {
      const v = (w.direction === 4 ? -1 : 1) * w.value;
      return C.viewLayout.getCurrentScrollLeft() + v * C.cursorConfig.typicalHalfwidthCharacterWidth;
    }
  }
  s.EditorScrollImpl = f, s.EditorScroll = Le(new f()), s.ScrollLineUp = Le(new class extends Ht {
    constructor() {
      super({
        id: "scrollLineUp",
        precondition: void 0,
        kbOpts: {
          weight: tt,
          kbExpr: Z.textInputFocus,
          primary: 2064,
          mac: {
            primary: 267
            /* KeyCode.PageUp */
          }
        }
      });
    }
    runCoreEditorCommand(b, C) {
      s.EditorScroll.runCoreEditorCommand(b, {
        to: Pi.RawDirection.Up,
        by: Pi.RawUnit.WrappedLine,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: C.source
      });
    }
  }()), s.ScrollPageUp = Le(new class extends Ht {
    constructor() {
      super({
        id: "scrollPageUp",
        precondition: void 0,
        kbOpts: {
          weight: tt,
          kbExpr: Z.textInputFocus,
          primary: 2059,
          win: {
            primary: 523
            /* KeyCode.PageUp */
          },
          linux: {
            primary: 523
            /* KeyCode.PageUp */
          }
        }
      });
    }
    runCoreEditorCommand(b, C) {
      s.EditorScroll.runCoreEditorCommand(b, {
        to: Pi.RawDirection.Up,
        by: Pi.RawUnit.Page,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: C.source
      });
    }
  }()), s.ScrollEditorTop = Le(new class extends Ht {
    constructor() {
      super({
        id: "scrollEditorTop",
        precondition: void 0,
        kbOpts: {
          weight: tt,
          kbExpr: Z.textInputFocus
        }
      });
    }
    runCoreEditorCommand(b, C) {
      s.EditorScroll.runCoreEditorCommand(b, {
        to: Pi.RawDirection.Up,
        by: Pi.RawUnit.Editor,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: C.source
      });
    }
  }()), s.ScrollLineDown = Le(new class extends Ht {
    constructor() {
      super({
        id: "scrollLineDown",
        precondition: void 0,
        kbOpts: {
          weight: tt,
          kbExpr: Z.textInputFocus,
          primary: 2066,
          mac: {
            primary: 268
            /* KeyCode.PageDown */
          }
        }
      });
    }
    runCoreEditorCommand(b, C) {
      s.EditorScroll.runCoreEditorCommand(b, {
        to: Pi.RawDirection.Down,
        by: Pi.RawUnit.WrappedLine,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: C.source
      });
    }
  }()), s.ScrollPageDown = Le(new class extends Ht {
    constructor() {
      super({
        id: "scrollPageDown",
        precondition: void 0,
        kbOpts: {
          weight: tt,
          kbExpr: Z.textInputFocus,
          primary: 2060,
          win: {
            primary: 524
            /* KeyCode.PageDown */
          },
          linux: {
            primary: 524
            /* KeyCode.PageDown */
          }
        }
      });
    }
    runCoreEditorCommand(b, C) {
      s.EditorScroll.runCoreEditorCommand(b, {
        to: Pi.RawDirection.Down,
        by: Pi.RawUnit.Page,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: C.source
      });
    }
  }()), s.ScrollEditorBottom = Le(new class extends Ht {
    constructor() {
      super({
        id: "scrollEditorBottom",
        precondition: void 0,
        kbOpts: {
          weight: tt,
          kbExpr: Z.textInputFocus
        }
      });
    }
    runCoreEditorCommand(b, C) {
      s.EditorScroll.runCoreEditorCommand(b, {
        to: Pi.RawDirection.Down,
        by: Pi.RawUnit.Editor,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: C.source
      });
    }
  }()), s.ScrollLeft = Le(new class extends Ht {
    constructor() {
      super({
        id: "scrollLeft",
        precondition: void 0,
        kbOpts: {
          weight: tt,
          kbExpr: Z.textInputFocus
        }
      });
    }
    runCoreEditorCommand(b, C) {
      s.EditorScroll.runCoreEditorCommand(b, {
        to: Pi.RawDirection.Left,
        by: Pi.RawUnit.Column,
        value: 2,
        revealCursor: !1,
        select: !1,
        source: C.source
      });
    }
  }()), s.ScrollRight = Le(new class extends Ht {
    constructor() {
      super({
        id: "scrollRight",
        precondition: void 0,
        kbOpts: {
          weight: tt,
          kbExpr: Z.textInputFocus
        }
      });
    }
    runCoreEditorCommand(b, C) {
      s.EditorScroll.runCoreEditorCommand(b, {
        to: Pi.RawDirection.Right,
        by: Pi.RawUnit.Column,
        value: 2,
        revealCursor: !1,
        select: !1,
        source: C.source
      });
    }
  }());
  class g extends Ht {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      w.position && (C.model.pushStackElement(), C.setCursorStates(w.source, 3, [
        Qi.word(C, C.getPrimaryCursorState(), this._inSelectionMode, w.position)
      ]), w.revealType !== 2 && C.revealAllCursors(w.source, !0, !0));
    }
  }
  s.WordSelect = Le(new g({
    inSelectionMode: !1,
    id: "_wordSelect",
    precondition: void 0
  })), s.WordSelectDrag = Le(new g({
    inSelectionMode: !0,
    id: "_wordSelectDrag",
    precondition: void 0
  })), s.LastCursorWordSelect = Le(new class extends Ht {
    constructor() {
      super({
        id: "lastCursorWordSelect",
        precondition: void 0
      });
    }
    runCoreEditorCommand(b, C) {
      if (!C.position)
        return;
      const w = b.getLastAddedCursorIndex(), v = b.getCursorStates(), S = v.slice(0), L = v[w];
      S[w] = Qi.word(b, L, L.modelState.hasSelection(), C.position), b.model.pushStackElement(), b.setCursorStates(C.source, 3, S);
    }
  }());
  class p extends Ht {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      w.position && (C.model.pushStackElement(), C.setCursorStates(w.source, 3, [
        Qi.line(C, C.getPrimaryCursorState(), this._inSelectionMode, w.position, w.viewPosition)
      ]), w.revealType !== 2 && C.revealAllCursors(w.source, !1, !0));
    }
  }
  s.LineSelect = Le(new p({
    inSelectionMode: !1,
    id: "_lineSelect",
    precondition: void 0
  })), s.LineSelectDrag = Le(new p({
    inSelectionMode: !0,
    id: "_lineSelectDrag",
    precondition: void 0
  }));
  class _ extends Ht {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, w) {
      if (!w.position)
        return;
      const v = C.getLastAddedCursorIndex(), S = C.getCursorStates(), L = S.slice(0);
      L[v] = Qi.line(C, S[v], this._inSelectionMode, w.position, w.viewPosition), C.model.pushStackElement(), C.setCursorStates(w.source, 3, L);
    }
  }
  s.LastCursorLineSelect = Le(new _({
    inSelectionMode: !1,
    id: "lastCursorLineSelect",
    precondition: void 0
  })), s.LastCursorLineSelectDrag = Le(new _({
    inSelectionMode: !0,
    id: "lastCursorLineSelectDrag",
    precondition: void 0
  })), s.CancelSelection = Le(new class extends Ht {
    constructor() {
      super({
        id: "cancelSelection",
        precondition: Z.hasNonEmptySelection,
        kbOpts: {
          weight: tt,
          kbExpr: Z.textInputFocus,
          primary: 9,
          secondary: [
            1033
            /* KeyCode.Escape */
          ]
        }
      });
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, [
        Qi.cancelSelection(b, b.getPrimaryCursorState())
      ]), b.revealAllCursors(C.source, !0);
    }
  }()), s.RemoveSecondaryCursors = Le(new class extends Ht {
    constructor() {
      super({
        id: "removeSecondaryCursors",
        precondition: Z.hasMultipleSelections,
        kbOpts: {
          weight: tt + 1,
          kbExpr: Z.textInputFocus,
          primary: 9,
          secondary: [
            1033
            /* KeyCode.Escape */
          ]
        }
      });
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, [
        b.getPrimaryCursorState()
      ]), b.revealAllCursors(C.source, !0), Rm(m("removedCursor", "Removed secondary cursors"));
    }
  }()), s.RevealLine = Le(new class extends Ht {
    constructor() {
      super({
        id: "revealLine",
        precondition: void 0,
        metadata: iu.metadata
      });
    }
    runCoreEditorCommand(b, C) {
      const w = C, v = w.lineNumber || 0;
      let S = typeof v == "number" ? v + 1 : parseInt(v) + 1;
      S < 1 && (S = 1);
      const L = b.model.getLineCount();
      S > L && (S = L);
      const k = new T(S, 1, S, b.model.getLineMaxColumn(S));
      let x = 0;
      if (w.at)
        switch (w.at) {
          case iu.RawAtArgument.Top:
            x = 3;
            break;
          case iu.RawAtArgument.Center:
            x = 1;
            break;
          case iu.RawAtArgument.Bottom:
            x = 4;
            break;
        }
      const I = b.coordinatesConverter.convertModelRangeToViewRange(k);
      b.revealRange(
        C.source,
        !1,
        I,
        x,
        0
        /* ScrollType.Smooth */
      );
    }
  }()), s.SelectAll = new class extends QS {
    constructor() {
      super(uB);
    }
    runDOMCommand(b) {
      uo && (b.focus(), b.select()), b.ownerDocument.execCommand("selectAll");
    }
    runEditorCommand(b, C, w) {
      const v = C._getViewModel();
      v && this.runCoreEditorCommand(v, w);
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates("keyboard", 3, [
        Qi.selectAll(b, b.getPrimaryCursorState())
      ]);
    }
  }(), s.SetSelection = Le(new class extends Ht {
    constructor() {
      super({
        id: "setSelection",
        precondition: void 0
      });
    }
    runCoreEditorCommand(b, C) {
      C.selection && (b.model.pushStackElement(), b.setCursorStates(C.source, 3, [
        Ve.fromModelSelection(C.selection)
      ]));
    }
  }());
})(Ci || (Ci = {}));
const Gj = ve.and(Z.textInputFocus, Z.columnSelection);
function Wf(s, e) {
  ts.registerKeybindingRule({
    id: s,
    primary: e,
    when: Gj,
    weight: tt + 1
  });
}
Wf(
  Ci.CursorColumnSelectLeft.id,
  1039
  /* KeyCode.LeftArrow */
);
Wf(
  Ci.CursorColumnSelectRight.id,
  1041
  /* KeyCode.RightArrow */
);
Wf(
  Ci.CursorColumnSelectUp.id,
  1040
  /* KeyCode.UpArrow */
);
Wf(
  Ci.CursorColumnSelectPageUp.id,
  1035
  /* KeyCode.PageUp */
);
Wf(
  Ci.CursorColumnSelectDown.id,
  1042
  /* KeyCode.DownArrow */
);
Wf(
  Ci.CursorColumnSelectPageDown.id,
  1036
  /* KeyCode.PageDown */
);
function YT(s) {
  return s.register(), s;
}
var XT;
(function(s) {
  class e extends jo {
    runEditorCommand(i, n, o) {
      const r = n._getViewModel();
      r && this.runCoreEditingCommand(n, r, o || {});
    }
  }
  s.CoreEditingCommand = e, s.LineBreakInsert = Le(new class extends e {
    constructor() {
      super({
        id: "lineBreakInsert",
        precondition: Z.writable,
        kbOpts: {
          weight: tt,
          kbExpr: Z.textInputFocus,
          primary: 0,
          mac: {
            primary: 301
            /* KeyCode.KeyO */
          }
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      t.pushUndoStop(), t.executeCommands(this.id, z5.lineBreakInsert(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection)));
    }
  }()), s.Outdent = Le(new class extends e {
    constructor() {
      super({
        id: "outdent",
        precondition: Z.writable,
        kbOpts: {
          weight: tt,
          kbExpr: ve.and(Z.editorTextFocus, Z.tabDoesNotMoveFocus),
          primary: 1026
          /* KeyCode.Tab */
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      t.pushUndoStop(), t.executeCommands(this.id, Mc.outdent(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection))), t.pushUndoStop();
    }
  }()), s.Tab = Le(new class extends e {
    constructor() {
      super({
        id: "tab",
        precondition: Z.writable,
        kbOpts: {
          weight: tt,
          kbExpr: ve.and(Z.editorTextFocus, Z.tabDoesNotMoveFocus),
          primary: 2
          /* KeyCode.Tab */
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      t.pushUndoStop(), t.executeCommands(this.id, Mc.tab(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection))), t.pushUndoStop();
    }
  }()), s.DeleteLeft = Le(new class extends e {
    constructor() {
      super({
        id: "deleteLeft",
        precondition: void 0,
        kbOpts: {
          weight: tt,
          kbExpr: Z.textInputFocus,
          primary: 1,
          secondary: [
            1025
            /* KeyCode.Backspace */
          ],
          mac: { primary: 1, secondary: [
            1025,
            294,
            257
            /* KeyCode.Backspace */
          ] }
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      const [o, r] = jh.deleteLeft(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection), i.getCursorAutoClosedCharacters());
      o && t.pushUndoStop(), t.executeCommands(this.id, r), i.setPrevEditOperationType(
        2
        /* EditOperationType.DeletingLeft */
      );
    }
  }()), s.DeleteRight = Le(new class extends e {
    constructor() {
      super({
        id: "deleteRight",
        precondition: void 0,
        kbOpts: {
          weight: tt,
          kbExpr: Z.textInputFocus,
          primary: 20,
          mac: { primary: 20, secondary: [
            290,
            276
            /* KeyCode.Delete */
          ] }
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      const [o, r] = jh.deleteRight(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection));
      o && t.pushUndoStop(), t.executeCommands(this.id, r), i.setPrevEditOperationType(
        3
        /* EditOperationType.DeletingRight */
      );
    }
  }()), s.Undo = new class extends QS {
    constructor() {
      super(j4);
    }
    runDOMCommand(t) {
      t.ownerDocument.execCommand("undo");
    }
    runEditorCommand(t, i, n) {
      if (!(!i.hasModel() || i.getOption(
        92
        /* EditorOption.readOnly */
      ) === !0))
        return i.getModel().undo();
    }
  }(), s.Redo = new class extends QS {
    constructor() {
      super(q4);
    }
    runDOMCommand(t) {
      t.ownerDocument.execCommand("redo");
    }
    runEditorCommand(t, i, n) {
      if (!(!i.hasModel() || i.getOption(
        92
        /* EditorOption.readOnly */
      ) === !0))
        return i.getModel().redo();
    }
  }();
})(XT || (XT = {}));
class QT extends Jv {
  constructor(e, t, i) {
    super({
      id: e,
      precondition: void 0,
      metadata: i
    }), this._handlerId = t;
  }
  runCommand(e, t) {
    const i = e.get(Tt).getFocusedCodeEditor();
    i && i.trigger("keyboard", this._handlerId, t);
  }
}
function dd(s, e) {
  YT(new QT("default:" + s, s)), YT(new QT(s, s, e));
}
dd("type", {
  description: "Type",
  args: [{
    name: "args",
    schema: {
      type: "object",
      required: ["text"],
      properties: {
        text: {
          type: "string"
        }
      }
    }
  }]
});
dd(
  "replacePreviousChar"
  /* Handler.ReplacePreviousChar */
);
dd(
  "compositionType"
  /* Handler.CompositionType */
);
dd(
  "compositionStart"
  /* Handler.CompositionStart */
);
dd(
  "compositionEnd"
  /* Handler.CompositionEnd */
);
dd(
  "paste"
  /* Handler.Paste */
);
dd(
  "cut"
  /* Handler.Cut */
);
class Zj {
  constructor(e, t, i, n) {
    this.configuration = e, this.viewModel = t, this.userInputEvents = i, this.commandDelegate = n;
  }
  paste(e, t, i, n) {
    this.commandDelegate.paste(e, t, i, n);
  }
  type(e) {
    this.commandDelegate.type(e);
  }
  compositionType(e, t, i, n) {
    this.commandDelegate.compositionType(e, t, i, n);
  }
  compositionStart() {
    this.commandDelegate.startComposition();
  }
  compositionEnd() {
    this.commandDelegate.endComposition();
  }
  cut() {
    this.commandDelegate.cut();
  }
  setSelection(e) {
    Ci.SetSelection.runCoreEditorCommand(this.viewModel, {
      source: "keyboard",
      selection: e
    });
  }
  _validateViewColumn(e) {
    const t = this.viewModel.getLineMinColumn(e.lineNumber);
    return e.column < t ? new F(e.lineNumber, t) : e;
  }
  _hasMulticursorModifier(e) {
    switch (this.configuration.options.get(
      78
      /* EditorOption.multiCursorModifier */
    )) {
      case "altKey":
        return e.altKey;
      case "ctrlKey":
        return e.ctrlKey;
      case "metaKey":
        return e.metaKey;
      default:
        return !1;
    }
  }
  _hasNonMulticursorModifier(e) {
    switch (this.configuration.options.get(
      78
      /* EditorOption.multiCursorModifier */
    )) {
      case "altKey":
        return e.ctrlKey || e.metaKey;
      case "ctrlKey":
        return e.altKey || e.metaKey;
      case "metaKey":
        return e.ctrlKey || e.altKey;
      default:
        return !1;
    }
  }
  dispatchMouse(e) {
    const t = this.configuration.options, i = Rn && t.get(
      108
      /* EditorOption.selectionClipboard */
    ), n = t.get(
      22
      /* EditorOption.columnSelection */
    );
    e.middleButton && !i ? this._columnSelect(e.position, e.mouseColumn, e.inSelectionMode) : e.startedOnLineNumbers ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelect(e.position, e.revealType) : this._createCursor(e.position, !0) : e.inSelectionMode ? this._lineSelectDrag(e.position, e.revealType) : this._lineSelect(e.position, e.revealType) : e.mouseDownCount >= 4 ? this._selectAll() : e.mouseDownCount === 3 ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelectDrag(e.position, e.revealType) : this._lastCursorLineSelect(e.position, e.revealType) : e.inSelectionMode ? this._lineSelectDrag(e.position, e.revealType) : this._lineSelect(e.position, e.revealType) : e.mouseDownCount === 2 ? e.onInjectedText || (this._hasMulticursorModifier(e) ? this._lastCursorWordSelect(e.position, e.revealType) : e.inSelectionMode ? this._wordSelectDrag(e.position, e.revealType) : this._wordSelect(e.position, e.revealType)) : this._hasMulticursorModifier(e) ? this._hasNonMulticursorModifier(e) || (e.shiftKey ? this._columnSelect(e.position, e.mouseColumn, !0) : e.inSelectionMode ? this._lastCursorMoveToSelect(e.position, e.revealType) : this._createCursor(e.position, !1)) : e.inSelectionMode ? e.altKey ? this._columnSelect(e.position, e.mouseColumn, !0) : n ? this._columnSelect(e.position, e.mouseColumn, !0) : this._moveToSelect(e.position, e.revealType) : this.moveTo(e.position, e.revealType);
  }
  _usualArgs(e, t) {
    return e = this._validateViewColumn(e), {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      revealType: t
    };
  }
  moveTo(e, t) {
    Ci.MoveTo.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _moveToSelect(e, t) {
    Ci.MoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _columnSelect(e, t, i) {
    e = this._validateViewColumn(e), Ci.ColumnSelect.runCoreEditorCommand(this.viewModel, {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      mouseColumn: t,
      doColumnSelect: i
    });
  }
  _createCursor(e, t) {
    e = this._validateViewColumn(e), Ci.CreateCursor.runCoreEditorCommand(this.viewModel, {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      wholeLine: t
    });
  }
  _lastCursorMoveToSelect(e, t) {
    Ci.LastCursorMoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _wordSelect(e, t) {
    Ci.WordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _wordSelectDrag(e, t) {
    Ci.WordSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lastCursorWordSelect(e, t) {
    Ci.LastCursorWordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lineSelect(e, t) {
    Ci.LineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lineSelectDrag(e, t) {
    Ci.LineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lastCursorLineSelect(e, t) {
    Ci.LastCursorLineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lastCursorLineSelectDrag(e, t) {
    Ci.LastCursorLineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _selectAll() {
    Ci.SelectAll.runCoreEditorCommand(this.viewModel, { source: "mouse" });
  }
  // ----------------------
  _convertViewToModelPosition(e) {
    return this.viewModel.coordinatesConverter.convertViewPositionToModelPosition(e);
  }
  emitKeyDown(e) {
    this.userInputEvents.emitKeyDown(e);
  }
  emitKeyUp(e) {
    this.userInputEvents.emitKeyUp(e);
  }
  emitContextMenu(e) {
    this.userInputEvents.emitContextMenu(e);
  }
  emitMouseMove(e) {
    this.userInputEvents.emitMouseMove(e);
  }
  emitMouseLeave(e) {
    this.userInputEvents.emitMouseLeave(e);
  }
  emitMouseUp(e) {
    this.userInputEvents.emitMouseUp(e);
  }
  emitMouseDown(e) {
    this.userInputEvents.emitMouseDown(e);
  }
  emitMouseDrag(e) {
    this.userInputEvents.emitMouseDrag(e);
  }
  emitMouseDrop(e) {
    this.userInputEvents.emitMouseDrop(e);
  }
  emitMouseDropCanceled() {
    this.userInputEvents.emitMouseDropCanceled();
  }
  emitMouseWheel(e) {
    this.userInputEvents.emitMouseWheel(e);
  }
}
function ud(s, e) {
  var i;
  const t = globalThis.MonacoEnvironment;
  if (t != null && t.createTrustedTypesPolicy)
    try {
      return t.createTrustedTypesPolicy(s, e);
    } catch (n) {
      Je(n);
      return;
    }
  try {
    return (i = globalThis.trustedTypes) == null ? void 0 : i.createPolicy(s, e);
  } catch (n) {
    Je(n);
    return;
  }
}
class K5 {
  constructor(e) {
    this._lineFactory = e, this._set(1, []);
  }
  flush() {
    this._set(1, []);
  }
  _set(e, t) {
    this._lines = t, this._rendLineNumberStart = e;
  }
  _get() {
    return {
      rendLineNumberStart: this._rendLineNumberStart,
      lines: this._lines
    };
  }
  /**
   * @returns Inclusive line number that is inside this collection
   */
  getStartLineNumber() {
    return this._rendLineNumberStart;
  }
  /**
   * @returns Inclusive line number that is inside this collection
   */
  getEndLineNumber() {
    return this._rendLineNumberStart + this._lines.length - 1;
  }
  getCount() {
    return this._lines.length;
  }
  getLine(e) {
    const t = e - this._rendLineNumberStart;
    if (t < 0 || t >= this._lines.length)
      throw new at("Illegal value for lineNumber");
    return this._lines[t];
  }
  /**
   * @returns Lines that were removed from this collection
   */
  onLinesDeleted(e, t) {
    if (this.getCount() === 0)
      return null;
    const i = this.getStartLineNumber(), n = this.getEndLineNumber();
    if (t < i) {
      const l = t - e + 1;
      return this._rendLineNumberStart -= l, null;
    }
    if (e > n)
      return null;
    let o = 0, r = 0;
    for (let l = i; l <= n; l++) {
      const c = l - this._rendLineNumberStart;
      e <= l && l <= t && (r === 0 ? (o = c, r = 1) : r++);
    }
    if (e < i) {
      let l = 0;
      t < i ? l = t - e + 1 : l = i - e, this._rendLineNumberStart -= l;
    }
    return this._lines.splice(o, r);
  }
  onLinesChanged(e, t) {
    const i = e + t - 1;
    if (this.getCount() === 0)
      return !1;
    const n = this.getStartLineNumber(), o = this.getEndLineNumber();
    let r = !1;
    for (let a = e; a <= i; a++)
      a >= n && a <= o && (this._lines[a - this._rendLineNumberStart].onContentChanged(), r = !0);
    return r;
  }
  onLinesInserted(e, t) {
    if (this.getCount() === 0)
      return null;
    const i = t - e + 1, n = this.getStartLineNumber(), o = this.getEndLineNumber();
    if (e <= n)
      return this._rendLineNumberStart += i, null;
    if (e > o)
      return null;
    if (i + e > o)
      return this._lines.splice(e - this._rendLineNumberStart, o - e + 1);
    const r = [];
    for (let d = 0; d < i; d++)
      r[d] = this._lineFactory.createLine();
    const a = e - this._rendLineNumberStart, l = this._lines.slice(0, a), c = this._lines.slice(a, this._lines.length - i), h = this._lines.slice(this._lines.length - i, this._lines.length);
    return this._lines = l.concat(r).concat(c), h;
  }
  onTokensChanged(e) {
    if (this.getCount() === 0)
      return !1;
    const t = this.getStartLineNumber(), i = this.getEndLineNumber();
    let n = !1;
    for (let o = 0, r = e.length; o < r; o++) {
      const a = e[o];
      if (a.toLineNumber < t || a.fromLineNumber > i)
        continue;
      const l = Math.max(t, a.fromLineNumber), c = Math.min(i, a.toLineNumber);
      for (let h = l; h <= c; h++) {
        const d = h - this._rendLineNumberStart;
        this._lines[d].onTokensChanged(), n = !0;
      }
    }
    return n;
  }
}
class j5 {
  constructor(e) {
    this._lineFactory = e, this.domNode = this._createDomNode(), this._linesCollection = new K5(this._lineFactory);
  }
  _createDomNode() {
    const e = st(document.createElement("div"));
    return e.setClassName("view-layer"), e.setPosition("absolute"), e.domNode.setAttribute("role", "presentation"), e.domNode.setAttribute("aria-hidden", "true"), e;
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    return !!e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    );
  }
  onFlushed(e) {
    return this._linesCollection.flush(), !0;
  }
  onLinesChanged(e) {
    return this._linesCollection.onLinesChanged(e.fromLineNumber, e.count);
  }
  onLinesDeleted(e) {
    const t = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
    if (t)
      for (let i = 0, n = t.length; i < n; i++) {
        const o = t[i].getDomNode();
        o == null || o.remove();
      }
    return !0;
  }
  onLinesInserted(e) {
    const t = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);
    if (t)
      for (let i = 0, n = t.length; i < n; i++) {
        const o = t[i].getDomNode();
        o == null || o.remove();
      }
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onTokensChanged(e) {
    return this._linesCollection.onTokensChanged(e.ranges);
  }
  onZonesChanged(e) {
    return !0;
  }
  // ---- end view event handlers
  getStartLineNumber() {
    return this._linesCollection.getStartLineNumber();
  }
  getEndLineNumber() {
    return this._linesCollection.getEndLineNumber();
  }
  getVisibleLine(e) {
    return this._linesCollection.getLine(e);
  }
  renderLines(e) {
    const t = this._linesCollection._get(), i = new JS(this.domNode.domNode, this._lineFactory, e), n = {
      rendLineNumberStart: t.rendLineNumberStart,
      lines: t.lines,
      linesLength: t.lines.length
    }, o = i.render(n, e.startLineNumber, e.endLineNumber, e.relativeVerticalOffset);
    this._linesCollection._set(o.rendLineNumberStart, o.lines);
  }
}
const fa = class fa {
  constructor(e, t, i) {
    this._domNode = e, this._lineFactory = t, this._viewportData = i;
  }
  render(e, t, i, n) {
    const o = {
      rendLineNumberStart: e.rendLineNumberStart,
      lines: e.lines.slice(0),
      linesLength: e.linesLength
    };
    if (o.rendLineNumberStart + o.linesLength - 1 < t || i < o.rendLineNumberStart) {
      o.rendLineNumberStart = t, o.linesLength = i - t + 1, o.lines = [];
      for (let r = t; r <= i; r++)
        o.lines[r - t] = this._lineFactory.createLine();
      return this._finishRendering(o, !0, n), o;
    }
    if (this._renderUntouchedLines(o, Math.max(t - o.rendLineNumberStart, 0), Math.min(i - o.rendLineNumberStart, o.linesLength - 1), n, t), o.rendLineNumberStart > t) {
      const r = t, a = Math.min(i, o.rendLineNumberStart - 1);
      r <= a && (this._insertLinesBefore(o, r, a, n, t), o.linesLength += a - r + 1);
    } else if (o.rendLineNumberStart < t) {
      const r = Math.min(o.linesLength, t - o.rendLineNumberStart);
      r > 0 && (this._removeLinesBefore(o, r), o.linesLength -= r);
    }
    if (o.rendLineNumberStart = t, o.rendLineNumberStart + o.linesLength - 1 < i) {
      const r = o.rendLineNumberStart + o.linesLength, a = i;
      r <= a && (this._insertLinesAfter(o, r, a, n, t), o.linesLength += a - r + 1);
    } else if (o.rendLineNumberStart + o.linesLength - 1 > i) {
      const r = Math.max(0, i - o.rendLineNumberStart + 1), l = o.linesLength - 1 - r + 1;
      l > 0 && (this._removeLinesAfter(o, l), o.linesLength -= l);
    }
    return this._finishRendering(o, !1, n), o;
  }
  _renderUntouchedLines(e, t, i, n, o) {
    const r = e.rendLineNumberStart, a = e.lines;
    for (let l = t; l <= i; l++) {
      const c = r + l;
      a[l].layoutLine(c, n[c - o], this._viewportData.lineHeight);
    }
  }
  _insertLinesBefore(e, t, i, n, o) {
    const r = [];
    let a = 0;
    for (let l = t; l <= i; l++)
      r[a++] = this._lineFactory.createLine();
    e.lines = r.concat(e.lines);
  }
  _removeLinesBefore(e, t) {
    for (let i = 0; i < t; i++) {
      const n = e.lines[i].getDomNode();
      n == null || n.remove();
    }
    e.lines.splice(0, t);
  }
  _insertLinesAfter(e, t, i, n, o) {
    const r = [];
    let a = 0;
    for (let l = t; l <= i; l++)
      r[a++] = this._lineFactory.createLine();
    e.lines = e.lines.concat(r);
  }
  _removeLinesAfter(e, t) {
    const i = e.linesLength - t;
    for (let n = 0; n < t; n++) {
      const o = e.lines[i + n].getDomNode();
      o == null || o.remove();
    }
    e.lines.splice(i, t);
  }
  _finishRenderingNewLines(e, t, i, n) {
    fa._ttPolicy && (i = fa._ttPolicy.createHTML(i));
    const o = this._domNode.lastChild;
    t || !o ? this._domNode.innerHTML = i : o.insertAdjacentHTML("afterend", i);
    let r = this._domNode.lastChild;
    for (let a = e.linesLength - 1; a >= 0; a--) {
      const l = e.lines[a];
      n[a] && (l.setDomNode(r), r = r.previousSibling);
    }
  }
  _finishRenderingInvalidLines(e, t, i) {
    const n = document.createElement("div");
    fa._ttPolicy && (t = fa._ttPolicy.createHTML(t)), n.innerHTML = t;
    for (let o = 0; o < e.linesLength; o++) {
      const r = e.lines[o];
      if (i[o]) {
        const a = n.firstChild, l = r.getDomNode();
        l.parentNode.replaceChild(a, l), r.setDomNode(a);
      }
    }
  }
  _finishRendering(e, t, i) {
    const n = fa._sb, o = e.linesLength, r = e.lines, a = e.rendLineNumberStart, l = [];
    {
      n.reset();
      let c = !1;
      for (let h = 0; h < o; h++) {
        const d = r[h];
        l[h] = !1, !(d.getDomNode() || !d.renderLine(h + a, i[h], this._viewportData.lineHeight, this._viewportData, n)) && (l[h] = !0, c = !0);
      }
      c && this._finishRenderingNewLines(e, t, n.build(), l);
    }
    {
      n.reset();
      let c = !1;
      const h = [];
      for (let d = 0; d < o; d++) {
        const u = r[d];
        h[d] = !1, !(l[d] || !u.renderLine(d + a, i[d], this._viewportData.lineHeight, this._viewportData, n)) && (h[d] = !0, c = !0);
      }
      c && this._finishRenderingInvalidLines(e, n.build(), h);
    }
  }
};
fa._ttPolicy = ud("editorViewLayer", { createHTML: (e) => e }), fa._sb = new ww(1e5);
let JS = fa;
class q5 extends rs {
  constructor(e) {
    super(e), this._dynamicOverlays = [], this._isFocused = !1, this._visibleLines = new j5({
      createLine: () => new Yj(this._dynamicOverlays)
    }), this.domNode = this._visibleLines.domNode;
    const i = this._context.configuration.options.get(
      50
      /* EditorOption.fontInfo */
    );
    Zi(this.domNode, i), this.domNode.setClassName("view-overlays");
  }
  shouldRender() {
    if (super.shouldRender())
      return !0;
    for (let e = 0, t = this._dynamicOverlays.length; e < t; e++)
      if (this._dynamicOverlays[e].shouldRender())
        return !0;
    return !1;
  }
  dispose() {
    super.dispose();
    for (let e = 0, t = this._dynamicOverlays.length; e < t; e++)
      this._dynamicOverlays[e].dispose();
    this._dynamicOverlays = [];
  }
  getDomNode() {
    return this.domNode;
  }
  addDynamicOverlay(e) {
    this._dynamicOverlays.push(e);
  }
  // ----- event handlers
  onConfigurationChanged(e) {
    this._visibleLines.onConfigurationChanged(e);
    const i = this._context.configuration.options.get(
      50
      /* EditorOption.fontInfo */
    );
    return Zi(this.domNode, i), !0;
  }
  onFlushed(e) {
    return this._visibleLines.onFlushed(e);
  }
  onFocusChanged(e) {
    return this._isFocused = e.isFocused, !0;
  }
  onLinesChanged(e) {
    return this._visibleLines.onLinesChanged(e);
  }
  onLinesDeleted(e) {
    return this._visibleLines.onLinesDeleted(e);
  }
  onLinesInserted(e) {
    return this._visibleLines.onLinesInserted(e);
  }
  onScrollChanged(e) {
    return this._visibleLines.onScrollChanged(e) || !0;
  }
  onTokensChanged(e) {
    return this._visibleLines.onTokensChanged(e);
  }
  onZonesChanged(e) {
    return this._visibleLines.onZonesChanged(e);
  }
  // ----- end event handlers
  prepareRender(e) {
    const t = this._dynamicOverlays.filter((i) => i.shouldRender());
    for (let i = 0, n = t.length; i < n; i++) {
      const o = t[i];
      o.prepareRender(e), o.onDidRender();
    }
  }
  render(e) {
    this._viewOverlaysRender(e), this.domNode.toggleClassName("focused", this._isFocused);
  }
  _viewOverlaysRender(e) {
    this._visibleLines.renderLines(e.viewportData);
  }
}
class Yj {
  constructor(e) {
    this._dynamicOverlays = e, this._domNode = null, this._renderedContent = null;
  }
  getDomNode() {
    return this._domNode ? this._domNode.domNode : null;
  }
  setDomNode(e) {
    this._domNode = st(e);
  }
  onContentChanged() {
  }
  onTokensChanged() {
  }
  renderLine(e, t, i, n, o) {
    let r = "";
    for (let a = 0, l = this._dynamicOverlays.length; a < l; a++) {
      const c = this._dynamicOverlays[a];
      r += c.render(n.startLineNumber, e);
    }
    return this._renderedContent === r ? !1 : (this._renderedContent = r, o.appendString('<div style="top:'), o.appendString(String(t)), o.appendString("px;height:"), o.appendString(String(i)), o.appendString('px;">'), o.appendString(r), o.appendString("</div>"), !0);
  }
  layoutLine(e, t, i) {
    this._domNode && (this._domNode.setTop(t), this._domNode.setHeight(i));
  }
}
class Xj extends q5 {
  constructor(e) {
    super(e);
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._contentWidth = i.contentWidth, this.domNode.setHeight(0);
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._contentWidth = i.contentWidth, super.onConfigurationChanged(e) || !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollWidthChanged;
  }
  // --- end event handlers
  _viewOverlaysRender(e) {
    super._viewOverlaysRender(e), this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth));
  }
}
class Qj extends q5 {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._contentLeft = i.contentLeft, this.domNode.setClassName("margin-view-overlays"), this.domNode.setWidth(1), Zi(this.domNode, t.get(
      50
      /* EditorOption.fontInfo */
    ));
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    Zi(this.domNode, t.get(
      50
      /* EditorOption.fontInfo */
    ));
    const i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._contentLeft = i.contentLeft, super.onConfigurationChanged(e) || !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollHeightChanged;
  }
  _viewOverlaysRender(e) {
    super._viewOverlaysRender(e);
    const t = Math.min(e.scrollHeight, 1e6);
    this.domNode.setHeight(t), this.domNode.setWidth(this._contentLeft);
  }
}
class Ew {
  constructor(e) {
    this.onKeyDown = null, this.onKeyUp = null, this.onContextMenu = null, this.onMouseMove = null, this.onMouseLeave = null, this.onMouseDown = null, this.onMouseUp = null, this.onMouseDrag = null, this.onMouseDrop = null, this.onMouseDropCanceled = null, this.onMouseWheel = null, this._coordinatesConverter = e;
  }
  emitKeyDown(e) {
    var t;
    (t = this.onKeyDown) == null || t.call(this, e);
  }
  emitKeyUp(e) {
    var t;
    (t = this.onKeyUp) == null || t.call(this, e);
  }
  emitContextMenu(e) {
    var t;
    (t = this.onContextMenu) == null || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseMove(e) {
    var t;
    (t = this.onMouseMove) == null || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseLeave(e) {
    var t;
    (t = this.onMouseLeave) == null || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseDown(e) {
    var t;
    (t = this.onMouseDown) == null || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseUp(e) {
    var t;
    (t = this.onMouseUp) == null || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseDrag(e) {
    var t;
    (t = this.onMouseDrag) == null || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseDrop(e) {
    var t;
    (t = this.onMouseDrop) == null || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseDropCanceled() {
    var e;
    (e = this.onMouseDropCanceled) == null || e.call(this);
  }
  emitMouseWheel(e) {
    var t;
    (t = this.onMouseWheel) == null || t.call(this, e);
  }
  _convertViewToModelMouseEvent(e) {
    return e.target ? {
      event: e.event,
      target: this._convertViewToModelMouseTarget(e.target)
    } : e;
  }
  _convertViewToModelMouseTarget(e) {
    return Ew.convertViewToModelMouseTarget(e, this._coordinatesConverter);
  }
  static convertViewToModelMouseTarget(e, t) {
    const i = { ...e };
    return i.position && (i.position = t.convertViewPositionToModelPosition(i.position)), i.range && (i.range = t.convertViewRangeToModelRange(i.range)), (i.type === 5 || i.type === 8) && (i.detail = this.convertViewToModelViewZoneData(i.detail, t)), i;
  }
  static convertViewToModelViewZoneData(e, t) {
    return {
      viewZoneId: e.viewZoneId,
      positionBefore: e.positionBefore ? t.convertViewPositionToModelPosition(e.positionBefore) : e.positionBefore,
      positionAfter: e.positionAfter ? t.convertViewPositionToModelPosition(e.positionAfter) : e.positionAfter,
      position: t.convertViewPositionToModelPosition(e.position),
      afterLineNumber: t.convertViewPositionToModelPosition(new F(e.afterLineNumber, 1)).lineNumber
    };
  }
}
class Jj extends rs {
  constructor(e) {
    super(e), this.blocks = [], this.contentWidth = -1, this.contentLeft = 0, this.domNode = st(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setClassName("blockDecorations-container"), this.update();
  }
  update() {
    let e = !1;
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    ), n = i.contentWidth - i.verticalScrollbarWidth;
    this.contentWidth !== n && (this.contentWidth = n, e = !0);
    const o = i.contentLeft;
    return this.contentLeft !== o && (this.contentLeft = o, e = !0), e;
  }
  dispose() {
    super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    return this.update();
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollLeftChanged;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    let t = 0;
    const i = e.getDecorationsInViewport();
    for (const n of i) {
      if (!n.options.blockClassName)
        continue;
      let o = this.blocks[t];
      o || (o = this.blocks[t] = st(document.createElement("div")), this.domNode.appendChild(o));
      let r, a;
      n.options.blockIsAfterEnd ? (r = e.getVerticalOffsetAfterLineNumber(n.range.endLineNumber, !1), a = e.getVerticalOffsetAfterLineNumber(n.range.endLineNumber, !0)) : (r = e.getVerticalOffsetForLineNumber(n.range.startLineNumber, !0), a = n.range.isEmpty() && !n.options.blockDoesNotCollapse ? e.getVerticalOffsetForLineNumber(n.range.startLineNumber, !1) : e.getVerticalOffsetAfterLineNumber(n.range.endLineNumber, !0));
      const [l, c, h, d] = n.options.blockPadding ?? [0, 0, 0, 0];
      o.setClassName("blockDecorations-block " + n.options.blockClassName), o.setLeft(this.contentLeft - d), o.setWidth(this.contentWidth + d + c), o.setTop(r - e.scrollTop - l), o.setHeight(a - r + l + h), t++;
    }
    for (let n = t; n < this.blocks.length; n++)
      this.blocks[n].domNode.remove();
    this.blocks.length = t;
  }
}
class eq extends rs {
  constructor(e, t) {
    super(e), this._viewDomNode = t, this._widgets = {}, this.domNode = st(document.createElement("div")), Go.write(
      this.domNode,
      1
      /* PartFingerprint.ContentWidgets */
    ), this.domNode.setClassName("contentWidgets"), this.domNode.setPosition("absolute"), this.domNode.setTop(0), this.overflowingContentWidgetsDomNode = st(document.createElement("div")), Go.write(
      this.overflowingContentWidgetsDomNode,
      2
      /* PartFingerprint.OverflowingContentWidgets */
    ), this.overflowingContentWidgetsDomNode.setClassName("overflowingContentWidgets");
  }
  dispose() {
    super.dispose(), this._widgets = {};
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onConfigurationChanged(e);
    return !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLineMappingChanged(e) {
    return this._updateAnchorsViewPositions(), !0;
  }
  onLinesChanged(e) {
    return this._updateAnchorsViewPositions(), !0;
  }
  onLinesDeleted(e) {
    return this._updateAnchorsViewPositions(), !0;
  }
  onLinesInserted(e) {
    return this._updateAnchorsViewPositions(), !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  // ---- end view event handlers
  _updateAnchorsViewPositions() {
    const e = Object.keys(this._widgets);
    for (const t of e)
      this._widgets[t].updateAnchorViewPosition();
  }
  addWidget(e) {
    const t = new tq(this._context, this._viewDomNode, e);
    this._widgets[t.id] = t, t.allowEditorOverflow ? this.overflowingContentWidgetsDomNode.appendChild(t.domNode) : this.domNode.appendChild(t.domNode), this.setShouldRender();
  }
  setWidgetPosition(e, t, i, n, o) {
    this._widgets[e.getId()].setPosition(t, i, n, o), this.setShouldRender();
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets.hasOwnProperty(t)) {
      const i = this._widgets[t];
      delete this._widgets[t];
      const n = i.domNode.domNode;
      n.remove(), n.removeAttribute("monaco-visible-content-widget"), this.setShouldRender();
    }
  }
  shouldSuppressMouseDownOnWidget(e) {
    return this._widgets.hasOwnProperty(e) ? this._widgets[e].suppressMouseDown : !1;
  }
  onBeforeRender(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onBeforeRender(e);
  }
  prepareRender(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].prepareRender(e);
  }
  render(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].render(e);
  }
}
class tq {
  constructor(e, t, i) {
    this._primaryAnchor = new eg(null, null), this._secondaryAnchor = new eg(null, null), this._context = e, this._viewDomNode = t, this._actual = i, this.domNode = st(this._actual.getDomNode()), this.id = this._actual.getId(), this.allowEditorOverflow = this._actual.allowEditorOverflow || !1, this.suppressMouseDown = this._actual.suppressMouseDown || !1;
    const n = this._context.configuration.options, o = n.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._fixedOverflowWidgets = n.get(
      42
      /* EditorOption.fixedOverflowWidgets */
    ), this._contentWidth = o.contentWidth, this._contentLeft = o.contentLeft, this._lineHeight = n.get(
      67
      /* EditorOption.lineHeight */
    ), this._affinity = null, this._preference = [], this._cachedDomNodeOffsetWidth = -1, this._cachedDomNodeOffsetHeight = -1, this._maxWidth = this._getMaxWidth(), this._isVisible = !1, this._renderData = null, this.domNode.setPosition(this._fixedOverflowWidgets && this.allowEditorOverflow ? "fixed" : "absolute"), this.domNode.setDisplay("none"), this.domNode.setVisibility("hidden"), this.domNode.setAttribute("widgetId", this.id), this.domNode.setMaxWidth(this._maxWidth);
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    if (this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    )) {
      const i = t.get(
        146
        /* EditorOption.layoutInfo */
      );
      this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._maxWidth = this._getMaxWidth();
    }
  }
  updateAnchorViewPosition() {
    this._setPosition(this._affinity, this._primaryAnchor.modelPosition, this._secondaryAnchor.modelPosition);
  }
  _setPosition(e, t, i) {
    this._affinity = e, this._primaryAnchor = n(t, this._context.viewModel, this._affinity), this._secondaryAnchor = n(i, this._context.viewModel, this._affinity);
    function n(o, r, a) {
      if (!o)
        return new eg(null, null);
      const l = r.model.validatePosition(o);
      if (r.coordinatesConverter.modelPositionIsVisible(l)) {
        const c = r.coordinatesConverter.convertModelPositionToViewPosition(l, a ?? void 0);
        return new eg(o, c);
      }
      return new eg(o, null);
    }
  }
  _getMaxWidth() {
    const e = this.domNode.domNode.ownerDocument, t = e.defaultView;
    return this.allowEditorOverflow ? (t == null ? void 0 : t.innerWidth) || e.documentElement.offsetWidth || e.body.offsetWidth : this._contentWidth;
  }
  setPosition(e, t, i, n) {
    this._setPosition(n, e, t), this._preference = i, this._primaryAnchor.viewPosition && this._preference && this._preference.length > 0 ? this.domNode.setDisplay("block") : this.domNode.setDisplay("none"), this._cachedDomNodeOffsetWidth = -1, this._cachedDomNodeOffsetHeight = -1;
  }
  _layoutBoxInViewport(e, t, i, n) {
    const o = e.top, r = o, a = e.top + e.height, l = n.viewportHeight - a, c = o - i, h = r >= i, d = a, u = l >= i;
    let f = e.left;
    return f + t > n.scrollLeft + n.viewportWidth && (f = n.scrollLeft + n.viewportWidth - t), f < n.scrollLeft && (f = n.scrollLeft), { fitsAbove: h, aboveTop: c, fitsBelow: u, belowTop: d, left: f };
  }
  _layoutHorizontalSegmentInPage(e, t, i, n) {
    const a = Math.max(15, t.left - n), l = Math.min(t.left + t.width + n, e.width - 15), h = this._viewDomNode.domNode.ownerDocument.defaultView;
    let d = t.left + i - ((h == null ? void 0 : h.scrollX) ?? 0);
    if (d + n > l) {
      const u = d - (l - n);
      d -= u, i -= u;
    }
    if (d < a) {
      const u = d - a;
      d -= u, i -= u;
    }
    return [i, d];
  }
  _layoutBoxInPage(e, t, i, n) {
    const o = e.top - i, r = e.top + e.height, a = ui(this._viewDomNode.domNode), l = this._viewDomNode.domNode.ownerDocument, c = l.defaultView, h = a.top + o - ((c == null ? void 0 : c.scrollY) ?? 0), d = a.top + r - ((c == null ? void 0 : c.scrollY) ?? 0), u = Im(l.body), [f, g] = this._layoutHorizontalSegmentInPage(u, a, e.left - n.scrollLeft + this._contentLeft, t), p = 22, _ = 22, b = h >= p, C = d + i <= u.height - _;
    return this._fixedOverflowWidgets ? {
      fitsAbove: b,
      aboveTop: Math.max(h, p),
      fitsBelow: C,
      belowTop: d,
      left: g
    } : { fitsAbove: b, aboveTop: o, fitsBelow: C, belowTop: r, left: f };
  }
  _prepareRenderWidgetAtExactPositionOverflowing(e) {
    return new tg(e.top, e.left + this._contentLeft);
  }
  /**
   * Compute the coordinates above and below the primary and secondary anchors.
   * The content widget *must* touch the primary anchor.
   * The content widget should touch if possible the secondary anchor.
   */
  _getAnchorsCoordinates(e) {
    var r, a;
    const t = o(this._primaryAnchor.viewPosition, this._affinity, this._lineHeight), i = ((r = this._secondaryAnchor.viewPosition) == null ? void 0 : r.lineNumber) === ((a = this._primaryAnchor.viewPosition) == null ? void 0 : a.lineNumber) ? this._secondaryAnchor.viewPosition : null, n = o(i, this._affinity, this._lineHeight);
    return { primary: t, secondary: n };
    function o(l, c, h) {
      if (!l)
        return null;
      const d = e.visibleRangeForPosition(l);
      if (!d)
        return null;
      const u = l.column === 1 && c === 3 ? 0 : d.left, f = e.getVerticalOffsetForLineNumber(l.lineNumber) - e.scrollTop;
      return new JT(f, u, h);
    }
  }
  _reduceAnchorCoordinates(e, t, i) {
    if (!t)
      return e;
    const n = this._context.configuration.options.get(
      50
      /* EditorOption.fontInfo */
    );
    let o = t.left;
    return o < e.left ? o = Math.max(o, e.left - i + n.typicalFullwidthCharacterWidth) : o = Math.min(o, e.left + i - n.typicalFullwidthCharacterWidth), new JT(e.top, o, e.height);
  }
  _prepareRenderWidget(e) {
    if (!this._preference || this._preference.length === 0)
      return null;
    const { primary: t, secondary: i } = this._getAnchorsCoordinates(e);
    if (!t)
      return {
        kind: "offViewport",
        preserveFocus: this.domNode.domNode.contains(this.domNode.domNode.ownerDocument.activeElement)
      };
    if (this._cachedDomNodeOffsetWidth === -1 || this._cachedDomNodeOffsetHeight === -1) {
      let r = null;
      if (typeof this._actual.beforeRender == "function" && (r = W0(this._actual.beforeRender, this._actual)), r)
        this._cachedDomNodeOffsetWidth = r.width, this._cachedDomNodeOffsetHeight = r.height;
      else {
        const l = this.domNode.domNode.getBoundingClientRect();
        this._cachedDomNodeOffsetWidth = Math.round(l.width), this._cachedDomNodeOffsetHeight = Math.round(l.height);
      }
    }
    const n = this._reduceAnchorCoordinates(t, i, this._cachedDomNodeOffsetWidth);
    let o;
    this.allowEditorOverflow ? o = this._layoutBoxInPage(n, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, e) : o = this._layoutBoxInViewport(n, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, e);
    for (let r = 1; r <= 2; r++)
      for (const a of this._preference)
        if (a === 1) {
          if (!o)
            return null;
          if (r === 2 || o.fitsAbove)
            return {
              kind: "inViewport",
              coordinate: new tg(o.aboveTop, o.left),
              position: 1
              /* ContentWidgetPositionPreference.ABOVE */
            };
        } else if (a === 2) {
          if (!o)
            return null;
          if (r === 2 || o.fitsBelow)
            return {
              kind: "inViewport",
              coordinate: new tg(o.belowTop, o.left),
              position: 2
              /* ContentWidgetPositionPreference.BELOW */
            };
        } else
          return this.allowEditorOverflow ? {
            kind: "inViewport",
            coordinate: this._prepareRenderWidgetAtExactPositionOverflowing(new tg(n.top, n.left)),
            position: 0
            /* ContentWidgetPositionPreference.EXACT */
          } : {
            kind: "inViewport",
            coordinate: new tg(n.top, n.left),
            position: 0
            /* ContentWidgetPositionPreference.EXACT */
          };
    return null;
  }
  /**
   * On this first pass, we ensure that the content widget (if it is in the viewport) has the max width set correctly.
   */
  onBeforeRender(e) {
    !this._primaryAnchor.viewPosition || !this._preference || this._primaryAnchor.viewPosition.lineNumber < e.startLineNumber || this._primaryAnchor.viewPosition.lineNumber > e.endLineNumber || this.domNode.setMaxWidth(this._maxWidth);
  }
  prepareRender(e) {
    this._renderData = this._prepareRenderWidget(e);
  }
  render(e) {
    var t;
    if (!this._renderData || this._renderData.kind === "offViewport") {
      this._isVisible && (this.domNode.removeAttribute("monaco-visible-content-widget"), this._isVisible = !1, ((t = this._renderData) == null ? void 0 : t.kind) === "offViewport" && this._renderData.preserveFocus ? this.domNode.setTop(-1e3) : this.domNode.setVisibility("hidden")), typeof this._actual.afterRender == "function" && W0(this._actual.afterRender, this._actual, null);
      return;
    }
    this.allowEditorOverflow ? (this.domNode.setTop(this._renderData.coordinate.top), this.domNode.setLeft(this._renderData.coordinate.left)) : (this.domNode.setTop(this._renderData.coordinate.top + e.scrollTop - e.bigNumbersDelta), this.domNode.setLeft(this._renderData.coordinate.left)), this._isVisible || (this.domNode.setVisibility("inherit"), this.domNode.setAttribute("monaco-visible-content-widget", "true"), this._isVisible = !0), typeof this._actual.afterRender == "function" && W0(this._actual.afterRender, this._actual, this._renderData.position);
  }
}
class eg {
  constructor(e, t) {
    this.modelPosition = e, this.viewPosition = t;
  }
}
class tg {
  constructor(e, t) {
    this.top = e, this.left = t, this._coordinateBrand = void 0;
  }
}
class JT {
  constructor(e, t, i) {
    this.top = e, this.left = t, this.height = i, this._anchorCoordinateBrand = void 0;
  }
}
function W0(s, e, ...t) {
  try {
    return s.call(e, ...t);
  } catch {
    return null;
  }
}
class G5 extends cd {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._renderLineHighlight = t.get(
      97
      /* EditorOption.renderLineHighlight */
    ), this._renderLineHighlightOnlyWhenFocus = t.get(
      98
      /* EditorOption.renderLineHighlightOnlyWhenFocus */
    ), this._wordWrap = i.isViewportWrapping, this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._selectionIsEmpty = !0, this._focused = !1, this._cursorLineNumbers = [1], this._selections = [new Ue(1, 1, 1, 1)], this._renderData = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
  _readFromSelections() {
    let e = !1;
    const t = /* @__PURE__ */ new Set();
    for (const o of this._selections)
      t.add(o.positionLineNumber);
    const i = Array.from(t);
    i.sort((o, r) => o - r), li(this._cursorLineNumbers, i) || (this._cursorLineNumbers = i, e = !0);
    const n = this._selections.every((o) => o.isEmpty());
    return this._selectionIsEmpty !== n && (this._selectionIsEmpty = n, e = !0), e;
  }
  // --- begin event handlers
  onThemeChanged(e) {
    return this._readFromSelections();
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._renderLineHighlight = t.get(
      97
      /* EditorOption.renderLineHighlight */
    ), this._renderLineHighlightOnlyWhenFocus = t.get(
      98
      /* EditorOption.renderLineHighlightOnlyWhenFocus */
    ), this._wordWrap = i.isViewportWrapping, this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, this._readFromSelections();
  }
  onFlushed(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollWidthChanged || e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onFocusChanged(e) {
    return this._renderLineHighlightOnlyWhenFocus ? (this._focused = e.isFocused, !0) : !1;
  }
  // --- end event handlers
  prepareRender(e) {
    if (!this._shouldRenderThis()) {
      this._renderData = null;
      return;
    }
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = [];
    for (let r = t; r <= i; r++) {
      const a = r - t;
      n[a] = "";
    }
    if (this._wordWrap) {
      const r = this._renderOne(e, !1);
      for (const a of this._cursorLineNumbers) {
        const l = this._context.viewModel.coordinatesConverter, c = l.convertViewPositionToModelPosition(new F(a, 1)).lineNumber, h = l.convertModelPositionToViewPosition(new F(c, 1)).lineNumber, d = l.convertModelPositionToViewPosition(new F(c, this._context.viewModel.model.getLineMaxColumn(c))).lineNumber, u = Math.max(h, t), f = Math.min(d, i);
        for (let g = u; g <= f; g++) {
          const p = g - t;
          n[p] = r;
        }
      }
    }
    const o = this._renderOne(e, !0);
    for (const r of this._cursorLineNumbers) {
      if (r < t || r > i)
        continue;
      const a = r - t;
      n[a] = o;
    }
    this._renderData = n;
  }
  render(e, t) {
    if (!this._renderData)
      return "";
    const i = t - e;
    return i >= this._renderData.length ? "" : this._renderData[i];
  }
  _shouldRenderInMargin() {
    return (this._renderLineHighlight === "gutter" || this._renderLineHighlight === "all") && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
  _shouldRenderInContent() {
    return (this._renderLineHighlight === "line" || this._renderLineHighlight === "all") && this._selectionIsEmpty && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
}
class iq extends G5 {
  _renderOne(e, t) {
    return `<div class="${"current-line" + (this._shouldRenderInMargin() ? " current-line-both" : "") + (t ? " current-line-exact" : "")}" style="width:${Math.max(e.scrollWidth, this._contentWidth)}px;"></div>`;
  }
  _shouldRenderThis() {
    return this._shouldRenderInContent();
  }
  _shouldRenderOther() {
    return this._shouldRenderInMargin();
  }
}
class nq extends G5 {
  _renderOne(e, t) {
    return `<div class="${"current-line" + (this._shouldRenderInMargin() ? " current-line-margin" : "") + (this._shouldRenderOther() ? " current-line-margin-both" : "") + (this._shouldRenderInMargin() && t ? " current-line-exact-margin" : "")}" style="width:${this._contentLeft}px"></div>`;
  }
  _shouldRenderThis() {
    return !0;
  }
  _shouldRenderOther() {
    return this._shouldRenderInContent();
  }
}
tr((s, e) => {
  const t = s.getColor(y5);
  if (t && (e.addRule(`.monaco-editor .view-overlays .current-line { background-color: ${t}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { background-color: ${t}; border: none; }`)), !t || t.isTransparent() || s.defines(NT)) {
    const i = s.getColor(NT);
    i && (e.addRule(`.monaco-editor .view-overlays .current-line-exact { border: 2px solid ${i}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-exact-margin { border: 2px solid ${i}; }`), dh(s.type) && (e.addRule(".monaco-editor .view-overlays .current-line-exact { border-width: 1px; }"), e.addRule(".monaco-editor .margin-view-overlays .current-line-exact-margin { border-width: 1px; }")));
  }
});
class sq extends cd {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options;
    this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollWidthChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
    const t = e.getDecorationsInViewport();
    let i = [], n = 0;
    for (let l = 0, c = t.length; l < c; l++) {
      const h = t[l];
      h.options.className && (i[n++] = h);
    }
    i = i.sort((l, c) => {
      if (l.options.zIndex < c.options.zIndex)
        return -1;
      if (l.options.zIndex > c.options.zIndex)
        return 1;
      const h = l.options.className, d = c.options.className;
      return h < d ? -1 : h > d ? 1 : T.compareRangesUsingStarts(l.range, c.range);
    });
    const o = e.visibleRange.startLineNumber, r = e.visibleRange.endLineNumber, a = [];
    for (let l = o; l <= r; l++) {
      const c = l - o;
      a[c] = "";
    }
    this._renderWholeLineDecorations(e, i, a), this._renderNormalDecorations(e, i, a), this._renderResult = a;
  }
  _renderWholeLineDecorations(e, t, i) {
    const n = e.visibleRange.startLineNumber, o = e.visibleRange.endLineNumber;
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      if (!l.options.isWholeLine)
        continue;
      const c = '<div class="cdr ' + l.options.className + '" style="left:0;width:100%;"></div>', h = Math.max(l.range.startLineNumber, n), d = Math.min(l.range.endLineNumber, o);
      for (let u = h; u <= d; u++) {
        const f = u - n;
        i[f] += c;
      }
    }
  }
  _renderNormalDecorations(e, t, i) {
    const n = e.visibleRange.startLineNumber;
    let o = null, r = !1, a = null, l = !1;
    for (let c = 0, h = t.length; c < h; c++) {
      const d = t[c];
      if (d.options.isWholeLine)
        continue;
      const u = d.options.className, f = !!d.options.showIfCollapsed;
      let g = d.range;
      if (f && g.endColumn === 1 && g.endLineNumber !== g.startLineNumber && (g = new T(g.startLineNumber, g.startColumn, g.endLineNumber - 1, this._context.viewModel.getLineMaxColumn(g.endLineNumber - 1))), o === u && r === f && T.areIntersectingOrTouching(a, g)) {
        a = T.plusRange(a, g);
        continue;
      }
      o !== null && this._renderNormalDecoration(e, a, o, l, r, n, i), o = u, r = f, a = g, l = d.options.shouldFillLineOnLineBreak ?? !1;
    }
    o !== null && this._renderNormalDecoration(e, a, o, l, r, n, i);
  }
  _renderNormalDecoration(e, t, i, n, o, r, a) {
    const l = e.linesVisibleRangesForRange(
      t,
      /*TODO@Alex*/
      i === "findMatch"
    );
    if (l)
      for (let c = 0, h = l.length; c < h; c++) {
        const d = l[c];
        if (d.outsideRenderedLine)
          continue;
        const u = d.lineNumber - r;
        if (o && d.ranges.length === 1) {
          const f = d.ranges[0];
          if (f.width < this._typicalHalfwidthCharacterWidth) {
            const g = Math.round(f.left + f.width / 2), p = Math.max(0, Math.round(g - this._typicalHalfwidthCharacterWidth / 2));
            d.ranges[0] = new vw(p, this._typicalHalfwidthCharacterWidth);
          }
        }
        for (let f = 0, g = d.ranges.length; f < g; f++) {
          const p = n && d.continuesOnNextLine && g === 1, _ = d.ranges[f], b = '<div class="cdr ' + i + '" style="left:' + String(_.left) + "px;width:" + (p ? "100%;" : String(_.width) + "px;") + '"></div>';
          a[u] += b;
        }
      }
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
class oq extends rs {
  constructor(e, t, i, n) {
    super(e);
    const o = this._context.configuration.options, r = o.get(
      104
      /* EditorOption.scrollbar */
    ), a = o.get(
      75
      /* EditorOption.mouseWheelScrollSensitivity */
    ), l = o.get(
      40
      /* EditorOption.fastScrollSensitivity */
    ), c = o.get(
      107
      /* EditorOption.scrollPredominantAxis */
    ), h = {
      listenOnDomNode: i.domNode,
      className: "editor-scrollable " + HS(e.theme.type),
      useShadows: !1,
      lazyRender: !0,
      vertical: r.vertical,
      horizontal: r.horizontal,
      verticalHasArrows: r.verticalHasArrows,
      horizontalHasArrows: r.horizontalHasArrows,
      verticalScrollbarSize: r.verticalScrollbarSize,
      verticalSliderSize: r.verticalSliderSize,
      horizontalScrollbarSize: r.horizontalScrollbarSize,
      horizontalSliderSize: r.horizontalSliderSize,
      handleMouseWheel: r.handleMouseWheel,
      alwaysConsumeMouseWheel: r.alwaysConsumeMouseWheel,
      arrowSize: r.arrowSize,
      mouseWheelScrollSensitivity: a,
      fastScrollSensitivity: l,
      scrollPredominantAxis: c,
      scrollByPage: r.scrollByPage
    };
    this.scrollbar = this._register(new rw(t.domNode, h, this._context.viewLayout.getScrollable())), Go.write(
      this.scrollbar.getDomNode(),
      6
      /* PartFingerprint.ScrollableElement */
    ), this.scrollbarDomNode = st(this.scrollbar.getDomNode()), this.scrollbarDomNode.setPosition("absolute"), this._setLayout();
    const d = (u, f, g) => {
      const p = {};
      {
        const _ = u.scrollTop;
        _ && (p.scrollTop = this._context.viewLayout.getCurrentScrollTop() + _, u.scrollTop = 0);
      }
      if (g) {
        const _ = u.scrollLeft;
        _ && (p.scrollLeft = this._context.viewLayout.getCurrentScrollLeft() + _, u.scrollLeft = 0);
      }
      this._context.viewModel.viewLayout.setScrollPosition(
        p,
        1
        /* ScrollType.Immediate */
      );
    };
    this._register(z(i.domNode, "scroll", (u) => d(i.domNode, !0, !0))), this._register(z(t.domNode, "scroll", (u) => d(t.domNode, !0, !1))), this._register(z(n.domNode, "scroll", (u) => d(n.domNode, !0, !1))), this._register(z(this.scrollbarDomNode.domNode, "scroll", (u) => d(this.scrollbarDomNode.domNode, !0, !1)));
  }
  dispose() {
    super.dispose();
  }
  _setLayout() {
    const e = this._context.configuration.options, t = e.get(
      146
      /* EditorOption.layoutInfo */
    );
    this.scrollbarDomNode.setLeft(t.contentLeft), e.get(
      73
      /* EditorOption.minimap */
    ).side === "right" ? this.scrollbarDomNode.setWidth(t.contentWidth + t.minimap.minimapWidth) : this.scrollbarDomNode.setWidth(t.contentWidth), this.scrollbarDomNode.setHeight(t.height);
  }
  getOverviewRulerLayoutInfo() {
    return this.scrollbar.getOverviewRulerLayoutInfo();
  }
  getDomNode() {
    return this.scrollbarDomNode;
  }
  delegateVerticalScrollbarPointerDown(e) {
    this.scrollbar.delegateVerticalScrollbarPointerDown(e);
  }
  delegateScrollFromMouseWheelEvent(e) {
    this.scrollbar.delegateScrollFromMouseWheelEvent(e);
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    if (e.hasChanged(
      104
      /* EditorOption.scrollbar */
    ) || e.hasChanged(
      75
      /* EditorOption.mouseWheelScrollSensitivity */
    ) || e.hasChanged(
      40
      /* EditorOption.fastScrollSensitivity */
    )) {
      const t = this._context.configuration.options, i = t.get(
        104
        /* EditorOption.scrollbar */
      ), n = t.get(
        75
        /* EditorOption.mouseWheelScrollSensitivity */
      ), o = t.get(
        40
        /* EditorOption.fastScrollSensitivity */
      ), r = t.get(
        107
        /* EditorOption.scrollPredominantAxis */
      ), a = {
        vertical: i.vertical,
        horizontal: i.horizontal,
        verticalScrollbarSize: i.verticalScrollbarSize,
        horizontalScrollbarSize: i.horizontalScrollbarSize,
        scrollByPage: i.scrollByPage,
        handleMouseWheel: i.handleMouseWheel,
        mouseWheelScrollSensitivity: n,
        fastScrollSensitivity: o,
        scrollPredominantAxis: r
      };
      this.scrollbar.updateOptions(a);
    }
    return e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    ) && this._setLayout(), !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onThemeChanged(e) {
    return this.scrollbar.updateClassName("editor-scrollable " + HS(this._context.theme.type)), !0;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this.scrollbar.renderNow();
  }
}
var S1;
(function(s) {
  s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 4] = "Right", s[s.Full = 7] = "Full";
})(S1 || (S1 = {}));
var _o;
(function(s) {
  s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 3] = "Right";
})(_o || (_o = {}));
var Nr;
(function(s) {
  s[s.Both = 0] = "Both", s[s.Right = 1] = "Right", s[s.Left = 2] = "Left", s[s.None = 3] = "None";
})(Nr || (Nr = {}));
class hb {
  get originalIndentSize() {
    return this._indentSizeIsTabSize ? "tabSize" : this.indentSize;
  }
  /**
   * @internal
   */
  constructor(e) {
    this._textModelResolvedOptionsBrand = void 0, this.tabSize = Math.max(1, e.tabSize | 0), e.indentSize === "tabSize" ? (this.indentSize = this.tabSize, this._indentSizeIsTabSize = !0) : (this.indentSize = Math.max(1, e.indentSize | 0), this._indentSizeIsTabSize = !1), this.insertSpaces = !!e.insertSpaces, this.defaultEOL = e.defaultEOL | 0, this.trimAutoWhitespace = !!e.trimAutoWhitespace, this.bracketPairColorizationOptions = e.bracketPairColorizationOptions;
  }
  /**
   * @internal
   */
  equals(e) {
    return this.tabSize === e.tabSize && this._indentSizeIsTabSize === e._indentSizeIsTabSize && this.indentSize === e.indentSize && this.insertSpaces === e.insertSpaces && this.defaultEOL === e.defaultEOL && this.trimAutoWhitespace === e.trimAutoWhitespace && Xn(this.bracketPairColorizationOptions, e.bracketPairColorizationOptions);
  }
  /**
   * @internal
   */
  createChangeEvent(e) {
    return {
      tabSize: this.tabSize !== e.tabSize,
      indentSize: this.indentSize !== e.indentSize,
      insertSpaces: this.insertSpaces !== e.insertSpaces,
      trimAutoWhitespace: this.trimAutoWhitespace !== e.trimAutoWhitespace
    };
  }
}
class jm {
  /**
   * @internal
   */
  constructor(e, t) {
    this._findMatchBrand = void 0, this.range = e, this.matches = t;
  }
}
function rq(s) {
  return s && typeof s.read == "function";
}
class H0 {
  constructor(e, t, i, n, o, r) {
    this.identifier = e, this.range = t, this.text = i, this.forceMoveMarkers = n, this.isAutoWhitespaceEdit = o, this._isTracked = r;
  }
}
class aq {
  constructor(e, t, i) {
    this.regex = e, this.wordSeparators = t, this.simpleSearch = i;
  }
}
class lq {
  constructor(e, t, i) {
    this.reverseEdits = e, this.changes = t, this.trimAutoWhitespaceLineNumbers = i;
  }
}
function cq(s) {
  return !s.isTooLargeForSyncing() && !s.isForSimpleWidget;
}
class eL {
  constructor(e, t, i, n, o) {
    this.startLineNumber = e, this.endLineNumber = t, this.className = i, this.tooltip = n, this._decorationToRenderBrand = void 0, this.zIndex = o ?? 0;
  }
}
class hq {
  constructor(e, t, i) {
    this.className = e, this.zIndex = t, this.tooltip = i;
  }
}
class dq {
  constructor() {
    this.decorations = [];
  }
  add(e) {
    this.decorations.push(e);
  }
  getDecorations() {
    return this.decorations;
  }
}
class Z5 extends cd {
  /**
   * Returns an array with an element for each visible line number.
   */
  _render(e, t, i) {
    const n = [];
    for (let a = e; a <= t; a++) {
      const l = a - e;
      n[l] = new dq();
    }
    if (i.length === 0)
      return n;
    i.sort((a, l) => a.className === l.className ? a.startLineNumber === l.startLineNumber ? a.endLineNumber - l.endLineNumber : a.startLineNumber - l.startLineNumber : a.className < l.className ? -1 : 1);
    let o = null, r = 0;
    for (let a = 0, l = i.length; a < l; a++) {
      const c = i[a], h = c.className, d = c.zIndex;
      let u = Math.max(c.startLineNumber, e) - e;
      const f = Math.min(c.endLineNumber, t) - e;
      o === h ? (u = Math.max(r + 1, u), r = Math.max(r, f)) : (o = h, r = f);
      for (let g = u; g <= r; g++)
        n[g].add(new hq(h, d, c.tooltip));
    }
    return n;
  }
}
class uq extends rs {
  constructor(e) {
    super(e), this._widgets = {}, this._context = e;
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this.domNode = st(document.createElement("div")), this.domNode.setClassName("glyph-margin-widgets"), this.domNode.setPosition("absolute"), this.domNode.setTop(0), this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._glyphMargin = t.get(
      57
      /* EditorOption.glyphMargin */
    ), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._glyphMarginDecorationLaneCount = i.glyphMarginDecorationLaneCount, this._managedDomNodes = [], this._decorationGlyphsToRender = [];
  }
  dispose() {
    this._managedDomNodes = [], this._decorationGlyphsToRender = [], this._widgets = {}, super.dispose();
  }
  getWidgets() {
    return Object.values(this._widgets);
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._glyphMargin = t.get(
      57
      /* EditorOption.glyphMargin */
    ), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._glyphMarginDecorationLaneCount = i.glyphMarginDecorationLaneCount, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  // --- begin widget management
  addWidget(e) {
    const t = st(e.getDomNode());
    this._widgets[e.getId()] = {
      widget: e,
      preference: e.getPosition(),
      domNode: t,
      renderInfo: null
    }, t.setPosition("absolute"), t.setDisplay("none"), t.setAttribute("widgetId", e.getId()), this.domNode.appendChild(t), this.setShouldRender();
  }
  setWidgetPosition(e, t) {
    const i = this._widgets[e.getId()];
    return i.preference.lane === t.lane && i.preference.zIndex === t.zIndex && T.equalsRange(i.preference.range, t.range) ? !1 : (i.preference = t, this.setShouldRender(), !0);
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets[t]) {
      const n = this._widgets[t].domNode.domNode;
      delete this._widgets[t], n.remove(), this.setShouldRender();
    }
  }
  // --- end widget management
  _collectDecorationBasedGlyphRenderRequest(e, t) {
    var r;
    const i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber, o = e.getDecorationsInViewport();
    for (const a of o) {
      const l = a.options.glyphMarginClassName;
      if (!l)
        continue;
      const c = Math.max(a.range.startLineNumber, i), h = Math.min(a.range.endLineNumber, n), d = ((r = a.options.glyphMargin) == null ? void 0 : r.position) ?? _o.Center, u = a.options.zIndex ?? 0;
      for (let f = c; f <= h; f++) {
        const g = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new F(f, 0)), p = this._context.viewModel.glyphLanes.getLanesAtLine(g.lineNumber).indexOf(d);
        t.push(new fq(f, p, u, l));
      }
    }
  }
  _collectWidgetBasedGlyphRenderRequest(e, t) {
    const i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber;
    for (const o of Object.values(this._widgets)) {
      const r = o.preference.range, { startLineNumber: a, endLineNumber: l } = this._context.viewModel.coordinatesConverter.convertModelRangeToViewRange(T.lift(r));
      if (!a || !l || l < i || a > n)
        continue;
      const c = Math.max(a, i), h = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new F(c, 0)), d = this._context.viewModel.glyphLanes.getLanesAtLine(h.lineNumber).indexOf(o.preference.lane);
      t.push(new gq(c, d, o.preference.zIndex, o));
    }
  }
  _collectSortedGlyphRenderRequests(e) {
    const t = [];
    return this._collectDecorationBasedGlyphRenderRequest(e, t), this._collectWidgetBasedGlyphRenderRequest(e, t), t.sort((i, n) => i.lineNumber === n.lineNumber ? i.laneIndex === n.laneIndex ? i.zIndex === n.zIndex ? n.type === i.type ? i.type === 0 && n.type === 0 ? i.className < n.className ? -1 : 1 : 0 : n.type - i.type : n.zIndex - i.zIndex : i.laneIndex - n.laneIndex : i.lineNumber - n.lineNumber), t;
  }
  /**
   * Will store render information in each widget's renderInfo and in `_decorationGlyphsToRender`.
   */
  prepareRender(e) {
    if (!this._glyphMargin) {
      this._decorationGlyphsToRender = [];
      return;
    }
    for (const n of Object.values(this._widgets))
      n.renderInfo = null;
    const t = new $a(this._collectSortedGlyphRenderRequests(e)), i = [];
    for (; t.length > 0; ) {
      const n = t.peek();
      if (!n)
        break;
      const o = t.takeWhile((a) => a.lineNumber === n.lineNumber && a.laneIndex === n.laneIndex);
      if (!o || o.length === 0)
        break;
      const r = o[0];
      if (r.type === 0) {
        const a = [];
        for (const l of o) {
          if (l.zIndex !== r.zIndex || l.type !== r.type)
            break;
          (a.length === 0 || a[a.length - 1] !== l.className) && a.push(l.className);
        }
        i.push(r.accept(a.join(" ")));
      } else
        r.widget.renderInfo = {
          lineNumber: r.lineNumber,
          laneIndex: r.laneIndex
        };
    }
    this._decorationGlyphsToRender = i;
  }
  render(e) {
    if (!this._glyphMargin) {
      for (const i of Object.values(this._widgets))
        i.domNode.setDisplay("none");
      for (; this._managedDomNodes.length > 0; ) {
        const i = this._managedDomNodes.pop();
        i == null || i.domNode.remove();
      }
      return;
    }
    const t = Math.round(this._glyphMarginWidth / this._glyphMarginDecorationLaneCount);
    for (const i of Object.values(this._widgets))
      if (!i.renderInfo)
        i.domNode.setDisplay("none");
      else {
        const n = e.viewportData.relativeVerticalOffset[i.renderInfo.lineNumber - e.viewportData.startLineNumber], o = this._glyphMarginLeft + i.renderInfo.laneIndex * this._lineHeight;
        i.domNode.setDisplay("block"), i.domNode.setTop(n), i.domNode.setLeft(o), i.domNode.setWidth(t), i.domNode.setHeight(this._lineHeight);
      }
    for (let i = 0; i < this._decorationGlyphsToRender.length; i++) {
      const n = this._decorationGlyphsToRender[i], o = e.viewportData.relativeVerticalOffset[n.lineNumber - e.viewportData.startLineNumber], r = this._glyphMarginLeft + n.laneIndex * this._lineHeight;
      let a;
      i < this._managedDomNodes.length ? a = this._managedDomNodes[i] : (a = st(document.createElement("div")), this._managedDomNodes.push(a), this.domNode.appendChild(a)), a.setClassName("cgmr codicon " + n.combinedClassName), a.setPosition("absolute"), a.setTop(o), a.setLeft(r), a.setWidth(t), a.setHeight(this._lineHeight);
    }
    for (; this._managedDomNodes.length > this._decorationGlyphsToRender.length; ) {
      const i = this._managedDomNodes.pop();
      i == null || i.domNode.remove();
    }
  }
}
class fq {
  constructor(e, t, i, n) {
    this.lineNumber = e, this.laneIndex = t, this.zIndex = i, this.className = n, this.type = 0;
  }
  accept(e) {
    return new mq(this.lineNumber, this.laneIndex, e);
  }
}
class gq {
  constructor(e, t, i, n) {
    this.lineNumber = e, this.laneIndex = t, this.zIndex = i, this.widget = n, this.type = 1;
  }
}
class mq {
  constructor(e, t, i) {
    this.lineNumber = e, this.laneIndex = t, this.combinedClassName = i;
  }
}
function L1(s, e) {
  const t = pq(s, e);
  if (t !== -1)
    return s[t];
}
function pq(s, e, t = s.length - 1) {
  for (let i = t; i >= 0; i--) {
    const n = s[i];
    if (e(n))
      return i;
  }
  return -1;
}
function mf(s, e) {
  const t = qm(s, e);
  return t === -1 ? void 0 : s[t];
}
function qm(s, e, t = 0, i = s.length) {
  let n = t, o = i;
  for (; n < o; ) {
    const r = Math.floor((n + o) / 2);
    e(s[r]) ? n = r + 1 : o = r;
  }
  return n - 1;
}
function _q(s, e) {
  const t = tL(s, e);
  return t === s.length ? void 0 : s[t];
}
function tL(s, e, t = 0, i = s.length) {
  let n = t, o = i;
  for (; n < o; ) {
    const r = Math.floor((n + o) / 2);
    e(s[r]) ? o = r : n = r + 1;
  }
  return n;
}
const tv = class tv {
  constructor(e) {
    this._array = e, this._findLastMonotonousLastIdx = 0;
  }
  /**
   * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!
   * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.
   */
  findLastMonotonous(e) {
    if (tv.assertInvariants) {
      if (this._prevFindLastPredicate) {
        for (const i of this._array)
          if (this._prevFindLastPredicate(i) && !e(i))
            throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
      }
      this._prevFindLastPredicate = e;
    }
    const t = qm(this._array, e, this._findLastMonotonousLastIdx);
    return this._findLastMonotonousLastIdx = t + 1, t === -1 ? void 0 : this._array[t];
  }
};
tv.assertInvariants = !1;
let k1 = tv;
function Y5(s, e) {
  if (s.length === 0)
    return;
  let t = s[0];
  for (let i = 1; i < s.length; i++) {
    const n = s[i];
    e(n, t) > 0 && (t = n);
  }
  return t;
}
function bq(s, e) {
  if (s.length === 0)
    return;
  let t = s[0];
  for (let i = 1; i < s.length; i++) {
    const n = s[i];
    e(n, t) >= 0 && (t = n);
  }
  return t;
}
function Cq(s, e) {
  return Y5(s, (t, i) => -e(t, i));
}
function vq(s, e) {
  if (s.length === 0)
    return -1;
  let t = 0;
  for (let i = 1; i < s.length; i++) {
    const n = s[i];
    e(n, s[t]) > 0 && (t = i);
  }
  return t;
}
class X5 extends U {
  constructor() {
    super(...arguments), this._isDisposed = !1;
  }
  dispose() {
    super.dispose(), this._isDisposed = !0;
  }
  assertNotDisposed() {
    if (this._isDisposed)
      throw new Error("TextModelPart is disposed!");
  }
}
function Q5(s, e) {
  let t = 0, i = 0;
  const n = s.length;
  for (; i < n; ) {
    const o = s.charCodeAt(i);
    if (o === 32)
      t++;
    else if (o === 9)
      t = t - t % e + e;
    else
      break;
    i++;
  }
  return i === n ? -1 : t;
}
var uh;
(function(s) {
  s[s.Disabled = 0] = "Disabled", s[s.EnabledForActive = 1] = "EnabledForActive", s[s.Enabled = 2] = "Enabled";
})(uh || (uh = {}));
class th {
  constructor(e, t, i, n, o, r) {
    if (this.visibleColumn = e, this.column = t, this.className = i, this.horizontalLine = n, this.forWrappedLinesAfterColumn = o, this.forWrappedLinesBeforeOrAtColumn = r, e !== -1 == (t !== -1))
      throw new Error();
  }
}
class Bg {
  constructor(e, t) {
    this.top = e, this.endColumn = t;
  }
}
class wq extends X5 {
  constructor(e, t) {
    super(), this.textModel = e, this.languageConfigurationService = t;
  }
  getLanguageConfiguration(e) {
    return this.languageConfigurationService.getLanguageConfiguration(e);
  }
  _computeIndentLevel(e) {
    return Q5(this.textModel.getLineContent(e + 1), this.textModel.getOptions().tabSize);
  }
  getActiveIndentGuide(e, t, i) {
    this.assertNotDisposed();
    const n = this.textModel.getLineCount();
    if (e < 1 || e > n)
      throw new at("Illegal value for lineNumber");
    const o = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules, r = !!(o && o.offSide);
    let a = -2, l = -1, c = -2, h = -1;
    const d = (k) => {
      if (a !== -1 && (a === -2 || a > k - 1)) {
        a = -1, l = -1;
        for (let x = k - 2; x >= 0; x--) {
          const I = this._computeIndentLevel(x);
          if (I >= 0) {
            a = x, l = I;
            break;
          }
        }
      }
      if (c === -2) {
        c = -1, h = -1;
        for (let x = k; x < n; x++) {
          const I = this._computeIndentLevel(x);
          if (I >= 0) {
            c = x, h = I;
            break;
          }
        }
      }
    };
    let u = -2, f = -1, g = -2, p = -1;
    const _ = (k) => {
      if (u === -2) {
        u = -1, f = -1;
        for (let x = k - 2; x >= 0; x--) {
          const I = this._computeIndentLevel(x);
          if (I >= 0) {
            u = x, f = I;
            break;
          }
        }
      }
      if (g !== -1 && (g === -2 || g < k - 1)) {
        g = -1, p = -1;
        for (let x = k; x < n; x++) {
          const I = this._computeIndentLevel(x);
          if (I >= 0) {
            g = x, p = I;
            break;
          }
        }
      }
    };
    let b = 0, C = !0, w = 0, v = !0, S = 0, L = 0;
    for (let k = 0; C || v; k++) {
      const x = e - k, I = e + k;
      k > 1 && (x < 1 || x < t) && (C = !1), k > 1 && (I > n || I > i) && (v = !1), k > 5e4 && (C = !1, v = !1);
      let K = -1;
      if (C && x >= 1) {
        const W = this._computeIndentLevel(x - 1);
        W >= 0 ? (c = x - 1, h = W, K = Math.ceil(W / this.textModel.getOptions().indentSize)) : (d(x), K = this._getIndentLevelForWhitespaceLine(r, l, h));
      }
      let B = -1;
      if (v && I <= n) {
        const W = this._computeIndentLevel(I - 1);
        W >= 0 ? (u = I - 1, f = W, B = Math.ceil(W / this.textModel.getOptions().indentSize)) : (_(I), B = this._getIndentLevelForWhitespaceLine(r, f, p));
      }
      if (k === 0) {
        L = K;
        continue;
      }
      if (k === 1) {
        if (I <= n && B >= 0 && L + 1 === B) {
          C = !1, b = I, w = I, S = B;
          continue;
        }
        if (x >= 1 && K >= 0 && K - 1 === L) {
          v = !1, b = x, w = x, S = K;
          continue;
        }
        if (b = e, w = e, S = L, S === 0)
          return { startLineNumber: b, endLineNumber: w, indent: S };
      }
      C && (K >= S ? b = x : C = !1), v && (B >= S ? w = I : v = !1);
    }
    return { startLineNumber: b, endLineNumber: w, indent: S };
  }
  getLinesBracketGuides(e, t, i, n) {
    var d;
    const o = [];
    for (let u = e; u <= t; u++)
      o.push([]);
    const r = !0, a = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new T(e, 1, t, this.textModel.getLineMaxColumn(t))).toArray();
    let l;
    if (i && a.length > 0) {
      const u = (e <= i.lineNumber && i.lineNumber <= t ? a : this.textModel.bracketPairs.getBracketPairsInRange(T.fromPositions(i)).toArray()).filter((f) => T.strictContainsPosition(f.range, i));
      l = (d = L1(u, (f) => r)) == null ? void 0 : d.range;
    }
    const c = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType, h = new J5();
    for (const u of a) {
      if (!u.closingBracketRange)
        continue;
      const f = l && u.range.equalsRange(l);
      if (!f && !n.includeInactive)
        continue;
      const g = h.getInlineClassName(u.nestingLevel, u.nestingLevelOfEqualBracketType, c) + (n.highlightActive && f ? " " + h.activeClassName : ""), p = u.openingBracketRange.getStartPosition(), _ = u.closingBracketRange.getStartPosition(), b = n.horizontalGuides === uh.Enabled || n.horizontalGuides === uh.EnabledForActive && f;
      if (u.range.startLineNumber === u.range.endLineNumber) {
        b && o[u.range.startLineNumber - e].push(new th(-1, u.openingBracketRange.getEndPosition().column, g, new Bg(!1, _.column), -1, -1));
        continue;
      }
      const C = this.getVisibleColumnFromPosition(_), w = this.getVisibleColumnFromPosition(u.openingBracketRange.getStartPosition()), v = Math.min(w, C, u.minVisibleColumnIndentation + 1);
      let S = !1;
      Zn(this.textModel.getLineContent(u.closingBracketRange.startLineNumber)) < u.closingBracketRange.startColumn - 1 && (S = !0);
      const x = Math.max(p.lineNumber, e), I = Math.min(_.lineNumber, t), K = S ? 1 : 0;
      for (let B = x; B < I + K; B++)
        o[B - e].push(new th(v, -1, g, null, B === p.lineNumber ? p.column : -1, B === _.lineNumber ? _.column : -1));
      b && (p.lineNumber >= e && w > v && o[p.lineNumber - e].push(new th(v, -1, g, new Bg(!1, p.column), -1, -1)), _.lineNumber <= t && C > v && o[_.lineNumber - e].push(new th(v, -1, g, new Bg(!S, _.column), -1, -1)));
    }
    for (const u of o)
      u.sort((f, g) => f.visibleColumn - g.visibleColumn);
    return o;
  }
  getVisibleColumnFromPosition(e) {
    return pi.visibleColumnFromColumn(this.textModel.getLineContent(e.lineNumber), e.column, this.textModel.getOptions().tabSize) + 1;
  }
  getLinesIndentGuides(e, t) {
    this.assertNotDisposed();
    const i = this.textModel.getLineCount();
    if (e < 1 || e > i)
      throw new Error("Illegal value for startLineNumber");
    if (t < 1 || t > i)
      throw new Error("Illegal value for endLineNumber");
    const n = this.textModel.getOptions(), o = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules, r = !!(o && o.offSide), a = new Array(t - e + 1);
    let l = -2, c = -1, h = -2, d = -1;
    for (let u = e; u <= t; u++) {
      const f = u - e, g = this._computeIndentLevel(u - 1);
      if (g >= 0) {
        l = u - 1, c = g, a[f] = Math.ceil(g / n.indentSize);
        continue;
      }
      if (l === -2) {
        l = -1, c = -1;
        for (let p = u - 2; p >= 0; p--) {
          const _ = this._computeIndentLevel(p);
          if (_ >= 0) {
            l = p, c = _;
            break;
          }
        }
      }
      if (h !== -1 && (h === -2 || h < u - 1)) {
        h = -1, d = -1;
        for (let p = u; p < i; p++) {
          const _ = this._computeIndentLevel(p);
          if (_ >= 0) {
            h = p, d = _;
            break;
          }
        }
      }
      a[f] = this._getIndentLevelForWhitespaceLine(r, c, d);
    }
    return a;
  }
  _getIndentLevelForWhitespaceLine(e, t, i) {
    const n = this.textModel.getOptions();
    return t === -1 || i === -1 ? 0 : t < i ? 1 + Math.floor(t / n.indentSize) : t === i || e ? Math.ceil(i / n.indentSize) : 1 + Math.floor(i / n.indentSize);
  }
}
class J5 {
  constructor() {
    this.activeClassName = "indent-active";
  }
  getInlineClassName(e, t, i) {
    return this.getInlineClassNameOfLevel(i ? t : e);
  }
  getInlineClassNameOfLevel(e) {
    return `bracket-indent-guide lvl-${e % 30}`;
  }
}
class yq extends cd {
  constructor(e) {
    super(), this._context = e, this._primaryPosition = null;
    const t = this._context.configuration.options, i = t.get(
      147
      /* EditorOption.wrappingInfo */
    ), n = t.get(
      50
      /* EditorOption.fontInfo */
    );
    this._spaceWidth = n.spaceWidth, this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * n.typicalHalfwidthCharacterWidth, this._bracketPairGuideOptions = t.get(
      16
      /* EditorOption.guides */
    ), this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      147
      /* EditorOption.wrappingInfo */
    ), n = t.get(
      50
      /* EditorOption.fontInfo */
    );
    return this._spaceWidth = n.spaceWidth, this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * n.typicalHalfwidthCharacterWidth, this._bracketPairGuideOptions = t.get(
      16
      /* EditorOption.guides */
    ), !0;
  }
  onCursorStateChanged(e) {
    var n;
    const i = e.selections[0].getPosition();
    return (n = this._primaryPosition) != null && n.equals(i) ? !1 : (this._primaryPosition = i, !0);
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onLanguageConfigurationChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
    var l, c;
    if (!this._bracketPairGuideOptions.indentation && this._bracketPairGuideOptions.bracketPairs === !1) {
      this._renderResult = null;
      return;
    }
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = e.scrollWidth, o = this._primaryPosition, r = this.getGuidesByLine(t, Math.min(i + 1, this._context.viewModel.getLineCount()), o), a = [];
    for (let h = t; h <= i; h++) {
      const d = h - t, u = r[d];
      let f = "";
      const g = ((l = e.visibleRangeForPosition(new F(h, 1))) == null ? void 0 : l.left) ?? 0;
      for (const p of u) {
        const _ = p.column === -1 ? g + (p.visibleColumn - 1) * this._spaceWidth : e.visibleRangeForPosition(new F(h, p.column)).left;
        if (_ > n || this._maxIndentLeft > 0 && _ > this._maxIndentLeft)
          break;
        const b = p.horizontalLine ? p.horizontalLine.top ? "horizontal-top" : "horizontal-bottom" : "vertical", C = p.horizontalLine ? (((c = e.visibleRangeForPosition(new F(h, p.horizontalLine.endColumn))) == null ? void 0 : c.left) ?? _ + this._spaceWidth) - _ : this._spaceWidth;
        f += `<div class="core-guide ${p.className} ${b}" style="left:${_}px;width:${C}px"></div>`;
      }
      a[d] = f;
    }
    this._renderResult = a;
  }
  getGuidesByLine(e, t, i) {
    const n = this._bracketPairGuideOptions.bracketPairs !== !1 ? this._context.viewModel.getBracketGuidesInRangeByLine(e, t, i, {
      highlightActive: this._bracketPairGuideOptions.highlightActiveBracketPair,
      horizontalGuides: this._bracketPairGuideOptions.bracketPairsHorizontal === !0 ? uh.Enabled : this._bracketPairGuideOptions.bracketPairsHorizontal === "active" ? uh.EnabledForActive : uh.Disabled,
      includeInactive: this._bracketPairGuideOptions.bracketPairs === !0
    }) : null, o = this._bracketPairGuideOptions.indentation ? this._context.viewModel.getLinesIndentGuides(e, t) : null;
    let r = 0, a = 0, l = 0;
    if (this._bracketPairGuideOptions.highlightActiveIndentation !== !1 && i) {
      const d = this._context.viewModel.getActiveIndentGuide(i.lineNumber, e, t);
      r = d.startLineNumber, a = d.endLineNumber, l = d.indent;
    }
    const { indentSize: c } = this._context.viewModel.model.getOptions(), h = [];
    for (let d = e; d <= t; d++) {
      const u = new Array();
      h.push(u);
      const f = n ? n[d - e] : [], g = new $a(f), p = o ? o[d - e] : 0;
      for (let _ = 1; _ <= p; _++) {
        const b = (_ - 1) * c + 1, C = (
          // Disable active indent guide if there are bracket guides.
          (this._bracketPairGuideOptions.highlightActiveIndentation === "always" || f.length === 0) && r <= d && d <= a && _ === l
        );
        u.push(...g.takeWhile((v) => v.visibleColumn < b) || []);
        const w = g.peek();
        (!w || w.visibleColumn !== b || w.horizontalLine) && u.push(new th(b, -1, `core-guide-indent lvl-${(_ - 1) % 30}` + (C ? " indent-active" : ""), null, -1, -1));
      }
      u.push(...g.takeWhile((_) => !0) || []);
    }
    return h;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
function Nd(s) {
  if (!(s && s.isTransparent()))
    return s;
}
tr((s, e) => {
  const t = [
    { bracketColor: k5, guideColor: LK, guideColorActive: NK },
    { bracketColor: x5, guideColor: kK, guideColorActive: TK },
    { bracketColor: D5, guideColor: xK, guideColorActive: MK },
    { bracketColor: E5, guideColor: DK, guideColorActive: RK },
    { bracketColor: I5, guideColor: EK, guideColorActive: AK },
    { bracketColor: N5, guideColor: IK, guideColorActive: PK }
  ], i = new J5(), n = [
    { indentColor: Bp, indentColorActive: Wp },
    { indentColor: sK, indentColorActive: cK },
    { indentColor: oK, indentColorActive: hK },
    { indentColor: rK, indentColorActive: dK },
    { indentColor: aK, indentColorActive: uK },
    { indentColor: lK, indentColorActive: fK }
  ], o = t.map((a) => {
    const l = s.getColor(a.bracketColor), c = s.getColor(a.guideColor), h = s.getColor(a.guideColorActive), d = Nd(Nd(c) ?? (l == null ? void 0 : l.transparent(0.3))), u = Nd(Nd(h) ?? l);
    if (!(!d || !u))
      return {
        guideColor: d,
        guideColorActive: u
      };
  }).filter(nf), r = n.map((a) => {
    const l = s.getColor(a.indentColor), c = s.getColor(a.indentColorActive), h = Nd(l), d = Nd(c);
    if (!(!h || !d))
      return {
        indentColor: h,
        indentColorActive: d
      };
  }).filter(nf);
  if (o.length > 0) {
    for (let a = 0; a < 30; a++) {
      const l = o[a % o.length];
      e.addRule(`.monaco-editor .${i.getInlineClassNameOfLevel(a).replace(/ /g, ".")} { --guide-color: ${l.guideColor}; --guide-color-active: ${l.guideColorActive}; }`);
    }
    e.addRule(".monaco-editor .vertical { box-shadow: 1px 0 0 0 var(--guide-color) inset; }"), e.addRule(".monaco-editor .horizontal-top { border-top: 1px solid var(--guide-color); }"), e.addRule(".monaco-editor .horizontal-bottom { border-bottom: 1px solid var(--guide-color); }"), e.addRule(`.monaco-editor .vertical.${i.activeClassName} { box-shadow: 1px 0 0 0 var(--guide-color-active) inset; }`), e.addRule(`.monaco-editor .horizontal-top.${i.activeClassName} { border-top: 1px solid var(--guide-color-active); }`), e.addRule(`.monaco-editor .horizontal-bottom.${i.activeClassName} { border-bottom: 1px solid var(--guide-color-active); }`);
  }
  if (r.length > 0) {
    for (let a = 0; a < 30; a++) {
      const l = r[a % r.length];
      e.addRule(`.monaco-editor .lines-content .core-guide-indent.lvl-${a} { --indent-color: ${l.indentColor}; --indent-color-active: ${l.indentColorActive}; }`);
    }
    e.addRule(".monaco-editor .lines-content .core-guide-indent { box-shadow: 1px 0 0 0 var(--indent-color) inset; }"), e.addRule(".monaco-editor .lines-content .core-guide-indent.indent-active { box-shadow: 1px 0 0 0 var(--indent-color-active) inset; }");
  }
});
class V0 {
  get didDomLayout() {
    return this._didDomLayout;
  }
  readClientRect() {
    if (!this._clientRectRead) {
      this._clientRectRead = !0;
      const e = this._domNode.getBoundingClientRect();
      this.markDidDomLayout(), this._clientRectDeltaLeft = e.left, this._clientRectScale = e.width / this._domNode.offsetWidth;
    }
  }
  get clientRectDeltaLeft() {
    return this._clientRectRead || this.readClientRect(), this._clientRectDeltaLeft;
  }
  get clientRectScale() {
    return this._clientRectRead || this.readClientRect(), this._clientRectScale;
  }
  constructor(e, t) {
    this._domNode = e, this.endNode = t, this._didDomLayout = !1, this._clientRectDeltaLeft = 0, this._clientRectScale = 1, this._clientRectRead = !1;
  }
  markDidDomLayout() {
    this._didDomLayout = !0;
  }
}
class Sq {
  constructor() {
    this._currentVisibleRange = new T(1, 1, 1, 1);
  }
  getCurrentVisibleRange() {
    return this._currentVisibleRange;
  }
  setCurrentVisibleRange(e) {
    this._currentVisibleRange = e;
  }
}
class Lq {
  constructor(e, t, i, n, o, r, a) {
    this.minimalReveal = e, this.lineNumber = t, this.startColumn = i, this.endColumn = n, this.startScrollTop = o, this.stopScrollTop = r, this.scrollType = a, this.type = "range", this.minLineNumber = t, this.maxLineNumber = t;
  }
}
class kq {
  constructor(e, t, i, n, o) {
    this.minimalReveal = e, this.selections = t, this.startScrollTop = i, this.stopScrollTop = n, this.scrollType = o, this.type = "selections";
    let r = t[0].startLineNumber, a = t[0].endLineNumber;
    for (let l = 1, c = t.length; l < c; l++) {
      const h = t[l];
      r = Math.min(r, h.startLineNumber), a = Math.max(a, h.endLineNumber);
    }
    this.minLineNumber = r, this.maxLineNumber = a;
  }
}
const iv = class iv extends rs {
  constructor(e, t) {
    super(e);
    const i = this._context.configuration, n = this._context.configuration.options, o = n.get(
      50
      /* EditorOption.fontInfo */
    ), r = n.get(
      147
      /* EditorOption.wrappingInfo */
    );
    this._lineHeight = n.get(
      67
      /* EditorOption.lineHeight */
    ), this._typicalHalfwidthCharacterWidth = o.typicalHalfwidthCharacterWidth, this._isViewportWrapping = r.isViewportWrapping, this._revealHorizontalRightPadding = n.get(
      101
      /* EditorOption.revealHorizontalRightPadding */
    ), this._cursorSurroundingLines = n.get(
      29
      /* EditorOption.cursorSurroundingLines */
    ), this._cursorSurroundingLinesStyle = n.get(
      30
      /* EditorOption.cursorSurroundingLinesStyle */
    ), this._canUseLayerHinting = !n.get(
      32
      /* EditorOption.disableLayerHinting */
    ), this._viewLineOptions = new xT(i, this._context.theme.type), this._linesContent = t, this._textRangeRestingSpot = document.createElement("div"), this._visibleLines = new j5({
      createLine: () => new ya(this._viewLineOptions)
    }), this.domNode = this._visibleLines.domNode, Go.write(
      this.domNode,
      8
      /* PartFingerprint.ViewLines */
    ), this.domNode.setClassName(`view-lines ${Pu}`), Zi(this.domNode, o), this._maxLineWidth = 0, this._asyncUpdateLineWidths = new ai(() => {
      this._updateLineWidthsSlow();
    }, 200), this._asyncCheckMonospaceFontAssumptions = new ai(() => {
      this._checkMonospaceFontAssumptions();
    }, 2e3), this._lastRenderedData = new Sq(), this._horizontalRevealRequest = null, this._stickyScrollEnabled = n.get(
      116
      /* EditorOption.stickyScroll */
    ).enabled, this._maxNumberStickyLines = n.get(
      116
      /* EditorOption.stickyScroll */
    ).maxLineCount;
  }
  dispose() {
    this._asyncUpdateLineWidths.dispose(), this._asyncCheckMonospaceFontAssumptions.dispose(), super.dispose();
  }
  getDomNode() {
    return this.domNode;
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    this._visibleLines.onConfigurationChanged(e), e.hasChanged(
      147
      /* EditorOption.wrappingInfo */
    ) && (this._maxLineWidth = 0);
    const t = this._context.configuration.options, i = t.get(
      50
      /* EditorOption.fontInfo */
    ), n = t.get(
      147
      /* EditorOption.wrappingInfo */
    );
    return this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._isViewportWrapping = n.isViewportWrapping, this._revealHorizontalRightPadding = t.get(
      101
      /* EditorOption.revealHorizontalRightPadding */
    ), this._cursorSurroundingLines = t.get(
      29
      /* EditorOption.cursorSurroundingLines */
    ), this._cursorSurroundingLinesStyle = t.get(
      30
      /* EditorOption.cursorSurroundingLinesStyle */
    ), this._canUseLayerHinting = !t.get(
      32
      /* EditorOption.disableLayerHinting */
    ), this._stickyScrollEnabled = t.get(
      116
      /* EditorOption.stickyScroll */
    ).enabled, this._maxNumberStickyLines = t.get(
      116
      /* EditorOption.stickyScroll */
    ).maxLineCount, Zi(this.domNode, i), this._onOptionsMaybeChanged(), e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    ) && (this._maxLineWidth = 0), !0;
  }
  _onOptionsMaybeChanged() {
    const e = this._context.configuration, t = new xT(e, this._context.theme.type);
    if (!this._viewLineOptions.equals(t)) {
      this._viewLineOptions = t;
      const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
      for (let o = i; o <= n; o++)
        this._visibleLines.getVisibleLine(o).onOptionsChanged(this._viewLineOptions);
      return !0;
    }
    return !1;
  }
  onCursorStateChanged(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    let n = !1;
    for (let o = t; o <= i; o++)
      n = this._visibleLines.getVisibleLine(o).onSelectionChanged() || n;
    return n;
  }
  onDecorationsChanged(e) {
    {
      const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
      for (let n = t; n <= i; n++)
        this._visibleLines.getVisibleLine(n).onDecorationsChanged();
    }
    return !0;
  }
  onFlushed(e) {
    const t = this._visibleLines.onFlushed(e);
    return this._maxLineWidth = 0, t;
  }
  onLinesChanged(e) {
    return this._visibleLines.onLinesChanged(e);
  }
  onLinesDeleted(e) {
    return this._visibleLines.onLinesDeleted(e);
  }
  onLinesInserted(e) {
    return this._visibleLines.onLinesInserted(e);
  }
  onRevealRangeRequest(e) {
    const t = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.minimalReveal, e.range, e.selections, e.verticalType);
    if (t === -1)
      return !1;
    let i = this._context.viewLayout.validateScrollPosition({ scrollTop: t });
    e.revealHorizontal ? e.range && e.range.startLineNumber !== e.range.endLineNumber ? i = {
      scrollTop: i.scrollTop,
      scrollLeft: 0
    } : e.range ? this._horizontalRevealRequest = new Lq(e.minimalReveal, e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType) : e.selections && e.selections.length > 0 && (this._horizontalRevealRequest = new kq(e.minimalReveal, e.selections, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType)) : this._horizontalRevealRequest = null;
    const o = Math.abs(this._context.viewLayout.getCurrentScrollTop() - i.scrollTop) <= this._lineHeight ? 1 : e.scrollType;
    return this._context.viewModel.viewLayout.setScrollPosition(i, o), !0;
  }
  onScrollChanged(e) {
    if (this._horizontalRevealRequest && e.scrollLeftChanged && (this._horizontalRevealRequest = null), this._horizontalRevealRequest && e.scrollTopChanged) {
      const t = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop), i = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);
      (e.scrollTop < t || e.scrollTop > i) && (this._horizontalRevealRequest = null);
    }
    return this.domNode.setWidth(e.scrollWidth), this._visibleLines.onScrollChanged(e) || !0;
  }
  onTokensChanged(e) {
    return this._visibleLines.onTokensChanged(e);
  }
  onZonesChanged(e) {
    return this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth), this._visibleLines.onZonesChanged(e);
  }
  onThemeChanged(e) {
    return this._onOptionsMaybeChanged();
  }
  // ---- end view event handlers
  // ----------- HELPERS FOR OTHERS
  getPositionFromDOMInfo(e, t) {
    const i = this._getViewLineDomNode(e);
    if (i === null)
      return null;
    const n = this._getLineNumberFor(i);
    if (n === -1 || n < 1 || n > this._context.viewModel.getLineCount())
      return null;
    if (this._context.viewModel.getLineMaxColumn(n) === 1)
      return new F(n, 1);
    const o = this._visibleLines.getStartLineNumber(), r = this._visibleLines.getEndLineNumber();
    if (n < o || n > r)
      return null;
    let a = this._visibleLines.getVisibleLine(n).getColumnOfNodeOffset(e, t);
    const l = this._context.viewModel.getLineMinColumn(n);
    return a < l && (a = l), new F(n, a);
  }
  _getViewLineDomNode(e) {
    for (; e && e.nodeType === 1; ) {
      if (e.className === ya.CLASS_NAME)
        return e;
      e = e.parentElement;
    }
    return null;
  }
  /**
   * @returns the line number of this view line dom node.
   */
  _getLineNumberFor(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    for (let n = t; n <= i; n++) {
      const o = this._visibleLines.getVisibleLine(n);
      if (e === o.getDomNode())
        return n;
    }
    return -1;
  }
  getLineWidth(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    if (e < t || e > i)
      return -1;
    const n = new V0(this.domNode.domNode, this._textRangeRestingSpot), o = this._visibleLines.getVisibleLine(e).getWidth(n);
    return this._updateLineWidthsSlowIfDomDidLayout(n), o;
  }
  linesVisibleRangesForRange(e, t) {
    if (this.shouldRender())
      return null;
    const i = e.endLineNumber, n = T.intersectRanges(e, this._lastRenderedData.getCurrentVisibleRange());
    if (!n)
      return null;
    const o = [];
    let r = 0;
    const a = new V0(this.domNode.domNode, this._textRangeRestingSpot);
    let l = 0;
    t && (l = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new F(n.startLineNumber, 1)).lineNumber);
    const c = this._visibleLines.getStartLineNumber(), h = this._visibleLines.getEndLineNumber();
    for (let d = n.startLineNumber; d <= n.endLineNumber; d++) {
      if (d < c || d > h)
        continue;
      const u = d === n.startLineNumber ? n.startColumn : 1, f = d !== n.endLineNumber, g = f ? this._context.viewModel.getLineMaxColumn(d) : n.endColumn, p = this._visibleLines.getVisibleLine(d).getVisibleRangesForRange(d, u, g, a);
      if (p) {
        if (t && d < i) {
          const _ = l;
          l = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new F(d + 1, 1)).lineNumber, _ !== l && (p.ranges[p.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth);
        }
        o[r++] = new _$(p.outsideRenderedLine, d, vw.from(p.ranges), f);
      }
    }
    return this._updateLineWidthsSlowIfDomDidLayout(a), r === 0 ? null : o;
  }
  _visibleRangesForLineRange(e, t, i) {
    if (this.shouldRender() || e < this._visibleLines.getStartLineNumber() || e > this._visibleLines.getEndLineNumber())
      return null;
    const n = new V0(this.domNode.domNode, this._textRangeRestingSpot), o = this._visibleLines.getVisibleLine(e).getVisibleRangesForRange(e, t, i, n);
    return this._updateLineWidthsSlowIfDomDidLayout(n), o;
  }
  visibleRangeForPosition(e) {
    const t = this._visibleRangesForLineRange(e.lineNumber, e.column, e.column);
    return t ? new b$(t.outsideRenderedLine, t.ranges[0].left) : null;
  }
  /**
   * Updates the max line width if it is fast to compute.
   * Returns true if all lines were taken into account.
   * Returns false if some lines need to be reevaluated (in a slow fashion).
   */
  _updateLineWidthsFast() {
    return this._updateLineWidths(!0);
  }
  _updateLineWidthsSlow() {
    this._updateLineWidths(!1);
  }
  /**
   * Update the line widths using DOM layout information after someone else
   * has caused a synchronous layout.
   */
  _updateLineWidthsSlowIfDomDidLayout(e) {
    e.didDomLayout && (this._asyncUpdateLineWidths.isScheduled() || (this._asyncUpdateLineWidths.cancel(), this._updateLineWidthsSlow()));
  }
  _updateLineWidths(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    let n = 1, o = !0;
    for (let r = t; r <= i; r++) {
      const a = this._visibleLines.getVisibleLine(r);
      if (e && !a.getWidthIsFast()) {
        o = !1;
        continue;
      }
      n = Math.max(n, a.getWidth(null));
    }
    return o && t === 1 && i === this._context.viewModel.getLineCount() && (this._maxLineWidth = 0), this._ensureMaxLineWidth(n), o;
  }
  _checkMonospaceFontAssumptions() {
    let e = -1, t = -1;
    const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
    for (let o = i; o <= n; o++) {
      const r = this._visibleLines.getVisibleLine(o);
      if (r.needsMonospaceFontCheck()) {
        const a = r.getWidth(null);
        a > t && (t = a, e = o);
      }
    }
    if (e !== -1 && !this._visibleLines.getVisibleLine(e).monospaceAssumptionsAreValid())
      for (let o = i; o <= n; o++)
        this._visibleLines.getVisibleLine(o).onMonospaceAssumptionsInvalidated();
  }
  prepareRender() {
    throw new Error("Not supported");
  }
  render() {
    throw new Error("Not supported");
  }
  renderText(e) {
    if (this._visibleLines.renderLines(e), this._lastRenderedData.setCurrentVisibleRange(e.visibleRange), this.domNode.setWidth(this._context.viewLayout.getScrollWidth()), this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1e6)), this._horizontalRevealRequest) {
      const i = this._horizontalRevealRequest;
      if (e.startLineNumber <= i.minLineNumber && i.maxLineNumber <= e.endLineNumber) {
        this._horizontalRevealRequest = null, this.onDidRender();
        const n = this._computeScrollLeftToReveal(i);
        n && (this._isViewportWrapping || this._ensureMaxLineWidth(n.maxHorizontalOffset), this._context.viewModel.viewLayout.setScrollPosition({
          scrollLeft: n.scrollLeft
        }, i.scrollType));
      }
    }
    if (this._updateLineWidthsFast() ? this._asyncUpdateLineWidths.cancel() : this._asyncUpdateLineWidths.schedule(), Rn && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {
      const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
      for (let o = i; o <= n; o++)
        if (this._visibleLines.getVisibleLine(o).needsMonospaceFontCheck()) {
          this._asyncCheckMonospaceFontAssumptions.schedule();
          break;
        }
    }
    this._linesContent.setLayerHinting(this._canUseLayerHinting), this._linesContent.setContain("strict");
    const t = this._context.viewLayout.getCurrentScrollTop() - e.bigNumbersDelta;
    this._linesContent.setTop(-t), this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());
  }
  // --- width
  _ensureMaxLineWidth(e) {
    const t = Math.ceil(e);
    this._maxLineWidth < t && (this._maxLineWidth = t, this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth));
  }
  _computeScrollTopToRevealRange(e, t, i, n, o, r) {
    const a = e.top, l = e.height, c = a + l;
    let h, d, u;
    if (o && o.length > 0) {
      let b = o[0].startLineNumber, C = o[0].endLineNumber;
      for (let w = 1, v = o.length; w < v; w++) {
        const S = o[w];
        b = Math.min(b, S.startLineNumber), C = Math.max(C, S.endLineNumber);
      }
      h = !1, d = this._context.viewLayout.getVerticalOffsetForLineNumber(b), u = this._context.viewLayout.getVerticalOffsetForLineNumber(C) + this._lineHeight;
    } else if (n)
      h = !0, d = this._context.viewLayout.getVerticalOffsetForLineNumber(n.startLineNumber), u = this._context.viewLayout.getVerticalOffsetForLineNumber(n.endLineNumber) + this._lineHeight;
    else
      return -1;
    const f = (t === "mouse" || i) && this._cursorSurroundingLinesStyle === "default";
    let g = 0, p = 0;
    if (f)
      i || (g = this._lineHeight);
    else {
      const b = l / this._lineHeight, C = Math.max(this._cursorSurroundingLines, this._stickyScrollEnabled ? this._maxNumberStickyLines : 0), w = Math.min(b / 2, C);
      g = w * this._lineHeight, p = Math.max(0, w - 1) * this._lineHeight;
    }
    i || (r === 0 || r === 4) && (p += this._lineHeight), d -= g, u += p;
    let _;
    if (u - d > l) {
      if (!h)
        return -1;
      _ = d;
    } else if (r === 5 || r === 6)
      if (r === 6 && a <= d && u <= c)
        _ = a;
      else {
        const b = Math.max(5 * this._lineHeight, l * 0.2), C = d - b, w = u - l;
        _ = Math.max(w, C);
      }
    else if (r === 1 || r === 2)
      if (r === 2 && a <= d && u <= c)
        _ = a;
      else {
        const b = (d + u) / 2;
        _ = Math.max(0, b - l / 2);
      }
    else
      _ = this._computeMinimumScrolling(
        a,
        c,
        d,
        u,
        r === 3,
        r === 4
        /* viewEvents.VerticalRevealType.Bottom */
      );
    return _;
  }
  _computeScrollLeftToReveal(e) {
    const t = this._context.viewLayout.getCurrentViewport(), i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    ), n = t.left, o = n + t.width - i.verticalScrollbarWidth;
    let r = 1073741824, a = 0;
    if (e.type === "range") {
      const c = this._visibleRangesForLineRange(e.lineNumber, e.startColumn, e.endColumn);
      if (!c)
        return null;
      for (const h of c.ranges)
        r = Math.min(r, Math.round(h.left)), a = Math.max(a, Math.round(h.left + h.width));
    } else
      for (const c of e.selections) {
        if (c.startLineNumber !== c.endLineNumber)
          return null;
        const h = this._visibleRangesForLineRange(c.startLineNumber, c.startColumn, c.endColumn);
        if (!h)
          return null;
        for (const d of h.ranges)
          r = Math.min(r, Math.round(d.left)), a = Math.max(a, Math.round(d.left + d.width));
      }
    return e.minimalReveal || (r = Math.max(0, r - iv.HORIZONTAL_EXTRA_PX), a += this._revealHorizontalRightPadding), e.type === "selections" && a - r > t.width ? null : {
      scrollLeft: this._computeMinimumScrolling(n, o, r, a),
      maxHorizontalOffset: a
    };
  }
  _computeMinimumScrolling(e, t, i, n, o, r) {
    e = e | 0, t = t | 0, i = i | 0, n = n | 0, o = !!o, r = !!r;
    const a = t - e;
    if (n - i < a) {
      if (o)
        return i;
      if (r)
        return Math.max(0, n - a);
      if (i < e)
        return i;
      if (n > t)
        return Math.max(0, n - a);
    } else
      return i;
    return e;
  }
};
iv.HORIZONTAL_EXTRA_PX = 30;
let iL = iv;
class xq extends Z5 {
  constructor(e) {
    super(), this._context = e;
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _getDecorations(e) {
    const t = e.getDecorationsInViewport(), i = [];
    let n = 0;
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.options.linesDecorationsClassName, c = a.options.zIndex;
      l && (i[n++] = new eL(a.range.startLineNumber, a.range.endLineNumber, l, a.options.linesDecorationsTooltip ?? null, c));
      const h = a.options.firstLineDecorationClassName;
      h && (i[n++] = new eL(a.range.startLineNumber, a.range.startLineNumber, h, a.options.linesDecorationsTooltip ?? null, c));
    }
    return i;
  }
  prepareRender(e) {
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = this._render(t, i, this._getDecorations(e)), o = this._decorationsLeft.toString(), r = this._decorationsWidth.toString(), a = '" style="left:' + o + "px;width:" + r + 'px;"></div>', l = [];
    for (let c = t; c <= i; c++) {
      const h = c - t, d = n[h].getDecorations();
      let u = "";
      for (const f of d) {
        let g = '<div class="cldr ' + f.className;
        f.tooltip !== null && (g += '" title="' + f.tooltip), g += a, u += g;
      }
      l[h] = u;
    }
    this._renderResult = l;
  }
  render(e, t) {
    return this._renderResult ? this._renderResult[t - e] : "";
  }
}
class Dq extends Z5 {
  constructor(e) {
    super(), this._context = e, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    return !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _getDecorations(e) {
    const t = e.getDecorationsInViewport(), i = [];
    let n = 0;
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.options.marginClassName, c = a.options.zIndex;
      l && (i[n++] = new eL(a.range.startLineNumber, a.range.endLineNumber, l, null, c));
    }
    return i;
  }
  prepareRender(e) {
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = this._render(t, i, this._getDecorations(e)), o = [];
    for (let r = t; r <= i; r++) {
      const a = r - t, l = n[a].getDecorations();
      let c = "";
      for (const h of l)
        c += '<div class="cmdr ' + h.className + '" style=""></div>';
      o[a] = c;
    }
    this._renderResult = o;
  }
  render(e, t) {
    return this._renderResult ? this._renderResult[t - e] : "";
  }
}
const fl = class fl {
  constructor(e, t, i, n) {
    this._rgba8Brand = void 0, this.r = fl._clamp(e), this.g = fl._clamp(t), this.b = fl._clamp(i), this.a = fl._clamp(n);
  }
  equals(e) {
    return this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
  }
  static _clamp(e) {
    return e < 0 ? 0 : e > 255 ? 255 : e | 0;
  }
};
fl.Empty = new fl(0, 0, 0, 0);
let Wa = fl;
const nv = class nv extends U {
  static getInstance() {
    return this._INSTANCE || (this._INSTANCE = new nv()), this._INSTANCE;
  }
  constructor() {
    super(), this._onDidChange = new A(), this.onDidChange = this._onDidChange.event, this._updateColorMap(), this._register(ii.onDidChange((e) => {
      e.changedColorMap && this._updateColorMap();
    }));
  }
  _updateColorMap() {
    const e = ii.getColorMap();
    if (!e) {
      this._colors = [Wa.Empty], this._backgroundIsLight = !0;
      return;
    }
    this._colors = [Wa.Empty];
    for (let i = 1; i < e.length; i++) {
      const n = e[i].rgba;
      this._colors[i] = new Wa(n.r, n.g, n.b, Math.round(n.a * 255));
    }
    const t = e[
      2
      /* ColorId.DefaultBackground */
    ].getRelativeLuminance();
    this._backgroundIsLight = t >= 0.5, this._onDidChange.fire(void 0);
  }
  getColor(e) {
    return (e < 1 || e >= this._colors.length) && (e = 2), this._colors[e];
  }
  backgroundIsLight() {
    return this._backgroundIsLight;
  }
};
nv._INSTANCE = null;
let x1 = nv;
class eM {
  constructor(e, t, i, n) {
    this._viewportBrand = void 0, this.top = e | 0, this.left = t | 0, this.width = i | 0, this.height = n | 0;
  }
}
class Eq {
  constructor(e, t) {
    this.tabSize = e, this.data = t;
  }
}
class xI {
  constructor(e, t, i, n, o, r, a) {
    this._viewLineDataBrand = void 0, this.content = e, this.continuesWithWrappedLine = t, this.minColumn = i, this.maxColumn = n, this.startVisibleColumn = o, this.tokens = r, this.inlineDecorations = a;
  }
}
class xs {
  constructor(e, t, i, n, o, r, a, l, c, h) {
    this.minColumn = e, this.maxColumn = t, this.content = i, this.continuesWithWrappedLine = n, this.isBasicASCII = xs.isBasicASCII(i, r), this.containsRTL = xs.containsRTL(i, this.isBasicASCII, o), this.tokens = a, this.inlineDecorations = l, this.tabSize = c, this.startVisibleColumn = h;
  }
  static isBasicASCII(e, t) {
    return t ? fE(e) : !0;
  }
  static containsRTL(e, t, i) {
    return !t && i ? km(e) : !1;
  }
}
class Wg {
  constructor(e, t, i) {
    this.range = e, this.inlineClassName = t, this.type = i;
  }
}
class Iq {
  constructor(e, t, i, n) {
    this.startOffset = e, this.endOffset = t, this.inlineClassName = i, this.inlineClassNameAffectsLetterSpacing = n;
  }
  toInlineDecoration(e) {
    return new Wg(
      new T(e, this.startOffset + 1, e, this.endOffset + 1),
      this.inlineClassName,
      this.inlineClassNameAffectsLetterSpacing ? 3 : 0
      /* InlineDecorationType.Regular */
    );
  }
}
class eF {
  constructor(e, t) {
    this._viewModelDecorationBrand = void 0, this.range = e, this.options = t;
  }
}
class Gm {
  constructor(e, t, i) {
    this.color = e, this.zIndex = t, this.data = i;
  }
  static compareByRenderingProps(e, t) {
    return e.zIndex === t.zIndex ? e.color < t.color ? -1 : e.color > t.color ? 1 : 0 : e.zIndex - t.zIndex;
  }
  static equals(e, t) {
    return e.color === t.color && e.zIndex === t.zIndex && li(e.data, t.data);
  }
  static equalsArr(e, t) {
    return li(e, t, Gm.equals);
  }
}
const Nq = (() => {
  const s = [];
  for (let e = 32; e <= 126; e++)
    s.push(e);
  return s.push(
    65533
    /* Constants.UNKNOWN_CODE */
  ), s;
})(), Tq = (s, e) => (s -= 32, s < 0 || s > 96 ? e <= 2 ? (s + 96) % 96 : 95 : s);
class Zm {
  constructor(e, t) {
    this.scale = t, this._minimapCharRendererBrand = void 0, this.charDataNormal = Zm.soften(e, 12 / 15), this.charDataLight = Zm.soften(e, 50 / 60);
  }
  static soften(e, t) {
    const i = new Uint8ClampedArray(e.length);
    for (let n = 0, o = e.length; n < o; n++)
      i[n] = m1(e[n] * t);
    return i;
  }
  renderChar(e, t, i, n, o, r, a, l, c, h, d) {
    const u = 1 * this.scale, f = 2 * this.scale, g = d ? 1 : f;
    if (t + u > e.width || i + g > e.height) {
      console.warn("bad render request outside image data");
      return;
    }
    const p = h ? this.charDataLight : this.charDataNormal, _ = Tq(n, c), b = e.width * 4, C = a.r, w = a.g, v = a.b, S = o.r - C, L = o.g - w, k = o.b - v, x = Math.max(r, l), I = e.data;
    let K = _ * u * f, B = i * b + t * 4;
    for (let W = 0; W < g; W++) {
      let H = B;
      for (let P = 0; P < u; P++) {
        const q = p[K++] / 255 * (r / 255);
        I[H++] = C + S * q, I[H++] = w + L * q, I[H++] = v + k * q, I[H++] = x;
      }
      B += b;
    }
  }
  blockRenderChar(e, t, i, n, o, r, a, l) {
    const c = 1 * this.scale, h = 2 * this.scale, d = l ? 1 : h;
    if (t + c > e.width || i + d > e.height) {
      console.warn("bad render request outside image data");
      return;
    }
    const u = e.width * 4, f = 0.5 * (o / 255), g = r.r, p = r.g, _ = r.b, b = n.r - g, C = n.g - p, w = n.b - _, v = g + b * f, S = p + C * f, L = _ + w * f, k = Math.max(o, a), x = e.data;
    let I = i * u + t * 4;
    for (let K = 0; K < d; K++) {
      let B = I;
      for (let W = 0; W < c; W++)
        x[B++] = v, x[B++] = S, x[B++] = L, x[B++] = k;
      I += u;
    }
  }
}
const tM = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
}, iM = (s) => {
  const e = new Uint8ClampedArray(s.length / 2);
  for (let t = 0; t < s.length; t += 2)
    e[t >> 1] = tM[s[t]] << 4 | tM[s[t + 1]] & 15;
  return e;
}, nM = {
  1: tf(() => iM("0000511D6300CF609C709645A78432005642574171487021003C451900274D35D762755E8B629C5BA856AF57BA649530C167D1512A272A3F6038604460398526BCA2A968DB6F8957C768BE5FBE2FB467CF5D8D5B795DC7625B5DFF50DE64C466DB2FC47CD860A65E9A2EB96CB54CE06DA763AB2EA26860524D3763536601005116008177A8705E53AB738E6A982F88BAA35B5F5B626D9C636B449B737E5B7B678598869A662F6B5B8542706C704C80736A607578685B70594A49715A4522E792")),
  2: tf(() => iM("000000000000000055394F383D2800008B8B1F210002000081B1CBCBCC820000847AAF6B9AAF2119BE08B8881AD60000A44FD07DCCF107015338130C00000000385972265F390B406E2437634B4B48031B12B8A0847000001E15B29A402F0000000000004B33460B00007A752C2A0000000000004D3900000084394B82013400ABA5CFC7AD9C0302A45A3E5A98AB000089A43382D97900008BA54AA087A70A0248A6A7AE6DBE0000BF6F94987EA40A01A06DCFA7A7A9030496C32F77891D0000A99FB1A0AFA80603B29AB9CA75930D010C0948354D3900000C0948354F37460D0028BE673D8400000000AF9D7B6E00002B007AA8933400007AA642675C2700007984CFB9C3985B768772A8A6B7B20000CAAECAAFC4B700009F94A6009F840009D09F9BA4CA9C0000CC8FC76DC87F0000C991C472A2000000A894A48CA7B501079BA2C9C69BA20000B19A5D3FA89000005CA6009DA2960901B0A7F0669FB200009D009E00B7890000DAD0F5D092820000D294D4C48BD10000B5A7A4A3B1A50402CAB6CBA6A2000000B5A7A4A3B1A8044FCDADD19D9CB00000B7778F7B8AAE0803C9AB5D3F5D3F00009EA09EA0BAB006039EA0989A8C7900009B9EF4D6B7C00000A9A7816CACA80000ABAC84705D3F000096DA635CDC8C00006F486F266F263D4784006124097B00374F6D2D6D2D6D4A3A95872322000000030000000000008D8939130000000000002E22A5C9CBC70600AB25C0B5C9B400061A2DB04CA67001082AA6BEBEBFC606002321DACBC19E03087AA08B6768380000282FBAC0B8CA7A88AD25BBA5A29900004C396C5894A6000040485A6E356E9442A32CD17EADA70000B4237923628600003E2DE9C1D7B500002F25BBA5A2990000231DB6AFB4A804023025C0B5CAB588062B2CBDBEC0C706882435A75CA20000002326BD6A82A908048B4B9A5A668000002423A09CB4BB060025259C9D8A7900001C1FCAB2C7C700002A2A9387ABA200002626A4A47D6E9D14333163A0C87500004B6F9C2D643A257049364936493647358A34438355497F1A0000A24C1D590000D38DFFBDD4CD3126"))
};
class Hg {
  /**
   * Creates a new character renderer factory with the given scale.
   */
  static create(e, t) {
    if (this.lastCreated && e === this.lastCreated.scale && t === this.lastFontFamily)
      return this.lastCreated;
    let i;
    return nM[e] ? i = new Zm(nM[e](), e) : i = Hg.createFromSampleData(Hg.createSampleData(t).data, e), this.lastFontFamily = t, this.lastCreated = i, i;
  }
  /**
   * Creates the font sample data, writing to a canvas.
   */
  static createSampleData(e) {
    const t = document.createElement("canvas"), i = t.getContext("2d");
    t.style.height = "16px", t.height = 16, t.width = 96 * 10, t.style.width = 96 * 10 + "px", i.fillStyle = "#ffffff", i.font = `bold 16px ${e}`, i.textBaseline = "middle";
    let n = 0;
    for (const o of Nq)
      i.fillText(String.fromCharCode(o), n, 16 / 2), n += 10;
    return i.getImageData(
      0,
      0,
      96 * 10,
      16
      /* Constants.SAMPLED_CHAR_HEIGHT */
    );
  }
  /**
   * Creates a character renderer from the canvas sample data.
   */
  static createFromSampleData(e, t) {
    if (e.length !== 61440)
      throw new Error("Unexpected source in MinimapCharRenderer");
    const n = Hg._downsample(e, t);
    return new Zm(n, t);
  }
  static _downsampleChar(e, t, i, n, o) {
    const r = 1 * o, a = 2 * o;
    let l = n, c = 0;
    for (let h = 0; h < a; h++) {
      const d = h / a * 16, u = (h + 1) / a * 16;
      for (let f = 0; f < r; f++) {
        const g = f / r * 10, p = (f + 1) / r * 10;
        let _ = 0, b = 0;
        for (let w = d; w < u; w++) {
          const v = t + Math.floor(w) * 3840, S = 1 - (w - Math.floor(w));
          for (let L = g; L < p; L++) {
            const k = 1 - (L - Math.floor(L)), x = v + Math.floor(L) * 4, I = k * S;
            b += I, _ += e[x] * e[x + 3] / 255 * I;
          }
        }
        const C = _ / b;
        c = Math.max(c, C), i[l++] = m1(C);
      }
    }
    return c;
  }
  static _downsample(e, t) {
    const i = 2 * t * 1 * t, n = i * 96, o = new Uint8ClampedArray(n);
    let r = 0, a = 0, l = 0;
    for (let c = 0; c < 96; c++)
      l = Math.max(l, this._downsampleChar(e, a, o, r, t)), r += i, a += 10 * 4;
    if (l > 0) {
      const c = 255 / l;
      for (let h = 0; h < n; h++)
        o[h] *= c;
    }
    return o;
  }
}
const Mq = es ? '"Segoe WPC", "Segoe UI", sans-serif' : $e ? "-apple-system, BlinkMacSystemFont, sans-serif" : 'system-ui, "Ubuntu", "Droid Sans", sans-serif', Rq = 140, Aq = 2;
class Fu {
  constructor(e, t, i) {
    const n = e.options, o = n.get(
      144
      /* EditorOption.pixelRatio */
    ), r = n.get(
      146
      /* EditorOption.layoutInfo */
    ), a = r.minimap, l = n.get(
      50
      /* EditorOption.fontInfo */
    ), c = n.get(
      73
      /* EditorOption.minimap */
    );
    this.renderMinimap = a.renderMinimap, this.size = c.size, this.minimapHeightIsEditorHeight = a.minimapHeightIsEditorHeight, this.scrollBeyondLastLine = n.get(
      106
      /* EditorOption.scrollBeyondLastLine */
    ), this.paddingTop = n.get(
      84
      /* EditorOption.padding */
    ).top, this.paddingBottom = n.get(
      84
      /* EditorOption.padding */
    ).bottom, this.showSlider = c.showSlider, this.autohide = c.autohide, this.pixelRatio = o, this.typicalHalfwidthCharacterWidth = l.typicalHalfwidthCharacterWidth, this.lineHeight = n.get(
      67
      /* EditorOption.lineHeight */
    ), this.minimapLeft = a.minimapLeft, this.minimapWidth = a.minimapWidth, this.minimapHeight = r.height, this.canvasInnerWidth = a.minimapCanvasInnerWidth, this.canvasInnerHeight = a.minimapCanvasInnerHeight, this.canvasOuterWidth = a.minimapCanvasOuterWidth, this.canvasOuterHeight = a.minimapCanvasOuterHeight, this.isSampling = a.minimapIsSampling, this.editorHeight = r.height, this.fontScale = a.minimapScale, this.minimapLineHeight = a.minimapLineHeight, this.minimapCharWidth = 1 * this.fontScale, this.sectionHeaderFontFamily = Mq, this.sectionHeaderFontSize = c.sectionHeaderFontSize * o, this.sectionHeaderLetterSpacing = c.sectionHeaderLetterSpacing, this.sectionHeaderFontColor = Fu._getSectionHeaderColor(t, i.getColor(
      1
      /* ColorId.DefaultForeground */
    )), this.charRenderer = tf(() => Hg.create(this.fontScale, l.fontFamily)), this.defaultBackgroundColor = i.getColor(
      2
      /* ColorId.DefaultBackground */
    ), this.backgroundColor = Fu._getMinimapBackground(t, this.defaultBackgroundColor), this.foregroundAlpha = Fu._getMinimapForegroundOpacity(t);
  }
  static _getMinimapBackground(e, t) {
    const i = e.getColor(eU);
    return i ? new Wa(i.rgba.r, i.rgba.g, i.rgba.b, Math.round(255 * i.rgba.a)) : t;
  }
  static _getMinimapForegroundOpacity(e) {
    const t = e.getColor(tU);
    return t ? Wa._clamp(Math.round(255 * t.rgba.a)) : 255;
  }
  static _getSectionHeaderColor(e, t) {
    const i = e.getColor(Ja);
    return i ? new Wa(i.rgba.r, i.rgba.g, i.rgba.b, Math.round(255 * i.rgba.a)) : t;
  }
  equals(e) {
    return this.renderMinimap === e.renderMinimap && this.size === e.size && this.minimapHeightIsEditorHeight === e.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === e.scrollBeyondLastLine && this.paddingTop === e.paddingTop && this.paddingBottom === e.paddingBottom && this.showSlider === e.showSlider && this.autohide === e.autohide && this.pixelRatio === e.pixelRatio && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.lineHeight === e.lineHeight && this.minimapLeft === e.minimapLeft && this.minimapWidth === e.minimapWidth && this.minimapHeight === e.minimapHeight && this.canvasInnerWidth === e.canvasInnerWidth && this.canvasInnerHeight === e.canvasInnerHeight && this.canvasOuterWidth === e.canvasOuterWidth && this.canvasOuterHeight === e.canvasOuterHeight && this.isSampling === e.isSampling && this.editorHeight === e.editorHeight && this.fontScale === e.fontScale && this.minimapLineHeight === e.minimapLineHeight && this.minimapCharWidth === e.minimapCharWidth && this.sectionHeaderFontSize === e.sectionHeaderFontSize && this.sectionHeaderLetterSpacing === e.sectionHeaderLetterSpacing && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(e.defaultBackgroundColor) && this.backgroundColor && this.backgroundColor.equals(e.backgroundColor) && this.foregroundAlpha === e.foregroundAlpha;
  }
}
class Vg {
  constructor(e, t, i, n, o, r, a, l, c) {
    this.scrollTop = e, this.scrollHeight = t, this.sliderNeeded = i, this._computedSliderRatio = n, this.sliderTop = o, this.sliderHeight = r, this.topPaddingLineCount = a, this.startLineNumber = l, this.endLineNumber = c;
  }
  /**
   * Compute a desired `scrollPosition` such that the slider moves by `delta`.
   */
  getDesiredScrollTopFromDelta(e) {
    return Math.round(this.scrollTop + e / this._computedSliderRatio);
  }
  getDesiredScrollTopFromTouchLocation(e) {
    return Math.round((e - this.sliderHeight / 2) / this._computedSliderRatio);
  }
  /**
   * Intersect a line range with `this.startLineNumber` and `this.endLineNumber`.
   */
  intersectWithViewport(e) {
    const t = Math.max(this.startLineNumber, e.startLineNumber), i = Math.min(this.endLineNumber, e.endLineNumber);
    return t > i ? null : [t, i];
  }
  /**
   * Get the inner minimap y coordinate for a line number.
   */
  getYForLineNumber(e, t) {
    return +(e - this.startLineNumber + this.topPaddingLineCount) * t;
  }
  static create(e, t, i, n, o, r, a, l, c, h, d) {
    const u = e.pixelRatio, f = e.minimapLineHeight, g = Math.floor(e.canvasInnerHeight / f), p = e.lineHeight;
    if (e.minimapHeightIsEditorHeight) {
      let L = l * e.lineHeight + e.paddingTop + e.paddingBottom;
      e.scrollBeyondLastLine && (L += Math.max(0, o - e.lineHeight - e.paddingBottom));
      const k = Math.max(1, Math.floor(o * o / L)), x = Math.max(0, e.minimapHeight - k), I = x / (h - o), K = c * I, B = x > 0, W = Math.floor(e.canvasInnerHeight / e.minimapLineHeight), H = Math.floor(e.paddingTop / e.lineHeight);
      return new Vg(c, h, B, I, K, k, H, 1, Math.min(a, W));
    }
    let _;
    if (r && i !== a) {
      const L = i - t + 1;
      _ = Math.floor(L * f / u);
    } else {
      const L = o / p;
      _ = Math.floor(L * f / u);
    }
    const b = Math.floor(e.paddingTop / p);
    let C = Math.floor(e.paddingBottom / p);
    if (e.scrollBeyondLastLine) {
      const L = o / p;
      C = Math.max(C, L - 1);
    }
    let w;
    if (C > 0) {
      const L = o / p;
      w = (b + a + C - L - 1) * f / u;
    } else
      w = Math.max(0, (b + a) * f / u - _);
    w = Math.min(e.minimapHeight - _, w);
    const v = w / (h - o), S = c * v;
    if (g >= b + a + C) {
      const L = w > 0;
      return new Vg(c, h, L, v, S, _, b, 1, a);
    } else {
      let L;
      t > 1 ? L = t + b : L = Math.max(1, c / p);
      let k, x = Math.max(1, Math.floor(L - S * u / f));
      x < b ? (k = b - x + 1, x = 1) : (k = 0, x = Math.max(1, x - b)), d && d.scrollHeight === h && (d.scrollTop > c && (x = Math.min(x, d.startLineNumber), k = Math.max(k, d.topPaddingLineCount)), d.scrollTop < c && (x = Math.max(x, d.startLineNumber), k = Math.min(k, d.topPaddingLineCount)));
      const I = Math.min(a, x - k + g - 1), K = (c - n) / p;
      let B;
      return c >= e.paddingTop ? B = (t - x + k + K) * f / u : B = c / e.paddingTop * (k + K) * f / u, new Vg(c, h, !0, v, B, _, k, x, I);
    }
  }
}
const sv = class sv {
  constructor(e) {
    this.dy = e;
  }
  onContentChanged() {
    this.dy = -1;
  }
  onTokensChanged() {
    this.dy = -1;
  }
};
sv.INVALID = new sv(-1);
let D1 = sv;
class sM {
  constructor(e, t, i) {
    this.renderedLayout = e, this._imageData = t, this._renderedLines = new K5({
      createLine: () => D1.INVALID
    }), this._renderedLines._set(e.startLineNumber, i);
  }
  /**
   * Check if the current RenderData matches accurately the new desired layout and no painting is needed.
   */
  linesEquals(e) {
    if (!this.scrollEquals(e))
      return !1;
    const i = this._renderedLines._get().lines;
    for (let n = 0, o = i.length; n < o; n++)
      if (i[n].dy === -1)
        return !1;
    return !0;
  }
  /**
   * Check if the current RenderData matches the new layout's scroll position
   */
  scrollEquals(e) {
    return this.renderedLayout.startLineNumber === e.startLineNumber && this.renderedLayout.endLineNumber === e.endLineNumber;
  }
  _get() {
    const e = this._renderedLines._get();
    return {
      imageData: this._imageData,
      rendLineNumberStart: e.rendLineNumberStart,
      lines: e.lines
    };
  }
  onLinesChanged(e, t) {
    return this._renderedLines.onLinesChanged(e, t);
  }
  onLinesDeleted(e, t) {
    this._renderedLines.onLinesDeleted(e, t);
  }
  onLinesInserted(e, t) {
    this._renderedLines.onLinesInserted(e, t);
  }
  onTokensChanged(e) {
    return this._renderedLines.onTokensChanged(e);
  }
}
class DI {
  constructor(e, t, i, n) {
    this._backgroundFillData = DI._createBackgroundFillData(t, i, n), this._buffers = [
      e.createImageData(t, i),
      e.createImageData(t, i)
    ], this._lastUsedBuffer = 0;
  }
  getBuffer() {
    this._lastUsedBuffer = 1 - this._lastUsedBuffer;
    const e = this._buffers[this._lastUsedBuffer];
    return e.data.set(this._backgroundFillData), e;
  }
  static _createBackgroundFillData(e, t, i) {
    const n = i.r, o = i.g, r = i.b, a = i.a, l = new Uint8ClampedArray(e * t * 4);
    let c = 0;
    for (let h = 0; h < t; h++)
      for (let d = 0; d < e; d++)
        l[c] = n, l[c + 1] = o, l[c + 2] = r, l[c + 3] = a, c += 4;
    return l;
  }
}
class Ym {
  static compute(e, t, i) {
    if (e.renderMinimap === 0 || !e.isSampling)
      return [null, []];
    const { minimapLineCount: n } = Mu.computeContainedMinimapLineCount({
      viewLineCount: t,
      scrollBeyondLastLine: e.scrollBeyondLastLine,
      paddingTop: e.paddingTop,
      paddingBottom: e.paddingBottom,
      height: e.editorHeight,
      lineHeight: e.lineHeight,
      pixelRatio: e.pixelRatio
    }), o = t / n, r = o / 2;
    if (!i || i.minimapLines.length === 0) {
      const _ = [];
      if (_[0] = 1, n > 1) {
        for (let b = 0, C = n - 1; b < C; b++)
          _[b] = Math.round(b * o + r);
        _[n - 1] = t;
      }
      return [new Ym(o, _), []];
    }
    const a = i.minimapLines, l = a.length, c = [];
    let h = 0, d = 0, u = 1;
    const f = 10;
    let g = [], p = null;
    for (let _ = 0; _ < n; _++) {
      const b = Math.max(u, Math.round(_ * o)), C = Math.max(b, Math.round((_ + 1) * o));
      for (; h < l && a[h] < b; ) {
        if (g.length < f) {
          const v = h + 1 + d;
          p && p.type === "deleted" && p._oldIndex === h - 1 ? p.deleteToLineNumber++ : (p = { type: "deleted", _oldIndex: h, deleteFromLineNumber: v, deleteToLineNumber: v }, g.push(p)), d--;
        }
        h++;
      }
      let w;
      if (h < l && a[h] <= C)
        w = a[h], h++;
      else if (_ === 0 ? w = 1 : _ + 1 === n ? w = t : w = Math.round(_ * o + r), g.length < f) {
        const v = h + 1 + d;
        p && p.type === "inserted" && p._i === _ - 1 ? p.insertToLineNumber++ : (p = { type: "inserted", _i: _, insertFromLineNumber: v, insertToLineNumber: v }, g.push(p)), d++;
      }
      c[_] = w, u = w;
    }
    if (g.length < f)
      for (; h < l; ) {
        const _ = h + 1 + d;
        p && p.type === "deleted" && p._oldIndex === h - 1 ? p.deleteToLineNumber++ : (p = { type: "deleted", _oldIndex: h, deleteFromLineNumber: _, deleteToLineNumber: _ }, g.push(p)), d--, h++;
      }
    else
      g = [{ type: "flush" }];
    return [new Ym(o, c), g];
  }
  constructor(e, t) {
    this.samplingRatio = e, this.minimapLines = t;
  }
  modelLineToMinimapLine(e) {
    return Math.min(this.minimapLines.length, Math.max(1, Math.round(e / this.samplingRatio)));
  }
  /**
   * Will return null if the model line ranges are not intersecting with a sampled model line.
   */
  modelLineRangeToMinimapLineRange(e, t) {
    let i = this.modelLineToMinimapLine(e) - 1;
    for (; i > 0 && this.minimapLines[i - 1] >= e; )
      i--;
    let n = this.modelLineToMinimapLine(t) - 1;
    for (; n + 1 < this.minimapLines.length && this.minimapLines[n + 1] <= t; )
      n++;
    if (i === n) {
      const o = this.minimapLines[i];
      if (o < e || o > t)
        return null;
    }
    return [i + 1, n + 1];
  }
  /**
   * Will always return a range, even if it is not intersecting with a sampled model line.
   */
  decorationLineRangeToMinimapLineRange(e, t) {
    let i = this.modelLineToMinimapLine(e), n = this.modelLineToMinimapLine(t);
    return e !== t && n === i && (n === this.minimapLines.length ? i > 1 && i-- : n++), [i, n];
  }
  onLinesDeleted(e) {
    const t = e.toLineNumber - e.fromLineNumber + 1;
    let i = this.minimapLines.length, n = 0;
    for (let o = this.minimapLines.length - 1; o >= 0 && !(this.minimapLines[o] < e.fromLineNumber); o--)
      this.minimapLines[o] <= e.toLineNumber ? (this.minimapLines[o] = Math.max(1, e.fromLineNumber - 1), i = Math.min(i, o), n = Math.max(n, o)) : this.minimapLines[o] -= t;
    return [i, n];
  }
  onLinesInserted(e) {
    const t = e.toLineNumber - e.fromLineNumber + 1;
    for (let i = this.minimapLines.length - 1; i >= 0 && !(this.minimapLines[i] < e.fromLineNumber); i--)
      this.minimapLines[i] += t;
  }
}
class Pq extends rs {
  constructor(e) {
    super(e), this._sectionHeaderCache = new Mf(10, 1.5), this.tokensColorTracker = x1.getInstance(), this._selections = [], this._minimapSelections = null, this.options = new Fu(this._context.configuration, this._context.theme, this.tokensColorTracker);
    const [t] = Ym.compute(this.options, this._context.viewModel.getLineCount(), null);
    this._samplingState = t, this._shouldCheckSampling = !1, this._actual = new nu(e.theme, this);
  }
  dispose() {
    this._actual.dispose(), super.dispose();
  }
  getDomNode() {
    return this._actual.getDomNode();
  }
  _onOptionsMaybeChanged() {
    const e = new Fu(this._context.configuration, this._context.theme, this.tokensColorTracker);
    return this.options.equals(e) ? !1 : (this.options = e, this._recreateLineSampling(), this._actual.onDidChangeOptions(), !0);
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    return this._onOptionsMaybeChanged();
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, this._minimapSelections = null, this._actual.onSelectionChanged();
  }
  onDecorationsChanged(e) {
    return e.affectsMinimap ? this._actual.onDecorationsChanged() : !1;
  }
  onFlushed(e) {
    return this._samplingState && (this._shouldCheckSampling = !0), this._actual.onFlushed();
  }
  onLinesChanged(e) {
    if (this._samplingState) {
      const t = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1);
      return t ? this._actual.onLinesChanged(t[0], t[1] - t[0] + 1) : !1;
    } else
      return this._actual.onLinesChanged(e.fromLineNumber, e.count);
  }
  onLinesDeleted(e) {
    if (this._samplingState) {
      const [t, i] = this._samplingState.onLinesDeleted(e);
      return t <= i && this._actual.onLinesChanged(t + 1, i - t + 1), this._shouldCheckSampling = !0, !0;
    } else
      return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
  }
  onLinesInserted(e) {
    return this._samplingState ? (this._samplingState.onLinesInserted(e), this._shouldCheckSampling = !0, !0) : this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);
  }
  onScrollChanged(e) {
    return this._actual.onScrollChanged();
  }
  onThemeChanged(e) {
    return this._actual.onThemeChanged(), this._onOptionsMaybeChanged(), !0;
  }
  onTokensChanged(e) {
    if (this._samplingState) {
      const t = [];
      for (const i of e.ranges) {
        const n = this._samplingState.modelLineRangeToMinimapLineRange(i.fromLineNumber, i.toLineNumber);
        n && t.push({ fromLineNumber: n[0], toLineNumber: n[1] });
      }
      return t.length ? this._actual.onTokensChanged(t) : !1;
    } else
      return this._actual.onTokensChanged(e.ranges);
  }
  onTokensColorsChanged(e) {
    return this._onOptionsMaybeChanged(), this._actual.onTokensColorsChanged();
  }
  onZonesChanged(e) {
    return this._actual.onZonesChanged();
  }
  // --- end event handlers
  prepareRender(e) {
    this._shouldCheckSampling && (this._shouldCheckSampling = !1, this._recreateLineSampling());
  }
  render(e) {
    let t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber;
    this._samplingState && (t = this._samplingState.modelLineToMinimapLine(t), i = this._samplingState.modelLineToMinimapLine(i));
    const n = {
      viewportContainsWhitespaceGaps: e.viewportData.whitespaceViewportData.length > 0,
      scrollWidth: e.scrollWidth,
      scrollHeight: e.scrollHeight,
      viewportStartLineNumber: t,
      viewportEndLineNumber: i,
      viewportStartLineNumberVerticalOffset: e.getVerticalOffsetForLineNumber(t),
      scrollTop: e.scrollTop,
      scrollLeft: e.scrollLeft,
      viewportWidth: e.viewportWidth,
      viewportHeight: e.viewportHeight
    };
    this._actual.render(n);
  }
  //#region IMinimapModel
  _recreateLineSampling() {
    this._minimapSelections = null;
    const e = !!this._samplingState, [t, i] = Ym.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);
    if (this._samplingState = t, e && this._samplingState)
      for (const n of i)
        switch (n.type) {
          case "deleted":
            this._actual.onLinesDeleted(n.deleteFromLineNumber, n.deleteToLineNumber);
            break;
          case "inserted":
            this._actual.onLinesInserted(n.insertFromLineNumber, n.insertToLineNumber);
            break;
          case "flush":
            this._actual.onFlushed();
            break;
        }
  }
  getLineCount() {
    return this._samplingState ? this._samplingState.minimapLines.length : this._context.viewModel.getLineCount();
  }
  getRealLineCount() {
    return this._context.viewModel.getLineCount();
  }
  getLineContent(e) {
    return this._samplingState ? this._context.viewModel.getLineContent(this._samplingState.minimapLines[e - 1]) : this._context.viewModel.getLineContent(e);
  }
  getLineMaxColumn(e) {
    return this._samplingState ? this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[e - 1]) : this._context.viewModel.getLineMaxColumn(e);
  }
  getMinimapLinesRenderingData(e, t, i) {
    if (this._samplingState) {
      const n = [];
      for (let o = 0, r = t - e + 1; o < r; o++)
        i[o] ? n[o] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[e + o - 1]) : n[o] = null;
      return n;
    }
    return this._context.viewModel.getMinimapLinesRenderingData(e, t, i).data;
  }
  getSelections() {
    if (this._minimapSelections === null)
      if (this._samplingState) {
        this._minimapSelections = [];
        for (const e of this._selections) {
          const [t, i] = this._samplingState.decorationLineRangeToMinimapLineRange(e.startLineNumber, e.endLineNumber);
          this._minimapSelections.push(new Ue(t, e.startColumn, i, e.endColumn));
        }
      } else
        this._minimapSelections = this._selections;
    return this._minimapSelections;
  }
  getMinimapDecorationsInViewport(e, t) {
    const i = this._getMinimapDecorationsInViewport(e, t).filter((n) => {
      var o;
      return !((o = n.options.minimap) != null && o.sectionHeaderStyle);
    });
    if (this._samplingState) {
      const n = [];
      for (const o of i) {
        if (!o.options.minimap)
          continue;
        const r = o.range, a = this._samplingState.modelLineToMinimapLine(r.startLineNumber), l = this._samplingState.modelLineToMinimapLine(r.endLineNumber);
        n.push(new eF(new T(a, r.startColumn, l, r.endColumn), o.options));
      }
      return n;
    }
    return i;
  }
  getSectionHeaderDecorationsInViewport(e, t) {
    const i = this.options.minimapLineHeight, o = this.options.sectionHeaderFontSize / i;
    return e = Math.floor(Math.max(1, e - o)), this._getMinimapDecorationsInViewport(e, t).filter((r) => {
      var a;
      return !!((a = r.options.minimap) != null && a.sectionHeaderStyle);
    });
  }
  _getMinimapDecorationsInViewport(e, t) {
    let i;
    if (this._samplingState) {
      const n = this._samplingState.minimapLines[e - 1], o = this._samplingState.minimapLines[t - 1];
      i = new T(n, 1, o, this._context.viewModel.getLineMaxColumn(o));
    } else
      i = new T(e, 1, t, this._context.viewModel.getLineMaxColumn(t));
    return this._context.viewModel.getMinimapDecorationsInRange(i);
  }
  getSectionHeaderText(e, t) {
    var r;
    const i = (r = e.options.minimap) == null ? void 0 : r.sectionHeaderText;
    if (!i)
      return null;
    const n = this._sectionHeaderCache.get(i);
    if (n)
      return n;
    const o = t(i);
    return this._sectionHeaderCache.set(i, o), o;
  }
  getOptions() {
    return this._context.viewModel.model.getOptions();
  }
  revealLineNumber(e) {
    this._samplingState && (e = this._samplingState.minimapLines[e - 1]), this._context.viewModel.revealRange(
      "mouse",
      !1,
      new T(e, 1, e, 1),
      1,
      0
      /* ScrollType.Smooth */
    );
  }
  setScrollTop(e) {
    this._context.viewModel.viewLayout.setScrollPosition(
      {
        scrollTop: e
      },
      1
      /* ScrollType.Immediate */
    );
  }
}
class nu extends U {
  constructor(e, t) {
    super(), this._renderDecorations = !1, this._gestureInProgress = !1, this._theme = e, this._model = t, this._lastRenderData = null, this._buffers = null, this._selectionColor = this._theme.getColor(wT), this._domNode = st(document.createElement("div")), Go.write(
      this._domNode,
      9
      /* PartFingerprint.Minimap */
    ), this._domNode.setClassName(this._getMinimapDomNodeClassName()), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._shadow = st(document.createElement("div")), this._shadow.setClassName("minimap-shadow-hidden"), this._domNode.appendChild(this._shadow), this._canvas = st(document.createElement("canvas")), this._canvas.setPosition("absolute"), this._canvas.setLeft(0), this._domNode.appendChild(this._canvas), this._decorationsCanvas = st(document.createElement("canvas")), this._decorationsCanvas.setPosition("absolute"), this._decorationsCanvas.setClassName("minimap-decorations-layer"), this._decorationsCanvas.setLeft(0), this._domNode.appendChild(this._decorationsCanvas), this._slider = st(document.createElement("div")), this._slider.setPosition("absolute"), this._slider.setClassName("minimap-slider"), this._slider.setLayerHinting(!0), this._slider.setContain("strict"), this._domNode.appendChild(this._slider), this._sliderHorizontal = st(document.createElement("div")), this._sliderHorizontal.setPosition("absolute"), this._sliderHorizontal.setClassName("minimap-slider-horizontal"), this._slider.appendChild(this._sliderHorizontal), this._applyLayout(), this._pointerDownListener = Zt(this._domNode.domNode, X.POINTER_DOWN, (i) => {
      if (i.preventDefault(), this._model.options.renderMinimap === 0 || !this._lastRenderData)
        return;
      if (this._model.options.size !== "proportional") {
        if (i.button === 0 && this._lastRenderData) {
          const c = ui(this._slider.domNode), h = c.top + c.height / 2;
          this._startSliderDragging(i, h, this._lastRenderData.renderedLayout);
        }
        return;
      }
      const o = this._model.options.minimapLineHeight, r = this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight * i.offsetY;
      let l = Math.floor(r / o) + this._lastRenderData.renderedLayout.startLineNumber - this._lastRenderData.renderedLayout.topPaddingLineCount;
      l = Math.min(l, this._model.getLineCount()), this._model.revealLineNumber(l);
    }), this._sliderPointerMoveMonitor = new Af(), this._sliderPointerDownListener = Zt(this._slider.domNode, X.POINTER_DOWN, (i) => {
      i.preventDefault(), i.stopPropagation(), i.button === 0 && this._lastRenderData && this._startSliderDragging(i, i.pageY, this._lastRenderData.renderedLayout);
    }), this._gestureDisposable = ln.addTarget(this._domNode.domNode), this._sliderTouchStartListener = z(this._domNode.domNode, vt.Start, (i) => {
      i.preventDefault(), i.stopPropagation(), this._lastRenderData && (this._slider.toggleClassName("active", !0), this._gestureInProgress = !0, this.scrollDueToTouchEvent(i));
    }, { passive: !1 }), this._sliderTouchMoveListener = z(this._domNode.domNode, vt.Change, (i) => {
      i.preventDefault(), i.stopPropagation(), this._lastRenderData && this._gestureInProgress && this.scrollDueToTouchEvent(i);
    }, { passive: !1 }), this._sliderTouchEndListener = Zt(this._domNode.domNode, vt.End, (i) => {
      i.preventDefault(), i.stopPropagation(), this._gestureInProgress = !1, this._slider.toggleClassName("active", !1);
    });
  }
  _startSliderDragging(e, t, i) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const n = e.pageX;
    this._slider.toggleClassName("active", !0);
    const o = (r, a) => {
      const l = ui(this._domNode.domNode), c = Math.min(Math.abs(a - n), Math.abs(a - l.left), Math.abs(a - l.left - l.width));
      if (es && c > Rq) {
        this._model.setScrollTop(i.scrollTop);
        return;
      }
      const h = r - t;
      this._model.setScrollTop(i.getDesiredScrollTopFromDelta(h));
    };
    e.pageY !== t && o(e.pageY, n), this._sliderPointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (r) => o(r.pageY, r.pageX), () => {
      this._slider.toggleClassName("active", !1);
    });
  }
  scrollDueToTouchEvent(e) {
    const t = this._domNode.domNode.getBoundingClientRect().top, i = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(e.pageY - t);
    this._model.setScrollTop(i);
  }
  dispose() {
    this._pointerDownListener.dispose(), this._sliderPointerMoveMonitor.dispose(), this._sliderPointerDownListener.dispose(), this._gestureDisposable.dispose(), this._sliderTouchStartListener.dispose(), this._sliderTouchMoveListener.dispose(), this._sliderTouchEndListener.dispose(), super.dispose();
  }
  _getMinimapDomNodeClassName() {
    const e = ["minimap"];
    return this._model.options.showSlider === "always" ? e.push("slider-always") : e.push("slider-mouseover"), this._model.options.autohide && e.push("autohide"), e.join(" ");
  }
  getDomNode() {
    return this._domNode;
  }
  _applyLayout() {
    this._domNode.setLeft(this._model.options.minimapLeft), this._domNode.setWidth(this._model.options.minimapWidth), this._domNode.setHeight(this._model.options.minimapHeight), this._shadow.setHeight(this._model.options.minimapHeight), this._canvas.setWidth(this._model.options.canvasOuterWidth), this._canvas.setHeight(this._model.options.canvasOuterHeight), this._canvas.domNode.width = this._model.options.canvasInnerWidth, this._canvas.domNode.height = this._model.options.canvasInnerHeight, this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth), this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight), this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth, this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight, this._slider.setWidth(this._model.options.minimapWidth);
  }
  _getBuffer() {
    return this._buffers || this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0 && (this._buffers = new DI(this._canvas.domNode.getContext("2d"), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor)), this._buffers ? this._buffers.getBuffer() : null;
  }
  // ---- begin view event handlers
  onDidChangeOptions() {
    this._lastRenderData = null, this._buffers = null, this._applyLayout(), this._domNode.setClassName(this._getMinimapDomNodeClassName());
  }
  onSelectionChanged() {
    return this._renderDecorations = !0, !0;
  }
  onDecorationsChanged() {
    return this._renderDecorations = !0, !0;
  }
  onFlushed() {
    return this._lastRenderData = null, !0;
  }
  onLinesChanged(e, t) {
    return this._lastRenderData ? this._lastRenderData.onLinesChanged(e, t) : !1;
  }
  onLinesDeleted(e, t) {
    var i;
    return (i = this._lastRenderData) == null || i.onLinesDeleted(e, t), !0;
  }
  onLinesInserted(e, t) {
    var i;
    return (i = this._lastRenderData) == null || i.onLinesInserted(e, t), !0;
  }
  onScrollChanged() {
    return this._renderDecorations = !0, !0;
  }
  onThemeChanged() {
    return this._selectionColor = this._theme.getColor(wT), this._renderDecorations = !0, !0;
  }
  onTokensChanged(e) {
    return this._lastRenderData ? this._lastRenderData.onTokensChanged(e) : !1;
  }
  onTokensColorsChanged() {
    return this._lastRenderData = null, this._buffers = null, !0;
  }
  onZonesChanged() {
    return this._lastRenderData = null, !0;
  }
  // --- end event handlers
  render(e) {
    if (this._model.options.renderMinimap === 0) {
      this._shadow.setClassName("minimap-shadow-hidden"), this._sliderHorizontal.setWidth(0), this._sliderHorizontal.setHeight(0);
      return;
    }
    e.scrollLeft + e.viewportWidth >= e.scrollWidth ? this._shadow.setClassName("minimap-shadow-hidden") : this._shadow.setClassName("minimap-shadow-visible");
    const i = Vg.create(this._model.options, e.viewportStartLineNumber, e.viewportEndLineNumber, e.viewportStartLineNumberVerticalOffset, e.viewportHeight, e.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), e.scrollTop, e.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);
    this._slider.setDisplay(i.sliderNeeded ? "block" : "none"), this._slider.setTop(i.sliderTop), this._slider.setHeight(i.sliderHeight), this._sliderHorizontal.setLeft(0), this._sliderHorizontal.setWidth(this._model.options.minimapWidth), this._sliderHorizontal.setTop(0), this._sliderHorizontal.setHeight(i.sliderHeight), this.renderDecorations(i), this._lastRenderData = this.renderLines(i);
  }
  renderDecorations(e) {
    if (this._renderDecorations) {
      this._renderDecorations = !1;
      const t = this._model.getSelections();
      t.sort(T.compareRangesUsingStarts);
      const i = this._model.getMinimapDecorationsInViewport(e.startLineNumber, e.endLineNumber);
      i.sort((u, f) => (u.options.zIndex || 0) - (f.options.zIndex || 0));
      const { canvasInnerWidth: n, canvasInnerHeight: o } = this._model.options, r = this._model.options.minimapLineHeight, a = this._model.options.minimapCharWidth, l = this._model.getOptions().tabSize, c = this._decorationsCanvas.domNode.getContext("2d");
      c.clearRect(0, 0, n, o);
      const h = new oM(e.startLineNumber, e.endLineNumber, !1);
      this._renderSelectionLineHighlights(c, t, h, e, r), this._renderDecorationsLineHighlights(c, i, h, e, r);
      const d = new oM(e.startLineNumber, e.endLineNumber, null);
      this._renderSelectionsHighlights(c, t, d, e, r, l, a, n), this._renderDecorationsHighlights(c, i, d, e, r, l, a, n), this._renderSectionHeaders(e);
    }
  }
  _renderSelectionLineHighlights(e, t, i, n, o) {
    if (!this._selectionColor || this._selectionColor.isTransparent())
      return;
    e.fillStyle = this._selectionColor.transparent(0.5).toString();
    let r = 0, a = 0;
    for (const l of t) {
      const c = n.intersectWithViewport(l);
      if (!c)
        continue;
      const [h, d] = c;
      for (let g = h; g <= d; g++)
        i.set(g, !0);
      const u = n.getYForLineNumber(h, o), f = n.getYForLineNumber(d, o);
      a >= u || (a > r && e.fillRect(ur, r, e.canvas.width, a - r), r = u), a = f;
    }
    a > r && e.fillRect(ur, r, e.canvas.width, a - r);
  }
  _renderDecorationsLineHighlights(e, t, i, n, o) {
    const r = /* @__PURE__ */ new Map();
    for (let a = t.length - 1; a >= 0; a--) {
      const l = t[a], c = l.options.minimap;
      if (!c || c.position !== 1)
        continue;
      const h = n.intersectWithViewport(l.range);
      if (!h)
        continue;
      const [d, u] = h, f = c.getColor(this._theme.value);
      if (!f || f.isTransparent())
        continue;
      let g = r.get(f.toString());
      g || (g = f.transparent(0.5).toString(), r.set(f.toString(), g)), e.fillStyle = g;
      for (let p = d; p <= u; p++) {
        if (i.has(p))
          continue;
        i.set(p, !0);
        const _ = n.getYForLineNumber(d, o);
        e.fillRect(ur, _, e.canvas.width, o);
      }
    }
  }
  _renderSelectionsHighlights(e, t, i, n, o, r, a, l) {
    if (!(!this._selectionColor || this._selectionColor.isTransparent()))
      for (const c of t) {
        const h = n.intersectWithViewport(c);
        if (!h)
          continue;
        const [d, u] = h;
        for (let f = d; f <= u; f++)
          this.renderDecorationOnLine(e, i, c, this._selectionColor, n, f, o, o, r, a, l);
      }
  }
  _renderDecorationsHighlights(e, t, i, n, o, r, a, l) {
    for (const c of t) {
      const h = c.options.minimap;
      if (!h)
        continue;
      const d = n.intersectWithViewport(c.range);
      if (!d)
        continue;
      const [u, f] = d, g = h.getColor(this._theme.value);
      if (!(!g || g.isTransparent()))
        for (let p = u; p <= f; p++)
          switch (h.position) {
            case 1:
              this.renderDecorationOnLine(e, i, c.range, g, n, p, o, o, r, a, l);
              continue;
            case 2: {
              const _ = n.getYForLineNumber(p, o);
              this.renderDecoration(e, g, 2, _, Aq, o);
              continue;
            }
          }
    }
  }
  renderDecorationOnLine(e, t, i, n, o, r, a, l, c, h, d) {
    const u = o.getYForLineNumber(r, l);
    if (u + a < 0 || u > this._model.options.canvasInnerHeight)
      return;
    const { startLineNumber: f, endLineNumber: g } = i, p = f === r ? i.startColumn : 1, _ = g === r ? i.endColumn : this._model.getLineMaxColumn(r), b = this.getXOffsetForPosition(t, r, p, c, h, d), C = this.getXOffsetForPosition(t, r, _, c, h, d);
    this.renderDecoration(e, n, b, u, C - b, a);
  }
  getXOffsetForPosition(e, t, i, n, o, r) {
    if (i === 1)
      return ur;
    if ((i - 1) * o >= r)
      return r;
    let l = e.get(t);
    if (!l) {
      const c = this._model.getLineContent(t);
      l = [ur];
      let h = ur;
      for (let d = 1; d < c.length + 1; d++) {
        const u = c.charCodeAt(d - 1), f = u === 9 ? n * o : jl(u) ? 2 * o : o, g = h + f;
        if (g >= r) {
          l[d] = r;
          break;
        }
        l[d] = g, h = g;
      }
      e.set(t, l);
    }
    return i - 1 < l.length ? l[i - 1] : r;
  }
  renderDecoration(e, t, i, n, o, r) {
    e.fillStyle = t && t.toString() || "", e.fillRect(i, n, o, r);
  }
  _renderSectionHeaders(e) {
    var p;
    const t = this._model.options.minimapLineHeight, i = this._model.options.sectionHeaderFontSize, n = this._model.options.sectionHeaderLetterSpacing, o = i * 1.5, { canvasInnerWidth: r } = this._model.options, a = this._model.options.backgroundColor, l = `rgb(${a.r} ${a.g} ${a.b} / .7)`, c = this._model.options.sectionHeaderFontColor, h = `rgb(${c.r} ${c.g} ${c.b})`, d = h, u = this._decorationsCanvas.domNode.getContext("2d");
    u.letterSpacing = n + "px", u.font = "500 " + i + "px " + this._model.options.sectionHeaderFontFamily, u.strokeStyle = d, u.lineWidth = 0.2;
    const f = this._model.getSectionHeaderDecorationsInViewport(e.startLineNumber, e.endLineNumber);
    f.sort((_, b) => _.range.startLineNumber - b.range.startLineNumber);
    const g = nu._fitSectionHeader.bind(null, u, r - ur);
    for (const _ of f) {
      const b = e.getYForLineNumber(_.range.startLineNumber, t) + i, C = b - i, w = C + 2, v = this._model.getSectionHeaderText(_, g);
      nu._renderSectionLabel(u, v, ((p = _.options.minimap) == null ? void 0 : p.sectionHeaderStyle) === 2, l, h, r, C, o, b, w);
    }
  }
  static _fitSectionHeader(e, t, i) {
    if (!i)
      return i;
    const n = "…", o = e.measureText(i).width, r = e.measureText(n).width;
    if (o <= t || o <= r)
      return i;
    const a = i.length, l = o / i.length, c = Math.floor((t - r) / l) - 1;
    let h = Math.ceil(c / 2);
    for (; h > 0 && /\s/.test(i[h - 1]); )
      --h;
    return i.substring(0, h) + n + i.substring(a - (c - h));
  }
  static _renderSectionLabel(e, t, i, n, o, r, a, l, c, h) {
    t && (e.fillStyle = n, e.fillRect(0, a, r, l), e.fillStyle = o, e.fillText(t, ur, c)), i && (e.beginPath(), e.moveTo(0, h), e.lineTo(r, h), e.closePath(), e.stroke());
  }
  renderLines(e) {
    const t = e.startLineNumber, i = e.endLineNumber, n = this._model.options.minimapLineHeight;
    if (this._lastRenderData && this._lastRenderData.linesEquals(e)) {
      const q = this._lastRenderData._get();
      return new sM(e, q.imageData, q.lines);
    }
    const o = this._getBuffer();
    if (!o)
      return null;
    const [r, a, l] = nu._renderUntouchedLines(o, e.topPaddingLineCount, t, i, n, this._lastRenderData), c = this._model.getMinimapLinesRenderingData(t, i, l), h = this._model.getOptions().tabSize, d = this._model.options.defaultBackgroundColor, u = this._model.options.backgroundColor, f = this._model.options.foregroundAlpha, g = this._model.tokensColorTracker, p = g.backgroundIsLight(), _ = this._model.options.renderMinimap, b = this._model.options.charRenderer(), C = this._model.options.fontScale, w = this._model.options.minimapCharWidth, S = (_ === 1 ? 2 : 3) * C, L = n > S ? Math.floor((n - S) / 2) : 0, k = u.a / 255, x = new Wa(Math.round((u.r - d.r) * k + d.r), Math.round((u.g - d.g) * k + d.g), Math.round((u.b - d.b) * k + d.b), 255);
    let I = e.topPaddingLineCount * n;
    const K = [];
    for (let q = 0, J = i - t + 1; q < J; q++)
      l[q] && nu._renderLine(o, x, u.a, p, _, w, g, f, b, I, L, h, c[q], C, n), K[q] = new D1(I), I += n;
    const B = r === -1 ? 0 : r, H = (a === -1 ? o.height : a) - B;
    return this._canvas.domNode.getContext("2d").putImageData(o, 0, 0, 0, B, o.width, H), new sM(e, o, K);
  }
  static _renderUntouchedLines(e, t, i, n, o, r) {
    const a = [];
    if (!r) {
      for (let I = 0, K = n - i + 1; I < K; I++)
        a[I] = !0;
      return [-1, -1, a];
    }
    const l = r._get(), c = l.imageData.data, h = l.rendLineNumberStart, d = l.lines, u = d.length, f = e.width, g = e.data, p = (n - i + 1) * o * f * 4;
    let _ = -1, b = -1, C = -1, w = -1, v = -1, S = -1, L = t * o;
    for (let I = i; I <= n; I++) {
      const K = I - i, B = I - h, W = B >= 0 && B < u ? d[B].dy : -1;
      if (W === -1) {
        a[K] = !0, L += o;
        continue;
      }
      const H = W * f * 4, P = (W + o) * f * 4, q = L * f * 4, J = (L + o) * f * 4;
      w === H && S === q ? (w = P, S = J) : (C !== -1 && (g.set(c.subarray(C, w), v), _ === -1 && C === 0 && C === v && (_ = w), b === -1 && w === p && C === v && (b = C)), C = H, w = P, v = q, S = J), a[K] = !1, L += o;
    }
    C !== -1 && (g.set(c.subarray(C, w), v), _ === -1 && C === 0 && C === v && (_ = w), b === -1 && w === p && C === v && (b = C));
    const k = _ === -1 ? -1 : _ / (f * 4), x = b === -1 ? -1 : b / (f * 4);
    return [k, x, a];
  }
  static _renderLine(e, t, i, n, o, r, a, l, c, h, d, u, f, g, p) {
    const _ = f.content, b = f.tokens, C = e.width - r, w = p === 1;
    let v = ur, S = 0, L = 0;
    for (let k = 0, x = b.getCount(); k < x; k++) {
      const I = b.getEndOffset(k), K = b.getForeground(k), B = a.getColor(K);
      for (; S < I; S++) {
        if (v > C)
          return;
        const W = _.charCodeAt(S);
        if (W === 9) {
          const H = u - (S + L) % u;
          L += H - 1, v += H * r;
        } else if (W === 32)
          v += r;
        else {
          const H = jl(W) ? 2 : 1;
          for (let P = 0; P < H; P++)
            if (o === 2 ? c.blockRenderChar(e, v, h + d, B, l, t, i, w) : c.renderChar(e, v, h + d, W, B, l, t, i, g, n, w), v += r, v > C)
              return;
        }
      }
    }
  }
}
class oM {
  constructor(e, t, i) {
    this._startLineNumber = e, this._endLineNumber = t, this._defaultValue = i, this._values = [];
    for (let n = 0, o = this._endLineNumber - this._startLineNumber + 1; n < o; n++)
      this._values[n] = i;
  }
  has(e) {
    return this.get(e) !== this._defaultValue;
  }
  set(e, t) {
    e < this._startLineNumber || e > this._endLineNumber || (this._values[e - this._startLineNumber] = t);
  }
  get(e) {
    return e < this._startLineNumber || e > this._endLineNumber ? this._defaultValue : this._values[e - this._startLineNumber];
  }
}
class Oq extends rs {
  constructor(e, t) {
    super(e), this._viewDomNode = t;
    const n = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._widgets = {}, this._verticalScrollbarWidth = n.verticalScrollbarWidth, this._minimapWidth = n.minimap.minimapWidth, this._horizontalScrollbarHeight = n.horizontalScrollbarHeight, this._editorHeight = n.height, this._editorWidth = n.width, this._viewDomNodeRect = { top: 0, left: 0, width: 0, height: 0 }, this._domNode = st(document.createElement("div")), Go.write(
      this._domNode,
      4
      /* PartFingerprint.OverlayWidgets */
    ), this._domNode.setClassName("overlayWidgets"), this.overflowingOverlayWidgetsDomNode = st(document.createElement("div")), Go.write(
      this.overflowingOverlayWidgetsDomNode,
      5
      /* PartFingerprint.OverflowingOverlayWidgets */
    ), this.overflowingOverlayWidgetsDomNode.setClassName("overflowingOverlayWidgets");
  }
  dispose() {
    super.dispose(), this._widgets = {};
  }
  getDomNode() {
    return this._domNode;
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._verticalScrollbarWidth = i.verticalScrollbarWidth, this._minimapWidth = i.minimap.minimapWidth, this._horizontalScrollbarHeight = i.horizontalScrollbarHeight, this._editorHeight = i.height, this._editorWidth = i.width, !0;
  }
  // ---- end view event handlers
  addWidget(e) {
    const t = st(e.getDomNode());
    this._widgets[e.getId()] = {
      widget: e,
      preference: null,
      domNode: t
    }, t.setPosition("absolute"), t.setAttribute("widgetId", e.getId()), e.allowEditorOverflow ? this.overflowingOverlayWidgetsDomNode.appendChild(t) : this._domNode.appendChild(t), this.setShouldRender(), this._updateMaxMinWidth();
  }
  setWidgetPosition(e, t) {
    const i = this._widgets[e.getId()], n = t ? t.preference : null, o = t == null ? void 0 : t.stackOridinal;
    return i.preference === n && i.stack === o ? (this._updateMaxMinWidth(), !1) : (i.preference = n, i.stack = o, this.setShouldRender(), this._updateMaxMinWidth(), !0);
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets.hasOwnProperty(t)) {
      const n = this._widgets[t].domNode.domNode;
      delete this._widgets[t], n.remove(), this.setShouldRender(), this._updateMaxMinWidth();
    }
  }
  _updateMaxMinWidth() {
    var i, n;
    let e = 0;
    const t = Object.keys(this._widgets);
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], c = (n = (i = this._widgets[a].widget).getMinContentWidthInPx) == null ? void 0 : n.call(i);
      typeof c < "u" && (e = Math.max(e, c));
    }
    this._context.viewLayout.setOverlayWidgetsMinWidth(e);
  }
  _renderWidget(e, t) {
    const i = e.domNode;
    if (e.preference === null) {
      i.setTop("");
      return;
    }
    const n = 2 * this._verticalScrollbarWidth + this._minimapWidth;
    if (e.preference === 0 || e.preference === 1) {
      if (e.preference === 1) {
        const o = i.domNode.clientHeight;
        i.setTop(this._editorHeight - o - 2 * this._horizontalScrollbarHeight);
      } else
        i.setTop(0);
      e.stack !== void 0 ? (i.setTop(t[e.preference]), t[e.preference] += i.domNode.clientWidth) : i.setRight(n);
    } else if (e.preference === 2)
      i.domNode.style.right = "50%", e.stack !== void 0 ? (i.setTop(t[
        2
        /* OverlayWidgetPositionPreference.TOP_CENTER */
      ]), t[
        2
        /* OverlayWidgetPositionPreference.TOP_CENTER */
      ] += i.domNode.clientHeight) : i.setTop(0);
    else {
      const { top: o, left: r } = e.preference;
      if (this._context.configuration.options.get(
        42
        /* EditorOption.fixedOverflowWidgets */
      ) && e.widget.allowEditorOverflow) {
        const l = this._viewDomNodeRect;
        i.setTop(o + l.top), i.setLeft(r + l.left), i.setPosition("fixed");
      } else
        i.setTop(o), i.setLeft(r), i.setPosition("absolute");
    }
  }
  prepareRender(e) {
    this._viewDomNodeRect = ui(this._viewDomNode.domNode);
  }
  render(e) {
    this._domNode.setWidth(this._editorWidth);
    const t = Object.keys(this._widgets), i = Array.from({ length: 3 }, () => 0);
    t.sort((n, o) => (this._widgets[n].stack || 0) - (this._widgets[o].stack || 0));
    for (let n = 0, o = t.length; n < o; n++) {
      const r = t[n];
      this._renderWidget(this._widgets[r], i);
    }
  }
}
class Fq {
  constructor(e, t) {
    const i = e.options;
    this.lineHeight = i.get(
      67
      /* EditorOption.lineHeight */
    ), this.pixelRatio = i.get(
      144
      /* EditorOption.pixelRatio */
    ), this.overviewRulerLanes = i.get(
      83
      /* EditorOption.overviewRulerLanes */
    ), this.renderBorder = i.get(
      82
      /* EditorOption.overviewRulerBorder */
    );
    const n = t.getColor(pK);
    this.borderColor = n ? n.toString() : null, this.hideCursor = i.get(
      59
      /* EditorOption.hideCursorInOverviewRuler */
    );
    const o = t.getColor(Lw);
    this.cursorColorSingle = o ? o.transparent(0.7).toString() : null;
    const r = t.getColor(S5);
    this.cursorColorPrimary = r ? r.transparent(0.7).toString() : null;
    const a = t.getColor(L5);
    this.cursorColorSecondary = a ? a.transparent(0.7).toString() : null, this.themeType = t.type;
    const l = i.get(
      73
      /* EditorOption.minimap */
    ), c = l.enabled, h = l.side, d = t.getColor(_K), u = ii.getDefaultBackground();
    d ? this.backgroundColor = d : c && h === "right" ? this.backgroundColor = u : this.backgroundColor = null;
    const g = i.get(
      146
      /* EditorOption.layoutInfo */
    ).overviewRuler;
    this.top = g.top, this.right = g.right, this.domWidth = g.width, this.domHeight = g.height, this.overviewRulerLanes === 0 ? (this.canvasWidth = 0, this.canvasHeight = 0) : (this.canvasWidth = this.domWidth * this.pixelRatio | 0, this.canvasHeight = this.domHeight * this.pixelRatio | 0);
    const [p, _] = this._initLanes(1, this.canvasWidth, this.overviewRulerLanes);
    this.x = p, this.w = _;
  }
  _initLanes(e, t, i) {
    const n = t - e;
    if (i >= 3) {
      const o = Math.floor(n / 3), r = Math.floor(n / 3), a = n - o - r, l = e, c = l + o, h = l + o + a;
      return [
        [
          0,
          l,
          // Left
          c,
          // Center
          l,
          // Left | Center
          h,
          // Right
          l,
          // Left | Right
          c,
          // Center | Right
          l
          // Left | Center | Right
        ],
        [
          0,
          o,
          // Left
          a,
          // Center
          o + a,
          // Left | Center
          r,
          // Right
          o + a + r,
          // Left | Right
          a + r,
          // Center | Right
          o + a + r
          // Left | Center | Right
        ]
      ];
    } else if (i === 2) {
      const o = Math.floor(n / 2), r = n - o, a = e, l = a + o;
      return [
        [
          0,
          a,
          // Left
          a,
          // Center
          a,
          // Left | Center
          l,
          // Right
          a,
          // Left | Right
          a,
          // Center | Right
          a
          // Left | Center | Right
        ],
        [
          0,
          o,
          // Left
          o,
          // Center
          o,
          // Left | Center
          r,
          // Right
          o + r,
          // Left | Right
          o + r,
          // Center | Right
          o + r
          // Left | Center | Right
        ]
      ];
    } else {
      const o = e, r = n;
      return [
        [
          0,
          o,
          // Left
          o,
          // Center
          o,
          // Left | Center
          o,
          // Right
          o,
          // Left | Right
          o,
          // Center | Right
          o
          // Left | Center | Right
        ],
        [
          0,
          r,
          // Left
          r,
          // Center
          r,
          // Left | Center
          r,
          // Right
          r,
          // Left | Right
          r,
          // Center | Right
          r
          // Left | Center | Right
        ]
      ];
    }
  }
  equals(e) {
    return this.lineHeight === e.lineHeight && this.pixelRatio === e.pixelRatio && this.overviewRulerLanes === e.overviewRulerLanes && this.renderBorder === e.renderBorder && this.borderColor === e.borderColor && this.hideCursor === e.hideCursor && this.cursorColorSingle === e.cursorColorSingle && this.cursorColorPrimary === e.cursorColorPrimary && this.cursorColorSecondary === e.cursorColorSecondary && this.themeType === e.themeType && j.equals(this.backgroundColor, e.backgroundColor) && this.top === e.top && this.right === e.right && this.domWidth === e.domWidth && this.domHeight === e.domHeight && this.canvasWidth === e.canvasWidth && this.canvasHeight === e.canvasHeight;
  }
}
class Bq extends rs {
  constructor(e) {
    super(e), this._actualShouldRender = 0, this._renderedDecorations = [], this._renderedCursorPositions = [], this._domNode = st(document.createElement("canvas")), this._domNode.setClassName("decorationsOverviewRuler"), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(!0), this._domNode.setContain("strict"), this._domNode.setAttribute("aria-hidden", "true"), this._updateSettings(!1), this._tokensColorTrackerListener = ii.onDidChange((t) => {
      t.changedColorMap && this._updateSettings(!0);
    }), this._cursorPositions = [{ position: new F(1, 1), color: this._settings.cursorColorSingle }];
  }
  dispose() {
    super.dispose(), this._tokensColorTrackerListener.dispose();
  }
  _updateSettings(e) {
    const t = new Fq(this._context.configuration, this._context.theme);
    return this._settings && this._settings.equals(t) ? !1 : (this._settings = t, this._domNode.setTop(this._settings.top), this._domNode.setRight(this._settings.right), this._domNode.setWidth(this._settings.domWidth), this._domNode.setHeight(this._settings.domHeight), this._domNode.domNode.width = this._settings.canvasWidth, this._domNode.domNode.height = this._settings.canvasHeight, e && this._render(), !0);
  }
  // ---- begin view event handlers
  _markRenderingIsNeeded() {
    return this._actualShouldRender = 2, !0;
  }
  _markRenderingIsMaybeNeeded() {
    return this._actualShouldRender = 1, !0;
  }
  onConfigurationChanged(e) {
    return this._updateSettings(!1) ? this._markRenderingIsNeeded() : !1;
  }
  onCursorStateChanged(e) {
    this._cursorPositions = [];
    for (let t = 0, i = e.selections.length; t < i; t++) {
      let n = this._settings.cursorColorSingle;
      i > 1 && (n = t === 0 ? this._settings.cursorColorPrimary : this._settings.cursorColorSecondary), this._cursorPositions.push({ position: e.selections[t].getPosition(), color: n });
    }
    return this._cursorPositions.sort((t, i) => F.compare(t.position, i.position)), this._markRenderingIsMaybeNeeded();
  }
  onDecorationsChanged(e) {
    return e.affectsOverviewRuler ? this._markRenderingIsMaybeNeeded() : !1;
  }
  onFlushed(e) {
    return this._markRenderingIsNeeded();
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged ? this._markRenderingIsNeeded() : !1;
  }
  onZonesChanged(e) {
    return this._markRenderingIsNeeded();
  }
  onThemeChanged(e) {
    return this._updateSettings(!1) ? this._markRenderingIsNeeded() : !1;
  }
  // ---- end view event handlers
  getDomNode() {
    return this._domNode.domNode;
  }
  prepareRender(e) {
  }
  render(e) {
    this._render(), this._actualShouldRender = 0;
  }
  _render() {
    const e = this._settings.backgroundColor;
    if (this._settings.overviewRulerLanes === 0) {
      this._domNode.setBackgroundColor(e ? j.Format.CSS.formatHexA(e) : ""), this._domNode.setDisplay("none");
      return;
    }
    const t = this._context.viewModel.getAllOverviewRulerDecorations(this._context.theme);
    if (t.sort(Gm.compareByRenderingProps), this._actualShouldRender === 1 && !Gm.equalsArr(this._renderedDecorations, t) && (this._actualShouldRender = 2), this._actualShouldRender === 1 && !li(this._renderedCursorPositions, this._cursorPositions, (g, p) => g.position.lineNumber === p.position.lineNumber && g.color === p.color) && (this._actualShouldRender = 2), this._actualShouldRender === 1)
      return;
    this._renderedDecorations = t, this._renderedCursorPositions = this._cursorPositions, this._domNode.setDisplay("block");
    const i = this._settings.canvasWidth, n = this._settings.canvasHeight, o = this._settings.lineHeight, r = this._context.viewLayout, a = this._context.viewLayout.getScrollHeight(), l = n / a, c = 6 * this._settings.pixelRatio | 0, h = c / 2 | 0, d = this._domNode.domNode.getContext("2d");
    e ? e.isOpaque() ? (d.fillStyle = j.Format.CSS.formatHexA(e), d.fillRect(0, 0, i, n)) : (d.clearRect(0, 0, i, n), d.fillStyle = j.Format.CSS.formatHexA(e), d.fillRect(0, 0, i, n)) : d.clearRect(0, 0, i, n);
    const u = this._settings.x, f = this._settings.w;
    for (const g of t) {
      const p = g.color, _ = g.data;
      d.fillStyle = p;
      let b = 0, C = 0, w = 0;
      for (let v = 0, S = _.length / 3; v < S; v++) {
        const L = _[3 * v], k = _[3 * v + 1], x = _[3 * v + 2];
        let I = r.getVerticalOffsetForLineNumber(k) * l | 0, K = (r.getVerticalOffsetForLineNumber(x) + o) * l | 0;
        if (K - I < c) {
          let W = (I + K) / 2 | 0;
          W < h ? W = h : W + h > n && (W = n - h), I = W - h, K = W + h;
        }
        I > w + 1 || L !== b ? (v !== 0 && d.fillRect(u[b], C, f[b], w - C), b = L, C = I, w = K) : K > w && (w = K);
      }
      d.fillRect(u[b], C, f[b], w - C);
    }
    if (!this._settings.hideCursor) {
      const g = 2 * this._settings.pixelRatio | 0, p = g / 2 | 0, _ = this._settings.x[
        7
        /* OverviewRulerLane.Full */
      ], b = this._settings.w[
        7
        /* OverviewRulerLane.Full */
      ];
      let C = -100, w = -100, v = null;
      for (let S = 0, L = this._cursorPositions.length; S < L; S++) {
        const k = this._cursorPositions[S].color;
        if (!k)
          continue;
        const x = this._cursorPositions[S].position;
        let I = r.getVerticalOffsetForLineNumber(x.lineNumber) * l | 0;
        I < p ? I = p : I + p > n && (I = n - p);
        const K = I - p, B = K + g;
        K > w + 1 || k !== v ? (S !== 0 && v && d.fillRect(_, C, b, w - C), C = K, w = B) : B > w && (w = B), v = k, d.fillStyle = k;
      }
      v && d.fillRect(_, C, b, w - C);
    }
    this._settings.renderBorder && this._settings.borderColor && this._settings.overviewRulerLanes > 0 && (d.beginPath(), d.lineWidth = 1, d.strokeStyle = this._settings.borderColor, d.moveTo(0, 0), d.lineTo(0, n), d.moveTo(1, 0), d.lineTo(i, 0), d.stroke());
  }
}
class rM {
  constructor(e, t, i) {
    this._colorZoneBrand = void 0, this.from = e | 0, this.to = t | 0, this.colorId = i | 0;
  }
  static compare(e, t) {
    return e.colorId === t.colorId ? e.from === t.from ? e.to - t.to : e.from - t.from : e.colorId - t.colorId;
  }
}
class tF {
  constructor(e, t, i, n) {
    this._overviewRulerZoneBrand = void 0, this.startLineNumber = e, this.endLineNumber = t, this.heightInLines = i, this.color = n, this._colorZone = null;
  }
  static compare(e, t) {
    return e.color === t.color ? e.startLineNumber === t.startLineNumber ? e.heightInLines === t.heightInLines ? e.endLineNumber - t.endLineNumber : e.heightInLines - t.heightInLines : e.startLineNumber - t.startLineNumber : e.color < t.color ? -1 : 1;
  }
  setColorZone(e) {
    this._colorZone = e;
  }
  getColorZones() {
    return this._colorZone;
  }
}
class Wq {
  constructor(e) {
    this._getVerticalOffsetForLine = e, this._zones = [], this._colorZonesInvalid = !1, this._lineHeight = 0, this._domWidth = 0, this._domHeight = 0, this._outerHeight = 0, this._pixelRatio = 1, this._lastAssignedId = 0, this._color2Id = /* @__PURE__ */ Object.create(null), this._id2Color = [];
  }
  getId2Color() {
    return this._id2Color;
  }
  setZones(e) {
    this._zones = e, this._zones.sort(tF.compare);
  }
  setLineHeight(e) {
    return this._lineHeight === e ? !1 : (this._lineHeight = e, this._colorZonesInvalid = !0, !0);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this._colorZonesInvalid = !0;
  }
  getDOMWidth() {
    return this._domWidth;
  }
  getCanvasWidth() {
    return this._domWidth * this._pixelRatio;
  }
  setDOMWidth(e) {
    return this._domWidth === e ? !1 : (this._domWidth = e, this._colorZonesInvalid = !0, !0);
  }
  getDOMHeight() {
    return this._domHeight;
  }
  getCanvasHeight() {
    return this._domHeight * this._pixelRatio;
  }
  setDOMHeight(e) {
    return this._domHeight === e ? !1 : (this._domHeight = e, this._colorZonesInvalid = !0, !0);
  }
  getOuterHeight() {
    return this._outerHeight;
  }
  setOuterHeight(e) {
    return this._outerHeight === e ? !1 : (this._outerHeight = e, this._colorZonesInvalid = !0, !0);
  }
  resolveColorZones() {
    const e = this._colorZonesInvalid, t = Math.floor(this._lineHeight), i = Math.floor(this.getCanvasHeight()), n = Math.floor(this._outerHeight), o = i / n, r = Math.floor(4 * this._pixelRatio / 2), a = [];
    for (let l = 0, c = this._zones.length; l < c; l++) {
      const h = this._zones[l];
      if (!e) {
        const v = h.getColorZones();
        if (v) {
          a.push(v);
          continue;
        }
      }
      const d = this._getVerticalOffsetForLine(h.startLineNumber), u = h.heightInLines === 0 ? this._getVerticalOffsetForLine(h.endLineNumber) + t : d + h.heightInLines * t, f = Math.floor(o * d), g = Math.floor(o * u);
      let p = Math.floor((f + g) / 2), _ = g - p;
      _ < r && (_ = r), p - _ < 0 && (p = _), p + _ > i && (p = i - _);
      const b = h.color;
      let C = this._color2Id[b];
      C || (C = ++this._lastAssignedId, this._color2Id[b] = C, this._id2Color[C] = b);
      const w = new rM(p - _, p + _, C);
      h.setColorZone(w), a.push(w);
    }
    return this._colorZonesInvalid = !1, a.sort(rM.compare), a;
  }
}
class Hq extends Fp {
  constructor(e, t) {
    super(), this._context = e;
    const i = this._context.configuration.options;
    this._domNode = st(document.createElement("canvas")), this._domNode.setClassName(t), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(!0), this._domNode.setContain("strict"), this._zoneManager = new Wq((n) => this._context.viewLayout.getVerticalOffsetForLineNumber(n)), this._zoneManager.setDOMWidth(0), this._zoneManager.setDOMHeight(0), this._zoneManager.setOuterHeight(this._context.viewLayout.getScrollHeight()), this._zoneManager.setLineHeight(i.get(
      67
      /* EditorOption.lineHeight */
    )), this._zoneManager.setPixelRatio(i.get(
      144
      /* EditorOption.pixelRatio */
    )), this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return e.hasChanged(
      67
      /* EditorOption.lineHeight */
    ) && (this._zoneManager.setLineHeight(t.get(
      67
      /* EditorOption.lineHeight */
    )), this._render()), e.hasChanged(
      144
      /* EditorOption.pixelRatio */
    ) && (this._zoneManager.setPixelRatio(t.get(
      144
      /* EditorOption.pixelRatio */
    )), this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render()), !0;
  }
  onFlushed(e) {
    return this._render(), !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged && (this._zoneManager.setOuterHeight(e.scrollHeight), this._render()), !0;
  }
  onZonesChanged(e) {
    return this._render(), !0;
  }
  // ---- end view event handlers
  getDomNode() {
    return this._domNode.domNode;
  }
  setLayout(e) {
    this._domNode.setTop(e.top), this._domNode.setRight(e.right);
    let t = !1;
    t = this._zoneManager.setDOMWidth(e.width) || t, t = this._zoneManager.setDOMHeight(e.height) || t, t && (this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render());
  }
  setZones(e) {
    this._zoneManager.setZones(e), this._render();
  }
  _render() {
    if (this._zoneManager.getOuterHeight() === 0)
      return !1;
    const e = this._zoneManager.getCanvasWidth(), t = this._zoneManager.getCanvasHeight(), i = this._zoneManager.resolveColorZones(), n = this._zoneManager.getId2Color(), o = this._domNode.domNode.getContext("2d");
    return o.clearRect(0, 0, e, t), i.length > 0 && this._renderOneLane(o, i, n, e), !0;
  }
  _renderOneLane(e, t, i, n) {
    let o = 0, r = 0, a = 0;
    for (const l of t) {
      const c = l.colorId, h = l.from, d = l.to;
      c !== o ? (e.fillRect(0, r, n, a - r), o = c, e.fillStyle = i[o], r = h, a = d) : a >= h ? a = Math.max(a, d) : (e.fillRect(0, r, n, a - r), r = h, a = d);
    }
    e.fillRect(0, r, n, a - r);
  }
}
class Vq extends rs {
  constructor(e) {
    super(e), this.domNode = st(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setClassName("view-rulers"), this._renderedRulers = [];
    const t = this._context.configuration.options;
    this._rulers = t.get(
      103
      /* EditorOption.rulers */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth;
  }
  dispose() {
    super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._rulers = t.get(
      103
      /* EditorOption.rulers */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  _ensureRulersCount() {
    const e = this._renderedRulers.length, t = this._rulers.length;
    if (e === t)
      return;
    if (e < t) {
      const { tabSize: n } = this._context.viewModel.model.getOptions(), o = n;
      let r = t - e;
      for (; r > 0; ) {
        const a = st(document.createElement("div"));
        a.setClassName("view-ruler"), a.setWidth(o), this.domNode.appendChild(a), this._renderedRulers.push(a), r--;
      }
      return;
    }
    let i = e - t;
    for (; i > 0; ) {
      const n = this._renderedRulers.pop();
      this.domNode.removeChild(n), i--;
    }
  }
  render(e) {
    this._ensureRulersCount();
    for (let t = 0, i = this._rulers.length; t < i; t++) {
      const n = this._renderedRulers[t], o = this._rulers[t];
      n.setBoxShadow(o.color ? `1px 0 0 0 ${o.color} inset` : ""), n.setHeight(Math.min(e.scrollHeight, 1e6)), n.setLeft(o.column * this._typicalHalfwidthCharacterWidth);
    }
  }
}
class zq extends rs {
  constructor(e) {
    super(e), this._scrollTop = 0, this._width = 0, this._updateWidth(), this._shouldShow = !1;
    const i = this._context.configuration.options.get(
      104
      /* EditorOption.scrollbar */
    );
    this._useShadows = i.useShadows, this._domNode = st(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true");
  }
  dispose() {
    super.dispose();
  }
  _updateShouldShow() {
    const e = this._useShadows && this._scrollTop > 0;
    return this._shouldShow !== e ? (this._shouldShow = e, !0) : !1;
  }
  getDomNode() {
    return this._domNode;
  }
  _updateWidth() {
    const t = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    t.minimap.renderMinimap === 0 || t.minimap.minimapWidth > 0 && t.minimap.minimapLeft === 0 ? this._width = t.width : this._width = t.width - t.verticalScrollbarWidth;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      104
      /* EditorOption.scrollbar */
    );
    return this._useShadows = i.useShadows, this._updateWidth(), this._updateShouldShow(), !0;
  }
  onScrollChanged(e) {
    return this._scrollTop = e.scrollTop, this._updateShouldShow();
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setWidth(this._width), this._domNode.setClassName(this._shouldShow ? "scroll-decoration" : "");
  }
}
class Uq {
  constructor(e) {
    this.left = e.left, this.width = e.width, this.startStyle = null, this.endStyle = null;
  }
}
class $q {
  constructor(e, t) {
    this.lineNumber = e, this.ranges = t;
  }
}
function Kq(s) {
  return new Uq(s);
}
function jq(s) {
  return new $q(s.lineNumber, s.ranges.map(Kq));
}
const jt = class jt extends cd {
  constructor(e) {
    super(), this._previousFrameVisibleRangesWithStyle = [], this._context = e;
    const t = this._context.configuration.options;
    this._roundedSelection = t.get(
      102
      /* EditorOption.roundedSelection */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, this._selections = [], this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._roundedSelection = t.get(
      102
      /* EditorOption.roundedSelection */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections.slice(0), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _visibleRangesHaveGaps(e) {
    for (let t = 0, i = e.length; t < i; t++)
      if (e[t].ranges.length > 1)
        return !0;
    return !1;
  }
  _enrichVisibleRangesWithStyle(e, t, i) {
    const n = this._typicalHalfwidthCharacterWidth / 4;
    let o = null, r = null;
    if (i && i.length > 0 && t.length > 0) {
      const a = t[0].lineNumber;
      if (a === e.startLineNumber)
        for (let c = 0; !o && c < i.length; c++)
          i[c].lineNumber === a && (o = i[c].ranges[0]);
      const l = t[t.length - 1].lineNumber;
      if (l === e.endLineNumber)
        for (let c = i.length - 1; !r && c >= 0; c--)
          i[c].lineNumber === l && (r = i[c].ranges[0]);
      o && !o.startStyle && (o = null), r && !r.startStyle && (r = null);
    }
    for (let a = 0, l = t.length; a < l; a++) {
      const c = t[a].ranges[0], h = c.left, d = c.left + c.width, u = {
        top: 0,
        bottom: 0
        /* CornerStyle.EXTERN */
      }, f = {
        top: 0,
        bottom: 0
        /* CornerStyle.EXTERN */
      };
      if (a > 0) {
        const g = t[a - 1].ranges[0].left, p = t[a - 1].ranges[0].left + t[a - 1].ranges[0].width;
        C_(h - g) < n ? u.top = 2 : h > g && (u.top = 1), C_(d - p) < n ? f.top = 2 : g < d && d < p && (f.top = 1);
      } else o && (u.top = o.startStyle.top, f.top = o.endStyle.top);
      if (a + 1 < l) {
        const g = t[a + 1].ranges[0].left, p = t[a + 1].ranges[0].left + t[a + 1].ranges[0].width;
        C_(h - g) < n ? u.bottom = 2 : g < h && h < p && (u.bottom = 1), C_(d - p) < n ? f.bottom = 2 : d < p && (f.bottom = 1);
      } else r && (u.bottom = r.startStyle.bottom, f.bottom = r.endStyle.bottom);
      c.startStyle = u, c.endStyle = f;
    }
  }
  _getVisibleRangesWithStyle(e, t, i) {
    const o = (t.linesVisibleRangesForRange(e, !0) || []).map(jq);
    return !this._visibleRangesHaveGaps(o) && this._roundedSelection && this._enrichVisibleRangesWithStyle(t.visibleRange, o, i), o;
  }
  _createSelectionPiece(e, t, i, n, o) {
    return '<div class="cslr ' + i + '" style="top:' + e.toString() + "px;bottom:" + t.toString() + "px;left:" + n.toString() + "px;width:" + o.toString() + 'px;"></div>';
  }
  _actualRenderOneSelection(e, t, i, n) {
    if (n.length === 0)
      return;
    const o = !!n[0].ranges[0].startStyle, r = n[0].lineNumber, a = n[n.length - 1].lineNumber;
    for (let l = 0, c = n.length; l < c; l++) {
      const h = n[l], d = h.lineNumber, u = d - t, f = i && d === r ? 1 : 0, g = i && d !== r && d === a ? 1 : 0;
      let p = "", _ = "";
      for (let b = 0, C = h.ranges.length; b < C; b++) {
        const w = h.ranges[b];
        if (o) {
          const S = w.startStyle, L = w.endStyle;
          if (S.top === 1 || S.bottom === 1) {
            p += this._createSelectionPiece(f, g, jt.SELECTION_CLASS_NAME, w.left - jt.ROUNDED_PIECE_WIDTH, jt.ROUNDED_PIECE_WIDTH);
            let k = jt.EDITOR_BACKGROUND_CLASS_NAME;
            S.top === 1 && (k += " " + jt.SELECTION_TOP_RIGHT), S.bottom === 1 && (k += " " + jt.SELECTION_BOTTOM_RIGHT), p += this._createSelectionPiece(f, g, k, w.left - jt.ROUNDED_PIECE_WIDTH, jt.ROUNDED_PIECE_WIDTH);
          }
          if (L.top === 1 || L.bottom === 1) {
            p += this._createSelectionPiece(f, g, jt.SELECTION_CLASS_NAME, w.left + w.width, jt.ROUNDED_PIECE_WIDTH);
            let k = jt.EDITOR_BACKGROUND_CLASS_NAME;
            L.top === 1 && (k += " " + jt.SELECTION_TOP_LEFT), L.bottom === 1 && (k += " " + jt.SELECTION_BOTTOM_LEFT), p += this._createSelectionPiece(f, g, k, w.left + w.width, jt.ROUNDED_PIECE_WIDTH);
          }
        }
        let v = jt.SELECTION_CLASS_NAME;
        if (o) {
          const S = w.startStyle, L = w.endStyle;
          S.top === 0 && (v += " " + jt.SELECTION_TOP_LEFT), S.bottom === 0 && (v += " " + jt.SELECTION_BOTTOM_LEFT), L.top === 0 && (v += " " + jt.SELECTION_TOP_RIGHT), L.bottom === 0 && (v += " " + jt.SELECTION_BOTTOM_RIGHT);
        }
        _ += this._createSelectionPiece(f, g, v, w.left, w.width);
      }
      e[u][0] += p, e[u][1] += _;
    }
  }
  prepareRender(e) {
    const t = [], i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber;
    for (let r = i; r <= n; r++) {
      const a = r - i;
      t[a] = ["", ""];
    }
    const o = [];
    for (let r = 0, a = this._selections.length; r < a; r++) {
      const l = this._selections[r];
      if (l.isEmpty()) {
        o[r] = null;
        continue;
      }
      const c = this._getVisibleRangesWithStyle(l, e, this._previousFrameVisibleRangesWithStyle[r]);
      o[r] = c, this._actualRenderOneSelection(t, i, this._selections.length > 1, c);
    }
    this._previousFrameVisibleRangesWithStyle = o, this._renderResult = t.map(([r, a]) => r + a);
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
};
jt.SELECTION_CLASS_NAME = "selected-text", jt.SELECTION_TOP_LEFT = "top-left-radius", jt.SELECTION_BOTTOM_LEFT = "bottom-left-radius", jt.SELECTION_TOP_RIGHT = "top-right-radius", jt.SELECTION_BOTTOM_RIGHT = "bottom-right-radius", jt.EDITOR_BACKGROUND_CLASS_NAME = "monaco-editor-background", jt.ROUNDED_PIECE_WIDTH = 10;
let nL = jt;
tr((s, e) => {
  const t = s.getColor(Rz);
  t && !t.isTransparent() && e.addRule(`.monaco-editor .view-line span.inline-selected-text { color: ${t}; }`);
});
function C_(s) {
  return s < 0 ? -s : s;
}
class aM {
  constructor(e, t, i, n, o, r, a) {
    this.top = e, this.left = t, this.paddingLeft = i, this.width = n, this.height = o, this.textContent = r, this.textContentClassName = a;
  }
}
var Ea;
(function(s) {
  s[s.Single = 0] = "Single", s[s.MultiPrimary = 1] = "MultiPrimary", s[s.MultiSecondary = 2] = "MultiSecondary";
})(Ea || (Ea = {}));
class lM {
  constructor(e, t) {
    this._context = e;
    const i = this._context.configuration.options, n = i.get(
      50
      /* EditorOption.fontInfo */
    );
    this._cursorStyle = i.get(
      28
      /* EditorOption.cursorStyle */
    ), this._lineHeight = i.get(
      67
      /* EditorOption.lineHeight */
    ), this._typicalHalfwidthCharacterWidth = n.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(i.get(
      31
      /* EditorOption.cursorWidth */
    ), this._typicalHalfwidthCharacterWidth), this._isVisible = !0, this._domNode = st(document.createElement("div")), this._domNode.setClassName(`cursor ${Pu}`), this._domNode.setHeight(this._lineHeight), this._domNode.setTop(0), this._domNode.setLeft(0), Zi(this._domNode, n), this._domNode.setDisplay("none"), this._position = new F(1, 1), this._pluralityClass = "", this.setPlurality(t), this._lastRenderedContent = "", this._renderData = null;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._position;
  }
  setPlurality(e) {
    switch (e) {
      default:
      case Ea.Single:
        this._pluralityClass = "";
        break;
      case Ea.MultiPrimary:
        this._pluralityClass = "cursor-primary";
        break;
      case Ea.MultiSecondary:
        this._pluralityClass = "cursor-secondary";
        break;
    }
  }
  show() {
    this._isVisible || (this._domNode.setVisibility("inherit"), this._isVisible = !0);
  }
  hide() {
    this._isVisible && (this._domNode.setVisibility("hidden"), this._isVisible = !1);
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      50
      /* EditorOption.fontInfo */
    );
    return this._cursorStyle = t.get(
      28
      /* EditorOption.cursorStyle */
    ), this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(t.get(
      31
      /* EditorOption.cursorWidth */
    ), this._typicalHalfwidthCharacterWidth), Zi(this._domNode, i), !0;
  }
  onCursorPositionChanged(e, t) {
    return t ? this._domNode.domNode.style.transitionProperty = "none" : this._domNode.domNode.style.transitionProperty = "", this._position = e, !0;
  }
  /**
   * If `this._position` is inside a grapheme, returns the position where the grapheme starts.
   * Also returns the next grapheme.
   */
  _getGraphemeAwarePosition() {
    const { lineNumber: e, column: t } = this._position, i = this._context.viewModel.getLineContent(e), [n, o] = b8(i, t - 1);
    return [new F(e, n + 1), i.substring(n, o)];
  }
  _prepareRender(e) {
    let t = "", i = "";
    const [n, o] = this._getGraphemeAwarePosition();
    if (this._cursorStyle === Ii.Line || this._cursorStyle === Ii.LineThin) {
      const u = e.visibleRangeForPosition(n);
      if (!u || u.outsideRenderedLine)
        return null;
      const f = fe(this._domNode.domNode);
      let g;
      this._cursorStyle === Ii.Line ? (g = A2(f, this._lineCursorWidth > 0 ? this._lineCursorWidth : 2), g > 2 && (t = o, i = this._getTokenClassName(n))) : g = A2(f, 1);
      let p = u.left, _ = 0;
      g >= 2 && p >= 1 && (_ = 1, p -= _);
      const b = e.getVerticalOffsetForLineNumber(n.lineNumber) - e.bigNumbersDelta;
      return new aM(b, p, _, g, this._lineHeight, t, i);
    }
    const r = e.linesVisibleRangesForRange(new T(n.lineNumber, n.column, n.lineNumber, n.column + o.length), !1);
    if (!r || r.length === 0)
      return null;
    const a = r[0];
    if (a.outsideRenderedLine || a.ranges.length === 0)
      return null;
    const l = a.ranges[0], c = o === "	" ? this._typicalHalfwidthCharacterWidth : l.width < 1 ? this._typicalHalfwidthCharacterWidth : l.width;
    this._cursorStyle === Ii.Block && (t = o, i = this._getTokenClassName(n));
    let h = e.getVerticalOffsetForLineNumber(n.lineNumber) - e.bigNumbersDelta, d = this._lineHeight;
    return (this._cursorStyle === Ii.Underline || this._cursorStyle === Ii.UnderlineThin) && (h += this._lineHeight - 2, d = 2), new aM(h, l.left, 0, c, d, t, i);
  }
  _getTokenClassName(e) {
    const t = this._context.viewModel.getViewLineData(e.lineNumber), i = t.tokens.findTokenIndexAtOffset(e.column - 1);
    return t.tokens.getClassName(i);
  }
  prepareRender(e) {
    this._renderData = this._prepareRender(e);
  }
  render(e) {
    return this._renderData ? (this._lastRenderedContent !== this._renderData.textContent && (this._lastRenderedContent = this._renderData.textContent, this._domNode.domNode.textContent = this._lastRenderedContent), this._domNode.setClassName(`cursor ${this._pluralityClass} ${Pu} ${this._renderData.textContentClassName}`), this._domNode.setDisplay("block"), this._domNode.setTop(this._renderData.top), this._domNode.setLeft(this._renderData.left), this._domNode.setPaddingLeft(this._renderData.paddingLeft), this._domNode.setWidth(this._renderData.width), this._domNode.setLineHeight(this._renderData.height), this._domNode.setHeight(this._renderData.height), {
      domNode: this._domNode.domNode,
      position: this._position,
      contentLeft: this._renderData.left,
      height: this._renderData.height,
      width: 2
    }) : (this._domNode.setDisplay("none"), null);
  }
}
const dm = class dm extends rs {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options;
    this._readOnly = t.get(
      92
      /* EditorOption.readOnly */
    ), this._cursorBlinking = t.get(
      26
      /* EditorOption.cursorBlinking */
    ), this._cursorStyle = t.get(
      28
      /* EditorOption.cursorStyle */
    ), this._cursorSmoothCaretAnimation = t.get(
      27
      /* EditorOption.cursorSmoothCaretAnimation */
    ), this._selectionIsEmpty = !0, this._isComposingInput = !1, this._isVisible = !1, this._primaryCursor = new lM(this._context, Ea.Single), this._secondaryCursors = [], this._renderData = [], this._domNode = st(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._updateDomClassName(), this._domNode.appendChild(this._primaryCursor.getDomNode()), this._startCursorBlinkAnimation = new Ya(), this._cursorFlatBlinkInterval = new LE(), this._blinkingEnabled = !1, this._editorHasFocus = !1, this._updateBlinking();
  }
  dispose() {
    super.dispose(), this._startCursorBlinkAnimation.dispose(), this._cursorFlatBlinkInterval.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  // --- begin event handlers
  onCompositionStart(e) {
    return this._isComposingInput = !0, this._updateBlinking(), !0;
  }
  onCompositionEnd(e) {
    return this._isComposingInput = !1, this._updateBlinking(), !0;
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    this._readOnly = t.get(
      92
      /* EditorOption.readOnly */
    ), this._cursorBlinking = t.get(
      26
      /* EditorOption.cursorBlinking */
    ), this._cursorStyle = t.get(
      28
      /* EditorOption.cursorStyle */
    ), this._cursorSmoothCaretAnimation = t.get(
      27
      /* EditorOption.cursorSmoothCaretAnimation */
    ), this._updateBlinking(), this._updateDomClassName(), this._primaryCursor.onConfigurationChanged(e);
    for (let i = 0, n = this._secondaryCursors.length; i < n; i++)
      this._secondaryCursors[i].onConfigurationChanged(e);
    return !0;
  }
  _onCursorPositionChanged(e, t, i) {
    const n = this._secondaryCursors.length !== t.length || this._cursorSmoothCaretAnimation === "explicit" && i !== 3;
    if (this._primaryCursor.setPlurality(t.length ? Ea.MultiPrimary : Ea.Single), this._primaryCursor.onCursorPositionChanged(e, n), this._updateBlinking(), this._secondaryCursors.length < t.length) {
      const o = t.length - this._secondaryCursors.length;
      for (let r = 0; r < o; r++) {
        const a = new lM(this._context, Ea.MultiSecondary);
        this._domNode.domNode.insertBefore(a.getDomNode().domNode, this._primaryCursor.getDomNode().domNode.nextSibling), this._secondaryCursors.push(a);
      }
    } else if (this._secondaryCursors.length > t.length) {
      const o = this._secondaryCursors.length - t.length;
      for (let r = 0; r < o; r++)
        this._domNode.removeChild(this._secondaryCursors[0].getDomNode()), this._secondaryCursors.splice(0, 1);
    }
    for (let o = 0; o < t.length; o++)
      this._secondaryCursors[o].onCursorPositionChanged(t[o], n);
  }
  onCursorStateChanged(e) {
    const t = [];
    for (let n = 0, o = e.selections.length; n < o; n++)
      t[n] = e.selections[n].getPosition();
    this._onCursorPositionChanged(t[0], t.slice(1), e.reason);
    const i = e.selections[0].isEmpty();
    return this._selectionIsEmpty !== i && (this._selectionIsEmpty = i, this._updateDomClassName()), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onFocusChanged(e) {
    return this._editorHasFocus = e.isFocused, this._updateBlinking(), !1;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onTokensChanged(e) {
    const t = (i) => {
      for (let n = 0, o = e.ranges.length; n < o; n++)
        if (e.ranges[n].fromLineNumber <= i.lineNumber && i.lineNumber <= e.ranges[n].toLineNumber)
          return !0;
      return !1;
    };
    if (t(this._primaryCursor.getPosition()))
      return !0;
    for (const i of this._secondaryCursors)
      if (t(i.getPosition()))
        return !0;
    return !1;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  // ---- blinking logic
  _getCursorBlinking() {
    return this._isComposingInput || !this._editorHasFocus ? 0 : this._readOnly ? 5 : this._cursorBlinking;
  }
  _updateBlinking() {
    this._startCursorBlinkAnimation.cancel(), this._cursorFlatBlinkInterval.cancel();
    const e = this._getCursorBlinking(), t = e === 0, i = e === 5;
    t ? this._hide() : this._show(), this._blinkingEnabled = !1, this._updateDomClassName(), !t && !i && (e === 1 ? this._cursorFlatBlinkInterval.cancelAndSet(() => {
      this._isVisible ? this._hide() : this._show();
    }, dm.BLINK_INTERVAL, fe(this._domNode.domNode)) : this._startCursorBlinkAnimation.setIfNotSet(() => {
      this._blinkingEnabled = !0, this._updateDomClassName();
    }, dm.BLINK_INTERVAL));
  }
  // --- end blinking logic
  _updateDomClassName() {
    this._domNode.setClassName(this._getClassName());
  }
  _getClassName() {
    let e = "cursors-layer";
    switch (this._selectionIsEmpty || (e += " has-selection"), this._cursorStyle) {
      case Ii.Line:
        e += " cursor-line-style";
        break;
      case Ii.Block:
        e += " cursor-block-style";
        break;
      case Ii.Underline:
        e += " cursor-underline-style";
        break;
      case Ii.LineThin:
        e += " cursor-line-thin-style";
        break;
      case Ii.BlockOutline:
        e += " cursor-block-outline-style";
        break;
      case Ii.UnderlineThin:
        e += " cursor-underline-thin-style";
        break;
      default:
        e += " cursor-line-style";
    }
    if (this._blinkingEnabled)
      switch (this._getCursorBlinking()) {
        case 1:
          e += " cursor-blink";
          break;
        case 2:
          e += " cursor-smooth";
          break;
        case 3:
          e += " cursor-phase";
          break;
        case 4:
          e += " cursor-expand";
          break;
        case 5:
          e += " cursor-solid";
          break;
        default:
          e += " cursor-solid";
      }
    else
      e += " cursor-solid";
    return (this._cursorSmoothCaretAnimation === "on" || this._cursorSmoothCaretAnimation === "explicit") && (e += " cursor-smooth-caret-animation"), e;
  }
  _show() {
    this._primaryCursor.show();
    for (let e = 0, t = this._secondaryCursors.length; e < t; e++)
      this._secondaryCursors[e].show();
    this._isVisible = !0;
  }
  _hide() {
    this._primaryCursor.hide();
    for (let e = 0, t = this._secondaryCursors.length; e < t; e++)
      this._secondaryCursors[e].hide();
    this._isVisible = !1;
  }
  // ---- IViewPart implementation
  prepareRender(e) {
    this._primaryCursor.prepareRender(e);
    for (let t = 0, i = this._secondaryCursors.length; t < i; t++)
      this._secondaryCursors[t].prepareRender(e);
  }
  render(e) {
    const t = [];
    let i = 0;
    const n = this._primaryCursor.render(e);
    n && (t[i++] = n);
    for (let o = 0, r = this._secondaryCursors.length; o < r; o++) {
      const a = this._secondaryCursors[o].render(e);
      a && (t[i++] = a);
    }
    this._renderData = t;
  }
  getLastRenderData() {
    return this._renderData;
  }
};
dm.BLINK_INTERVAL = 500;
let sL = dm;
tr((s, e) => {
  const t = [
    { class: ".cursor", foreground: Lw, background: mI },
    { class: ".cursor-primary", foreground: S5, background: J$ },
    { class: ".cursor-secondary", foreground: L5, background: eK }
  ];
  for (const i of t) {
    const n = s.getColor(i.foreground);
    if (n) {
      let o = s.getColor(i.background);
      o || (o = n.opposite()), e.addRule(`.monaco-editor .cursors-layer ${i.class} { background-color: ${n}; border-color: ${n}; color: ${o}; }`), dh(s.type) && e.addRule(`.monaco-editor .cursors-layer.has-selection ${i.class} { border-left: 1px solid ${o}; border-right: 1px solid ${o}; }`);
    }
  }
});
const z0 = () => {
  throw new Error("Invalid change accessor");
};
class qq extends rs {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, this.domNode = st(document.createElement("div")), this.domNode.setClassName("view-zones"), this.domNode.setPosition("absolute"), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.marginDomNode = st(document.createElement("div")), this.marginDomNode.setClassName("margin-view-zones"), this.marginDomNode.setPosition("absolute"), this.marginDomNode.setAttribute("role", "presentation"), this.marginDomNode.setAttribute("aria-hidden", "true"), this._zones = {};
  }
  dispose() {
    super.dispose(), this._zones = {};
  }
  // ---- begin view event handlers
  _recomputeWhitespacesProps() {
    const e = this._context.viewLayout.getWhitespaces(), t = /* @__PURE__ */ new Map();
    for (const n of e)
      t.set(n.id, n);
    let i = !1;
    return this._context.viewModel.changeWhitespace((n) => {
      const o = Object.keys(this._zones);
      for (let r = 0, a = o.length; r < a; r++) {
        const l = o[r], c = this._zones[l], h = this._computeWhitespaceProps(c.delegate);
        c.isInHiddenArea = h.isInHiddenArea;
        const d = t.get(l);
        d && (d.afterLineNumber !== h.afterViewLineNumber || d.height !== h.heightInPx) && (n.changeOneWhitespace(l, h.afterViewLineNumber, h.heightInPx), this._safeCallOnComputedHeight(c.delegate, h.heightInPx), i = !0);
      }
    }), i;
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, e.hasChanged(
      67
      /* EditorOption.lineHeight */
    ) && this._recomputeWhitespacesProps(), !0;
  }
  onLineMappingChanged(e) {
    return this._recomputeWhitespacesProps();
  }
  onLinesDeleted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollWidthChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  // ---- end view event handlers
  _getZoneOrdinal(e) {
    return e.ordinal ?? e.afterColumn ?? 1e4;
  }
  _computeWhitespaceProps(e) {
    if (e.afterLineNumber === 0)
      return {
        isInHiddenArea: !1,
        afterViewLineNumber: 0,
        heightInPx: this._heightInPixels(e),
        minWidthInPx: this._minWidthInPixels(e)
      };
    let t;
    if (typeof e.afterColumn < "u")
      t = this._context.viewModel.model.validatePosition({
        lineNumber: e.afterLineNumber,
        column: e.afterColumn
      });
    else {
      const r = this._context.viewModel.model.validatePosition({
        lineNumber: e.afterLineNumber,
        column: 1
      }).lineNumber;
      t = new F(r, this._context.viewModel.model.getLineMaxColumn(r));
    }
    let i;
    t.column === this._context.viewModel.model.getLineMaxColumn(t.lineNumber) ? i = this._context.viewModel.model.validatePosition({
      lineNumber: t.lineNumber + 1,
      column: 1
    }) : i = this._context.viewModel.model.validatePosition({
      lineNumber: t.lineNumber,
      column: t.column + 1
    });
    const n = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(t, e.afterColumnAffinity, !0), o = e.showInHiddenAreas || this._context.viewModel.coordinatesConverter.modelPositionIsVisible(i);
    return {
      isInHiddenArea: !o,
      afterViewLineNumber: n.lineNumber,
      heightInPx: o ? this._heightInPixels(e) : 0,
      minWidthInPx: this._minWidthInPixels(e)
    };
  }
  changeViewZones(e) {
    let t = !1;
    return this._context.viewModel.changeWhitespace((i) => {
      const n = {
        addZone: (o) => (t = !0, this._addZone(i, o)),
        removeZone: (o) => {
          o && (t = this._removeZone(i, o) || t);
        },
        layoutZone: (o) => {
          o && (t = this._layoutZone(i, o) || t);
        }
      };
      Gq(e, n), n.addZone = z0, n.removeZone = z0, n.layoutZone = z0;
    }), t;
  }
  _addZone(e, t) {
    const i = this._computeWhitespaceProps(t), o = {
      whitespaceId: e.insertWhitespace(i.afterViewLineNumber, this._getZoneOrdinal(t), i.heightInPx, i.minWidthInPx),
      delegate: t,
      isInHiddenArea: i.isInHiddenArea,
      isVisible: !1,
      domNode: st(t.domNode),
      marginDomNode: t.marginDomNode ? st(t.marginDomNode) : null
    };
    return this._safeCallOnComputedHeight(o.delegate, i.heightInPx), o.domNode.setPosition("absolute"), o.domNode.domNode.style.width = "100%", o.domNode.setDisplay("none"), o.domNode.setAttribute("monaco-view-zone", o.whitespaceId), this.domNode.appendChild(o.domNode), o.marginDomNode && (o.marginDomNode.setPosition("absolute"), o.marginDomNode.domNode.style.width = "100%", o.marginDomNode.setDisplay("none"), o.marginDomNode.setAttribute("monaco-view-zone", o.whitespaceId), this.marginDomNode.appendChild(o.marginDomNode)), this._zones[o.whitespaceId] = o, this.setShouldRender(), o.whitespaceId;
  }
  _removeZone(e, t) {
    if (this._zones.hasOwnProperty(t)) {
      const i = this._zones[t];
      return delete this._zones[t], e.removeWhitespace(i.whitespaceId), i.domNode.removeAttribute("monaco-visible-view-zone"), i.domNode.removeAttribute("monaco-view-zone"), i.domNode.domNode.remove(), i.marginDomNode && (i.marginDomNode.removeAttribute("monaco-visible-view-zone"), i.marginDomNode.removeAttribute("monaco-view-zone"), i.marginDomNode.domNode.remove()), this.setShouldRender(), !0;
    }
    return !1;
  }
  _layoutZone(e, t) {
    if (this._zones.hasOwnProperty(t)) {
      const i = this._zones[t], n = this._computeWhitespaceProps(i.delegate);
      return i.isInHiddenArea = n.isInHiddenArea, e.changeOneWhitespace(i.whitespaceId, n.afterViewLineNumber, n.heightInPx), this._safeCallOnComputedHeight(i.delegate, n.heightInPx), this.setShouldRender(), !0;
    }
    return !1;
  }
  shouldSuppressMouseDownOnViewZone(e) {
    return this._zones.hasOwnProperty(e) ? !!this._zones[e].delegate.suppressMouseDown : !1;
  }
  _heightInPixels(e) {
    return typeof e.heightInPx == "number" ? e.heightInPx : typeof e.heightInLines == "number" ? this._lineHeight * e.heightInLines : this._lineHeight;
  }
  _minWidthInPixels(e) {
    return typeof e.minWidthInPx == "number" ? e.minWidthInPx : 0;
  }
  _safeCallOnComputedHeight(e, t) {
    if (typeof e.onComputedHeight == "function")
      try {
        e.onComputedHeight(t);
      } catch (i) {
        Je(i);
      }
  }
  _safeCallOnDomNodeTop(e, t) {
    if (typeof e.onDomNodeTop == "function")
      try {
        e.onDomNodeTop(t);
      } catch (i) {
        Je(i);
      }
  }
  prepareRender(e) {
  }
  render(e) {
    const t = e.viewportData.whitespaceViewportData, i = {};
    let n = !1;
    for (const r of t)
      this._zones[r.id].isInHiddenArea || (i[r.id] = r, n = !0);
    const o = Object.keys(this._zones);
    for (let r = 0, a = o.length; r < a; r++) {
      const l = o[r], c = this._zones[l];
      let h = 0, d = 0, u = "none";
      i.hasOwnProperty(l) ? (h = i[l].verticalOffset - e.bigNumbersDelta, d = i[l].height, u = "block", c.isVisible || (c.domNode.setAttribute("monaco-visible-view-zone", "true"), c.isVisible = !0), this._safeCallOnDomNodeTop(c.delegate, e.getScrolledTopFromAbsoluteTop(i[l].verticalOffset))) : (c.isVisible && (c.domNode.removeAttribute("monaco-visible-view-zone"), c.isVisible = !1), this._safeCallOnDomNodeTop(c.delegate, e.getScrolledTopFromAbsoluteTop(-1e6))), c.domNode.setTop(h), c.domNode.setHeight(d), c.domNode.setDisplay(u), c.marginDomNode && (c.marginDomNode.setTop(h), c.marginDomNode.setHeight(d), c.marginDomNode.setDisplay(u));
    }
    n && (this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth)), this.marginDomNode.setWidth(this._contentLeft));
  }
}
function Gq(s, e) {
  try {
    return s(e);
  } catch (t) {
    Je(t);
  }
}
class Zq extends cd {
  constructor(e) {
    super(), this._context = e, this._options = new cM(this._context.configuration), this._selection = [], this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = new cM(this._context.configuration);
    return this._options.equals(t) ? e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    ) : (this._options = t, !0);
  }
  onCursorStateChanged(e) {
    return this._selection = e.selections, this._options.renderWhitespace === "selection";
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
    if (this._options.renderWhitespace === "none") {
      this._renderResult = null;
      return;
    }
    const t = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber - t + 1, o = new Array(n);
    for (let a = 0; a < n; a++)
      o[a] = !0;
    const r = this._context.viewModel.getMinimapLinesRenderingData(e.viewportData.startLineNumber, e.viewportData.endLineNumber, o);
    this._renderResult = [];
    for (let a = e.viewportData.startLineNumber; a <= e.viewportData.endLineNumber; a++) {
      const l = a - e.viewportData.startLineNumber, c = r.data[l];
      let h = null;
      if (this._options.renderWhitespace === "selection") {
        const d = this._selection;
        for (const u of d) {
          if (u.endLineNumber < a || u.startLineNumber > a)
            continue;
          const f = u.startLineNumber === a ? u.startColumn : c.minColumn, g = u.endLineNumber === a ? u.endColumn : c.maxColumn;
          f < g && (h || (h = []), h.push(new f5(f - 1, g - 1)));
        }
      }
      this._renderResult[l] = this._applyRenderWhitespace(e, a, h, c);
    }
  }
  _applyRenderWhitespace(e, t, i, n) {
    if (this._options.renderWhitespace === "selection" && !i || this._options.renderWhitespace === "trailing" && n.continuesWithWrappedLine)
      return "";
    const o = this._context.theme.getColor(pI), r = this._options.renderWithSVG, a = n.content, l = this._options.stopRenderingLineAfter === -1 ? a.length : Math.min(this._options.stopRenderingLineAfter, a.length), c = n.continuesWithWrappedLine, h = n.minColumn - 1, d = this._options.renderWhitespace === "boundary", u = this._options.renderWhitespace === "trailing", f = this._options.lineHeight, g = this._options.middotWidth, p = this._options.wsmiddotWidth, _ = this._options.spaceWidth, b = Math.abs(p - _), C = Math.abs(g - _), w = b < C ? 11825 : 183, v = this._options.canUseHalfwidthRightwardsArrow;
    let S = "", L = !1, k = Zn(a), x;
    k === -1 ? (L = !0, k = l, x = l) : x = id(a);
    let I = 0, K = i && i[I], B = 0;
    for (let W = h; W < l; W++) {
      const H = a.charCodeAt(W);
      if (K && W >= K.endOffset && (I++, K = i && i[I]), H !== 9 && H !== 32 || u && !L && W <= x)
        continue;
      if (d && W >= k && W <= x && H === 32) {
        const q = W - 1 >= 0 ? a.charCodeAt(W - 1) : 0, J = W + 1 < l ? a.charCodeAt(W + 1) : 0;
        if (q !== 32 && J !== 32)
          continue;
      }
      if (d && c && W === l - 1) {
        const q = W - 1 >= 0 ? a.charCodeAt(W - 1) : 0;
        if (H === 32 && q !== 32 && q !== 9)
          continue;
      }
      if (i && (!K || K.startOffset > W || K.endOffset <= W))
        continue;
      const P = e.visibleRangeForPosition(new F(t, W + 1));
      P && (r ? (B = Math.max(B, P.left), H === 9 ? S += this._renderArrow(f, _, P.left) : S += `<circle cx="${(P.left + _ / 2).toFixed(2)}" cy="${(f / 2).toFixed(2)}" r="${(_ / 7).toFixed(2)}" />`) : H === 9 ? S += `<div class="mwh" style="left:${P.left}px;height:${f}px;">${v ? "￫" : "→"}</div>` : S += `<div class="mwh" style="left:${P.left}px;height:${f}px;">${String.fromCharCode(w)}</div>`);
    }
    return r ? (B = Math.round(B + _), `<svg style="bottom:0;position:absolute;width:${B}px;height:${f}px" viewBox="0 0 ${B} ${f}" xmlns="http://www.w3.org/2000/svg" fill="${o}">` + S + "</svg>") : S;
  }
  _renderArrow(e, t, i) {
    const n = t / 7, o = t, r = e / 2, a = i, l = { x: 0, y: n / 2 }, c = { x: 100 / 125 * o, y: l.y }, h = { x: c.x - 0.2 * c.x, y: c.y + 0.2 * c.x }, d = { x: h.x + 0.1 * c.x, y: h.y + 0.1 * c.x }, u = { x: d.x + 0.35 * c.x, y: d.y - 0.35 * c.x }, f = { x: u.x, y: -u.y }, g = { x: d.x, y: -d.y }, p = { x: h.x, y: -h.y }, _ = { x: c.x, y: -c.y }, b = { x: l.x, y: -l.y };
    return `<path d="M ${[l, c, h, d, u, f, g, p, _, b].map((v) => `${(a + v.x).toFixed(2)} ${(r + v.y).toFixed(2)}`).join(" L ")}" />`;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
class cM {
  constructor(e) {
    const t = e.options, i = t.get(
      50
      /* EditorOption.fontInfo */
    ), n = t.get(
      38
      /* EditorOption.experimentalWhitespaceRendering */
    );
    n === "off" ? (this.renderWhitespace = "none", this.renderWithSVG = !1) : n === "svg" ? (this.renderWhitespace = t.get(
      100
      /* EditorOption.renderWhitespace */
    ), this.renderWithSVG = !0) : (this.renderWhitespace = t.get(
      100
      /* EditorOption.renderWhitespace */
    ), this.renderWithSVG = !1), this.spaceWidth = i.spaceWidth, this.middotWidth = i.middotWidth, this.wsmiddotWidth = i.wsmiddotWidth, this.canUseHalfwidthRightwardsArrow = i.canUseHalfwidthRightwardsArrow, this.lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this.stopRenderingLineAfter = t.get(
      118
      /* EditorOption.stopRenderingLineAfter */
    );
  }
  equals(e) {
    return this.renderWhitespace === e.renderWhitespace && this.renderWithSVG === e.renderWithSVG && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineHeight === e.lineHeight && this.stopRenderingLineAfter === e.stopRenderingLineAfter;
  }
}
class Yq {
  constructor(e, t, i, n) {
    this.selections = e, this.startLineNumber = t.startLineNumber | 0, this.endLineNumber = t.endLineNumber | 0, this.relativeVerticalOffset = t.relativeVerticalOffset, this.bigNumbersDelta = t.bigNumbersDelta | 0, this.lineHeight = t.lineHeight | 0, this.whitespaceViewportData = i, this._model = n, this.visibleRange = new T(t.startLineNumber, this._model.getLineMinColumn(t.startLineNumber), t.endLineNumber, this._model.getLineMaxColumn(t.endLineNumber));
  }
  getViewLineRenderingData(e) {
    return this._model.getViewportViewLineRenderingData(this.visibleRange, e);
  }
  getDecorationsInViewport() {
    return this._model.getDecorationsInViewport(this.visibleRange);
  }
}
class Xq {
  get type() {
    return this._theme.type;
  }
  get value() {
    return this._theme;
  }
  constructor(e) {
    this._theme = e;
  }
  update(e) {
    this._theme = e;
  }
  getColor(e) {
    return this._theme.getColor(e);
  }
}
class Qq {
  constructor(e, t, i) {
    this.configuration = e, this.theme = new Xq(t), this.viewModel = i, this.viewLayout = i.viewLayout;
  }
  addEventHandler(e) {
    this.viewModel.addViewEventHandler(e);
  }
  removeEventHandler(e) {
    this.viewModel.removeViewEventHandler(e);
  }
}
var Jq = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, eG = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let oL = class extends Fp {
  constructor(e, t, i, n, o, r, a) {
    super(), this._instantiationService = a, this._shouldRecomputeGlyphMarginLanes = !1, this._selections = [new Ue(1, 1, 1, 1)], this._renderAnimationFrame = null;
    const l = new Zj(t, n, o, e);
    this._context = new Qq(t, i, n), this._context.addEventHandler(this), this._viewParts = [], this._textAreaHandler = this._instantiationService.createInstance(jS, this._context, l, this._createTextAreaHandlerHelper()), this._viewParts.push(this._textAreaHandler), this._linesContent = st(document.createElement("div")), this._linesContent.setClassName("lines-content monaco-editor-background"), this._linesContent.setPosition("absolute"), this.domNode = st(document.createElement("div")), this.domNode.setClassName(this._getEditorClassName()), this.domNode.setAttribute("role", "code"), this._overflowGuardContainer = st(document.createElement("div")), Go.write(
      this._overflowGuardContainer,
      3
      /* PartFingerprint.OverflowGuard */
    ), this._overflowGuardContainer.setClassName("overflow-guard"), this._scrollbar = new oq(this._context, this._linesContent, this.domNode, this._overflowGuardContainer), this._viewParts.push(this._scrollbar), this._viewLines = new iL(this._context, this._linesContent), this._viewZones = new qq(this._context), this._viewParts.push(this._viewZones);
    const c = new Bq(this._context);
    this._viewParts.push(c);
    const h = new zq(this._context);
    this._viewParts.push(h);
    const d = new Xj(this._context);
    this._viewParts.push(d), d.addDynamicOverlay(new iq(this._context)), d.addDynamicOverlay(new nL(this._context)), d.addDynamicOverlay(new yq(this._context)), d.addDynamicOverlay(new sq(this._context)), d.addDynamicOverlay(new Zq(this._context));
    const u = new Qj(this._context);
    this._viewParts.push(u), u.addDynamicOverlay(new nq(this._context)), u.addDynamicOverlay(new Dq(this._context)), u.addDynamicOverlay(new xq(this._context)), u.addDynamicOverlay(new f1(this._context)), this._glyphMarginWidgets = new uq(this._context), this._viewParts.push(this._glyphMarginWidgets);
    const f = new g1(this._context);
    f.getDomNode().appendChild(this._viewZones.marginDomNode), f.getDomNode().appendChild(u.getDomNode()), f.getDomNode().appendChild(this._glyphMarginWidgets.domNode), this._viewParts.push(f), this._contentWidgets = new eq(this._context, this.domNode), this._viewParts.push(this._contentWidgets), this._viewCursors = new sL(this._context), this._viewParts.push(this._viewCursors), this._overlayWidgets = new Oq(this._context, this.domNode), this._viewParts.push(this._overlayWidgets);
    const g = new Vq(this._context);
    this._viewParts.push(g);
    const p = new Jj(this._context);
    this._viewParts.push(p);
    const _ = new Pq(this._context);
    if (this._viewParts.push(_), c) {
      const b = this._scrollbar.getOverviewRulerLayoutInfo();
      b.parent.insertBefore(c.getDomNode(), b.insertBefore);
    }
    this._linesContent.appendChild(d.getDomNode()), this._linesContent.appendChild(g.domNode), this._linesContent.appendChild(this._viewZones.domNode), this._linesContent.appendChild(this._viewLines.getDomNode()), this._linesContent.appendChild(this._contentWidgets.domNode), this._linesContent.appendChild(this._viewCursors.getDomNode()), this._overflowGuardContainer.appendChild(f.getDomNode()), this._overflowGuardContainer.appendChild(this._scrollbar.getDomNode()), this._overflowGuardContainer.appendChild(h.getDomNode()), this._overflowGuardContainer.appendChild(this._textAreaHandler.textArea), this._overflowGuardContainer.appendChild(this._textAreaHandler.textAreaCover), this._overflowGuardContainer.appendChild(this._overlayWidgets.getDomNode()), this._overflowGuardContainer.appendChild(_.getDomNode()), this._overflowGuardContainer.appendChild(p.domNode), this.domNode.appendChild(this._overflowGuardContainer), r ? (r.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode.domNode), r.appendChild(this._overlayWidgets.overflowingOverlayWidgetsDomNode.domNode)) : (this.domNode.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode), this.domNode.appendChild(this._overlayWidgets.overflowingOverlayWidgetsDomNode)), this._applyLayout(), this._pointerHandler = this._register(new Y$(this._context, l, this._createPointerHandlerHelper()));
  }
  _computeGlyphMarginLanes() {
    const e = this._context.viewModel.model, t = this._context.viewModel.glyphLanes;
    let i = [], n = 0;
    i = i.concat(e.getAllMarginDecorations().map((o) => {
      var a, l;
      const r = ((a = o.options.glyphMargin) == null ? void 0 : a.position) ?? _o.Center;
      return n = Math.max(n, o.range.endLineNumber), { range: o.range, lane: r, persist: (l = o.options.glyphMargin) == null ? void 0 : l.persistLane };
    })), i = i.concat(this._glyphMarginWidgets.getWidgets().map((o) => {
      const r = e.validateRange(o.preference.range);
      return n = Math.max(n, r.endLineNumber), { range: r, lane: o.preference.lane };
    })), i.sort((o, r) => T.compareRangesUsingStarts(o.range, r.range)), t.reset(n);
    for (const o of i)
      t.push(o.lane, o.range, o.persist);
    return t;
  }
  _createPointerHandlerHelper() {
    return {
      viewDomNode: this.domNode.domNode,
      linesContentDomNode: this._linesContent.domNode,
      viewLinesDomNode: this._viewLines.getDomNode().domNode,
      focusTextArea: () => {
        this.focus();
      },
      dispatchTextAreaEvent: (e) => {
        this._textAreaHandler.textArea.domNode.dispatchEvent(e);
      },
      getLastRenderData: () => {
        const e = this._viewCursors.getLastRenderData() || [], t = this._textAreaHandler.getLastRenderData();
        return new B$(e, t);
      },
      renderNow: () => {
        this.render(!0, !1);
      },
      shouldSuppressMouseDownOnViewZone: (e) => this._viewZones.shouldSuppressMouseDownOnViewZone(e),
      shouldSuppressMouseDownOnWidget: (e) => this._contentWidgets.shouldSuppressMouseDownOnWidget(e),
      getPositionFromDOMInfo: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getPositionFromDOMInfo(e, t)),
      visibleRangeForPosition: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(new F(e, t))),
      getLineWidth: (e) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getLineWidth(e))
    };
  }
  _createTextAreaHandlerHelper() {
    return {
      visibleRangeForPosition: (e) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(e))
    };
  }
  _applyLayout() {
    const t = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    this.domNode.setWidth(t.width), this.domNode.setHeight(t.height), this._overflowGuardContainer.setWidth(t.width), this._overflowGuardContainer.setHeight(t.height), this._linesContent.setWidth(16777216), this._linesContent.setHeight(16777216);
  }
  _getEditorClassName() {
    const e = this._textAreaHandler.isFocused() ? " focused" : "";
    return this._context.configuration.options.get(
      143
      /* EditorOption.editorClassName */
    ) + " " + HS(this._context.theme.type) + e;
  }
  // --- begin event handlers
  handleEvents(e) {
    super.handleEvents(e), this._scheduleRender();
  }
  onConfigurationChanged(e) {
    return this.domNode.setClassName(this._getEditorClassName()), this._applyLayout(), !1;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, !1;
  }
  onDecorationsChanged(e) {
    return e.affectsGlyphMargin && (this._shouldRecomputeGlyphMarginLanes = !0), !1;
  }
  onFocusChanged(e) {
    return this.domNode.setClassName(this._getEditorClassName()), !1;
  }
  onThemeChanged(e) {
    return this._context.theme.update(e.theme), this.domNode.setClassName(this._getEditorClassName()), !1;
  }
  // --- end event handlers
  dispose() {
    this._renderAnimationFrame !== null && (this._renderAnimationFrame.dispose(), this._renderAnimationFrame = null), this._contentWidgets.overflowingContentWidgetsDomNode.domNode.remove(), this._context.removeEventHandler(this), this._viewLines.dispose();
    for (const e of this._viewParts)
      e.dispose();
    super.dispose();
  }
  _scheduleRender() {
    var e;
    if (this._store.isDisposed)
      throw new at();
    if (this._renderAnimationFrame === null) {
      const t = this._createCoordinatedRendering();
      this._renderAnimationFrame = rL.INSTANCE.scheduleCoordinatedRendering({
        window: fe((e = this.domNode) == null ? void 0 : e.domNode),
        prepareRenderText: () => {
          if (this._store.isDisposed)
            throw new at();
          try {
            return t.prepareRenderText();
          } finally {
            this._renderAnimationFrame = null;
          }
        },
        renderText: () => {
          if (this._store.isDisposed)
            throw new at();
          return t.renderText();
        },
        prepareRender: (i, n) => {
          if (this._store.isDisposed)
            throw new at();
          return t.prepareRender(i, n);
        },
        render: (i, n) => {
          if (this._store.isDisposed)
            throw new at();
          return t.render(i, n);
        }
      });
    }
  }
  _flushAccumulatedAndRenderNow() {
    const e = this._createCoordinatedRendering();
    kl(() => e.prepareRenderText());
    const t = kl(() => e.renderText());
    if (t) {
      const [i, n] = t;
      kl(() => e.prepareRender(i, n)), kl(() => e.render(i, n));
    }
  }
  _getViewPartsToRender() {
    const e = [];
    let t = 0;
    for (const i of this._viewParts)
      i.shouldRender() && (e[t++] = i);
    return e;
  }
  _createCoordinatedRendering() {
    return {
      prepareRenderText: () => {
        if (this._shouldRecomputeGlyphMarginLanes) {
          this._shouldRecomputeGlyphMarginLanes = !1;
          const e = this._computeGlyphMarginLanes();
          this._context.configuration.setGlyphMarginDecorationLaneCount(e.requiredLanes);
        }
        Ll.onRenderStart();
      },
      renderText: () => {
        if (!this.domNode.domNode.isConnected)
          return null;
        let e = this._getViewPartsToRender();
        if (!this._viewLines.shouldRender() && e.length === 0)
          return null;
        const t = this._context.viewLayout.getLinesViewportData();
        this._context.viewModel.setViewport(t.startLineNumber, t.endLineNumber, t.centeredLineNumber);
        const i = new Yq(this._selections, t, this._context.viewLayout.getWhitespaceViewportData(), this._context.viewModel);
        return this._contentWidgets.shouldRender() && this._contentWidgets.onBeforeRender(i), this._viewLines.shouldRender() && (this._viewLines.renderText(i), this._viewLines.onDidRender(), e = this._getViewPartsToRender()), [e, new p$(this._context.viewLayout, i, this._viewLines)];
      },
      prepareRender: (e, t) => {
        for (const i of e)
          i.prepareRender(t);
      },
      render: (e, t) => {
        for (const i of e)
          i.render(t), i.onDidRender();
      }
    };
  }
  // --- BEGIN CodeEditor helpers
  delegateVerticalScrollbarPointerDown(e) {
    this._scrollbar.delegateVerticalScrollbarPointerDown(e);
  }
  delegateScrollFromMouseWheelEvent(e) {
    this._scrollbar.delegateScrollFromMouseWheelEvent(e);
  }
  restoreState(e) {
    this._context.viewModel.viewLayout.setScrollPosition(
      {
        scrollTop: e.scrollTop,
        scrollLeft: e.scrollLeft
      },
      1
      /* ScrollType.Immediate */
    ), this._context.viewModel.visibleLinesStabilized();
  }
  getOffsetForColumn(e, t) {
    const i = this._context.viewModel.model.validatePosition({
      lineNumber: e,
      column: t
    }), n = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(i);
    this._flushAccumulatedAndRenderNow();
    const o = this._viewLines.visibleRangeForPosition(new F(n.lineNumber, n.column));
    return o ? o.left : -1;
  }
  getTargetAtClientPoint(e, t) {
    const i = this._pointerHandler.getTargetAtClientPoint(e, t);
    return i ? Ew.convertViewToModelMouseTarget(i, this._context.viewModel.coordinatesConverter) : null;
  }
  createOverviewRuler(e) {
    return new Hq(this._context, e);
  }
  change(e) {
    this._viewZones.changeViewZones(e), this._scheduleRender();
  }
  render(e, t) {
    if (t) {
      this._viewLines.forceShouldRender();
      for (const i of this._viewParts)
        i.forceShouldRender();
    }
    e ? this._flushAccumulatedAndRenderNow() : this._scheduleRender();
  }
  writeScreenReaderContent(e) {
    this._textAreaHandler.writeScreenReaderContent(e);
  }
  focus() {
    this._textAreaHandler.focusTextArea();
  }
  isFocused() {
    return this._textAreaHandler.isFocused();
  }
  setAriaOptions(e) {
    this._textAreaHandler.setAriaOptions(e);
  }
  addContentWidget(e) {
    this._contentWidgets.addWidget(e.widget), this.layoutContentWidget(e), this._scheduleRender();
  }
  layoutContentWidget(e) {
    var t, i, n, o;
    this._contentWidgets.setWidgetPosition(e.widget, ((t = e.position) == null ? void 0 : t.position) ?? null, ((i = e.position) == null ? void 0 : i.secondaryPosition) ?? null, ((n = e.position) == null ? void 0 : n.preference) ?? null, ((o = e.position) == null ? void 0 : o.positionAffinity) ?? null), this._scheduleRender();
  }
  removeContentWidget(e) {
    this._contentWidgets.removeWidget(e.widget), this._scheduleRender();
  }
  addOverlayWidget(e) {
    this._overlayWidgets.addWidget(e.widget), this.layoutOverlayWidget(e), this._scheduleRender();
  }
  layoutOverlayWidget(e) {
    this._overlayWidgets.setWidgetPosition(e.widget, e.position) && this._scheduleRender();
  }
  removeOverlayWidget(e) {
    this._overlayWidgets.removeWidget(e.widget), this._scheduleRender();
  }
  addGlyphMarginWidget(e) {
    this._glyphMarginWidgets.addWidget(e.widget), this._shouldRecomputeGlyphMarginLanes = !0, this._scheduleRender();
  }
  layoutGlyphMarginWidget(e) {
    const t = e.position;
    this._glyphMarginWidgets.setWidgetPosition(e.widget, t) && (this._shouldRecomputeGlyphMarginLanes = !0, this._scheduleRender());
  }
  removeGlyphMarginWidget(e) {
    this._glyphMarginWidgets.removeWidget(e.widget), this._shouldRecomputeGlyphMarginLanes = !0, this._scheduleRender();
  }
};
oL = Jq([
  eG(6, Pe)
], oL);
function kl(s) {
  try {
    return s();
  } catch (e) {
    return Je(e), null;
  }
}
const ov = class ov {
  constructor() {
    this._coordinatedRenderings = [], this._animationFrameRunners = /* @__PURE__ */ new Map();
  }
  scheduleCoordinatedRendering(e) {
    return this._coordinatedRenderings.push(e), this._scheduleRender(e.window), {
      dispose: () => {
        const t = this._coordinatedRenderings.indexOf(e);
        if (t !== -1 && (this._coordinatedRenderings.splice(t, 1), this._coordinatedRenderings.length === 0)) {
          for (const [i, n] of this._animationFrameRunners)
            n.dispose();
          this._animationFrameRunners.clear();
        }
      }
    };
  }
  _scheduleRender(e) {
    if (!this._animationFrameRunners.has(e)) {
      const t = () => {
        this._animationFrameRunners.delete(e), this._onRenderScheduled();
      };
      this._animationFrameRunners.set(e, F4(e, t, 100));
    }
  }
  _onRenderScheduled() {
    const e = this._coordinatedRenderings.slice(0);
    this._coordinatedRenderings = [];
    for (const i of e)
      kl(() => i.prepareRenderText());
    const t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      t[i] = kl(() => o.renderText());
    }
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i], r = t[i];
      if (!r)
        continue;
      const [a, l] = r;
      kl(() => o.prepareRender(a, l));
    }
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i], r = t[i];
      if (!r)
        continue;
      const [a, l] = r;
      kl(() => o.render(a, l));
    }
  }
};
ov.INSTANCE = new ov();
let rL = ov;
class zg {
  constructor(e, t, i, n, o) {
    this.injectionOffsets = e, this.injectionOptions = t, this.breakOffsets = i, this.breakOffsetsVisibleColumn = n, this.wrappedTextIndentLength = o;
  }
  getOutputLineCount() {
    return this.breakOffsets.length;
  }
  getMinOutputOffset(e) {
    return e > 0 ? this.wrappedTextIndentLength : 0;
  }
  getLineLength(e) {
    const t = e > 0 ? this.breakOffsets[e - 1] : 0;
    let n = this.breakOffsets[e] - t;
    return e > 0 && (n += this.wrappedTextIndentLength), n;
  }
  getMaxOutputOffset(e) {
    return this.getLineLength(e);
  }
  translateToInputOffset(e, t) {
    e > 0 && (t = Math.max(0, t - this.wrappedTextIndentLength));
    let n = e === 0 ? t : this.breakOffsets[e - 1] + t;
    if (this.injectionOffsets !== null)
      for (let o = 0; o < this.injectionOffsets.length && n > this.injectionOffsets[o]; o++)
        n < this.injectionOffsets[o] + this.injectionOptions[o].content.length ? n = this.injectionOffsets[o] : n -= this.injectionOptions[o].content.length;
    return n;
  }
  translateToOutputPosition(e, t = 2) {
    let i = e;
    if (this.injectionOffsets !== null)
      for (let n = 0; n < this.injectionOffsets.length && !(e < this.injectionOffsets[n] || t !== 1 && e === this.injectionOffsets[n]); n++)
        i += this.injectionOptions[n].content.length;
    return this.offsetInInputWithInjectionsToOutputPosition(i, t);
  }
  offsetInInputWithInjectionsToOutputPosition(e, t = 2) {
    let i = 0, n = this.breakOffsets.length - 1, o = 0, r = 0;
    for (; i <= n; ) {
      o = i + (n - i) / 2 | 0;
      const l = this.breakOffsets[o];
      if (r = o > 0 ? this.breakOffsets[o - 1] : 0, t === 0)
        if (e <= r)
          n = o - 1;
        else if (e > l)
          i = o + 1;
        else
          break;
      else if (e < r)
        n = o - 1;
      else if (e >= l)
        i = o + 1;
      else
        break;
    }
    let a = e - r;
    return o > 0 && (a += this.wrappedTextIndentLength), new v_(o, a);
  }
  normalizeOutputPosition(e, t, i) {
    if (this.injectionOffsets !== null) {
      const n = this.outputPositionToOffsetInInputWithInjections(e, t), o = this.normalizeOffsetInInputWithInjectionsAroundInjections(n, i);
      if (o !== n)
        return this.offsetInInputWithInjectionsToOutputPosition(o, i);
    }
    if (i === 0) {
      if (e > 0 && t === this.getMinOutputOffset(e))
        return new v_(e - 1, this.getMaxOutputOffset(e - 1));
    } else if (i === 1) {
      const n = this.getOutputLineCount() - 1;
      if (e < n && t === this.getMaxOutputOffset(e))
        return new v_(e + 1, this.getMinOutputOffset(e + 1));
    }
    return new v_(e, t);
  }
  outputPositionToOffsetInInputWithInjections(e, t) {
    return e > 0 && (t = Math.max(0, t - this.wrappedTextIndentLength)), (e > 0 ? this.breakOffsets[e - 1] : 0) + t;
  }
  normalizeOffsetInInputWithInjectionsAroundInjections(e, t) {
    const i = this.getInjectedTextAtOffset(e);
    if (!i)
      return e;
    if (t === 2) {
      if (e === i.offsetInInputWithInjections + i.length && hM(this.injectionOptions[i.injectedTextIndex].cursorStops))
        return i.offsetInInputWithInjections + i.length;
      {
        let n = i.offsetInInputWithInjections;
        if (dM(this.injectionOptions[i.injectedTextIndex].cursorStops))
          return n;
        let o = i.injectedTextIndex - 1;
        for (; o >= 0 && this.injectionOffsets[o] === this.injectionOffsets[i.injectedTextIndex] && !(hM(this.injectionOptions[o].cursorStops) || (n -= this.injectionOptions[o].content.length, dM(this.injectionOptions[o].cursorStops))); )
          o--;
        return n;
      }
    } else if (t === 1 || t === 4) {
      let n = i.offsetInInputWithInjections + i.length, o = i.injectedTextIndex;
      for (; o + 1 < this.injectionOffsets.length && this.injectionOffsets[o + 1] === this.injectionOffsets[o]; )
        n += this.injectionOptions[o + 1].content.length, o++;
      return n;
    } else if (t === 0 || t === 3) {
      let n = i.offsetInInputWithInjections, o = i.injectedTextIndex;
      for (; o - 1 >= 0 && this.injectionOffsets[o - 1] === this.injectionOffsets[o]; )
        n -= this.injectionOptions[o - 1].content.length, o--;
      return n;
    }
    _E();
  }
  getInjectedText(e, t) {
    const i = this.outputPositionToOffsetInInputWithInjections(e, t), n = this.getInjectedTextAtOffset(i);
    return n ? {
      options: this.injectionOptions[n.injectedTextIndex]
    } : null;
  }
  getInjectedTextAtOffset(e) {
    const t = this.injectionOffsets, i = this.injectionOptions;
    if (t !== null) {
      let n = 0;
      for (let o = 0; o < t.length; o++) {
        const r = i[o].content.length, a = t[o] + n, l = t[o] + n + r;
        if (a > e)
          break;
        if (e <= l)
          return {
            injectedTextIndex: o,
            offsetInInputWithInjections: a,
            length: r
          };
        n += r;
      }
    }
  }
}
function hM(s) {
  return s == null ? !0 : s === Nr.Right || s === Nr.Both;
}
function dM(s) {
  return s == null ? !0 : s === Nr.Left || s === Nr.Both;
}
class v_ {
  constructor(e, t) {
    this.outputLineIndex = e, this.outputOffset = t;
  }
  toString() {
    return `${this.outputLineIndex}:${this.outputOffset}`;
  }
  toPosition(e) {
    return new F(e + this.outputLineIndex, this.outputOffset + 1);
  }
}
class tG {
  constructor() {
    this.changeType = 1;
  }
}
class Zo {
  static applyInjectedText(e, t) {
    if (!t || t.length === 0)
      return e;
    let i = "", n = 0;
    for (const o of t)
      i += e.substring(n, o.column - 1), n = o.column - 1, i += o.options.content;
    return i += e.substring(n), i;
  }
  static fromDecorations(e) {
    const t = [];
    for (const i of e)
      i.options.before && i.options.before.content.length > 0 && t.push(new Zo(i.ownerId, i.range.startLineNumber, i.range.startColumn, i.options.before, 0)), i.options.after && i.options.after.content.length > 0 && t.push(new Zo(i.ownerId, i.range.endLineNumber, i.range.endColumn, i.options.after, 1));
    return t.sort((i, n) => i.lineNumber === n.lineNumber ? i.column === n.column ? i.order - n.order : i.column - n.column : i.lineNumber - n.lineNumber), t;
  }
  constructor(e, t, i, n, o) {
    this.ownerId = e, this.lineNumber = t, this.column = i, this.options = n, this.order = o;
  }
}
class uM {
  constructor(e, t, i) {
    this.changeType = 2, this.lineNumber = e, this.detail = t, this.injectedText = i;
  }
}
class iG {
  constructor(e, t) {
    this.changeType = 3, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class nG {
  constructor(e, t, i, n) {
    this.changeType = 4, this.injectedTexts = n, this.fromLineNumber = e, this.toLineNumber = t, this.detail = i;
  }
}
class sG {
  constructor() {
    this.changeType = 5;
  }
}
class Bu {
  constructor(e, t, i, n) {
    this.changes = e, this.versionId = t, this.isUndoing = i, this.isRedoing = n, this.resultingSelection = null;
  }
  containsEvent(e) {
    for (let t = 0, i = this.changes.length; t < i; t++)
      if (this.changes[t].changeType === e)
        return !0;
    return !1;
  }
  static merge(e, t) {
    const i = [].concat(e.changes).concat(t.changes), n = t.versionId, o = e.isUndoing || t.isUndoing, r = e.isRedoing || t.isRedoing;
    return new Bu(i, n, o, r);
  }
}
class iF {
  constructor(e) {
    this.changes = e;
  }
}
class fh {
  constructor(e, t) {
    this.rawContentChangedEvent = e, this.contentChangedEvent = t;
  }
  merge(e) {
    const t = Bu.merge(this.rawContentChangedEvent, e.rawContentChangedEvent), i = fh._mergeChangeEvents(this.contentChangedEvent, e.contentChangedEvent);
    return new fh(t, i);
  }
  static _mergeChangeEvents(e, t) {
    const i = [].concat(e.changes).concat(t.changes), n = t.eol, o = t.versionId, r = e.isUndoing || t.isUndoing, a = e.isRedoing || t.isRedoing, l = e.isFlush || t.isFlush, c = e.isEolChange && t.isEolChange;
    return {
      changes: i,
      eol: n,
      isEolChange: c,
      versionId: o,
      isUndoing: r,
      isRedoing: a,
      isFlush: l
    };
  }
}
const U0 = ud("domLineBreaksComputer", { createHTML: (s) => s });
class EI {
  static create(e) {
    return new EI(new WeakRef(e));
  }
  constructor(e) {
    this.targetWindow = e;
  }
  createLineBreaksComputer(e, t, i, n, o) {
    const r = [], a = [];
    return {
      addRequest: (l, c, h) => {
        r.push(l), a.push(c);
      },
      finalize: () => oG(r4(this.targetWindow.deref()), r, e, t, i, n, o, a)
    };
  }
}
function oG(s, e, t, i, n, o, r, a) {
  function l(I) {
    const K = a[I];
    if (K) {
      const B = Zo.applyInjectedText(e[I], K), W = K.map((P) => P.options), H = K.map((P) => P.column - 1);
      return new zg(H, W, [B.length], [], 0);
    } else
      return null;
  }
  if (n === -1) {
    const I = [];
    for (let K = 0, B = e.length; K < B; K++)
      I[K] = l(K);
    return I;
  }
  const c = Math.round(n * t.typicalHalfwidthCharacterWidth), d = Math.round(i * (o === 3 ? 2 : o === 2 ? 1 : 0)), u = Math.ceil(t.spaceWidth * d), f = document.createElement("div");
  Zi(f, t);
  const g = new ww(1e4), p = [], _ = [], b = [], C = [], w = [];
  for (let I = 0; I < e.length; I++) {
    const K = Zo.applyInjectedText(e[I], a[I]);
    let B = 0, W = 0, H = c;
    if (o !== 0)
      if (B = Zn(K), B === -1)
        B = 0;
      else {
        for (let oe = 0; oe < B; oe++) {
          const ae = K.charCodeAt(oe) === 9 ? i - W % i : 1;
          W += ae;
        }
        const J = Math.ceil(t.spaceWidth * W);
        J + t.typicalFullwidthCharacterWidth > c ? (B = 0, W = 0) : H = c - J;
      }
    const P = K.substr(B), q = rG(P, W, i, H, g, u);
    p[I] = B, _[I] = W, b[I] = P, C[I] = q[0], w[I] = q[1];
  }
  const v = g.build(), S = (U0 == null ? void 0 : U0.createHTML(v)) ?? v;
  f.innerHTML = S, f.style.position = "absolute", f.style.top = "10000", r === "keepAll" ? (f.style.wordBreak = "keep-all", f.style.overflowWrap = "anywhere") : (f.style.wordBreak = "inherit", f.style.overflowWrap = "break-word"), s.document.body.appendChild(f);
  const L = document.createRange(), k = Array.prototype.slice.call(f.children, 0), x = [];
  for (let I = 0; I < e.length; I++) {
    const K = k[I], B = aG(L, K, b[I], C[I]);
    if (B === null) {
      x[I] = l(I);
      continue;
    }
    const W = p[I], H = _[I] + d, P = w[I], q = [];
    for (let re = 0, be = B.length; re < be; re++)
      q[re] = P[B[re]];
    if (W !== 0)
      for (let re = 0, be = B.length; re < be; re++)
        B[re] += W;
    let J, oe;
    const ae = a[I];
    ae ? (J = ae.map((re) => re.options), oe = ae.map((re) => re.column - 1)) : (J = null, oe = null), x[I] = new zg(oe, J, B, q, H);
  }
  return f.remove(), x;
}
function rG(s, e, t, i, n, o) {
  if (o !== 0) {
    const u = String(o);
    n.appendString('<div style="text-indent: -'), n.appendString(u), n.appendString("px; padding-left: "), n.appendString(u), n.appendString("px; box-sizing: border-box; width:");
  } else
    n.appendString('<div style="width:');
  n.appendString(String(i)), n.appendString('px;">');
  const r = s.length;
  let a = e, l = 0;
  const c = [], h = [];
  let d = 0 < r ? s.charCodeAt(0) : 0;
  n.appendString("<span>");
  for (let u = 0; u < r; u++) {
    u !== 0 && u % 16384 === 0 && n.appendString("</span><span>"), c[u] = l, h[u] = a;
    const f = d;
    d = u + 1 < r ? s.charCodeAt(u + 1) : 0;
    let g = 1, p = 1;
    switch (f) {
      case 9:
        g = t - a % t, p = g;
        for (let _ = 1; _ <= g; _++)
          _ < g ? n.appendCharCode(160) : n.appendASCIICharCode(
            32
            /* CharCode.Space */
          );
        break;
      case 32:
        d === 32 ? n.appendCharCode(160) : n.appendASCIICharCode(
          32
          /* CharCode.Space */
        );
        break;
      case 60:
        n.appendString("&lt;");
        break;
      case 62:
        n.appendString("&gt;");
        break;
      case 38:
        n.appendString("&amp;");
        break;
      case 0:
        n.appendString("&#00;");
        break;
      case 65279:
      case 8232:
      case 8233:
      case 133:
        n.appendCharCode(65533);
        break;
      default:
        jl(f) && p++, f < 32 ? n.appendCharCode(9216 + f) : n.appendCharCode(f);
    }
    l += g, a += p;
  }
  return n.appendString("</span>"), c[s.length] = l, h[s.length] = a, n.appendString("</div>"), [c, h];
}
function aG(s, e, t, i) {
  if (t.length <= 1)
    return null;
  const n = Array.prototype.slice.call(e.children, 0), o = [];
  try {
    aL(s, n, i, 0, null, t.length - 1, null, o);
  } catch (r) {
    return console.log(r), null;
  }
  return o.length === 0 ? null : (o.push(t.length), o);
}
function aL(s, e, t, i, n, o, r, a) {
  if (i === o || (n = n || $0(s, e, t[i], t[i + 1]), r = r || $0(s, e, t[o], t[o + 1]), Math.abs(n[0].top - r[0].top) <= 0.1))
    return;
  if (i + 1 === o) {
    a.push(o);
    return;
  }
  const l = i + (o - i) / 2 | 0, c = $0(s, e, t[l], t[l + 1]);
  aL(s, e, t, i, n, l, c, a), aL(s, e, t, l, c, o, r, a);
}
function $0(s, e, t, i) {
  return s.setStart(
    e[t / 16384 | 0].firstChild,
    t % 16384
    /* Constants.SPAN_MODULO_LIMIT */
  ), s.setEnd(
    e[i / 16384 | 0].firstChild,
    i % 16384
    /* Constants.SPAN_MODULO_LIMIT */
  ), s.getClientRects();
}
class lG extends U {
  constructor() {
    super(), this._editor = null, this._instantiationService = null, this._instances = this._register(new rE()), this._pending = /* @__PURE__ */ new Map(), this._finishedInstantiation = [], this._finishedInstantiation[
      0
      /* EditorContributionInstantiation.Eager */
    ] = !1, this._finishedInstantiation[
      1
      /* EditorContributionInstantiation.AfterFirstRender */
    ] = !1, this._finishedInstantiation[
      2
      /* EditorContributionInstantiation.BeforeFirstInteraction */
    ] = !1, this._finishedInstantiation[
      3
      /* EditorContributionInstantiation.Eventually */
    ] = !1;
  }
  initialize(e, t, i) {
    this._editor = e, this._instantiationService = i;
    for (const n of t) {
      if (this._pending.has(n.id)) {
        Je(new Error(`Cannot have two contributions with the same id ${n.id}`));
        continue;
      }
      this._pending.set(n.id, n);
    }
    this._instantiateSome(
      0
      /* EditorContributionInstantiation.Eager */
    ), this._register(a_(fe(this._editor.getDomNode()), () => {
      this._instantiateSome(
        1
        /* EditorContributionInstantiation.AfterFirstRender */
      );
    })), this._register(a_(fe(this._editor.getDomNode()), () => {
      this._instantiateSome(
        2
        /* EditorContributionInstantiation.BeforeFirstInteraction */
      );
    })), this._register(a_(fe(this._editor.getDomNode()), () => {
      this._instantiateSome(
        3
        /* EditorContributionInstantiation.Eventually */
      );
    }, 5e3));
  }
  saveViewState() {
    const e = {};
    for (const [t, i] of this._instances)
      typeof i.saveViewState == "function" && (e[t] = i.saveViewState());
    return e;
  }
  restoreViewState(e) {
    for (const [t, i] of this._instances)
      typeof i.restoreViewState == "function" && i.restoreViewState(e[t]);
  }
  get(e) {
    return this._instantiateById(e), this._instances.get(e) || null;
  }
  onBeforeInteractionEvent() {
    this._instantiateSome(
      2
      /* EditorContributionInstantiation.BeforeFirstInteraction */
    );
  }
  onAfterModelAttached() {
    var e;
    return a_(fe((e = this._editor) == null ? void 0 : e.getDomNode()), () => {
      this._instantiateSome(
        1
        /* EditorContributionInstantiation.AfterFirstRender */
      );
    }, 50);
  }
  _instantiateSome(e) {
    if (this._finishedInstantiation[e])
      return;
    this._finishedInstantiation[e] = !0;
    const t = this._findPendingContributionsByInstantiation(e);
    for (const i of t)
      this._instantiateById(i.id);
  }
  _findPendingContributionsByInstantiation(e) {
    const t = [];
    for (const [, i] of this._pending)
      i.instantiation === e && t.push(i);
    return t;
  }
  _instantiateById(e) {
    const t = this._pending.get(e);
    if (t) {
      if (this._pending.delete(e), !this._instantiationService || !this._editor)
        throw new Error("Cannot instantiate contributions before being initialized!");
      try {
        const i = this._instantiationService.createInstance(t.ctor, this._editor);
        this._instances.set(t.id, i), typeof i.restoreViewState == "function" && t.instantiation !== 0 && console.warn(`Editor contribution '${t.id}' should be eager instantiated because it uses saveViewState / restoreViewState.`);
      } catch (i) {
        Je(i);
      }
    }
  }
}
class nF {
  constructor(e, t, i, n, o, r, a) {
    this.id = e, this.label = t, this.alias = i, this.metadata = n, this._precondition = o, this._run = r, this._contextKeyService = a;
  }
  isSupported() {
    return this._contextKeyService.contextMatchesRules(this._precondition);
  }
  run(e) {
    return this.isSupported() ? this._run(e) : Promise.resolve(void 0);
  }
}
const Iw = {
  ICodeEditor: "vs.editor.ICodeEditor",
  IDiffEditor: "vs.editor.IDiffEditor"
};
function pf(s) {
  let e = 0, t = 0, i = 0, n = 0;
  for (let o = 0, r = s.length; o < r; o++) {
    const a = s.charCodeAt(o);
    a === 13 ? (e === 0 && (t = o), e++, o + 1 < r && s.charCodeAt(o + 1) === 10 ? (n |= 2, o++) : n |= 3, i = o + 1) : a === 10 && (n |= 1, e === 0 && (t = o), e++, i = o + 1);
  }
  return e === 0 && (t = s.length), [e, t, s.length - i, n];
}
class fM {
  constructor(e, t, i, n) {
    this.range = e, this.nestingLevel = t, this.nestingLevelOfEqualBracketType = i, this.isInvalid = n;
  }
}
class cG {
  constructor(e, t, i, n, o, r) {
    this.range = e, this.openingBracketRange = t, this.closingBracketRange = i, this.nestingLevel = n, this.nestingLevelOfEqualBracketType = o, this.bracketPairNode = r;
  }
  get openingBracketInfo() {
    return this.bracketPairNode.openingBracket.bracketInfo;
  }
}
class hG extends cG {
  constructor(e, t, i, n, o, r, a) {
    super(e, t, i, n, o, r), this.minVisibleColumnIndentation = a;
  }
}
const gl = class gl {
  static betweenPositions(e, t) {
    return e.lineNumber === t.lineNumber ? new gl(0, t.column - e.column) : new gl(t.lineNumber - e.lineNumber, t.column - 1);
  }
  static ofRange(e) {
    return gl.betweenPositions(e.getStartPosition(), e.getEndPosition());
  }
  static ofText(e) {
    let t = 0, i = 0;
    for (const n of e)
      n === `
` ? (t++, i = 0) : i++;
    return new gl(t, i);
  }
  constructor(e, t) {
    this.lineCount = e, this.columnCount = t;
  }
  isGreaterThanOrEqualTo(e) {
    return this.lineCount !== e.lineCount ? this.lineCount > e.lineCount : this.columnCount >= e.columnCount;
  }
  createRange(e) {
    return this.lineCount === 0 ? new T(e.lineNumber, e.column, e.lineNumber, e.column + this.columnCount) : new T(e.lineNumber, e.column, e.lineNumber + this.lineCount, this.columnCount + 1);
  }
  addToPosition(e) {
    return this.lineCount === 0 ? new F(e.lineNumber, e.column + this.columnCount) : new F(e.lineNumber + this.lineCount, this.columnCount + 1);
  }
  toString() {
    return `${this.lineCount},${this.columnCount}`;
  }
};
gl.zero = new gl(0, 0);
let Xl = gl;
function dG(s, e, t, i) {
  return s !== t ? ei(t - s, i) : ei(0, i - e);
}
const Mn = 0;
function E1(s) {
  return s === 0;
}
const ws = 2 ** 26;
function ei(s, e) {
  return s * ws + e;
}
function Bs(s) {
  const e = s, t = Math.floor(e / ws), i = e - t * ws;
  return new Xl(t, i);
}
function uG(s) {
  return Math.floor(s / ws);
}
function hi(s, e) {
  let t = s + e;
  return e >= ws && (t = t - s % ws), t;
}
function fG(s, e) {
  return s.reduce((t, i) => hi(t, e(i)), Mn);
}
function sF(s, e) {
  return s === e;
}
function Xm(s, e) {
  const t = s, i = e;
  if (i - t <= 0)
    return Mn;
  const o = Math.floor(t / ws), r = Math.floor(i / ws), a = i - r * ws;
  if (o === r) {
    const l = t - o * ws;
    return ei(0, a - l);
  } else
    return ei(r - o, a);
}
function Wu(s, e) {
  return s < e;
}
function Hu(s, e) {
  return s <= e;
}
function wg(s, e) {
  return s >= e;
}
function su(s) {
  return ei(s.lineNumber - 1, s.column - 1);
}
function gh(s, e) {
  const t = s, i = Math.floor(t / ws), n = t - i * ws, o = e, r = Math.floor(o / ws), a = o - r * ws;
  return new T(i + 1, n + 1, r + 1, a + 1);
}
function gG(s) {
  const e = td(s);
  return ei(e.length - 1, e[e.length - 1].length);
}
class Ia {
  static fromModelContentChanges(e) {
    return e.map((i) => {
      const n = T.lift(i.range);
      return new Ia(su(n.getStartPosition()), su(n.getEndPosition()), gG(i.text));
    }).reverse();
  }
  constructor(e, t, i) {
    this.startOffset = e, this.endOffset = t, this.newLength = i;
  }
  toString() {
    return `[${Bs(this.startOffset)}...${Bs(this.endOffset)}) -> ${Bs(this.newLength)}`;
  }
}
class mG {
  /**
   * @param edits Must be sorted by offset in ascending order.
  */
  constructor(e) {
    this.nextEditIdx = 0, this.deltaOldToNewLineCount = 0, this.deltaOldToNewColumnCount = 0, this.deltaLineIdxInOld = -1, this.edits = e.map((t) => II.from(t));
  }
  /**
   * @param offset Must be equal to or greater than the last offset this method has been called with.
  */
  getOffsetBeforeChange(e) {
    return this.adjustNextEdit(e), this.translateCurToOld(e);
  }
  /**
   * @param offset Must be equal to or greater than the last offset this method has been called with.
   * Returns null if there is no edit anymore.
  */
  getDistanceToNextChange(e) {
    this.adjustNextEdit(e);
    const t = this.edits[this.nextEditIdx], i = t ? this.translateOldToCur(t.offsetObj) : null;
    return i === null ? null : Xm(e, i);
  }
  translateOldToCur(e) {
    return e.lineCount === this.deltaLineIdxInOld ? ei(e.lineCount + this.deltaOldToNewLineCount, e.columnCount + this.deltaOldToNewColumnCount) : ei(e.lineCount + this.deltaOldToNewLineCount, e.columnCount);
  }
  translateCurToOld(e) {
    const t = Bs(e);
    return t.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld ? ei(t.lineCount - this.deltaOldToNewLineCount, t.columnCount - this.deltaOldToNewColumnCount) : ei(t.lineCount - this.deltaOldToNewLineCount, t.columnCount);
  }
  adjustNextEdit(e) {
    for (; this.nextEditIdx < this.edits.length; ) {
      const t = this.edits[this.nextEditIdx], i = this.translateOldToCur(t.endOffsetAfterObj);
      if (Hu(i, e)) {
        this.nextEditIdx++;
        const n = Bs(i), o = Bs(this.translateOldToCur(t.endOffsetBeforeObj)), r = n.lineCount - o.lineCount;
        this.deltaOldToNewLineCount += r;
        const a = this.deltaLineIdxInOld === t.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0, l = n.columnCount - o.columnCount;
        this.deltaOldToNewColumnCount = a + l, this.deltaLineIdxInOld = t.endOffsetBeforeObj.lineCount;
      } else
        break;
    }
  }
}
class II {
  static from(e) {
    return new II(e.startOffset, e.endOffset, e.newLength);
  }
  constructor(e, t, i) {
    this.endOffsetBeforeObj = Bs(t), this.endOffsetAfterObj = Bs(hi(e, i)), this.offsetObj = Bs(e);
  }
}
const w_ = [], Ns = class Ns {
  static create(e, t) {
    if (e <= 128 && t.length === 0) {
      let i = Ns.cache[e];
      return i || (i = new Ns(e, t), Ns.cache[e] = i), i;
    }
    return new Ns(e, t);
  }
  static getEmpty() {
    return this.empty;
  }
  constructor(e, t) {
    this.items = e, this.additionalItems = t;
  }
  add(e, t) {
    const i = t.getKey(e);
    let n = i >> 5;
    if (n === 0) {
      const r = 1 << i | this.items;
      return r === this.items ? this : Ns.create(r, this.additionalItems);
    }
    n--;
    const o = this.additionalItems.slice(0);
    for (; o.length < n; )
      o.push(0);
    return o[n] |= 1 << (i & 31), Ns.create(this.items, o);
  }
  merge(e) {
    const t = this.items | e.items;
    if (this.additionalItems === w_ && e.additionalItems === w_)
      return t === this.items ? this : t === e.items ? e : Ns.create(t, w_);
    const i = [];
    for (let n = 0; n < Math.max(this.additionalItems.length, e.additionalItems.length); n++) {
      const o = this.additionalItems[n] || 0, r = e.additionalItems[n] || 0;
      i.push(o | r);
    }
    return Ns.create(t, i);
  }
  intersects(e) {
    if ((this.items & e.items) !== 0)
      return !0;
    for (let t = 0; t < Math.min(this.additionalItems.length, e.additionalItems.length); t++)
      if ((this.additionalItems[t] & e.additionalItems[t]) !== 0)
        return !0;
    return !1;
  }
};
Ns.cache = new Array(129), Ns.empty = Ns.create(0, w_);
let Gn = Ns;
const gM = {
  getKey(s) {
    return s;
  }
};
class pG {
  constructor() {
    this.items = /* @__PURE__ */ new Map();
  }
  getKey(e) {
    let t = this.items.get(e);
    return t === void 0 && (t = this.items.size, this.items.set(e, t)), t;
  }
}
class NI {
  /**
   * The length of the entire node, which should equal the sum of lengths of all children.
  */
  get length() {
    return this._length;
  }
  constructor(e) {
    this._length = e;
  }
}
class Qm extends NI {
  static create(e, t, i) {
    let n = e.length;
    return t && (n = hi(n, t.length)), i && (n = hi(n, i.length)), new Qm(n, e, t, i, t ? t.missingOpeningBracketIds : Gn.getEmpty());
  }
  get kind() {
    return 2;
  }
  get listHeight() {
    return 0;
  }
  get childrenLength() {
    return 3;
  }
  getChild(e) {
    switch (e) {
      case 0:
        return this.openingBracket;
      case 1:
        return this.child;
      case 2:
        return this.closingBracket;
    }
    throw new Error("Invalid child index");
  }
  /**
   * Avoid using this property, it allocates an array!
  */
  get children() {
    const e = [];
    return e.push(this.openingBracket), this.child && e.push(this.child), this.closingBracket && e.push(this.closingBracket), e;
  }
  constructor(e, t, i, n, o) {
    super(e), this.openingBracket = t, this.child = i, this.closingBracket = n, this.missingOpeningBracketIds = o;
  }
  canBeReused(e) {
    return !(this.closingBracket === null || e.intersects(this.missingOpeningBracketIds));
  }
  deepClone() {
    return new Qm(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);
  }
  computeMinIndentation(e, t) {
    return this.child ? this.child.computeMinIndentation(hi(e, this.openingBracket.length), t) : Number.MAX_SAFE_INTEGER;
  }
}
class Hr extends NI {
  /**
   * This method uses more memory-efficient list nodes that can only store 2 or 3 children.
  */
  static create23(e, t, i, n = !1) {
    let o = e.length, r = e.missingOpeningBracketIds;
    if (e.listHeight !== t.listHeight)
      throw new Error("Invalid list heights");
    if (o = hi(o, t.length), r = r.merge(t.missingOpeningBracketIds), i) {
      if (e.listHeight !== i.listHeight)
        throw new Error("Invalid list heights");
      o = hi(o, i.length), r = r.merge(i.missingOpeningBracketIds);
    }
    return n ? new _G(o, e.listHeight + 1, e, t, i, r) : new Jm(o, e.listHeight + 1, e, t, i, r);
  }
  static getEmpty() {
    return new bG(Mn, 0, [], Gn.getEmpty());
  }
  get kind() {
    return 4;
  }
  get missingOpeningBracketIds() {
    return this._missingOpeningBracketIds;
  }
  /**
   * Use ListAstNode.create.
  */
  constructor(e, t, i) {
    super(e), this.listHeight = t, this._missingOpeningBracketIds = i, this.cachedMinIndentation = -1;
  }
  throwIfImmutable() {
  }
  makeLastElementMutable() {
    this.throwIfImmutable();
    const e = this.childrenLength;
    if (e === 0)
      return;
    const t = this.getChild(e - 1), i = t.kind === 4 ? t.toMutable() : t;
    return t !== i && this.setChild(e - 1, i), i;
  }
  makeFirstElementMutable() {
    if (this.throwIfImmutable(), this.childrenLength === 0)
      return;
    const t = this.getChild(0), i = t.kind === 4 ? t.toMutable() : t;
    return t !== i && this.setChild(0, i), i;
  }
  canBeReused(e) {
    if (e.intersects(this.missingOpeningBracketIds) || this.childrenLength === 0)
      return !1;
    let t = this;
    for (; t.kind === 4; ) {
      const i = t.childrenLength;
      if (i === 0)
        throw new at();
      t = t.getChild(i - 1);
    }
    return t.canBeReused(e);
  }
  handleChildrenChanged() {
    this.throwIfImmutable();
    const e = this.childrenLength;
    let t = this.getChild(0).length, i = this.getChild(0).missingOpeningBracketIds;
    for (let n = 1; n < e; n++) {
      const o = this.getChild(n);
      t = hi(t, o.length), i = i.merge(o.missingOpeningBracketIds);
    }
    this._length = t, this._missingOpeningBracketIds = i, this.cachedMinIndentation = -1;
  }
  computeMinIndentation(e, t) {
    if (this.cachedMinIndentation !== -1)
      return this.cachedMinIndentation;
    let i = Number.MAX_SAFE_INTEGER, n = e;
    for (let o = 0; o < this.childrenLength; o++) {
      const r = this.getChild(o);
      r && (i = Math.min(i, r.computeMinIndentation(n, t)), n = hi(n, r.length));
    }
    return this.cachedMinIndentation = i, i;
  }
}
class Jm extends Hr {
  get childrenLength() {
    return this._item3 !== null ? 3 : 2;
  }
  getChild(e) {
    switch (e) {
      case 0:
        return this._item1;
      case 1:
        return this._item2;
      case 2:
        return this._item3;
    }
    throw new Error("Invalid child index");
  }
  setChild(e, t) {
    switch (e) {
      case 0:
        this._item1 = t;
        return;
      case 1:
        this._item2 = t;
        return;
      case 2:
        this._item3 = t;
        return;
    }
    throw new Error("Invalid child index");
  }
  get children() {
    return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];
  }
  get item1() {
    return this._item1;
  }
  get item2() {
    return this._item2;
  }
  get item3() {
    return this._item3;
  }
  constructor(e, t, i, n, o, r) {
    super(e, t, r), this._item1 = i, this._item2 = n, this._item3 = o;
  }
  deepClone() {
    return new Jm(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);
  }
  appendChildOfSameHeight(e) {
    if (this._item3)
      throw new Error("Cannot append to a full (2,3) tree node");
    this.throwIfImmutable(), this._item3 = e, this.handleChildrenChanged();
  }
  unappendChild() {
    if (!this._item3)
      throw new Error("Cannot remove from a non-full (2,3) tree node");
    this.throwIfImmutable();
    const e = this._item3;
    return this._item3 = null, this.handleChildrenChanged(), e;
  }
  prependChildOfSameHeight(e) {
    if (this._item3)
      throw new Error("Cannot prepend to a full (2,3) tree node");
    this.throwIfImmutable(), this._item3 = this._item2, this._item2 = this._item1, this._item1 = e, this.handleChildrenChanged();
  }
  unprependChild() {
    if (!this._item3)
      throw new Error("Cannot remove from a non-full (2,3) tree node");
    this.throwIfImmutable();
    const e = this._item1;
    return this._item1 = this._item2, this._item2 = this._item3, this._item3 = null, this.handleChildrenChanged(), e;
  }
  toMutable() {
    return this;
  }
}
class _G extends Jm {
  toMutable() {
    return new Jm(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);
  }
  throwIfImmutable() {
    throw new Error("this instance is immutable");
  }
}
class I1 extends Hr {
  get childrenLength() {
    return this._children.length;
  }
  getChild(e) {
    return this._children[e];
  }
  setChild(e, t) {
    this._children[e] = t;
  }
  get children() {
    return this._children;
  }
  constructor(e, t, i, n) {
    super(e, t, n), this._children = i;
  }
  deepClone() {
    const e = new Array(this._children.length);
    for (let t = 0; t < this._children.length; t++)
      e[t] = this._children[t].deepClone();
    return new I1(this.length, this.listHeight, e, this.missingOpeningBracketIds);
  }
  appendChildOfSameHeight(e) {
    this.throwIfImmutable(), this._children.push(e), this.handleChildrenChanged();
  }
  unappendChild() {
    this.throwIfImmutable();
    const e = this._children.pop();
    return this.handleChildrenChanged(), e;
  }
  prependChildOfSameHeight(e) {
    this.throwIfImmutable(), this._children.unshift(e), this.handleChildrenChanged();
  }
  unprependChild() {
    this.throwIfImmutable();
    const e = this._children.shift();
    return this.handleChildrenChanged(), e;
  }
  toMutable() {
    return this;
  }
}
class bG extends I1 {
  toMutable() {
    return new I1(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);
  }
  throwIfImmutable() {
    throw new Error("this instance is immutable");
  }
}
const CG = [];
class TI extends NI {
  get listHeight() {
    return 0;
  }
  get childrenLength() {
    return 0;
  }
  getChild(e) {
    return null;
  }
  get children() {
    return CG;
  }
  deepClone() {
    return this;
  }
}
class Rc extends TI {
  get kind() {
    return 0;
  }
  get missingOpeningBracketIds() {
    return Gn.getEmpty();
  }
  canBeReused(e) {
    return !0;
  }
  computeMinIndentation(e, t) {
    const i = Bs(e), n = (i.columnCount === 0 ? i.lineCount : i.lineCount + 1) + 1, o = uG(hi(e, this.length)) + 1;
    let r = Number.MAX_SAFE_INTEGER;
    for (let a = n; a <= o; a++) {
      const l = t.getLineFirstNonWhitespaceColumn(a), c = t.getLineContent(a);
      if (l === 0)
        continue;
      const h = pi.visibleColumnFromColumn(c, l, t.getOptions().tabSize);
      r = Math.min(r, h);
    }
    return r;
  }
}
class N1 extends TI {
  static create(e, t, i) {
    return new N1(e, t, i);
  }
  get kind() {
    return 1;
  }
  get missingOpeningBracketIds() {
    return Gn.getEmpty();
  }
  constructor(e, t, i) {
    super(e), this.bracketInfo = t, this.bracketIds = i;
  }
  get text() {
    return this.bracketInfo.bracketText;
  }
  get languageId() {
    return this.bracketInfo.languageId;
  }
  canBeReused(e) {
    return !1;
  }
  computeMinIndentation(e, t) {
    return Number.MAX_SAFE_INTEGER;
  }
}
class vG extends TI {
  get kind() {
    return 3;
  }
  constructor(e, t) {
    super(t), this.missingOpeningBracketIds = e;
  }
  canBeReused(e) {
    return !e.intersects(this.missingOpeningBracketIds);
  }
  computeMinIndentation(e, t) {
    return Number.MAX_SAFE_INTEGER;
  }
}
class bl {
  constructor(e, t, i, n, o) {
    this.length = e, this.kind = t, this.bracketId = i, this.bracketIds = n, this.astNode = o;
  }
}
class wG {
  constructor(e, t) {
    this.textModel = e, this.bracketTokens = t, this.reader = new yG(this.textModel, this.bracketTokens), this._offset = Mn, this.didPeek = !1, this.peeked = null, this.textBufferLineCount = e.getLineCount(), this.textBufferLastLineLength = e.getLineLength(this.textBufferLineCount);
  }
  get offset() {
    return this._offset;
  }
  get length() {
    return ei(this.textBufferLineCount - 1, this.textBufferLastLineLength);
  }
  skip(e) {
    this.didPeek = !1, this._offset = hi(this._offset, e);
    const t = Bs(this._offset);
    this.reader.setPosition(t.lineCount, t.columnCount);
  }
  read() {
    let e;
    return this.peeked ? (this.didPeek = !1, e = this.peeked) : e = this.reader.read(), e && (this._offset = hi(this._offset, e.length)), e;
  }
  peek() {
    return this.didPeek || (this.peeked = this.reader.read(), this.didPeek = !0), this.peeked;
  }
}
class yG {
  constructor(e, t) {
    this.textModel = e, this.bracketTokens = t, this.lineIdx = 0, this.line = null, this.lineCharOffset = 0, this.lineTokens = null, this.lineTokenOffset = 0, this.peekedToken = null, this.textBufferLineCount = e.getLineCount(), this.textBufferLastLineLength = e.getLineLength(this.textBufferLineCount);
  }
  setPosition(e, t) {
    e === this.lineIdx ? (this.lineCharOffset = t, this.line !== null && (this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset))) : (this.lineIdx = e, this.lineCharOffset = t, this.line = null), this.peekedToken = null;
  }
  read() {
    if (this.peekedToken) {
      const o = this.peekedToken;
      return this.peekedToken = null, this.lineCharOffset += o.length, o;
    }
    if (this.lineIdx > this.textBufferLineCount - 1 || this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)
      return null;
    this.line === null && (this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1), this.line = this.lineTokens.getLineContent(), this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset));
    const e = this.lineIdx, t = this.lineCharOffset;
    let i = 0;
    for (; ; ) {
      const o = this.lineTokens, r = o.getCount();
      let a = null;
      if (this.lineTokenOffset < r) {
        const l = o.getMetadata(this.lineTokenOffset);
        for (; this.lineTokenOffset + 1 < r && l === o.getMetadata(this.lineTokenOffset + 1); )
          this.lineTokenOffset++;
        const c = Bo.getTokenType(l) === 0, h = Bo.containsBalancedBrackets(l), d = o.getEndOffset(this.lineTokenOffset);
        if (h && c && this.lineCharOffset < d) {
          const u = o.getLanguageId(this.lineTokenOffset), f = this.line.substring(this.lineCharOffset, d), g = this.bracketTokens.getSingleLanguageBracketTokens(u), p = g.regExpGlobal;
          if (p) {
            p.lastIndex = 0;
            const _ = p.exec(f);
            _ && (a = g.getToken(_[0]), a && (this.lineCharOffset += _.index));
          }
        }
        if (i += d - this.lineCharOffset, a)
          if (e !== this.lineIdx || t !== this.lineCharOffset) {
            this.peekedToken = a;
            break;
          } else
            return this.lineCharOffset += a.length, a;
        else
          this.lineTokenOffset++, this.lineCharOffset = d;
      } else if (this.lineIdx === this.textBufferLineCount - 1 || (this.lineIdx++, this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1), this.lineTokenOffset = 0, this.line = this.lineTokens.getLineContent(), this.lineCharOffset = 0, i += 33, i > 1e3))
        break;
      if (i > 1500)
        break;
    }
    const n = dG(e, t, this.lineIdx, this.lineCharOffset);
    return new bl(n, 0, -1, Gn.getEmpty(), new Rc(n));
  }
}
class SG {
  constructor(e, t) {
    this.text = e, this._offset = Mn, this.idx = 0;
    const i = t.getRegExpStr(), n = i ? new RegExp(i + `|
`, "gi") : null, o = [];
    let r, a = 0, l = 0, c = 0, h = 0;
    const d = [];
    for (let g = 0; g < 60; g++)
      d.push(new bl(ei(0, g), 0, -1, Gn.getEmpty(), new Rc(ei(0, g))));
    const u = [];
    for (let g = 0; g < 60; g++)
      u.push(new bl(ei(1, g), 0, -1, Gn.getEmpty(), new Rc(ei(1, g))));
    if (n)
      for (n.lastIndex = 0; (r = n.exec(e)) !== null; ) {
        const g = r.index, p = r[0];
        if (p === `
`)
          a++, l = g + 1;
        else {
          if (c !== g) {
            let _;
            if (h === a) {
              const b = g - c;
              if (b < d.length)
                _ = d[b];
              else {
                const C = ei(0, b);
                _ = new bl(C, 0, -1, Gn.getEmpty(), new Rc(C));
              }
            } else {
              const b = a - h, C = g - l;
              if (b === 1 && C < u.length)
                _ = u[C];
              else {
                const w = ei(b, C);
                _ = new bl(w, 0, -1, Gn.getEmpty(), new Rc(w));
              }
            }
            o.push(_);
          }
          o.push(t.getToken(p)), c = g + p.length, h = a;
        }
      }
    const f = e.length;
    if (c !== f) {
      const g = h === a ? ei(0, f - c) : ei(a - h, f - l);
      o.push(new bl(g, 0, -1, Gn.getEmpty(), new Rc(g)));
    }
    this.length = ei(a, f - l), this.tokens = o;
  }
  get offset() {
    return this._offset;
  }
  read() {
    return this.tokens[this.idx++] || null;
  }
  peek() {
    return this.tokens[this.idx] || null;
  }
  skip(e) {
    throw new Z9();
  }
}
class MI {
  static createFromLanguage(e, t) {
    function i(o) {
      return t.getKey(`${o.languageId}:::${o.bracketText}`);
    }
    const n = /* @__PURE__ */ new Map();
    for (const o of e.bracketsNew.openingBrackets) {
      const r = ei(0, o.bracketText.length), a = i(o), l = Gn.getEmpty().add(a, gM);
      n.set(o.bracketText, new bl(r, 1, a, l, N1.create(r, o, l)));
    }
    for (const o of e.bracketsNew.closingBrackets) {
      const r = ei(0, o.bracketText.length);
      let a = Gn.getEmpty();
      const l = o.getOpeningBrackets();
      for (const c of l)
        a = a.add(i(c), gM);
      n.set(o.bracketText, new bl(r, 2, i(l[0]), a, N1.create(r, o, a)));
    }
    return new MI(n);
  }
  constructor(e) {
    this.map = e, this.hasRegExp = !1, this._regExpGlobal = null;
  }
  getRegExpStr() {
    if (this.isEmpty)
      return null;
    {
      const e = [...this.map.keys()];
      return e.sort(), e.reverse(), e.map((t) => LG(t)).join("|");
    }
  }
  /**
   * Returns null if there is no such regexp (because there are no brackets).
  */
  get regExpGlobal() {
    if (!this.hasRegExp) {
      const e = this.getRegExpStr();
      this._regExpGlobal = e ? new RegExp(e, "gi") : null, this.hasRegExp = !0;
    }
    return this._regExpGlobal;
  }
  getToken(e) {
    return this.map.get(e.toLowerCase());
  }
  findClosingTokenText(e) {
    for (const [t, i] of this.map)
      if (i.kind === 2 && i.bracketIds.intersects(e))
        return t;
  }
  get isEmpty() {
    return this.map.size === 0;
  }
}
function LG(s) {
  let e = za(s);
  return /^[\w ]+/.test(s) && (e = `\\b${e}`), /[\w ]+$/.test(s) && (e = `${e}\\b`), e;
}
class kG {
  constructor(e, t) {
    this.denseKeyProvider = e, this.getLanguageConfiguration = t, this.languageIdToBracketTokens = /* @__PURE__ */ new Map();
  }
  didLanguageChange(e) {
    return this.languageIdToBracketTokens.has(e);
  }
  getSingleLanguageBracketTokens(e) {
    let t = this.languageIdToBracketTokens.get(e);
    return t || (t = MI.createFromLanguage(this.getLanguageConfiguration(e), this.denseKeyProvider), this.languageIdToBracketTokens.set(e, t)), t;
  }
}
function xG(s) {
  if (s.length === 0)
    return null;
  if (s.length === 1)
    return s[0];
  let e = 0;
  function t() {
    if (e >= s.length)
      return null;
    const r = e, a = s[r].listHeight;
    for (e++; e < s.length && s[e].listHeight === a; )
      e++;
    return e - r >= 2 ? oF(r === 0 && e === s.length ? s : s.slice(r, e), !1) : s[r];
  }
  let i = t(), n = t();
  if (!n)
    return i;
  for (let r = t(); r; r = t())
    mM(i, n) <= mM(n, r) ? (i = K0(i, n), n = r) : n = K0(n, r);
  return K0(i, n);
}
function oF(s, e = !1) {
  if (s.length === 0)
    return null;
  if (s.length === 1)
    return s[0];
  let t = s.length;
  for (; t > 3; ) {
    const i = t >> 1;
    for (let n = 0; n < i; n++) {
      const o = n << 1;
      s[n] = Hr.create23(s[o], s[o + 1], o + 3 === t ? s[o + 2] : null, e);
    }
    t = i;
  }
  return Hr.create23(s[0], s[1], t >= 3 ? s[2] : null, e);
}
function mM(s, e) {
  return Math.abs(s.listHeight - e.listHeight);
}
function K0(s, e) {
  return s.listHeight === e.listHeight ? Hr.create23(s, e, null, !1) : s.listHeight > e.listHeight ? DG(s, e) : EG(e, s);
}
function DG(s, e) {
  s = s.toMutable();
  let t = s;
  const i = [];
  let n;
  for (; ; ) {
    if (e.listHeight === t.listHeight) {
      n = e;
      break;
    }
    if (t.kind !== 4)
      throw new Error("unexpected");
    i.push(t), t = t.makeLastElementMutable();
  }
  for (let o = i.length - 1; o >= 0; o--) {
    const r = i[o];
    n ? r.childrenLength >= 3 ? n = Hr.create23(r.unappendChild(), n, null, !1) : (r.appendChildOfSameHeight(n), n = void 0) : r.handleChildrenChanged();
  }
  return n ? Hr.create23(s, n, null, !1) : s;
}
function EG(s, e) {
  s = s.toMutable();
  let t = s;
  const i = [];
  for (; e.listHeight !== t.listHeight; ) {
    if (t.kind !== 4)
      throw new Error("unexpected");
    i.push(t), t = t.makeFirstElementMutable();
  }
  let n = e;
  for (let o = i.length - 1; o >= 0; o--) {
    const r = i[o];
    n ? r.childrenLength >= 3 ? n = Hr.create23(n, r.unprependChild(), null, !1) : (r.prependChildOfSameHeight(n), n = void 0) : r.handleChildrenChanged();
  }
  return n ? Hr.create23(n, s, null, !1) : s;
}
class IG {
  constructor(e) {
    this.lastOffset = Mn, this.nextNodes = [e], this.offsets = [Mn], this.idxs = [];
  }
  /**
   * Returns the longest node at `offset` that satisfies the predicate.
   * @param offset must be greater than or equal to the last offset this method has been called with!
  */
  readLongestNodeAt(e, t) {
    if (Wu(e, this.lastOffset))
      throw new Error("Invalid offset");
    for (this.lastOffset = e; ; ) {
      const i = ig(this.nextNodes);
      if (!i)
        return;
      const n = ig(this.offsets);
      if (Wu(e, n))
        return;
      if (Wu(n, e))
        if (hi(n, i.length) <= e)
          this.nextNodeAfterCurrent();
        else {
          const o = j0(i);
          o !== -1 ? (this.nextNodes.push(i.getChild(o)), this.offsets.push(n), this.idxs.push(o)) : this.nextNodeAfterCurrent();
        }
      else {
        if (t(i))
          return this.nextNodeAfterCurrent(), i;
        {
          const o = j0(i);
          if (o === -1) {
            this.nextNodeAfterCurrent();
            return;
          } else
            this.nextNodes.push(i.getChild(o)), this.offsets.push(n), this.idxs.push(o);
        }
      }
    }
  }
  // Navigates to the longest node that continues after the current node.
  nextNodeAfterCurrent() {
    for (; ; ) {
      const e = ig(this.offsets), t = ig(this.nextNodes);
      if (this.nextNodes.pop(), this.offsets.pop(), this.idxs.length === 0)
        break;
      const i = ig(this.nextNodes), n = j0(i, this.idxs[this.idxs.length - 1]);
      if (n !== -1) {
        this.nextNodes.push(i.getChild(n)), this.offsets.push(hi(e, t.length)), this.idxs[this.idxs.length - 1] = n;
        break;
      } else
        this.idxs.pop();
    }
  }
}
function j0(s, e = -1) {
  for (; ; ) {
    if (e++, e >= s.childrenLength)
      return -1;
    if (s.getChild(e))
      return e;
  }
}
function ig(s) {
  return s.length > 0 ? s[s.length - 1] : void 0;
}
function pM(s, e, t, i) {
  return new NG(s, e, t, i).parseDocument();
}
class NG {
  constructor(e, t, i, n) {
    if (this.tokenizer = e, this.createImmutableLists = n, this._itemsConstructed = 0, this._itemsFromCache = 0, i && n)
      throw new Error("Not supported");
    this.oldNodeReader = i ? new IG(i) : void 0, this.positionMapper = new mG(t);
  }
  parseDocument() {
    this._itemsConstructed = 0, this._itemsFromCache = 0;
    let e = this.parseList(Gn.getEmpty(), 0);
    return e || (e = Hr.getEmpty()), e;
  }
  parseList(e, t) {
    const i = [];
    for (; ; ) {
      let o = this.tryReadChildFromCache(e);
      if (!o) {
        const r = this.tokenizer.peek();
        if (!r || r.kind === 2 && r.bracketIds.intersects(e))
          break;
        o = this.parseChild(e, t + 1);
      }
      o.kind === 4 && o.childrenLength === 0 || i.push(o);
    }
    return this.oldNodeReader ? xG(i) : oF(i, this.createImmutableLists);
  }
  tryReadChildFromCache(e) {
    if (this.oldNodeReader) {
      const t = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);
      if (t === null || !E1(t)) {
        const i = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), (n) => t !== null && !Wu(n.length, t) ? !1 : n.canBeReused(e));
        if (i)
          return this._itemsFromCache++, this.tokenizer.skip(i.length), i;
      }
    }
  }
  parseChild(e, t) {
    this._itemsConstructed++;
    const i = this.tokenizer.read();
    switch (i.kind) {
      case 2:
        return new vG(i.bracketIds, i.length);
      case 0:
        return i.astNode;
      case 1: {
        if (t > 300)
          return new Rc(i.length);
        const n = e.merge(i.bracketIds), o = this.parseList(n, t + 1), r = this.tokenizer.peek();
        return r && r.kind === 2 && (r.bracketId === i.bracketId || r.bracketIds.intersects(i.bracketIds)) ? (this.tokenizer.read(), Qm.create(i.astNode, o, r.astNode)) : Qm.create(i.astNode, o, null);
      }
      default:
        throw new Error("unexpected");
    }
  }
}
function T1(s, e) {
  if (s.length === 0)
    return e;
  if (e.length === 0)
    return s;
  const t = new $a(_M(s)), i = _M(e);
  i.push({ modified: !1, lengthBefore: void 0, lengthAfter: void 0 });
  let n = t.dequeue();
  function o(c) {
    if (c === void 0) {
      const d = t.takeWhile((u) => !0) || [];
      return n && d.unshift(n), d;
    }
    const h = [];
    for (; n && !E1(c); ) {
      const [d, u] = n.splitAt(c);
      h.push(d), c = Xm(d.lengthAfter, c), n = u ?? t.dequeue();
    }
    return E1(c) || h.push(new xl(!1, c, c)), h;
  }
  const r = [];
  function a(c, h, d) {
    if (r.length > 0 && sF(r[r.length - 1].endOffset, c)) {
      const u = r[r.length - 1];
      r[r.length - 1] = new Ia(u.startOffset, h, hi(u.newLength, d));
    } else
      r.push({ startOffset: c, endOffset: h, newLength: d });
  }
  let l = Mn;
  for (const c of i) {
    const h = o(c.lengthBefore);
    if (c.modified) {
      const d = fG(h, (f) => f.lengthBefore), u = hi(l, d);
      a(l, u, c.lengthAfter), l = u;
    } else
      for (const d of h) {
        const u = l;
        l = hi(l, d.lengthBefore), d.modified && a(u, l, d.lengthAfter);
      }
  }
  return r;
}
class xl {
  constructor(e, t, i) {
    this.modified = e, this.lengthBefore = t, this.lengthAfter = i;
  }
  splitAt(e) {
    const t = Xm(e, this.lengthAfter);
    return sF(t, Mn) ? [this, void 0] : this.modified ? [
      new xl(this.modified, this.lengthBefore, e),
      new xl(this.modified, Mn, t)
    ] : [
      new xl(this.modified, e, e),
      new xl(this.modified, t, t)
    ];
  }
  toString() {
    return `${this.modified ? "M" : "U"}:${Bs(this.lengthBefore)} -> ${Bs(this.lengthAfter)}`;
  }
}
function _M(s) {
  const e = [];
  let t = Mn;
  for (const i of s) {
    const n = Xm(t, i.startOffset);
    E1(n) || e.push(new xl(!1, n, n));
    const o = Xm(i.startOffset, i.endOffset);
    e.push(new xl(!0, o, i.newLength)), t = i.endOffset;
  }
  return e;
}
class TG extends U {
  didLanguageChange(e) {
    return this.brackets.didLanguageChange(e);
  }
  constructor(e, t) {
    if (super(), this.textModel = e, this.getLanguageConfiguration = t, this.didChangeEmitter = new A(), this.denseKeyProvider = new pG(), this.brackets = new kG(this.denseKeyProvider, this.getLanguageConfiguration), this.onDidChange = this.didChangeEmitter.event, this.queuedTextEditsForInitialAstWithoutTokens = [], this.queuedTextEdits = [], e.tokenization.hasTokens)
      e.tokenization.backgroundTokenizationState === 2 ? (this.initialAstWithoutTokens = void 0, this.astWithTokens = this.parseDocumentFromTextBuffer([], void 0, !1)) : (this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], void 0, !0), this.astWithTokens = this.initialAstWithoutTokens);
    else {
      const i = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId()), n = new SG(this.textModel.getValue(), i);
      this.initialAstWithoutTokens = pM(n, [], void 0, !0), this.astWithTokens = this.initialAstWithoutTokens;
    }
  }
  //#region TextModel events
  handleDidChangeBackgroundTokenizationState() {
    if (this.textModel.tokenization.backgroundTokenizationState === 2) {
      const e = this.initialAstWithoutTokens === void 0;
      this.initialAstWithoutTokens = void 0, e || this.didChangeEmitter.fire();
    }
  }
  handleDidChangeTokens({ ranges: e }) {
    const t = e.map((i) => new Ia(ei(i.fromLineNumber - 1, 0), ei(i.toLineNumber, 0), ei(i.toLineNumber - i.fromLineNumber + 1, 0)));
    this.handleEdits(t, !0), this.initialAstWithoutTokens || this.didChangeEmitter.fire();
  }
  handleContentChanged(e) {
    const t = Ia.fromModelContentChanges(e.changes);
    this.handleEdits(t, !1);
  }
  handleEdits(e, t) {
    const i = T1(this.queuedTextEdits, e);
    this.queuedTextEdits = i, this.initialAstWithoutTokens && !t && (this.queuedTextEditsForInitialAstWithoutTokens = T1(this.queuedTextEditsForInitialAstWithoutTokens, e));
  }
  //#endregion
  flushQueue() {
    this.queuedTextEdits.length > 0 && (this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, !1), this.queuedTextEdits = []), this.queuedTextEditsForInitialAstWithoutTokens.length > 0 && (this.initialAstWithoutTokens && (this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, !1)), this.queuedTextEditsForInitialAstWithoutTokens = []);
  }
  /**
   * @pure (only if isPure = true)
  */
  parseDocumentFromTextBuffer(e, t, i) {
    const n = t, o = new wG(this.textModel, this.brackets);
    return pM(o, e, n, i);
  }
  getBracketsInRange(e, t) {
    this.flushQueue();
    const i = ei(e.startLineNumber - 1, e.startColumn - 1), n = ei(e.endLineNumber - 1, e.endColumn - 1);
    return new ah((o) => {
      const r = this.initialAstWithoutTokens || this.astWithTokens;
      lL(r, Mn, r.length, i, n, o, 0, 0, /* @__PURE__ */ new Map(), t);
    });
  }
  getBracketPairsInRange(e, t) {
    this.flushQueue();
    const i = su(e.getStartPosition()), n = su(e.getEndPosition());
    return new ah((o) => {
      const r = this.initialAstWithoutTokens || this.astWithTokens, a = new MG(o, t, this.textModel);
      cL(r, Mn, r.length, i, n, a, 0, /* @__PURE__ */ new Map());
    });
  }
  getFirstBracketAfter(e) {
    this.flushQueue();
    const t = this.initialAstWithoutTokens || this.astWithTokens;
    return aF(t, Mn, t.length, su(e));
  }
  getFirstBracketBefore(e) {
    this.flushQueue();
    const t = this.initialAstWithoutTokens || this.astWithTokens;
    return rF(t, Mn, t.length, su(e));
  }
}
function rF(s, e, t, i) {
  if (s.kind === 4 || s.kind === 2) {
    const n = [];
    for (const o of s.children)
      t = hi(e, o.length), n.push({ nodeOffsetStart: e, nodeOffsetEnd: t }), e = t;
    for (let o = n.length - 1; o >= 0; o--) {
      const { nodeOffsetStart: r, nodeOffsetEnd: a } = n[o];
      if (Wu(r, i)) {
        const l = rF(s.children[o], r, a, i);
        if (l)
          return l;
      }
    }
    return null;
  } else {
    if (s.kind === 3)
      return null;
    if (s.kind === 1) {
      const n = gh(e, t);
      return {
        bracketInfo: s.bracketInfo,
        range: n
      };
    }
  }
  return null;
}
function aF(s, e, t, i) {
  if (s.kind === 4 || s.kind === 2) {
    for (const n of s.children) {
      if (t = hi(e, n.length), Wu(i, t)) {
        const o = aF(n, e, t, i);
        if (o)
          return o;
      }
      e = t;
    }
    return null;
  } else {
    if (s.kind === 3)
      return null;
    if (s.kind === 1) {
      const n = gh(e, t);
      return {
        bracketInfo: s.bracketInfo,
        range: n
      };
    }
  }
  return null;
}
function lL(s, e, t, i, n, o, r, a, l, c, h = !1) {
  if (r > 200)
    return !0;
  e: for (; ; )
    switch (s.kind) {
      case 4: {
        const d = s.childrenLength;
        for (let u = 0; u < d; u++) {
          const f = s.getChild(u);
          if (f) {
            if (t = hi(e, f.length), Hu(e, n) && wg(t, i)) {
              if (wg(t, n)) {
                s = f;
                continue e;
              }
              if (!lL(f, e, t, i, n, o, r, 0, l, c))
                return !1;
            }
            e = t;
          }
        }
        return !0;
      }
      case 2: {
        const d = !c || !s.closingBracket || s.closingBracket.bracketInfo.closesColorized(s.openingBracket.bracketInfo);
        let u = 0;
        if (l) {
          let g = l.get(s.openingBracket.text);
          g === void 0 && (g = 0), u = g, d && (g++, l.set(s.openingBracket.text, g));
        }
        const f = s.childrenLength;
        for (let g = 0; g < f; g++) {
          const p = s.getChild(g);
          if (p) {
            if (t = hi(e, p.length), Hu(e, n) && wg(t, i)) {
              if (wg(t, n) && p.kind !== 1) {
                s = p, d ? (r++, a = u + 1) : a = u;
                continue e;
              }
              if ((d || p.kind !== 1 || !s.closingBracket) && !lL(p, e, t, i, n, o, d ? r + 1 : r, d ? u + 1 : u, l, c, !s.closingBracket))
                return !1;
            }
            e = t;
          }
        }
        return l == null || l.set(s.openingBracket.text, u), !0;
      }
      case 3: {
        const d = gh(e, t);
        return o(new fM(d, r - 1, 0, !0));
      }
      case 1: {
        const d = gh(e, t);
        return o(new fM(d, r - 1, a - 1, h));
      }
      case 0:
        return !0;
    }
}
class MG {
  constructor(e, t, i) {
    this.push = e, this.includeMinIndentation = t, this.textModel = i;
  }
}
function cL(s, e, t, i, n, o, r, a) {
  var c;
  if (r > 200)
    return !0;
  let l = !0;
  if (s.kind === 2) {
    let h = 0;
    if (a) {
      let f = a.get(s.openingBracket.text);
      f === void 0 && (f = 0), h = f, f++, a.set(s.openingBracket.text, f);
    }
    const d = hi(e, s.openingBracket.length);
    let u = -1;
    if (o.includeMinIndentation && (u = s.computeMinIndentation(e, o.textModel)), l = o.push(new hG(gh(e, t), gh(e, d), s.closingBracket ? gh(hi(d, ((c = s.child) == null ? void 0 : c.length) || Mn), t) : void 0, r, h, s, u)), e = d, l && s.child) {
      const f = s.child;
      if (t = hi(e, f.length), Hu(e, n) && wg(t, i) && (l = cL(f, e, t, i, n, o, r + 1, a), !l))
        return !1;
    }
    a == null || a.set(s.openingBracket.text, h);
  } else {
    let h = e;
    for (const d of s.children) {
      const u = h;
      if (h = hi(h, d.length), Hu(u, n) && Hu(i, h) && (l = cL(d, u, h, i, n, o, r, a), !l))
        return !1;
    }
  }
  return l;
}
class RG extends U {
  get canBuildAST() {
    return this.textModel.getValueLength() <= 5e6;
  }
  constructor(e, t) {
    super(), this.textModel = e, this.languageConfigurationService = t, this.bracketPairsTree = this._register(new Hs()), this.onDidChangeEmitter = new A(), this.onDidChange = this.onDidChangeEmitter.event, this.bracketsRequested = !1;
  }
  //#region TextModel events
  handleLanguageConfigurationServiceChange(e) {
    var t;
    (!e.languageId || (t = this.bracketPairsTree.value) != null && t.object.didLanguageChange(e.languageId)) && (this.bracketPairsTree.clear(), this.updateBracketPairsTree());
  }
  handleDidChangeOptions(e) {
    this.bracketPairsTree.clear(), this.updateBracketPairsTree();
  }
  handleDidChangeLanguage(e) {
    this.bracketPairsTree.clear(), this.updateBracketPairsTree();
  }
  handleDidChangeContent(e) {
    var t;
    (t = this.bracketPairsTree.value) == null || t.object.handleContentChanged(e);
  }
  handleDidChangeBackgroundTokenizationState() {
    var e;
    (e = this.bracketPairsTree.value) == null || e.object.handleDidChangeBackgroundTokenizationState();
  }
  handleDidChangeTokens(e) {
    var t;
    (t = this.bracketPairsTree.value) == null || t.object.handleDidChangeTokens(e);
  }
  //#endregion
  updateBracketPairsTree() {
    if (this.bracketsRequested && this.canBuildAST) {
      if (!this.bracketPairsTree.value) {
        const e = new ne();
        this.bracketPairsTree.value = AG(e.add(new TG(this.textModel, (t) => this.languageConfigurationService.getLanguageConfiguration(t))), e), e.add(this.bracketPairsTree.value.object.onDidChange((t) => this.onDidChangeEmitter.fire(t))), this.onDidChangeEmitter.fire();
      }
    } else
      this.bracketPairsTree.value && (this.bracketPairsTree.clear(), this.onDidChangeEmitter.fire());
  }
  /**
   * Returns all bracket pairs that intersect the given range.
   * The result is sorted by the start position.
  */
  getBracketPairsInRange(e) {
    var t;
    return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((t = this.bracketPairsTree.value) == null ? void 0 : t.object.getBracketPairsInRange(e, !1)) || ah.empty;
  }
  getBracketPairsInRangeWithMinIndentation(e) {
    var t;
    return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((t = this.bracketPairsTree.value) == null ? void 0 : t.object.getBracketPairsInRange(e, !0)) || ah.empty;
  }
  getBracketsInRange(e, t = !1) {
    var i;
    return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((i = this.bracketPairsTree.value) == null ? void 0 : i.object.getBracketsInRange(e, t)) || ah.empty;
  }
  findMatchingBracketUp(e, t, i) {
    const n = this.textModel.validatePosition(t), o = this.textModel.getLanguageIdAtPosition(n.lineNumber, n.column);
    if (this.canBuildAST) {
      const r = this.languageConfigurationService.getLanguageConfiguration(o).bracketsNew.getClosingBracketInfo(e);
      if (!r)
        return null;
      const a = this.getBracketPairsInRange(T.fromPositions(t, t)).findLast((l) => r.closes(l.openingBracketInfo));
      return a ? a.openingBracketRange : null;
    } else {
      const r = e.toLowerCase(), a = this.languageConfigurationService.getLanguageConfiguration(o).brackets;
      if (!a)
        return null;
      const l = a.textIsBracket[r];
      return l ? y_(this._findMatchingBracketUp(l, n, q0(i))) : null;
    }
  }
  matchBracket(e, t) {
    if (this.canBuildAST) {
      const i = this.getBracketPairsInRange(T.fromPositions(e, e)).filter((n) => n.closingBracketRange !== void 0 && (n.openingBracketRange.containsPosition(e) || n.closingBracketRange.containsPosition(e))).findLastMaxBy(Os((n) => n.openingBracketRange.containsPosition(e) ? n.openingBracketRange : n.closingBracketRange, T.compareRangesUsingStarts));
      return i ? [i.openingBracketRange, i.closingBracketRange] : null;
    } else {
      const i = q0(t);
      return this._matchBracket(this.textModel.validatePosition(e), i);
    }
  }
  _establishBracketSearchOffsets(e, t, i, n) {
    const o = t.getCount(), r = t.getLanguageId(n);
    let a = Math.max(0, e.column - 1 - i.maxBracketLength);
    for (let c = n - 1; c >= 0; c--) {
      const h = t.getEndOffset(c);
      if (h <= a)
        break;
      if (fr(t.getStandardTokenType(c)) || t.getLanguageId(c) !== r) {
        a = h;
        break;
      }
    }
    let l = Math.min(t.getLineContent().length, e.column - 1 + i.maxBracketLength);
    for (let c = n + 1; c < o; c++) {
      const h = t.getStartOffset(c);
      if (h >= l)
        break;
      if (fr(t.getStandardTokenType(c)) || t.getLanguageId(c) !== r) {
        l = h;
        break;
      }
    }
    return { searchStartOffset: a, searchEndOffset: l };
  }
  _matchBracket(e, t) {
    const i = e.lineNumber, n = this.textModel.tokenization.getLineTokens(i), o = this.textModel.getLineContent(i), r = n.findTokenIndexAtOffset(e.column - 1);
    if (r < 0)
      return null;
    const a = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId(r)).brackets;
    if (a && !fr(n.getStandardTokenType(r))) {
      let { searchStartOffset: l, searchEndOffset: c } = this._establishBracketSearchOffsets(e, n, a, r), h = null;
      for (; ; ) {
        const d = Ys.findNextBracketInRange(a.forwardRegex, i, o, l, c);
        if (!d)
          break;
        if (d.startColumn <= e.column && e.column <= d.endColumn) {
          const u = o.substring(d.startColumn - 1, d.endColumn - 1).toLowerCase(), f = this._matchFoundBracket(d, a.textIsBracket[u], a.textIsOpenBracket[u], t);
          if (f) {
            if (f instanceof _a)
              return null;
            h = f;
          }
        }
        l = d.endColumn - 1;
      }
      if (h)
        return h;
    }
    if (r > 0 && n.getStartOffset(r) === e.column - 1) {
      const l = r - 1, c = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId(l)).brackets;
      if (c && !fr(n.getStandardTokenType(l))) {
        const { searchStartOffset: h, searchEndOffset: d } = this._establishBracketSearchOffsets(e, n, c, l), u = Ys.findPrevBracketInRange(c.reversedRegex, i, o, h, d);
        if (u && u.startColumn <= e.column && e.column <= u.endColumn) {
          const f = o.substring(u.startColumn - 1, u.endColumn - 1).toLowerCase(), g = this._matchFoundBracket(u, c.textIsBracket[f], c.textIsOpenBracket[f], t);
          if (g)
            return g instanceof _a ? null : g;
        }
      }
    }
    return null;
  }
  _matchFoundBracket(e, t, i, n) {
    if (!t)
      return null;
    const o = i ? this._findMatchingBracketDown(t, e.getEndPosition(), n) : this._findMatchingBracketUp(t, e.getStartPosition(), n);
    return o ? o instanceof _a ? o : [e, o] : null;
  }
  _findMatchingBracketUp(e, t, i) {
    const n = e.languageId, o = e.reversedRegex;
    let r = -1, a = 0;
    const l = (c, h, d, u) => {
      for (; ; ) {
        if (i && ++a % 100 === 0 && !i())
          return _a.INSTANCE;
        const f = Ys.findPrevBracketInRange(o, c, h, d, u);
        if (!f)
          break;
        const g = h.substring(f.startColumn - 1, f.endColumn - 1).toLowerCase();
        if (e.isOpen(g) ? r++ : e.isClose(g) && r--, r === 0)
          return f;
        u = f.startColumn - 1;
      }
      return null;
    };
    for (let c = t.lineNumber; c >= 1; c--) {
      const h = this.textModel.tokenization.getLineTokens(c), d = h.getCount(), u = this.textModel.getLineContent(c);
      let f = d - 1, g = u.length, p = u.length;
      c === t.lineNumber && (f = h.findTokenIndexAtOffset(t.column - 1), g = t.column - 1, p = t.column - 1);
      let _ = !0;
      for (; f >= 0; f--) {
        const b = h.getLanguageId(f) === n && !fr(h.getStandardTokenType(f));
        if (b)
          _ ? g = h.getStartOffset(f) : (g = h.getStartOffset(f), p = h.getEndOffset(f));
        else if (_ && g !== p) {
          const C = l(c, u, g, p);
          if (C)
            return C;
        }
        _ = b;
      }
      if (_ && g !== p) {
        const b = l(c, u, g, p);
        if (b)
          return b;
      }
    }
    return null;
  }
  _findMatchingBracketDown(e, t, i) {
    const n = e.languageId, o = e.forwardRegex;
    let r = 1, a = 0;
    const l = (h, d, u, f) => {
      for (; ; ) {
        if (i && ++a % 100 === 0 && !i())
          return _a.INSTANCE;
        const g = Ys.findNextBracketInRange(o, h, d, u, f);
        if (!g)
          break;
        const p = d.substring(g.startColumn - 1, g.endColumn - 1).toLowerCase();
        if (e.isOpen(p) ? r++ : e.isClose(p) && r--, r === 0)
          return g;
        u = g.endColumn - 1;
      }
      return null;
    }, c = this.textModel.getLineCount();
    for (let h = t.lineNumber; h <= c; h++) {
      const d = this.textModel.tokenization.getLineTokens(h), u = d.getCount(), f = this.textModel.getLineContent(h);
      let g = 0, p = 0, _ = 0;
      h === t.lineNumber && (g = d.findTokenIndexAtOffset(t.column - 1), p = t.column - 1, _ = t.column - 1);
      let b = !0;
      for (; g < u; g++) {
        const C = d.getLanguageId(g) === n && !fr(d.getStandardTokenType(g));
        if (C)
          b || (p = d.getStartOffset(g)), _ = d.getEndOffset(g);
        else if (b && p !== _) {
          const w = l(h, f, p, _);
          if (w)
            return w;
        }
        b = C;
      }
      if (b && p !== _) {
        const C = l(h, f, p, _);
        if (C)
          return C;
      }
    }
    return null;
  }
  findPrevBracket(e) {
    var r;
    const t = this.textModel.validatePosition(e);
    if (this.canBuildAST)
      return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((r = this.bracketPairsTree.value) == null ? void 0 : r.object.getFirstBracketBefore(t)) || null;
    let i = null, n = null, o = null;
    for (let a = t.lineNumber; a >= 1; a--) {
      const l = this.textModel.tokenization.getLineTokens(a), c = l.getCount(), h = this.textModel.getLineContent(a);
      let d = c - 1, u = h.length, f = h.length;
      if (a === t.lineNumber) {
        d = l.findTokenIndexAtOffset(t.column - 1), u = t.column - 1, f = t.column - 1;
        const p = l.getLanguageId(d);
        i !== p && (i = p, n = this.languageConfigurationService.getLanguageConfiguration(i).brackets, o = this.languageConfigurationService.getLanguageConfiguration(i).bracketsNew);
      }
      let g = !0;
      for (; d >= 0; d--) {
        const p = l.getLanguageId(d);
        if (i !== p) {
          if (n && o && g && u !== f) {
            const b = Ys.findPrevBracketInRange(n.reversedRegex, a, h, u, f);
            if (b)
              return this._toFoundBracket(o, b);
            g = !1;
          }
          i = p, n = this.languageConfigurationService.getLanguageConfiguration(i).brackets, o = this.languageConfigurationService.getLanguageConfiguration(i).bracketsNew;
        }
        const _ = !!n && !fr(l.getStandardTokenType(d));
        if (_)
          g ? u = l.getStartOffset(d) : (u = l.getStartOffset(d), f = l.getEndOffset(d));
        else if (o && n && g && u !== f) {
          const b = Ys.findPrevBracketInRange(n.reversedRegex, a, h, u, f);
          if (b)
            return this._toFoundBracket(o, b);
        }
        g = _;
      }
      if (o && n && g && u !== f) {
        const p = Ys.findPrevBracketInRange(n.reversedRegex, a, h, u, f);
        if (p)
          return this._toFoundBracket(o, p);
      }
    }
    return null;
  }
  findNextBracket(e) {
    var a;
    const t = this.textModel.validatePosition(e);
    if (this.canBuildAST)
      return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((a = this.bracketPairsTree.value) == null ? void 0 : a.object.getFirstBracketAfter(t)) || null;
    const i = this.textModel.getLineCount();
    let n = null, o = null, r = null;
    for (let l = t.lineNumber; l <= i; l++) {
      const c = this.textModel.tokenization.getLineTokens(l), h = c.getCount(), d = this.textModel.getLineContent(l);
      let u = 0, f = 0, g = 0;
      if (l === t.lineNumber) {
        u = c.findTokenIndexAtOffset(t.column - 1), f = t.column - 1, g = t.column - 1;
        const _ = c.getLanguageId(u);
        n !== _ && (n = _, o = this.languageConfigurationService.getLanguageConfiguration(n).brackets, r = this.languageConfigurationService.getLanguageConfiguration(n).bracketsNew);
      }
      let p = !0;
      for (; u < h; u++) {
        const _ = c.getLanguageId(u);
        if (n !== _) {
          if (r && o && p && f !== g) {
            const C = Ys.findNextBracketInRange(o.forwardRegex, l, d, f, g);
            if (C)
              return this._toFoundBracket(r, C);
            p = !1;
          }
          n = _, o = this.languageConfigurationService.getLanguageConfiguration(n).brackets, r = this.languageConfigurationService.getLanguageConfiguration(n).bracketsNew;
        }
        const b = !!o && !fr(c.getStandardTokenType(u));
        if (b)
          p || (f = c.getStartOffset(u)), g = c.getEndOffset(u);
        else if (r && o && p && f !== g) {
          const C = Ys.findNextBracketInRange(o.forwardRegex, l, d, f, g);
          if (C)
            return this._toFoundBracket(r, C);
        }
        p = b;
      }
      if (r && o && p && f !== g) {
        const _ = Ys.findNextBracketInRange(o.forwardRegex, l, d, f, g);
        if (_)
          return this._toFoundBracket(r, _);
      }
    }
    return null;
  }
  findEnclosingBrackets(e, t) {
    const i = this.textModel.validatePosition(e);
    if (this.canBuildAST) {
      const f = T.fromPositions(i), g = this.getBracketPairsInRange(T.fromPositions(i, i)).findLast((p) => p.closingBracketRange !== void 0 && p.range.strictContainsRange(f));
      return g ? [g.openingBracketRange, g.closingBracketRange] : null;
    }
    const n = q0(t), o = this.textModel.getLineCount(), r = /* @__PURE__ */ new Map();
    let a = [];
    const l = (f, g) => {
      if (!r.has(f)) {
        const p = [];
        for (let _ = 0, b = g ? g.brackets.length : 0; _ < b; _++)
          p[_] = 0;
        r.set(f, p);
      }
      a = r.get(f);
    };
    let c = 0;
    const h = (f, g, p, _, b) => {
      for (; ; ) {
        if (n && ++c % 100 === 0 && !n())
          return _a.INSTANCE;
        const C = Ys.findNextBracketInRange(f.forwardRegex, g, p, _, b);
        if (!C)
          break;
        const w = p.substring(C.startColumn - 1, C.endColumn - 1).toLowerCase(), v = f.textIsBracket[w];
        if (v && (v.isOpen(w) ? a[v.index]++ : v.isClose(w) && a[v.index]--, a[v.index] === -1))
          return this._matchFoundBracket(C, v, !1, n);
        _ = C.endColumn - 1;
      }
      return null;
    };
    let d = null, u = null;
    for (let f = i.lineNumber; f <= o; f++) {
      const g = this.textModel.tokenization.getLineTokens(f), p = g.getCount(), _ = this.textModel.getLineContent(f);
      let b = 0, C = 0, w = 0;
      if (f === i.lineNumber) {
        b = g.findTokenIndexAtOffset(i.column - 1), C = i.column - 1, w = i.column - 1;
        const S = g.getLanguageId(b);
        d !== S && (d = S, u = this.languageConfigurationService.getLanguageConfiguration(d).brackets, l(d, u));
      }
      let v = !0;
      for (; b < p; b++) {
        const S = g.getLanguageId(b);
        if (d !== S) {
          if (u && v && C !== w) {
            const k = h(u, f, _, C, w);
            if (k)
              return y_(k);
            v = !1;
          }
          d = S, u = this.languageConfigurationService.getLanguageConfiguration(d).brackets, l(d, u);
        }
        const L = !!u && !fr(g.getStandardTokenType(b));
        if (L)
          v || (C = g.getStartOffset(b)), w = g.getEndOffset(b);
        else if (u && v && C !== w) {
          const k = h(u, f, _, C, w);
          if (k)
            return y_(k);
        }
        v = L;
      }
      if (u && v && C !== w) {
        const S = h(u, f, _, C, w);
        if (S)
          return y_(S);
      }
    }
    return null;
  }
  _toFoundBracket(e, t) {
    if (!t)
      return null;
    let i = this.textModel.getValueInRange(t);
    i = i.toLowerCase();
    const n = e.getBracketInfo(i);
    return n ? {
      range: t,
      bracketInfo: n
    } : null;
  }
}
function AG(s, e) {
  return {
    object: s,
    dispose: () => e == null ? void 0 : e.dispose()
  };
}
function q0(s) {
  if (typeof s > "u")
    return () => !0;
  {
    const e = Date.now();
    return () => Date.now() - e <= s;
  }
}
const rv = class rv {
  constructor() {
    this._searchCanceledBrand = void 0;
  }
};
rv.INSTANCE = new rv();
let _a = rv;
function y_(s) {
  return s instanceof _a ? null : s;
}
class PG extends U {
  constructor(e) {
    super(), this.textModel = e, this.colorProvider = new lF(), this.onDidChangeEmitter = new A(), this.onDidChange = this.onDidChangeEmitter.event, this.colorizationOptions = e.getOptions().bracketPairColorizationOptions, this._register(e.bracketPairs.onDidChange((t) => {
      this.onDidChangeEmitter.fire();
    }));
  }
  //#region TextModel events
  handleDidChangeOptions(e) {
    this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;
  }
  //#endregion
  getDecorationsInRange(e, t, i, n) {
    return n ? [] : t === void 0 ? [] : this.colorizationOptions.enabled ? this.textModel.bracketPairs.getBracketsInRange(e, !0).map((r) => ({
      id: `bracket${r.range.toString()}-${r.nestingLevel}`,
      options: {
        description: "BracketPairColorization",
        inlineClassName: this.colorProvider.getInlineClassName(r, this.colorizationOptions.independentColorPoolPerBracketType)
      },
      ownerId: 0,
      range: r.range
    })).toArray() : [];
  }
  getAllDecorations(e, t) {
    return e === void 0 ? [] : this.colorizationOptions.enabled ? this.getDecorationsInRange(new T(1, 1, this.textModel.getLineCount(), 1), e, t) : [];
  }
}
class lF {
  constructor() {
    this.unexpectedClosingBracketClassName = "unexpected-closing-bracket";
  }
  getInlineClassName(e, t) {
    return e.isInvalid ? this.unexpectedClosingBracketClassName : this.getInlineClassNameOfLevel(t ? e.nestingLevelOfEqualBracketType : e.nestingLevel);
  }
  getInlineClassNameOfLevel(e) {
    return `bracket-highlighting-${e % 30}`;
  }
}
tr((s, e) => {
  const t = [
    k5,
    x5,
    D5,
    E5,
    I5,
    N5
  ], i = new lF();
  e.addRule(`.monaco-editor .${i.unexpectedClosingBracketClassName} { color: ${s.getColor(SK)}; }`);
  const n = t.map((o) => s.getColor(o)).filter((o) => !!o).filter((o) => !o.isTransparent());
  for (let o = 0; o < 30; o++) {
    const r = n[o % n.length];
    e.addRule(`.monaco-editor .${i.getInlineClassNameOfLevel(o)} { color: ${r}; }`);
  }
});
function S_(s) {
  return s.replace(/\n/g, "\\n").replace(/\r/g, "\\r");
}
class Bi {
  get oldLength() {
    return this.oldText.length;
  }
  get oldEnd() {
    return this.oldPosition + this.oldText.length;
  }
  get newLength() {
    return this.newText.length;
  }
  get newEnd() {
    return this.newPosition + this.newText.length;
  }
  constructor(e, t, i, n) {
    this.oldPosition = e, this.oldText = t, this.newPosition = i, this.newText = n;
  }
  toString() {
    return this.oldText.length === 0 ? `(insert@${this.oldPosition} "${S_(this.newText)}")` : this.newText.length === 0 ? `(delete@${this.oldPosition} "${S_(this.oldText)}")` : `(replace@${this.oldPosition} "${S_(this.oldText)}" with "${S_(this.newText)}")`;
  }
  static _writeStringSize(e) {
    return 4 + 2 * e.length;
  }
  static _writeString(e, t, i) {
    const n = t.length;
    Ao(e, n, i), i += 4;
    for (let o = 0; o < n; o++)
      wW(e, t.charCodeAt(o), i), i += 2;
    return i;
  }
  static _readString(e, t) {
    const i = Ro(e, t);
    return t += 4, w$(e, t, i);
  }
  writeSize() {
    return 8 + Bi._writeStringSize(this.oldText) + Bi._writeStringSize(this.newText);
  }
  write(e, t) {
    return Ao(e, this.oldPosition, t), t += 4, Ao(e, this.newPosition, t), t += 4, t = Bi._writeString(e, this.oldText, t), t = Bi._writeString(e, this.newText, t), t;
  }
  static read(e, t, i) {
    const n = Ro(e, t);
    t += 4;
    const o = Ro(e, t);
    t += 4;
    const r = Bi._readString(e, t);
    t += Bi._writeStringSize(r);
    const a = Bi._readString(e, t);
    return t += Bi._writeStringSize(a), i.push(new Bi(n, r, o, a)), t;
  }
}
function OG(s, e) {
  return s === null || s.length === 0 ? e : new pr(s, e).compress();
}
class pr {
  constructor(e, t) {
    this._prevEdits = e, this._currEdits = t, this._result = [], this._resultLen = 0, this._prevLen = this._prevEdits.length, this._prevDeltaOffset = 0, this._currLen = this._currEdits.length, this._currDeltaOffset = 0;
  }
  compress() {
    let e = 0, t = 0, i = this._getPrev(e), n = this._getCurr(t);
    for (; e < this._prevLen || t < this._currLen; ) {
      if (i === null) {
        this._acceptCurr(n), n = this._getCurr(++t);
        continue;
      }
      if (n === null) {
        this._acceptPrev(i), i = this._getPrev(++e);
        continue;
      }
      if (n.oldEnd <= i.newPosition) {
        this._acceptCurr(n), n = this._getCurr(++t);
        continue;
      }
      if (i.newEnd <= n.oldPosition) {
        this._acceptPrev(i), i = this._getPrev(++e);
        continue;
      }
      if (n.oldPosition < i.newPosition) {
        const [c, h] = pr._splitCurr(n, i.newPosition - n.oldPosition);
        this._acceptCurr(c), n = h;
        continue;
      }
      if (i.newPosition < n.oldPosition) {
        const [c, h] = pr._splitPrev(i, n.oldPosition - i.newPosition);
        this._acceptPrev(c), i = h;
        continue;
      }
      let a, l;
      if (n.oldEnd === i.newEnd)
        a = i, l = n, i = this._getPrev(++e), n = this._getCurr(++t);
      else if (n.oldEnd < i.newEnd) {
        const [c, h] = pr._splitPrev(i, n.oldLength);
        a = c, l = n, i = h, n = this._getCurr(++t);
      } else {
        const [c, h] = pr._splitCurr(n, i.newLength);
        a = i, l = c, i = this._getPrev(++e), n = h;
      }
      this._result[this._resultLen++] = new Bi(a.oldPosition, a.oldText, l.newPosition, l.newText), this._prevDeltaOffset += a.newLength - a.oldLength, this._currDeltaOffset += l.newLength - l.oldLength;
    }
    const o = pr._merge(this._result);
    return pr._removeNoOps(o);
  }
  _acceptCurr(e) {
    this._result[this._resultLen++] = pr._rebaseCurr(this._prevDeltaOffset, e), this._currDeltaOffset += e.newLength - e.oldLength;
  }
  _getCurr(e) {
    return e < this._currLen ? this._currEdits[e] : null;
  }
  _acceptPrev(e) {
    this._result[this._resultLen++] = pr._rebasePrev(this._currDeltaOffset, e), this._prevDeltaOffset += e.newLength - e.oldLength;
  }
  _getPrev(e) {
    return e < this._prevLen ? this._prevEdits[e] : null;
  }
  static _rebaseCurr(e, t) {
    return new Bi(t.oldPosition - e, t.oldText, t.newPosition, t.newText);
  }
  static _rebasePrev(e, t) {
    return new Bi(t.oldPosition, t.oldText, t.newPosition + e, t.newText);
  }
  static _splitPrev(e, t) {
    const i = e.newText.substr(0, t), n = e.newText.substr(t);
    return [
      new Bi(e.oldPosition, e.oldText, e.newPosition, i),
      new Bi(e.oldEnd, "", e.newPosition + t, n)
    ];
  }
  static _splitCurr(e, t) {
    const i = e.oldText.substr(0, t), n = e.oldText.substr(t);
    return [
      new Bi(e.oldPosition, i, e.newPosition, e.newText),
      new Bi(e.oldPosition + t, n, e.newEnd, "")
    ];
  }
  static _merge(e) {
    if (e.length === 0)
      return e;
    const t = [];
    let i = 0, n = e[0];
    for (let o = 1; o < e.length; o++) {
      const r = e[o];
      n.oldEnd === r.oldPosition ? n = new Bi(n.oldPosition, n.oldText + r.oldText, n.newPosition, n.newText + r.newText) : (t[i++] = n, n = r);
    }
    return t[i++] = n, t;
  }
  static _removeNoOps(e) {
    if (e.length === 0)
      return e;
    const t = [];
    let i = 0;
    for (let n = 0; n < e.length; n++) {
      const o = e[n];
      o.oldText !== o.newText && (t[i++] = o);
    }
    return t;
  }
}
function Td(s) {
  return s.toString();
}
class vi {
  static create(e, t) {
    const i = e.getAlternativeVersionId(), n = hL(e);
    return new vi(i, i, n, n, t, t, []);
  }
  constructor(e, t, i, n, o, r, a) {
    this.beforeVersionId = e, this.afterVersionId = t, this.beforeEOL = i, this.afterEOL = n, this.beforeCursorState = o, this.afterCursorState = r, this.changes = a;
  }
  append(e, t, i, n, o) {
    t.length > 0 && (this.changes = OG(this.changes, t)), this.afterEOL = i, this.afterVersionId = n, this.afterCursorState = o;
  }
  static _writeSelectionsSize(e) {
    return 4 + 4 * 4 * (e ? e.length : 0);
  }
  static _writeSelections(e, t, i) {
    if (Ao(e, t ? t.length : 0, i), i += 4, t)
      for (const n of t)
        Ao(e, n.selectionStartLineNumber, i), i += 4, Ao(e, n.selectionStartColumn, i), i += 4, Ao(e, n.positionLineNumber, i), i += 4, Ao(e, n.positionColumn, i), i += 4;
    return i;
  }
  static _readSelections(e, t, i) {
    const n = Ro(e, t);
    t += 4;
    for (let o = 0; o < n; o++) {
      const r = Ro(e, t);
      t += 4;
      const a = Ro(e, t);
      t += 4;
      const l = Ro(e, t);
      t += 4;
      const c = Ro(e, t);
      t += 4, i.push(new Ue(r, a, l, c));
    }
    return t;
  }
  serialize() {
    let e = 10 + vi._writeSelectionsSize(this.beforeCursorState) + vi._writeSelectionsSize(this.afterCursorState) + 4;
    for (const n of this.changes)
      e += n.writeSize();
    const t = new Uint8Array(e);
    let i = 0;
    Ao(t, this.beforeVersionId, i), i += 4, Ao(t, this.afterVersionId, i), i += 4, Q2(t, this.beforeEOL, i), i += 1, Q2(t, this.afterEOL, i), i += 1, i = vi._writeSelections(t, this.beforeCursorState, i), i = vi._writeSelections(t, this.afterCursorState, i), Ao(t, this.changes.length, i), i += 4;
    for (const n of this.changes)
      i = n.write(t, i);
    return t.buffer;
  }
  static deserialize(e) {
    const t = new Uint8Array(e);
    let i = 0;
    const n = Ro(t, i);
    i += 4;
    const o = Ro(t, i);
    i += 4;
    const r = X2(t, i);
    i += 1;
    const a = X2(t, i);
    i += 1;
    const l = [];
    i = vi._readSelections(t, i, l);
    const c = [];
    i = vi._readSelections(t, i, c);
    const h = Ro(t, i);
    i += 4;
    const d = [];
    for (let u = 0; u < h; u++)
      i = Bi.read(t, i, d);
    return new vi(n, o, r, a, l, c, d);
  }
}
class cF {
  get type() {
    return 0;
  }
  get resource() {
    return we.isUri(this.model) ? this.model : this.model.uri;
  }
  constructor(e, t, i, n) {
    this.label = e, this.code = t, this.model = i, this._data = vi.create(i, n);
  }
  toString() {
    return (this._data instanceof vi ? this._data : vi.deserialize(this._data)).changes.map((t) => t.toString()).join(", ");
  }
  matchesResource(e) {
    return (we.isUri(this.model) ? this.model : this.model.uri).toString() === e.toString();
  }
  setModel(e) {
    this.model = e;
  }
  canAppend(e) {
    return this.model === e && this._data instanceof vi;
  }
  append(e, t, i, n, o) {
    this._data instanceof vi && this._data.append(e, t, i, n, o);
  }
  close() {
    this._data instanceof vi && (this._data = this._data.serialize());
  }
  open() {
    this._data instanceof vi || (this._data = vi.deserialize(this._data));
  }
  undo() {
    if (we.isUri(this.model))
      throw new Error("Invalid SingleModelEditStackElement");
    this._data instanceof vi && (this._data = this._data.serialize());
    const e = vi.deserialize(this._data);
    this.model._applyUndo(e.changes, e.beforeEOL, e.beforeVersionId, e.beforeCursorState);
  }
  redo() {
    if (we.isUri(this.model))
      throw new Error("Invalid SingleModelEditStackElement");
    this._data instanceof vi && (this._data = this._data.serialize());
    const e = vi.deserialize(this._data);
    this.model._applyRedo(e.changes, e.afterEOL, e.afterVersionId, e.afterCursorState);
  }
  heapSize() {
    return this._data instanceof vi && (this._data = this._data.serialize()), this._data.byteLength + 168;
  }
}
class FG {
  get resources() {
    return this._editStackElementsArr.map((e) => e.resource);
  }
  constructor(e, t, i) {
    this.label = e, this.code = t, this.type = 1, this._isOpen = !0, this._editStackElementsArr = i.slice(0), this._editStackElementsMap = /* @__PURE__ */ new Map();
    for (const n of this._editStackElementsArr) {
      const o = Td(n.resource);
      this._editStackElementsMap.set(o, n);
    }
    this._delegate = null;
  }
  prepareUndoRedo() {
    if (this._delegate)
      return this._delegate.prepareUndoRedo(this);
  }
  matchesResource(e) {
    const t = Td(e);
    return this._editStackElementsMap.has(t);
  }
  setModel(e) {
    const t = Td(we.isUri(e) ? e : e.uri);
    this._editStackElementsMap.has(t) && this._editStackElementsMap.get(t).setModel(e);
  }
  canAppend(e) {
    if (!this._isOpen)
      return !1;
    const t = Td(e.uri);
    return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).canAppend(e) : !1;
  }
  append(e, t, i, n, o) {
    const r = Td(e.uri);
    this._editStackElementsMap.get(r).append(e, t, i, n, o);
  }
  close() {
    this._isOpen = !1;
  }
  open() {
  }
  undo() {
    this._isOpen = !1;
    for (const e of this._editStackElementsArr)
      e.undo();
  }
  redo() {
    for (const e of this._editStackElementsArr)
      e.redo();
  }
  heapSize(e) {
    const t = Td(e);
    return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).heapSize() : 0;
  }
  split() {
    return this._editStackElementsArr;
  }
  toString() {
    const e = [];
    for (const t of this._editStackElementsArr)
      e.push(`${qo(t.resource)}: ${t}`);
    return `{${e.join(", ")}}`;
  }
}
function hL(s) {
  return s.getEOL() === `
` ? 0 : 1;
}
function ba(s) {
  return s ? s instanceof cF || s instanceof FG : !1;
}
class RI {
  constructor(e, t) {
    this._model = e, this._undoRedoService = t;
  }
  pushStackElement() {
    const e = this._undoRedoService.getLastElement(this._model.uri);
    ba(e) && e.close();
  }
  popStackElement() {
    const e = this._undoRedoService.getLastElement(this._model.uri);
    ba(e) && e.open();
  }
  clear() {
    this._undoRedoService.removeElements(this._model.uri);
  }
  _getOrCreateEditStackElement(e, t) {
    const i = this._undoRedoService.getLastElement(this._model.uri);
    if (ba(i) && i.canAppend(this._model))
      return i;
    const n = new cF(m("edit", "Typing"), "undoredo.textBufferEdit", this._model, e);
    return this._undoRedoService.pushElement(n, t), n;
  }
  pushEOL(e) {
    const t = this._getOrCreateEditStackElement(null, void 0);
    this._model.setEOL(e), t.append(this._model, [], hL(this._model), this._model.getAlternativeVersionId(), null);
  }
  pushEditOperation(e, t, i, n) {
    const o = this._getOrCreateEditStackElement(e, n), r = this._model.applyEdits(t, !0), a = RI._computeCursorState(i, r), l = r.map((c, h) => ({ index: h, textChange: c.textChange }));
    return l.sort((c, h) => c.textChange.oldPosition === h.textChange.oldPosition ? c.index - h.index : c.textChange.oldPosition - h.textChange.oldPosition), o.append(this._model, l.map((c) => c.textChange), hL(this._model), this._model.getAlternativeVersionId(), a), a;
  }
  static _computeCursorState(e, t) {
    try {
      return e ? e(t) : null;
    } catch (i) {
      return Je(i), null;
    }
  }
}
class BG {
  constructor() {
    this.spacesDiff = 0, this.looksLikeAlignment = !1;
  }
}
function WG(s, e, t, i, n) {
  n.spacesDiff = 0, n.looksLikeAlignment = !1;
  let o;
  for (o = 0; o < e && o < i; o++) {
    const u = s.charCodeAt(o), f = t.charCodeAt(o);
    if (u !== f)
      break;
  }
  let r = 0, a = 0;
  for (let u = o; u < e; u++)
    s.charCodeAt(u) === 32 ? r++ : a++;
  let l = 0, c = 0;
  for (let u = o; u < i; u++)
    t.charCodeAt(u) === 32 ? l++ : c++;
  if (r > 0 && a > 0 || l > 0 && c > 0)
    return;
  const h = Math.abs(a - c), d = Math.abs(r - l);
  if (h === 0) {
    n.spacesDiff = d, d > 0 && 0 <= l - 1 && l - 1 < s.length && l < t.length && t.charCodeAt(l) !== 32 && s.charCodeAt(l - 1) === 32 && s.charCodeAt(s.length - 1) === 44 && (n.looksLikeAlignment = !0);
    return;
  }
  if (d % h === 0) {
    n.spacesDiff = d / h;
    return;
  }
}
function bM(s, e, t) {
  const i = Math.min(s.getLineCount(), 1e4);
  let n = 0, o = 0, r = "", a = 0;
  const l = [2, 4, 6, 8, 3, 5, 7], c = 8, h = [0, 0, 0, 0, 0, 0, 0, 0, 0], d = new BG();
  for (let g = 1; g <= i; g++) {
    const p = s.getLineLength(g), _ = s.getLineContent(g), b = p <= 65536;
    let C = !1, w = 0, v = 0, S = 0;
    for (let k = 0, x = p; k < x; k++) {
      const I = b ? _.charCodeAt(k) : s.getLineCharCode(g, k);
      if (I === 9)
        S++;
      else if (I === 32)
        v++;
      else {
        C = !0, w = k;
        break;
      }
    }
    if (!C || (S > 0 ? n++ : v > 1 && o++, WG(r, a, _, w, d), d.looksLikeAlignment && !(t && e === d.spacesDiff)))
      continue;
    const L = d.spacesDiff;
    L <= c && h[L]++, r = _, a = w;
  }
  let u = t;
  n !== o && (u = n < o);
  let f = e;
  if (u) {
    let g = u ? 0 : 0.1 * i;
    l.forEach((p) => {
      const _ = h[p];
      _ > g && (g = _, f = p);
    }), f === 4 && h[4] > 0 && h[2] > 0 && h[2] >= h[4] / 2 && (f = 2);
  }
  return {
    insertSpaces: u,
    tabSize: f
  };
}
function kn(s) {
  return (s.metadata & 1) >>> 0;
}
function kt(s, e) {
  s.metadata = s.metadata & 254 | e << 0;
}
function zi(s) {
  return (s.metadata & 2) >>> 1 === 1;
}
function wt(s, e) {
  s.metadata = s.metadata & 253 | (e ? 1 : 0) << 1;
}
function hF(s) {
  return (s.metadata & 4) >>> 2 === 1;
}
function CM(s, e) {
  s.metadata = s.metadata & 251 | (e ? 1 : 0) << 2;
}
function dF(s) {
  return (s.metadata & 64) >>> 6 === 1;
}
function vM(s, e) {
  s.metadata = s.metadata & 191 | (e ? 1 : 0) << 6;
}
function HG(s) {
  return (s.metadata & 24) >>> 3;
}
function wM(s, e) {
  s.metadata = s.metadata & 231 | e << 3;
}
function VG(s) {
  return (s.metadata & 32) >>> 5 === 1;
}
function yM(s, e) {
  s.metadata = s.metadata & 223 | (e ? 1 : 0) << 5;
}
class uF {
  constructor(e, t, i) {
    this.metadata = 0, this.parent = this, this.left = this, this.right = this, kt(
      this,
      1
      /* NodeColor.Red */
    ), this.start = t, this.end = i, this.delta = 0, this.maxEnd = i, this.id = e, this.ownerId = 0, this.options = null, CM(this, !1), vM(this, !1), wM(
      this,
      1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    ), yM(this, !1), this.cachedVersionId = 0, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = null, wt(this, !1);
  }
  reset(e, t, i, n) {
    this.start = t, this.end = i, this.maxEnd = i, this.cachedVersionId = e, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = n;
  }
  setOptions(e) {
    this.options = e;
    const t = this.options.className;
    CM(this, t === "squiggly-error" || t === "squiggly-warning" || t === "squiggly-info"), vM(this, this.options.glyphMarginClassName !== null), wM(this, this.options.stickiness), yM(this, this.options.collapseOnReplaceEdit);
  }
  setCachedOffsets(e, t, i) {
    this.cachedVersionId !== i && (this.range = null), this.cachedVersionId = i, this.cachedAbsoluteStart = e, this.cachedAbsoluteEnd = t;
  }
  detach() {
    this.parent = null, this.left = null, this.right = null;
  }
}
const Oe = new uF(null, 0, 0);
Oe.parent = Oe;
Oe.left = Oe;
Oe.right = Oe;
kt(
  Oe,
  0
  /* NodeColor.Black */
);
class G0 {
  constructor() {
    this.root = Oe, this.requestNormalizeDelta = !1;
  }
  intervalSearch(e, t, i, n, o, r) {
    return this.root === Oe ? [] : ZG(this, e, t, i, n, o, r);
  }
  search(e, t, i, n) {
    return this.root === Oe ? [] : GG(this, e, t, i, n);
  }
  /**
   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
   */
  collectNodesFromOwner(e) {
    return jG(this, e);
  }
  /**
   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
   */
  collectNodesPostOrder() {
    return qG(this);
  }
  insert(e) {
    SM(this, e), this._normalizeDeltaIfNecessary();
  }
  delete(e) {
    LM(this, e), this._normalizeDeltaIfNecessary();
  }
  resolveNode(e, t) {
    const i = e;
    let n = 0;
    for (; e !== this.root; )
      e === e.parent.right && (n += e.parent.delta), e = e.parent;
    const o = i.start + n, r = i.end + n;
    i.setCachedOffsets(o, r, t);
  }
  acceptReplace(e, t, i, n) {
    const o = $G(this, e, e + t);
    for (let r = 0, a = o.length; r < a; r++) {
      const l = o[r];
      LM(this, l);
    }
    this._normalizeDeltaIfNecessary(), KG(this, e, e + t, i), this._normalizeDeltaIfNecessary();
    for (let r = 0, a = o.length; r < a; r++) {
      const l = o[r];
      l.start = l.cachedAbsoluteStart, l.end = l.cachedAbsoluteEnd, UG(l, e, e + t, i, n), l.maxEnd = l.end, SM(this, l);
    }
    this._normalizeDeltaIfNecessary();
  }
  _normalizeDeltaIfNecessary() {
    this.requestNormalizeDelta && (this.requestNormalizeDelta = !1, zG(this));
  }
}
function zG(s) {
  let e = s.root, t = 0;
  for (; e !== Oe; ) {
    if (e.left !== Oe && !zi(e.left)) {
      e = e.left;
      continue;
    }
    if (e.right !== Oe && !zi(e.right)) {
      t += e.delta, e = e.right;
      continue;
    }
    e.start = t + e.start, e.end = t + e.end, e.delta = 0, Ql(e), wt(e, !0), wt(e.left, !1), wt(e.right, !1), e === e.parent.right && (t -= e.parent.delta), e = e.parent;
  }
  wt(s.root, !1);
}
function Md(s, e, t, i) {
  return s < t ? !0 : s > t || i === 1 ? !1 : i === 2 ? !0 : e;
}
function UG(s, e, t, i, n) {
  const o = HG(s), r = o === 0 || o === 2, a = o === 1 || o === 2, l = t - e, c = i, h = Math.min(l, c), d = s.start;
  let u = !1;
  const f = s.end;
  let g = !1;
  e <= d && f <= t && VG(s) && (s.start = e, u = !0, s.end = e, g = !0);
  {
    const _ = n ? 1 : l > 0 ? 2 : 0;
    !u && Md(d, r, e, _) && (u = !0), !g && Md(f, a, e, _) && (g = !0);
  }
  if (h > 0 && !n) {
    const _ = l > c ? 2 : 0;
    !u && Md(d, r, e + h, _) && (u = !0), !g && Md(f, a, e + h, _) && (g = !0);
  }
  {
    const _ = n ? 1 : 0;
    !u && Md(d, r, t, _) && (s.start = e + c, u = !0), !g && Md(f, a, t, _) && (s.end = e + c, g = !0);
  }
  const p = c - l;
  u || (s.start = Math.max(0, d + p)), g || (s.end = Math.max(0, f + p)), s.start > s.end && (s.end = s.start);
}
function $G(s, e, t) {
  let i = s.root, n = 0, o = 0, r = 0, a = 0;
  const l = [];
  let c = 0;
  for (; i !== Oe; ) {
    if (zi(i)) {
      wt(i.left, !1), wt(i.right, !1), i === i.parent.right && (n -= i.parent.delta), i = i.parent;
      continue;
    }
    if (!zi(i.left)) {
      if (o = n + i.maxEnd, o < e) {
        wt(i, !0);
        continue;
      }
      if (i.left !== Oe) {
        i = i.left;
        continue;
      }
    }
    if (r = n + i.start, r > t) {
      wt(i, !0);
      continue;
    }
    if (a = n + i.end, a >= e && (i.setCachedOffsets(r, a, 0), l[c++] = i), wt(i, !0), i.right !== Oe && !zi(i.right)) {
      n += i.delta, i = i.right;
      continue;
    }
  }
  return wt(s.root, !1), l;
}
function KG(s, e, t, i) {
  let n = s.root, o = 0, r = 0, a = 0;
  const l = i - (t - e);
  for (; n !== Oe; ) {
    if (zi(n)) {
      wt(n.left, !1), wt(n.right, !1), n === n.parent.right && (o -= n.parent.delta), Ql(n), n = n.parent;
      continue;
    }
    if (!zi(n.left)) {
      if (r = o + n.maxEnd, r < e) {
        wt(n, !0);
        continue;
      }
      if (n.left !== Oe) {
        n = n.left;
        continue;
      }
    }
    if (a = o + n.start, a > t) {
      n.start += l, n.end += l, n.delta += l, (n.delta < -1073741824 || n.delta > 1073741824) && (s.requestNormalizeDelta = !0), wt(n, !0);
      continue;
    }
    if (wt(n, !0), n.right !== Oe && !zi(n.right)) {
      o += n.delta, n = n.right;
      continue;
    }
  }
  wt(s.root, !1);
}
function jG(s, e) {
  let t = s.root;
  const i = [];
  let n = 0;
  for (; t !== Oe; ) {
    if (zi(t)) {
      wt(t.left, !1), wt(t.right, !1), t = t.parent;
      continue;
    }
    if (t.left !== Oe && !zi(t.left)) {
      t = t.left;
      continue;
    }
    if (t.ownerId === e && (i[n++] = t), wt(t, !0), t.right !== Oe && !zi(t.right)) {
      t = t.right;
      continue;
    }
  }
  return wt(s.root, !1), i;
}
function qG(s) {
  let e = s.root;
  const t = [];
  let i = 0;
  for (; e !== Oe; ) {
    if (zi(e)) {
      wt(e.left, !1), wt(e.right, !1), e = e.parent;
      continue;
    }
    if (e.left !== Oe && !zi(e.left)) {
      e = e.left;
      continue;
    }
    if (e.right !== Oe && !zi(e.right)) {
      e = e.right;
      continue;
    }
    t[i++] = e, wt(e, !0);
  }
  return wt(s.root, !1), t;
}
function GG(s, e, t, i, n) {
  let o = s.root, r = 0, a = 0, l = 0;
  const c = [];
  let h = 0;
  for (; o !== Oe; ) {
    if (zi(o)) {
      wt(o.left, !1), wt(o.right, !1), o === o.parent.right && (r -= o.parent.delta), o = o.parent;
      continue;
    }
    if (o.left !== Oe && !zi(o.left)) {
      o = o.left;
      continue;
    }
    a = r + o.start, l = r + o.end, o.setCachedOffsets(a, l, i);
    let d = !0;
    if (e && o.ownerId && o.ownerId !== e && (d = !1), t && hF(o) && (d = !1), n && !dF(o) && (d = !1), d && (c[h++] = o), wt(o, !0), o.right !== Oe && !zi(o.right)) {
      r += o.delta, o = o.right;
      continue;
    }
  }
  return wt(s.root, !1), c;
}
function ZG(s, e, t, i, n, o, r) {
  let a = s.root, l = 0, c = 0, h = 0, d = 0;
  const u = [];
  let f = 0;
  for (; a !== Oe; ) {
    if (zi(a)) {
      wt(a.left, !1), wt(a.right, !1), a === a.parent.right && (l -= a.parent.delta), a = a.parent;
      continue;
    }
    if (!zi(a.left)) {
      if (c = l + a.maxEnd, c < e) {
        wt(a, !0);
        continue;
      }
      if (a.left !== Oe) {
        a = a.left;
        continue;
      }
    }
    if (h = l + a.start, h > t) {
      wt(a, !0);
      continue;
    }
    if (d = l + a.end, d >= e) {
      a.setCachedOffsets(h, d, o);
      let g = !0;
      i && a.ownerId && a.ownerId !== i && (g = !1), n && hF(a) && (g = !1), r && !dF(a) && (g = !1), g && (u[f++] = a);
    }
    if (wt(a, !0), a.right !== Oe && !zi(a.right)) {
      l += a.delta, a = a.right;
      continue;
    }
  }
  return wt(s.root, !1), u;
}
function SM(s, e) {
  if (s.root === Oe)
    return e.parent = Oe, e.left = Oe, e.right = Oe, kt(
      e,
      0
      /* NodeColor.Black */
    ), s.root = e, s.root;
  YG(s, e), cl(e.parent);
  let t = e;
  for (; t !== s.root && kn(t.parent) === 1; )
    if (t.parent === t.parent.parent.left) {
      const i = t.parent.parent.right;
      kn(i) === 1 ? (kt(
        t.parent,
        0
        /* NodeColor.Black */
      ), kt(
        i,
        0
        /* NodeColor.Black */
      ), kt(
        t.parent.parent,
        1
        /* NodeColor.Red */
      ), t = t.parent.parent) : (t === t.parent.right && (t = t.parent, Ug(s, t)), kt(
        t.parent,
        0
        /* NodeColor.Black */
      ), kt(
        t.parent.parent,
        1
        /* NodeColor.Red */
      ), $g(s, t.parent.parent));
    } else {
      const i = t.parent.parent.left;
      kn(i) === 1 ? (kt(
        t.parent,
        0
        /* NodeColor.Black */
      ), kt(
        i,
        0
        /* NodeColor.Black */
      ), kt(
        t.parent.parent,
        1
        /* NodeColor.Red */
      ), t = t.parent.parent) : (t === t.parent.left && (t = t.parent, $g(s, t)), kt(
        t.parent,
        0
        /* NodeColor.Black */
      ), kt(
        t.parent.parent,
        1
        /* NodeColor.Red */
      ), Ug(s, t.parent.parent));
    }
  return kt(
    s.root,
    0
    /* NodeColor.Black */
  ), e;
}
function YG(s, e) {
  let t = 0, i = s.root;
  const n = e.start, o = e.end;
  for (; ; )
    if (QG(n, o, i.start + t, i.end + t) < 0)
      if (i.left === Oe) {
        e.start -= t, e.end -= t, e.maxEnd -= t, i.left = e;
        break;
      } else
        i = i.left;
    else if (i.right === Oe) {
      e.start -= t + i.delta, e.end -= t + i.delta, e.maxEnd -= t + i.delta, i.right = e;
      break;
    } else
      t += i.delta, i = i.right;
  e.parent = i, e.left = Oe, e.right = Oe, kt(
    e,
    1
    /* NodeColor.Red */
  );
}
function LM(s, e) {
  let t, i;
  if (e.left === Oe ? (t = e.right, i = e, t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = !0), t.start += e.delta, t.end += e.delta) : e.right === Oe ? (t = e.left, i = e) : (i = XG(e.right), t = i.right, t.start += i.delta, t.end += i.delta, t.delta += i.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = !0), i.start += e.delta, i.end += e.delta, i.delta = e.delta, (i.delta < -1073741824 || i.delta > 1073741824) && (s.requestNormalizeDelta = !0)), i === s.root) {
    s.root = t, kt(
      t,
      0
      /* NodeColor.Black */
    ), e.detach(), Z0(), Ql(t), s.root.parent = Oe;
    return;
  }
  const n = kn(i) === 1;
  if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? t.parent = i.parent : (i.parent === e ? t.parent = i : t.parent = i.parent, i.left = e.left, i.right = e.right, i.parent = e.parent, kt(i, kn(e)), e === s.root ? s.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== Oe && (i.left.parent = i), i.right !== Oe && (i.right.parent = i)), e.detach(), n) {
    cl(t.parent), i !== e && (cl(i), cl(i.parent)), Z0();
    return;
  }
  cl(t), cl(t.parent), i !== e && (cl(i), cl(i.parent));
  let o;
  for (; t !== s.root && kn(t) === 0; )
    t === t.parent.left ? (o = t.parent.right, kn(o) === 1 && (kt(
      o,
      0
      /* NodeColor.Black */
    ), kt(
      t.parent,
      1
      /* NodeColor.Red */
    ), Ug(s, t.parent), o = t.parent.right), kn(o.left) === 0 && kn(o.right) === 0 ? (kt(
      o,
      1
      /* NodeColor.Red */
    ), t = t.parent) : (kn(o.right) === 0 && (kt(
      o.left,
      0
      /* NodeColor.Black */
    ), kt(
      o,
      1
      /* NodeColor.Red */
    ), $g(s, o), o = t.parent.right), kt(o, kn(t.parent)), kt(
      t.parent,
      0
      /* NodeColor.Black */
    ), kt(
      o.right,
      0
      /* NodeColor.Black */
    ), Ug(s, t.parent), t = s.root)) : (o = t.parent.left, kn(o) === 1 && (kt(
      o,
      0
      /* NodeColor.Black */
    ), kt(
      t.parent,
      1
      /* NodeColor.Red */
    ), $g(s, t.parent), o = t.parent.left), kn(o.left) === 0 && kn(o.right) === 0 ? (kt(
      o,
      1
      /* NodeColor.Red */
    ), t = t.parent) : (kn(o.left) === 0 && (kt(
      o.right,
      0
      /* NodeColor.Black */
    ), kt(
      o,
      1
      /* NodeColor.Red */
    ), Ug(s, o), o = t.parent.left), kt(o, kn(t.parent)), kt(
      t.parent,
      0
      /* NodeColor.Black */
    ), kt(
      o.left,
      0
      /* NodeColor.Black */
    ), $g(s, t.parent), t = s.root));
  kt(
    t,
    0
    /* NodeColor.Black */
  ), Z0();
}
function XG(s) {
  for (; s.left !== Oe; )
    s = s.left;
  return s;
}
function Z0() {
  Oe.parent = Oe, Oe.delta = 0, Oe.start = 0, Oe.end = 0;
}
function Ug(s, e) {
  const t = e.right;
  t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = !0), t.start += e.delta, t.end += e.delta, e.right = t.left, t.left !== Oe && (t.left.parent = e), t.parent = e.parent, e.parent === Oe ? s.root = t : e === e.parent.left ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t, Ql(e), Ql(t);
}
function $g(s, e) {
  const t = e.left;
  e.delta -= t.delta, (e.delta < -1073741824 || e.delta > 1073741824) && (s.requestNormalizeDelta = !0), e.start -= t.delta, e.end -= t.delta, e.left = t.right, t.right !== Oe && (t.right.parent = e), t.parent = e.parent, e.parent === Oe ? s.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t, Ql(e), Ql(t);
}
function fF(s) {
  let e = s.end;
  if (s.left !== Oe) {
    const t = s.left.maxEnd;
    t > e && (e = t);
  }
  if (s.right !== Oe) {
    const t = s.right.maxEnd + s.delta;
    t > e && (e = t);
  }
  return e;
}
function Ql(s) {
  s.maxEnd = fF(s);
}
function cl(s) {
  for (; s !== Oe; ) {
    const e = fF(s);
    if (s.maxEnd === e)
      return;
    s.maxEnd = e, s = s.parent;
  }
}
function QG(s, e, t, i) {
  return s === t ? e - i : s - t;
}
class dL {
  constructor(e, t) {
    this.piece = e, this.color = t, this.size_left = 0, this.lf_left = 0, this.parent = this, this.left = this, this.right = this;
  }
  next() {
    if (this.right !== Se)
      return AI(this.right);
    let e = this;
    for (; e.parent !== Se && e.parent.left !== e; )
      e = e.parent;
    return e.parent === Se ? Se : e.parent;
  }
  prev() {
    if (this.left !== Se)
      return gF(this.left);
    let e = this;
    for (; e.parent !== Se && e.parent.right !== e; )
      e = e.parent;
    return e.parent === Se ? Se : e.parent;
  }
  detach() {
    this.parent = null, this.left = null, this.right = null;
  }
}
const Se = new dL(
  null,
  0
  /* NodeColor.Black */
);
Se.parent = Se;
Se.left = Se;
Se.right = Se;
Se.color = 0;
function AI(s) {
  for (; s.left !== Se; )
    s = s.left;
  return s;
}
function gF(s) {
  for (; s.right !== Se; )
    s = s.right;
  return s;
}
function PI(s) {
  return s === Se ? 0 : s.size_left + s.piece.length + PI(s.right);
}
function OI(s) {
  return s === Se ? 0 : s.lf_left + s.piece.lineFeedCnt + OI(s.right);
}
function Y0() {
  Se.parent = Se;
}
function Kg(s, e) {
  const t = e.right;
  t.size_left += e.size_left + (e.piece ? e.piece.length : 0), t.lf_left += e.lf_left + (e.piece ? e.piece.lineFeedCnt : 0), e.right = t.left, t.left !== Se && (t.left.parent = e), t.parent = e.parent, e.parent === Se ? s.root = t : e.parent.left === e ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t;
}
function jg(s, e) {
  const t = e.left;
  e.left = t.right, t.right !== Se && (t.right.parent = e), t.parent = e.parent, e.size_left -= t.size_left + (t.piece ? t.piece.length : 0), e.lf_left -= t.lf_left + (t.piece ? t.piece.lineFeedCnt : 0), e.parent === Se ? s.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t;
}
function L_(s, e) {
  let t, i;
  if (e.left === Se ? (i = e, t = i.right) : e.right === Se ? (i = e, t = i.left) : (i = AI(e.right), t = i.right), i === s.root) {
    s.root = t, t.color = 0, e.detach(), Y0(), s.root.parent = Se;
    return;
  }
  const n = i.color === 1;
  if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? (t.parent = i.parent, yg(s, t)) : (i.parent === e ? t.parent = i : t.parent = i.parent, yg(s, t), i.left = e.left, i.right = e.right, i.parent = e.parent, i.color = e.color, e === s.root ? s.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== Se && (i.left.parent = i), i.right !== Se && (i.right.parent = i), i.size_left = e.size_left, i.lf_left = e.lf_left, yg(s, i)), e.detach(), t.parent.left === t) {
    const r = PI(t), a = OI(t);
    if (r !== t.parent.size_left || a !== t.parent.lf_left) {
      const l = r - t.parent.size_left, c = a - t.parent.lf_left;
      t.parent.size_left = r, t.parent.lf_left = a, ra(s, t.parent, l, c);
    }
  }
  if (yg(s, t.parent), n) {
    Y0();
    return;
  }
  let o;
  for (; t !== s.root && t.color === 0; )
    t === t.parent.left ? (o = t.parent.right, o.color === 1 && (o.color = 0, t.parent.color = 1, Kg(s, t.parent), o = t.parent.right), o.left.color === 0 && o.right.color === 0 ? (o.color = 1, t = t.parent) : (o.right.color === 0 && (o.left.color = 0, o.color = 1, jg(s, o), o = t.parent.right), o.color = t.parent.color, t.parent.color = 0, o.right.color = 0, Kg(s, t.parent), t = s.root)) : (o = t.parent.left, o.color === 1 && (o.color = 0, t.parent.color = 1, jg(s, t.parent), o = t.parent.left), o.left.color === 0 && o.right.color === 0 ? (o.color = 1, t = t.parent) : (o.left.color === 0 && (o.right.color = 0, o.color = 1, Kg(s, o), o = t.parent.left), o.color = t.parent.color, t.parent.color = 0, o.left.color = 0, jg(s, t.parent), t = s.root));
  t.color = 0, Y0();
}
function kM(s, e) {
  for (yg(s, e); e !== s.root && e.parent.color === 1; )
    if (e.parent === e.parent.parent.left) {
      const t = e.parent.parent.right;
      t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.right && (e = e.parent, Kg(s, e)), e.parent.color = 0, e.parent.parent.color = 1, jg(s, e.parent.parent));
    } else {
      const t = e.parent.parent.left;
      t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.left && (e = e.parent, jg(s, e)), e.parent.color = 0, e.parent.parent.color = 1, Kg(s, e.parent.parent));
    }
  s.root.color = 0;
}
function ra(s, e, t, i) {
  for (; e !== s.root && e !== Se; )
    e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
}
function yg(s, e) {
  let t = 0, i = 0;
  if (e !== s.root) {
    for (; e !== s.root && e === e.parent.right; )
      e = e.parent;
    if (e !== s.root)
      for (e = e.parent, t = PI(e.left) - e.size_left, i = OI(e.left) - e.lf_left, e.size_left += t, e.lf_left += i; e !== s.root && (t !== 0 || i !== 0); )
        e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
  }
}
const JG = 999;
class Rd {
  constructor(e, t, i, n) {
    this.searchString = e, this.isRegex = t, this.matchCase = i, this.wordSeparators = n;
  }
  parseSearchRequest() {
    if (this.searchString === "")
      return null;
    let e;
    this.isRegex ? e = eZ(this.searchString) : e = this.searchString.indexOf(`
`) >= 0;
    let t = null;
    try {
      t = c4(this.searchString, this.isRegex, {
        matchCase: this.matchCase,
        wholeWord: !1,
        multiline: e,
        global: !0,
        unicode: !0
      });
    } catch {
      return null;
    }
    if (!t)
      return null;
    let i = !this.isRegex && !e;
    return i && this.searchString.toLowerCase() !== this.searchString.toUpperCase() && (i = this.matchCase), new aq(t, this.wordSeparators ? ff(this.wordSeparators, []) : null, i ? this.searchString : null);
  }
}
function eZ(s) {
  if (!s || s.length === 0)
    return !1;
  for (let e = 0, t = s.length; e < t; e++) {
    const i = s.charCodeAt(e);
    if (i === 10)
      return !0;
    if (i === 92) {
      if (e++, e >= t)
        break;
      const n = s.charCodeAt(e);
      if (n === 110 || n === 114 || n === 87)
        return !0;
    }
  }
  return !1;
}
function Ac(s, e, t) {
  if (!t)
    return new jm(s, null);
  const i = [];
  for (let n = 0, o = e.length; n < o; n++)
    i[n] = e[n];
  return new jm(s, i);
}
class xM {
  constructor(e) {
    const t = [];
    let i = 0;
    for (let n = 0, o = e.length; n < o; n++)
      e.charCodeAt(n) === 10 && (t[i++] = n);
    this._lineFeedsOffsets = t;
  }
  findLineFeedCountBeforeOffset(e) {
    const t = this._lineFeedsOffsets;
    let i = 0, n = t.length - 1;
    if (n === -1 || e <= t[0])
      return 0;
    for (; i < n; ) {
      const o = i + ((n - i) / 2 >> 0);
      t[o] >= e ? n = o - 1 : t[o + 1] >= e ? (i = o, n = o) : i = o + 1;
    }
    return i + 1;
  }
}
class k_ {
  static findMatches(e, t, i, n, o) {
    const r = t.parseSearchRequest();
    return r ? r.regex.multiline ? this._doFindMatchesMultiline(e, i, new ou(r.wordSeparators, r.regex), n, o) : this._doFindMatchesLineByLine(e, i, r, n, o) : [];
  }
  /**
   * Multiline search always executes on the lines concatenated with \n.
   * We must therefore compensate for the count of \n in case the model is CRLF
   */
  static _getMultilineMatchRange(e, t, i, n, o, r) {
    let a, l = 0;
    n ? (l = n.findLineFeedCountBeforeOffset(o), a = t + o + l) : a = t + o;
    let c;
    if (n) {
      const f = n.findLineFeedCountBeforeOffset(o + r.length) - l;
      c = a + r.length + f;
    } else
      c = a + r.length;
    const h = e.getPositionAt(a), d = e.getPositionAt(c);
    return new T(h.lineNumber, h.column, d.lineNumber, d.column);
  }
  static _doFindMatchesMultiline(e, t, i, n, o) {
    const r = e.getOffsetAt(t.getStartPosition()), a = e.getValueInRange(
      t,
      1
      /* EndOfLinePreference.LF */
    ), l = e.getEOL() === `\r
` ? new xM(a) : null, c = [];
    let h = 0, d;
    for (i.reset(0); d = i.next(a); )
      if (c[h++] = Ac(this._getMultilineMatchRange(e, r, a, l, d.index, d[0]), d, n), h >= o)
        return c;
    return c;
  }
  static _doFindMatchesLineByLine(e, t, i, n, o) {
    const r = [];
    let a = 0;
    if (t.startLineNumber === t.endLineNumber) {
      const c = e.getLineContent(t.startLineNumber).substring(t.startColumn - 1, t.endColumn - 1);
      return a = this._findMatchesInLine(i, c, t.startLineNumber, t.startColumn - 1, a, r, n, o), r;
    }
    const l = e.getLineContent(t.startLineNumber).substring(t.startColumn - 1);
    a = this._findMatchesInLine(i, l, t.startLineNumber, t.startColumn - 1, a, r, n, o);
    for (let c = t.startLineNumber + 1; c < t.endLineNumber && a < o; c++)
      a = this._findMatchesInLine(i, e.getLineContent(c), c, 0, a, r, n, o);
    if (a < o) {
      const c = e.getLineContent(t.endLineNumber).substring(0, t.endColumn - 1);
      a = this._findMatchesInLine(i, c, t.endLineNumber, 0, a, r, n, o);
    }
    return r;
  }
  static _findMatchesInLine(e, t, i, n, o, r, a, l) {
    const c = e.wordSeparators;
    if (!a && e.simpleSearch) {
      const u = e.simpleSearch, f = u.length, g = t.length;
      let p = -f;
      for (; (p = t.indexOf(u, p + f)) !== -1; )
        if ((!c || FI(c, t, g, p, f)) && (r[o++] = new jm(new T(i, p + 1 + n, i, p + 1 + f + n), null), o >= l))
          return o;
      return o;
    }
    const h = new ou(e.wordSeparators, e.regex);
    let d;
    h.reset(0);
    do
      if (d = h.next(t), d && (r[o++] = Ac(new T(i, d.index + 1 + n, i, d.index + 1 + d[0].length + n), d, a), o >= l))
        return o;
    while (d);
    return o;
  }
  static findNextMatch(e, t, i, n) {
    const o = t.parseSearchRequest();
    if (!o)
      return null;
    const r = new ou(o.wordSeparators, o.regex);
    return o.regex.multiline ? this._doFindNextMatchMultiline(e, i, r, n) : this._doFindNextMatchLineByLine(e, i, r, n);
  }
  static _doFindNextMatchMultiline(e, t, i, n) {
    const o = new F(t.lineNumber, 1), r = e.getOffsetAt(o), a = e.getLineCount(), l = e.getValueInRange(
      new T(o.lineNumber, o.column, a, e.getLineMaxColumn(a)),
      1
      /* EndOfLinePreference.LF */
    ), c = e.getEOL() === `\r
` ? new xM(l) : null;
    i.reset(t.column - 1);
    const h = i.next(l);
    return h ? Ac(this._getMultilineMatchRange(e, r, l, c, h.index, h[0]), h, n) : t.lineNumber !== 1 || t.column !== 1 ? this._doFindNextMatchMultiline(e, new F(1, 1), i, n) : null;
  }
  static _doFindNextMatchLineByLine(e, t, i, n) {
    const o = e.getLineCount(), r = t.lineNumber, a = e.getLineContent(r), l = this._findFirstMatchInLine(i, a, r, t.column, n);
    if (l)
      return l;
    for (let c = 1; c <= o; c++) {
      const h = (r + c - 1) % o, d = e.getLineContent(h + 1), u = this._findFirstMatchInLine(i, d, h + 1, 1, n);
      if (u)
        return u;
    }
    return null;
  }
  static _findFirstMatchInLine(e, t, i, n, o) {
    e.reset(n - 1);
    const r = e.next(t);
    return r ? Ac(new T(i, r.index + 1, i, r.index + 1 + r[0].length), r, o) : null;
  }
  static findPreviousMatch(e, t, i, n) {
    const o = t.parseSearchRequest();
    if (!o)
      return null;
    const r = new ou(o.wordSeparators, o.regex);
    return o.regex.multiline ? this._doFindPreviousMatchMultiline(e, i, r, n) : this._doFindPreviousMatchLineByLine(e, i, r, n);
  }
  static _doFindPreviousMatchMultiline(e, t, i, n) {
    const o = this._doFindMatchesMultiline(e, new T(1, 1, t.lineNumber, t.column), i, n, 10 * JG);
    if (o.length > 0)
      return o[o.length - 1];
    const r = e.getLineCount();
    return t.lineNumber !== r || t.column !== e.getLineMaxColumn(r) ? this._doFindPreviousMatchMultiline(e, new F(r, e.getLineMaxColumn(r)), i, n) : null;
  }
  static _doFindPreviousMatchLineByLine(e, t, i, n) {
    const o = e.getLineCount(), r = t.lineNumber, a = e.getLineContent(r).substring(0, t.column - 1), l = this._findLastMatchInLine(i, a, r, n);
    if (l)
      return l;
    for (let c = 1; c <= o; c++) {
      const h = (o + r - c - 1) % o, d = e.getLineContent(h + 1), u = this._findLastMatchInLine(i, d, h + 1, n);
      if (u)
        return u;
    }
    return null;
  }
  static _findLastMatchInLine(e, t, i, n) {
    let o = null, r;
    for (e.reset(0); r = e.next(t); )
      o = Ac(new T(i, r.index + 1, i, r.index + 1 + r[0].length), r, n);
    return o;
  }
}
function tZ(s, e, t, i, n) {
  if (i === 0)
    return !0;
  const o = e.charCodeAt(i - 1);
  if (s.get(o) !== 0 || o === 13 || o === 10)
    return !0;
  if (n > 0) {
    const r = e.charCodeAt(i);
    if (s.get(r) !== 0)
      return !0;
  }
  return !1;
}
function iZ(s, e, t, i, n) {
  if (i + n === t)
    return !0;
  const o = e.charCodeAt(i + n);
  if (s.get(o) !== 0 || o === 13 || o === 10)
    return !0;
  if (n > 0) {
    const r = e.charCodeAt(i + n - 1);
    if (s.get(r) !== 0)
      return !0;
  }
  return !1;
}
function FI(s, e, t, i, n) {
  return tZ(s, e, t, i, n) && iZ(s, e, t, i, n);
}
class ou {
  constructor(e, t) {
    this._wordSeparators = e, this._searchRegex = t, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  reset(e) {
    this._searchRegex.lastIndex = e, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  next(e) {
    const t = e.length;
    let i;
    do {
      if (this._prevMatchStartIndex + this._prevMatchLength === t || (i = this._searchRegex.exec(e), !i))
        return null;
      const n = i.index, o = i[0].length;
      if (n === this._prevMatchStartIndex && o === this._prevMatchLength) {
        if (o === 0) {
          zb(e, t, this._searchRegex.lastIndex) > 65535 ? this._searchRegex.lastIndex += 2 : this._searchRegex.lastIndex += 1;
          continue;
        }
        return null;
      }
      if (this._prevMatchStartIndex = n, this._prevMatchLength = o, !this._wordSeparators || FI(this._wordSeparators, e, t, n, o))
        return i;
    } while (i);
    return null;
  }
}
const ia = 65535;
function mF(s) {
  let e;
  return s[s.length - 1] < 65536 ? e = new Uint16Array(s.length) : e = new Uint32Array(s.length), e.set(s, 0), e;
}
class nZ {
  constructor(e, t, i, n, o) {
    this.lineStarts = e, this.cr = t, this.lf = i, this.crlf = n, this.isBasicASCII = o;
  }
}
function aa(s, e = !0) {
  const t = [0];
  let i = 1;
  for (let n = 0, o = s.length; n < o; n++) {
    const r = s.charCodeAt(n);
    r === 13 ? n + 1 < o && s.charCodeAt(n + 1) === 10 ? (t[i++] = n + 2, n++) : t[i++] = n + 1 : r === 10 && (t[i++] = n + 1);
  }
  return e ? mF(t) : t;
}
function sZ(s, e) {
  s.length = 0, s[0] = 0;
  let t = 1, i = 0, n = 0, o = 0, r = !0;
  for (let l = 0, c = e.length; l < c; l++) {
    const h = e.charCodeAt(l);
    h === 13 ? l + 1 < c && e.charCodeAt(l + 1) === 10 ? (o++, s[t++] = l + 2, l++) : (i++, s[t++] = l + 1) : h === 10 ? (n++, s[t++] = l + 1) : r && h !== 9 && (h < 32 || h > 126) && (r = !1);
  }
  const a = new nZ(mF(s), i, n, o, r);
  return s.length = 0, a;
}
class zn {
  constructor(e, t, i, n, o) {
    this.bufferIndex = e, this.start = t, this.end = i, this.lineFeedCnt = n, this.length = o;
  }
}
class Pc {
  constructor(e, t) {
    this.buffer = e, this.lineStarts = t;
  }
}
class oZ {
  constructor(e, t) {
    this._pieces = [], this._tree = e, this._BOM = t, this._index = 0, e.root !== Se && e.iterate(e.root, (i) => (i !== Se && this._pieces.push(i.piece), !0));
  }
  read() {
    return this._pieces.length === 0 ? this._index === 0 ? (this._index++, this._BOM) : null : this._index > this._pieces.length - 1 ? null : this._index === 0 ? this._BOM + this._tree.getPieceContent(this._pieces[this._index++]) : this._tree.getPieceContent(this._pieces[this._index++]);
  }
}
class rZ {
  constructor(e) {
    this._limit = e, this._cache = [];
  }
  get(e) {
    for (let t = this._cache.length - 1; t >= 0; t--) {
      const i = this._cache[t];
      if (i.nodeStartOffset <= e && i.nodeStartOffset + i.node.piece.length >= e)
        return i;
    }
    return null;
  }
  get2(e) {
    for (let t = this._cache.length - 1; t >= 0; t--) {
      const i = this._cache[t];
      if (i.nodeStartLineNumber && i.nodeStartLineNumber < e && i.nodeStartLineNumber + i.node.piece.lineFeedCnt >= e)
        return i;
    }
    return null;
  }
  set(e) {
    this._cache.length >= this._limit && this._cache.shift(), this._cache.push(e);
  }
  validate(e) {
    let t = !1;
    const i = this._cache;
    for (let n = 0; n < i.length; n++) {
      const o = i[n];
      if (o.node.parent === null || o.nodeStartOffset >= e) {
        i[n] = null, t = !0;
        continue;
      }
    }
    if (t) {
      const n = [];
      for (const o of i)
        o !== null && n.push(o);
      this._cache = n;
    }
  }
}
class aZ {
  constructor(e, t, i) {
    this.create(e, t, i);
  }
  create(e, t, i) {
    this._buffers = [
      new Pc("", [0])
    ], this._lastChangeBufferPos = { line: 0, column: 0 }, this.root = Se, this._lineCnt = 1, this._length = 0, this._EOL = t, this._EOLLength = t.length, this._EOLNormalized = i;
    let n = null;
    for (let o = 0, r = e.length; o < r; o++)
      if (e[o].buffer.length > 0) {
        e[o].lineStarts || (e[o].lineStarts = aa(e[o].buffer));
        const a = new zn(o + 1, { line: 0, column: 0 }, { line: e[o].lineStarts.length - 1, column: e[o].buffer.length - e[o].lineStarts[e[o].lineStarts.length - 1] }, e[o].lineStarts.length - 1, e[o].buffer.length);
        this._buffers.push(e[o]), n = this.rbInsertRight(n, a);
      }
    this._searchCache = new rZ(1), this._lastVisitedLine = { lineNumber: 0, value: "" }, this.computeBufferMetadata();
  }
  normalizeEOL(e) {
    const t = ia, i = t - Math.floor(t / 3), n = i * 2;
    let o = "", r = 0;
    const a = [];
    if (this.iterate(this.root, (l) => {
      const c = this.getNodeContent(l), h = c.length;
      if (r <= i || r + h < n)
        return o += c, r += h, !0;
      const d = o.replace(/\r\n|\r|\n/g, e);
      return a.push(new Pc(d, aa(d))), o = c, r = h, !0;
    }), r > 0) {
      const l = o.replace(/\r\n|\r|\n/g, e);
      a.push(new Pc(l, aa(l)));
    }
    this.create(a, e, !0);
  }
  // #region Buffer API
  getEOL() {
    return this._EOL;
  }
  setEOL(e) {
    this._EOL = e, this._EOLLength = this._EOL.length, this.normalizeEOL(e);
  }
  createSnapshot(e) {
    return new oZ(this, e);
  }
  getOffsetAt(e, t) {
    let i = 0, n = this.root;
    for (; n !== Se; )
      if (n.left !== Se && n.lf_left + 1 >= e)
        n = n.left;
      else if (n.lf_left + n.piece.lineFeedCnt + 1 >= e) {
        i += n.size_left;
        const o = this.getAccumulatedValue(n, e - n.lf_left - 2);
        return i += o + t - 1;
      } else
        e -= n.lf_left + n.piece.lineFeedCnt, i += n.size_left + n.piece.length, n = n.right;
    return i;
  }
  getPositionAt(e) {
    e = Math.floor(e), e = Math.max(0, e);
    let t = this.root, i = 0;
    const n = e;
    for (; t !== Se; )
      if (t.size_left !== 0 && t.size_left >= e)
        t = t.left;
      else if (t.size_left + t.piece.length >= e) {
        const o = this.getIndexOf(t, e - t.size_left);
        if (i += t.lf_left + o.index, o.index === 0) {
          const r = this.getOffsetAt(i + 1, 1), a = n - r;
          return new F(i + 1, a + 1);
        }
        return new F(i + 1, o.remainder + 1);
      } else if (e -= t.size_left + t.piece.length, i += t.lf_left + t.piece.lineFeedCnt, t.right === Se) {
        const o = this.getOffsetAt(i + 1, 1), r = n - e - o;
        return new F(i + 1, r + 1);
      } else
        t = t.right;
    return new F(1, 1);
  }
  getValueInRange(e, t) {
    if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn)
      return "";
    const i = this.nodeAt2(e.startLineNumber, e.startColumn), n = this.nodeAt2(e.endLineNumber, e.endColumn), o = this.getValueInRange2(i, n);
    return t ? t !== this._EOL || !this._EOLNormalized ? o.replace(/\r\n|\r|\n/g, t) : t === this.getEOL() && this._EOLNormalized ? o : o.replace(/\r\n|\r|\n/g, t) : o;
  }
  getValueInRange2(e, t) {
    if (e.node === t.node) {
      const a = e.node, l = this._buffers[a.piece.bufferIndex].buffer, c = this.offsetInBuffer(a.piece.bufferIndex, a.piece.start);
      return l.substring(c + e.remainder, c + t.remainder);
    }
    let i = e.node;
    const n = this._buffers[i.piece.bufferIndex].buffer, o = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
    let r = n.substring(o + e.remainder, o + i.piece.length);
    for (i = i.next(); i !== Se; ) {
      const a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
      if (i === t.node) {
        r += a.substring(l, l + t.remainder);
        break;
      } else
        r += a.substr(l, i.piece.length);
      i = i.next();
    }
    return r;
  }
  getLinesContent() {
    const e = [];
    let t = 0, i = "", n = !1;
    return this.iterate(this.root, (o) => {
      if (o === Se)
        return !0;
      const r = o.piece;
      let a = r.length;
      if (a === 0)
        return !0;
      const l = this._buffers[r.bufferIndex].buffer, c = this._buffers[r.bufferIndex].lineStarts, h = r.start.line, d = r.end.line;
      let u = c[h] + r.start.column;
      if (n && (l.charCodeAt(u) === 10 && (u++, a--), e[t++] = i, i = "", n = !1, a === 0))
        return !0;
      if (h === d)
        return !this._EOLNormalized && l.charCodeAt(u + a - 1) === 13 ? (n = !0, i += l.substr(u, a - 1)) : i += l.substr(u, a), !0;
      i += this._EOLNormalized ? l.substring(u, Math.max(u, c[h + 1] - this._EOLLength)) : l.substring(u, c[h + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
      for (let f = h + 1; f < d; f++)
        i = this._EOLNormalized ? l.substring(c[f], c[f + 1] - this._EOLLength) : l.substring(c[f], c[f + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
      return !this._EOLNormalized && l.charCodeAt(c[d] + r.end.column - 1) === 13 ? (n = !0, r.end.column === 0 ? t-- : i = l.substr(c[d], r.end.column - 1)) : i = l.substr(c[d], r.end.column), !0;
    }), n && (e[t++] = i, i = ""), e[t++] = i, e;
  }
  getLength() {
    return this._length;
  }
  getLineCount() {
    return this._lineCnt;
  }
  getLineContent(e) {
    return this._lastVisitedLine.lineNumber === e ? this._lastVisitedLine.value : (this._lastVisitedLine.lineNumber = e, e === this._lineCnt ? this._lastVisitedLine.value = this.getLineRawContent(e) : this._EOLNormalized ? this._lastVisitedLine.value = this.getLineRawContent(e, this._EOLLength) : this._lastVisitedLine.value = this.getLineRawContent(e).replace(/(\r\n|\r|\n)$/, ""), this._lastVisitedLine.value);
  }
  _getCharCode(e) {
    if (e.remainder === e.node.piece.length) {
      const t = e.node.next();
      if (!t)
        return 0;
      const i = this._buffers[t.piece.bufferIndex], n = this.offsetInBuffer(t.piece.bufferIndex, t.piece.start);
      return i.buffer.charCodeAt(n);
    } else {
      const t = this._buffers[e.node.piece.bufferIndex], n = this.offsetInBuffer(e.node.piece.bufferIndex, e.node.piece.start) + e.remainder;
      return t.buffer.charCodeAt(n);
    }
  }
  getLineCharCode(e, t) {
    const i = this.nodeAt2(e, t + 1);
    return this._getCharCode(i);
  }
  getLineLength(e) {
    if (e === this.getLineCount()) {
      const t = this.getOffsetAt(e, 1);
      return this.getLength() - t;
    }
    return this.getOffsetAt(e + 1, 1) - this.getOffsetAt(e, 1) - this._EOLLength;
  }
  findMatchesInNode(e, t, i, n, o, r, a, l, c, h, d) {
    const u = this._buffers[e.piece.bufferIndex], f = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start), g = this.offsetInBuffer(e.piece.bufferIndex, o), p = this.offsetInBuffer(e.piece.bufferIndex, r);
    let _;
    const b = { line: 0, column: 0 };
    let C, w;
    t._wordSeparators ? (C = u.buffer.substring(g, p), w = (v) => v + g, t.reset(0)) : (C = u.buffer, w = (v) => v, t.reset(g));
    do
      if (_ = t.next(C), _) {
        if (w(_.index) >= p)
          return h;
        this.positionInBuffer(e, w(_.index) - f, b);
        const v = this.getLineFeedCnt(e.piece.bufferIndex, o, b), S = b.line === o.line ? b.column - o.column + n : b.column + 1, L = S + _[0].length;
        if (d[h++] = Ac(new T(i + v, S, i + v, L), _, l), w(_.index) + _[0].length >= p || h >= c)
          return h;
      }
    while (_);
    return h;
  }
  findMatchesLineByLine(e, t, i, n) {
    const o = [];
    let r = 0;
    const a = new ou(t.wordSeparators, t.regex);
    let l = this.nodeAt2(e.startLineNumber, e.startColumn);
    if (l === null)
      return [];
    const c = this.nodeAt2(e.endLineNumber, e.endColumn);
    if (c === null)
      return [];
    let h = this.positionInBuffer(l.node, l.remainder);
    const d = this.positionInBuffer(c.node, c.remainder);
    if (l.node === c.node)
      return this.findMatchesInNode(l.node, a, e.startLineNumber, e.startColumn, h, d, t, i, n, r, o), o;
    let u = e.startLineNumber, f = l.node;
    for (; f !== c.node; ) {
      const p = this.getLineFeedCnt(f.piece.bufferIndex, h, f.piece.end);
      if (p >= 1) {
        const b = this._buffers[f.piece.bufferIndex].lineStarts, C = this.offsetInBuffer(f.piece.bufferIndex, f.piece.start), w = b[h.line + p], v = u === e.startLineNumber ? e.startColumn : 1;
        if (r = this.findMatchesInNode(f, a, u, v, h, this.positionInBuffer(f, w - C), t, i, n, r, o), r >= n)
          return o;
        u += p;
      }
      const _ = u === e.startLineNumber ? e.startColumn - 1 : 0;
      if (u === e.endLineNumber) {
        const b = this.getLineContent(u).substring(_, e.endColumn - 1);
        return r = this._findMatchesInLine(t, a, b, e.endLineNumber, _, r, o, i, n), o;
      }
      if (r = this._findMatchesInLine(t, a, this.getLineContent(u).substr(_), u, _, r, o, i, n), r >= n)
        return o;
      u++, l = this.nodeAt2(u, 1), f = l.node, h = this.positionInBuffer(l.node, l.remainder);
    }
    if (u === e.endLineNumber) {
      const p = u === e.startLineNumber ? e.startColumn - 1 : 0, _ = this.getLineContent(u).substring(p, e.endColumn - 1);
      return r = this._findMatchesInLine(t, a, _, e.endLineNumber, p, r, o, i, n), o;
    }
    const g = u === e.startLineNumber ? e.startColumn : 1;
    return r = this.findMatchesInNode(c.node, a, u, g, h, d, t, i, n, r, o), o;
  }
  _findMatchesInLine(e, t, i, n, o, r, a, l, c) {
    const h = e.wordSeparators;
    if (!l && e.simpleSearch) {
      const u = e.simpleSearch, f = u.length, g = i.length;
      let p = -f;
      for (; (p = i.indexOf(u, p + f)) !== -1; )
        if ((!h || FI(h, i, g, p, f)) && (a[r++] = new jm(new T(n, p + 1 + o, n, p + 1 + f + o), null), r >= c))
          return r;
      return r;
    }
    let d;
    t.reset(0);
    do
      if (d = t.next(i), d && (a[r++] = Ac(new T(n, d.index + 1 + o, n, d.index + 1 + d[0].length + o), d, l), r >= c))
        return r;
    while (d);
    return r;
  }
  // #endregion
  // #region Piece Table
  insert(e, t, i = !1) {
    if (this._EOLNormalized = this._EOLNormalized && i, this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", this.root !== Se) {
      const { node: n, remainder: o, nodeStartOffset: r } = this.nodeAt(e), a = n.piece, l = a.bufferIndex, c = this.positionInBuffer(n, o);
      if (n.piece.bufferIndex === 0 && a.end.line === this._lastChangeBufferPos.line && a.end.column === this._lastChangeBufferPos.column && r + a.length === e && t.length < ia) {
        this.appendToNode(n, t), this.computeBufferMetadata();
        return;
      }
      if (r === e)
        this.insertContentToNodeLeft(t, n), this._searchCache.validate(e);
      else if (r + n.piece.length > e) {
        const h = [];
        let d = new zn(a.bufferIndex, c, a.end, this.getLineFeedCnt(a.bufferIndex, c, a.end), this.offsetInBuffer(l, a.end) - this.offsetInBuffer(l, c));
        if (this.shouldCheckCRLF() && this.endWithCR(t) && this.nodeCharCodeAt(n, o) === 10) {
          const p = { line: d.start.line + 1, column: 0 };
          d = new zn(d.bufferIndex, p, d.end, this.getLineFeedCnt(d.bufferIndex, p, d.end), d.length - 1), t += `
`;
        }
        if (this.shouldCheckCRLF() && this.startWithLF(t))
          if (this.nodeCharCodeAt(n, o - 1) === 13) {
            const p = this.positionInBuffer(n, o - 1);
            this.deleteNodeTail(n, p), t = "\r" + t, n.piece.length === 0 && h.push(n);
          } else
            this.deleteNodeTail(n, c);
        else
          this.deleteNodeTail(n, c);
        const u = this.createNewPieces(t);
        d.length > 0 && this.rbInsertRight(n, d);
        let f = n;
        for (let g = 0; g < u.length; g++)
          f = this.rbInsertRight(f, u[g]);
        this.deleteNodes(h);
      } else
        this.insertContentToNodeRight(t, n);
    } else {
      const n = this.createNewPieces(t);
      let o = this.rbInsertLeft(null, n[0]);
      for (let r = 1; r < n.length; r++)
        o = this.rbInsertRight(o, n[r]);
    }
    this.computeBufferMetadata();
  }
  delete(e, t) {
    if (this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", t <= 0 || this.root === Se)
      return;
    const i = this.nodeAt(e), n = this.nodeAt(e + t), o = i.node, r = n.node;
    if (o === r) {
      const u = this.positionInBuffer(o, i.remainder), f = this.positionInBuffer(o, n.remainder);
      if (i.nodeStartOffset === e) {
        if (t === o.piece.length) {
          const g = o.next();
          L_(this, o), this.validateCRLFWithPrevNode(g), this.computeBufferMetadata();
          return;
        }
        this.deleteNodeHead(o, f), this._searchCache.validate(e), this.validateCRLFWithPrevNode(o), this.computeBufferMetadata();
        return;
      }
      if (i.nodeStartOffset + o.piece.length === e + t) {
        this.deleteNodeTail(o, u), this.validateCRLFWithNextNode(o), this.computeBufferMetadata();
        return;
      }
      this.shrinkNode(o, u, f), this.computeBufferMetadata();
      return;
    }
    const a = [], l = this.positionInBuffer(o, i.remainder);
    this.deleteNodeTail(o, l), this._searchCache.validate(e), o.piece.length === 0 && a.push(o);
    const c = this.positionInBuffer(r, n.remainder);
    this.deleteNodeHead(r, c), r.piece.length === 0 && a.push(r);
    const h = o.next();
    for (let u = h; u !== Se && u !== r; u = u.next())
      a.push(u);
    const d = o.piece.length === 0 ? o.prev() : o;
    this.deleteNodes(a), this.validateCRLFWithNextNode(d), this.computeBufferMetadata();
  }
  insertContentToNodeLeft(e, t) {
    const i = [];
    if (this.shouldCheckCRLF() && this.endWithCR(e) && this.startWithLF(t)) {
      const r = t.piece, a = { line: r.start.line + 1, column: 0 }, l = new zn(r.bufferIndex, a, r.end, this.getLineFeedCnt(r.bufferIndex, a, r.end), r.length - 1);
      t.piece = l, e += `
`, ra(this, t, -1, -1), t.piece.length === 0 && i.push(t);
    }
    const n = this.createNewPieces(e);
    let o = this.rbInsertLeft(t, n[n.length - 1]);
    for (let r = n.length - 2; r >= 0; r--)
      o = this.rbInsertLeft(o, n[r]);
    this.validateCRLFWithPrevNode(o), this.deleteNodes(i);
  }
  insertContentToNodeRight(e, t) {
    this.adjustCarriageReturnFromNext(e, t) && (e += `
`);
    const i = this.createNewPieces(e), n = this.rbInsertRight(t, i[0]);
    let o = n;
    for (let r = 1; r < i.length; r++)
      o = this.rbInsertRight(o, i[r]);
    this.validateCRLFWithPrevNode(n);
  }
  positionInBuffer(e, t, i) {
    const n = e.piece, o = e.piece.bufferIndex, r = this._buffers[o].lineStarts, l = r[n.start.line] + n.start.column + t;
    let c = n.start.line, h = n.end.line, d = 0, u = 0, f = 0;
    for (; c <= h && (d = c + (h - c) / 2 | 0, f = r[d], d !== h); )
      if (u = r[d + 1], l < f)
        h = d - 1;
      else if (l >= u)
        c = d + 1;
      else
        break;
    return i ? (i.line = d, i.column = l - f, null) : {
      line: d,
      column: l - f
    };
  }
  getLineFeedCnt(e, t, i) {
    if (i.column === 0)
      return i.line - t.line;
    const n = this._buffers[e].lineStarts;
    if (i.line === n.length - 1)
      return i.line - t.line;
    const o = n[i.line + 1], r = n[i.line] + i.column;
    if (o > r + 1)
      return i.line - t.line;
    const a = r - 1;
    return this._buffers[e].buffer.charCodeAt(a) === 13 ? i.line - t.line + 1 : i.line - t.line;
  }
  offsetInBuffer(e, t) {
    return this._buffers[e].lineStarts[t.line] + t.column;
  }
  deleteNodes(e) {
    for (let t = 0; t < e.length; t++)
      L_(this, e[t]);
  }
  createNewPieces(e) {
    if (e.length > ia) {
      const h = [];
      for (; e.length > ia; ) {
        const u = e.charCodeAt(ia - 1);
        let f;
        u === 13 || u >= 55296 && u <= 56319 ? (f = e.substring(0, ia - 1), e = e.substring(ia - 1)) : (f = e.substring(0, ia), e = e.substring(ia));
        const g = aa(f);
        h.push(new zn(
          this._buffers.length,
          /* buffer index */
          { line: 0, column: 0 },
          { line: g.length - 1, column: f.length - g[g.length - 1] },
          g.length - 1,
          f.length
        )), this._buffers.push(new Pc(f, g));
      }
      const d = aa(e);
      return h.push(new zn(
        this._buffers.length,
        /* buffer index */
        { line: 0, column: 0 },
        { line: d.length - 1, column: e.length - d[d.length - 1] },
        d.length - 1,
        e.length
      )), this._buffers.push(new Pc(e, d)), h;
    }
    let t = this._buffers[0].buffer.length;
    const i = aa(e, !1);
    let n = this._lastChangeBufferPos;
    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === t && t !== 0 && this.startWithLF(e) && this.endWithCR(this._buffers[0].buffer)) {
      this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 }, n = this._lastChangeBufferPos;
      for (let h = 0; h < i.length; h++)
        i[h] += t + 1;
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += "_" + e, t += 1;
    } else {
      if (t !== 0)
        for (let h = 0; h < i.length; h++)
          i[h] += t;
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += e;
    }
    const o = this._buffers[0].buffer.length, r = this._buffers[0].lineStarts.length - 1, a = o - this._buffers[0].lineStarts[r], l = { line: r, column: a }, c = new zn(
      0,
      /** todo@peng */
      n,
      l,
      this.getLineFeedCnt(0, n, l),
      o - t
    );
    return this._lastChangeBufferPos = l, [c];
  }
  getLineRawContent(e, t = 0) {
    let i = this.root, n = "";
    const o = this._searchCache.get2(e);
    if (o) {
      i = o.node;
      const r = this.getAccumulatedValue(i, e - o.nodeStartLineNumber - 1), a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
      if (o.nodeStartLineNumber + i.piece.lineFeedCnt === e)
        n = a.substring(l + r, l + i.piece.length);
      else {
        const c = this.getAccumulatedValue(i, e - o.nodeStartLineNumber);
        return a.substring(l + r, l + c - t);
      }
    } else {
      let r = 0;
      const a = e;
      for (; i !== Se; )
        if (i.left !== Se && i.lf_left >= e - 1)
          i = i.left;
        else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
          const l = this.getAccumulatedValue(i, e - i.lf_left - 2), c = this.getAccumulatedValue(i, e - i.lf_left - 1), h = this._buffers[i.piece.bufferIndex].buffer, d = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          return r += i.size_left, this._searchCache.set({
            node: i,
            nodeStartOffset: r,
            nodeStartLineNumber: a - (e - 1 - i.lf_left)
          }), h.substring(d + l, d + c - t);
        } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
          const l = this.getAccumulatedValue(i, e - i.lf_left - 2), c = this._buffers[i.piece.bufferIndex].buffer, h = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          n = c.substring(h + l, h + i.piece.length);
          break;
        } else
          e -= i.lf_left + i.piece.lineFeedCnt, r += i.size_left + i.piece.length, i = i.right;
    }
    for (i = i.next(); i !== Se; ) {
      const r = this._buffers[i.piece.bufferIndex].buffer;
      if (i.piece.lineFeedCnt > 0) {
        const a = this.getAccumulatedValue(i, 0), l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
        return n += r.substring(l, l + a - t), n;
      } else {
        const a = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
        n += r.substr(a, i.piece.length);
      }
      i = i.next();
    }
    return n;
  }
  computeBufferMetadata() {
    let e = this.root, t = 1, i = 0;
    for (; e !== Se; )
      t += e.lf_left + e.piece.lineFeedCnt, i += e.size_left + e.piece.length, e = e.right;
    this._lineCnt = t, this._length = i, this._searchCache.validate(this._length);
  }
  // #region node operations
  getIndexOf(e, t) {
    const i = e.piece, n = this.positionInBuffer(e, t), o = n.line - i.start.line;
    if (this.offsetInBuffer(i.bufferIndex, i.end) - this.offsetInBuffer(i.bufferIndex, i.start) === t) {
      const r = this.getLineFeedCnt(e.piece.bufferIndex, i.start, n);
      if (r !== o)
        return { index: r, remainder: 0 };
    }
    return { index: o, remainder: n.column };
  }
  getAccumulatedValue(e, t) {
    if (t < 0)
      return 0;
    const i = e.piece, n = this._buffers[i.bufferIndex].lineStarts, o = i.start.line + t + 1;
    return o > i.end.line ? n[i.end.line] + i.end.column - n[i.start.line] - i.start.column : n[o] - n[i.start.line] - i.start.column;
  }
  deleteNodeTail(e, t) {
    const i = e.piece, n = i.lineFeedCnt, o = this.offsetInBuffer(i.bufferIndex, i.end), r = t, a = this.offsetInBuffer(i.bufferIndex, r), l = this.getLineFeedCnt(i.bufferIndex, i.start, r), c = l - n, h = a - o, d = i.length + h;
    e.piece = new zn(i.bufferIndex, i.start, r, l, d), ra(this, e, h, c);
  }
  deleteNodeHead(e, t) {
    const i = e.piece, n = i.lineFeedCnt, o = this.offsetInBuffer(i.bufferIndex, i.start), r = t, a = this.getLineFeedCnt(i.bufferIndex, r, i.end), l = this.offsetInBuffer(i.bufferIndex, r), c = a - n, h = o - l, d = i.length + h;
    e.piece = new zn(i.bufferIndex, r, i.end, a, d), ra(this, e, h, c);
  }
  shrinkNode(e, t, i) {
    const n = e.piece, o = n.start, r = n.end, a = n.length, l = n.lineFeedCnt, c = t, h = this.getLineFeedCnt(n.bufferIndex, n.start, c), d = this.offsetInBuffer(n.bufferIndex, t) - this.offsetInBuffer(n.bufferIndex, o);
    e.piece = new zn(n.bufferIndex, n.start, c, h, d), ra(this, e, d - a, h - l);
    const u = new zn(n.bufferIndex, i, r, this.getLineFeedCnt(n.bufferIndex, i, r), this.offsetInBuffer(n.bufferIndex, r) - this.offsetInBuffer(n.bufferIndex, i)), f = this.rbInsertRight(e, u);
    this.validateCRLFWithPrevNode(f);
  }
  appendToNode(e, t) {
    this.adjustCarriageReturnFromNext(t, e) && (t += `
`);
    const i = this.shouldCheckCRLF() && this.startWithLF(t) && this.endWithCR(e), n = this._buffers[0].buffer.length;
    this._buffers[0].buffer += t;
    const o = aa(t, !1);
    for (let f = 0; f < o.length; f++)
      o[f] += n;
    if (i) {
      const f = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
      this._buffers[0].lineStarts.pop(), this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: n - f };
    }
    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(o.slice(1));
    const r = this._buffers[0].lineStarts.length - 1, a = this._buffers[0].buffer.length - this._buffers[0].lineStarts[r], l = { line: r, column: a }, c = e.piece.length + t.length, h = e.piece.lineFeedCnt, d = this.getLineFeedCnt(0, e.piece.start, l), u = d - h;
    e.piece = new zn(e.piece.bufferIndex, e.piece.start, l, d, c), this._lastChangeBufferPos = l, ra(this, e, t.length, u);
  }
  nodeAt(e) {
    let t = this.root;
    const i = this._searchCache.get(e);
    if (i)
      return {
        node: i.node,
        nodeStartOffset: i.nodeStartOffset,
        remainder: e - i.nodeStartOffset
      };
    let n = 0;
    for (; t !== Se; )
      if (t.size_left > e)
        t = t.left;
      else if (t.size_left + t.piece.length >= e) {
        n += t.size_left;
        const o = {
          node: t,
          remainder: e - t.size_left,
          nodeStartOffset: n
        };
        return this._searchCache.set(o), o;
      } else
        e -= t.size_left + t.piece.length, n += t.size_left + t.piece.length, t = t.right;
    return null;
  }
  nodeAt2(e, t) {
    let i = this.root, n = 0;
    for (; i !== Se; )
      if (i.left !== Se && i.lf_left >= e - 1)
        i = i.left;
      else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
        const o = this.getAccumulatedValue(i, e - i.lf_left - 2), r = this.getAccumulatedValue(i, e - i.lf_left - 1);
        return n += i.size_left, {
          node: i,
          remainder: Math.min(o + t - 1, r),
          nodeStartOffset: n
        };
      } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
        const o = this.getAccumulatedValue(i, e - i.lf_left - 2);
        if (o + t - 1 <= i.piece.length)
          return {
            node: i,
            remainder: o + t - 1,
            nodeStartOffset: n
          };
        t -= i.piece.length - o;
        break;
      } else
        e -= i.lf_left + i.piece.lineFeedCnt, n += i.size_left + i.piece.length, i = i.right;
    for (i = i.next(); i !== Se; ) {
      if (i.piece.lineFeedCnt > 0) {
        const o = this.getAccumulatedValue(i, 0), r = this.offsetOfNode(i);
        return {
          node: i,
          remainder: Math.min(t - 1, o),
          nodeStartOffset: r
        };
      } else if (i.piece.length >= t - 1) {
        const o = this.offsetOfNode(i);
        return {
          node: i,
          remainder: t - 1,
          nodeStartOffset: o
        };
      } else
        t -= i.piece.length;
      i = i.next();
    }
    return null;
  }
  nodeCharCodeAt(e, t) {
    if (e.piece.lineFeedCnt < 1)
      return -1;
    const i = this._buffers[e.piece.bufferIndex], n = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start) + t;
    return i.buffer.charCodeAt(n);
  }
  offsetOfNode(e) {
    if (!e)
      return 0;
    let t = e.size_left;
    for (; e !== this.root; )
      e.parent.right === e && (t += e.parent.size_left + e.parent.piece.length), e = e.parent;
    return t;
  }
  // #endregion
  // #region CRLF
  shouldCheckCRLF() {
    return !(this._EOLNormalized && this._EOL === `
`);
  }
  startWithLF(e) {
    if (typeof e == "string")
      return e.charCodeAt(0) === 10;
    if (e === Se || e.piece.lineFeedCnt === 0)
      return !1;
    const t = e.piece, i = this._buffers[t.bufferIndex].lineStarts, n = t.start.line, o = i[n] + t.start.column;
    return n === i.length - 1 || i[n + 1] > o + 1 ? !1 : this._buffers[t.bufferIndex].buffer.charCodeAt(o) === 10;
  }
  endWithCR(e) {
    return typeof e == "string" ? e.charCodeAt(e.length - 1) === 13 : e === Se || e.piece.lineFeedCnt === 0 ? !1 : this.nodeCharCodeAt(e, e.piece.length - 1) === 13;
  }
  validateCRLFWithPrevNode(e) {
    if (this.shouldCheckCRLF() && this.startWithLF(e)) {
      const t = e.prev();
      this.endWithCR(t) && this.fixCRLF(t, e);
    }
  }
  validateCRLFWithNextNode(e) {
    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
      const t = e.next();
      this.startWithLF(t) && this.fixCRLF(e, t);
    }
  }
  fixCRLF(e, t) {
    const i = [], n = this._buffers[e.piece.bufferIndex].lineStarts;
    let o;
    e.piece.end.column === 0 ? o = { line: e.piece.end.line - 1, column: n[e.piece.end.line] - n[e.piece.end.line - 1] - 1 } : o = { line: e.piece.end.line, column: e.piece.end.column - 1 };
    const r = e.piece.length - 1, a = e.piece.lineFeedCnt - 1;
    e.piece = new zn(e.piece.bufferIndex, e.piece.start, o, a, r), ra(this, e, -1, -1), e.piece.length === 0 && i.push(e);
    const l = { line: t.piece.start.line + 1, column: 0 }, c = t.piece.length - 1, h = this.getLineFeedCnt(t.piece.bufferIndex, l, t.piece.end);
    t.piece = new zn(t.piece.bufferIndex, l, t.piece.end, h, c), ra(this, t, -1, -1), t.piece.length === 0 && i.push(t);
    const d = this.createNewPieces(`\r
`);
    this.rbInsertRight(e, d[0]);
    for (let u = 0; u < i.length; u++)
      L_(this, i[u]);
  }
  adjustCarriageReturnFromNext(e, t) {
    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
      const i = t.next();
      if (this.startWithLF(i)) {
        if (e += `
`, i.piece.length === 1)
          L_(this, i);
        else {
          const n = i.piece, o = { line: n.start.line + 1, column: 0 }, r = n.length - 1, a = this.getLineFeedCnt(n.bufferIndex, o, n.end);
          i.piece = new zn(n.bufferIndex, o, n.end, a, r), ra(this, i, -1, -1);
        }
        return !0;
      }
    }
    return !1;
  }
  // #endregion
  // #endregion
  // #region Tree operations
  iterate(e, t) {
    if (e === Se)
      return t(Se);
    const i = this.iterate(e.left, t);
    return i && t(e) && this.iterate(e.right, t);
  }
  getNodeContent(e) {
    if (e === Se)
      return "";
    const t = this._buffers[e.piece.bufferIndex], i = e.piece, n = this.offsetInBuffer(i.bufferIndex, i.start), o = this.offsetInBuffer(i.bufferIndex, i.end);
    return t.buffer.substring(n, o);
  }
  getPieceContent(e) {
    const t = this._buffers[e.bufferIndex], i = this.offsetInBuffer(e.bufferIndex, e.start), n = this.offsetInBuffer(e.bufferIndex, e.end);
    return t.buffer.substring(i, n);
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b    <----   a    b
   *                         /
   *                        z
   */
  rbInsertRight(e, t) {
    const i = new dL(
      t,
      1
      /* NodeColor.Red */
    );
    if (i.left = Se, i.right = Se, i.parent = Se, i.size_left = 0, i.lf_left = 0, this.root === Se)
      this.root = i, i.color = 0;
    else if (e.right === Se)
      e.right = i, i.parent = e;
    else {
      const o = AI(e.right);
      o.left = i, i.parent = o;
    }
    return kM(this, i), i;
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b     ---->   a    b
   *                       \
   *                        z
   */
  rbInsertLeft(e, t) {
    const i = new dL(
      t,
      1
      /* NodeColor.Red */
    );
    if (i.left = Se, i.right = Se, i.parent = Se, i.size_left = 0, i.lf_left = 0, this.root === Se)
      this.root = i, i.color = 0;
    else if (e.left === Se)
      e.left = i, i.parent = e;
    else {
      const n = gF(e.left);
      n.right = i, i.parent = n;
    }
    return kM(this, i), i;
  }
}
class Vu extends U {
  constructor(e, t, i, n, o, r, a) {
    super(), this._onDidChangeContent = this._register(new A()), this._BOM = t, this._mightContainNonBasicASCII = !r, this._mightContainRTL = n, this._mightContainUnusualLineTerminators = o, this._pieceTree = new aZ(e, i, a);
  }
  mightContainRTL() {
    return this._mightContainRTL;
  }
  mightContainUnusualLineTerminators() {
    return this._mightContainUnusualLineTerminators;
  }
  resetMightContainUnusualLineTerminators() {
    this._mightContainUnusualLineTerminators = !1;
  }
  mightContainNonBasicASCII() {
    return this._mightContainNonBasicASCII;
  }
  getBOM() {
    return this._BOM;
  }
  getEOL() {
    return this._pieceTree.getEOL();
  }
  createSnapshot(e) {
    return this._pieceTree.createSnapshot(e ? this._BOM : "");
  }
  getOffsetAt(e, t) {
    return this._pieceTree.getOffsetAt(e, t);
  }
  getPositionAt(e) {
    return this._pieceTree.getPositionAt(e);
  }
  getRangeAt(e, t) {
    const i = e + t, n = this.getPositionAt(e), o = this.getPositionAt(i);
    return new T(n.lineNumber, n.column, o.lineNumber, o.column);
  }
  getValueInRange(e, t = 0) {
    if (e.isEmpty())
      return "";
    const i = this._getEndOfLine(t);
    return this._pieceTree.getValueInRange(e, i);
  }
  getValueLengthInRange(e, t = 0) {
    if (e.isEmpty())
      return 0;
    if (e.startLineNumber === e.endLineNumber)
      return e.endColumn - e.startColumn;
    const i = this.getOffsetAt(e.startLineNumber, e.startColumn), n = this.getOffsetAt(e.endLineNumber, e.endColumn);
    let o = 0;
    const r = this._getEndOfLine(t), a = this.getEOL();
    if (r.length !== a.length) {
      const l = r.length - a.length, c = e.endLineNumber - e.startLineNumber;
      o = l * c;
    }
    return n - i + o;
  }
  getCharacterCountInRange(e, t = 0) {
    if (this._mightContainNonBasicASCII) {
      let i = 0;
      const n = e.startLineNumber, o = e.endLineNumber;
      for (let r = n; r <= o; r++) {
        const a = this.getLineContent(r), l = r === n ? e.startColumn - 1 : 0, c = r === o ? e.endColumn - 1 : a.length;
        for (let h = l; h < c; h++)
          Si(a.charCodeAt(h)) ? (i = i + 1, h = h + 1) : i = i + 1;
      }
      return i += this._getEndOfLine(t).length * (o - n), i;
    }
    return this.getValueLengthInRange(e, t);
  }
  getLength() {
    return this._pieceTree.getLength();
  }
  getLineCount() {
    return this._pieceTree.getLineCount();
  }
  getLinesContent() {
    return this._pieceTree.getLinesContent();
  }
  getLineContent(e) {
    return this._pieceTree.getLineContent(e);
  }
  getLineCharCode(e, t) {
    return this._pieceTree.getLineCharCode(e, t);
  }
  getLineLength(e) {
    return this._pieceTree.getLineLength(e);
  }
  getLineFirstNonWhitespaceColumn(e) {
    const t = Zn(this.getLineContent(e));
    return t === -1 ? 0 : t + 1;
  }
  getLineLastNonWhitespaceColumn(e) {
    const t = id(this.getLineContent(e));
    return t === -1 ? 0 : t + 2;
  }
  _getEndOfLine(e) {
    switch (e) {
      case 1:
        return `
`;
      case 2:
        return `\r
`;
      case 0:
        return this.getEOL();
      default:
        throw new Error("Unknown EOL preference");
    }
  }
  setEOL(e) {
    this._pieceTree.setEOL(e);
  }
  applyEdits(e, t, i) {
    let n = this._mightContainRTL, o = this._mightContainUnusualLineTerminators, r = this._mightContainNonBasicASCII, a = !0, l = [];
    for (let p = 0; p < e.length; p++) {
      const _ = e[p];
      a && _._isTracked && (a = !1);
      const b = _.range;
      if (_.text) {
        let L = !0;
        r || (L = !fE(_.text), r = L), !n && L && (n = km(_.text)), !o && L && (o = u4(_.text));
      }
      let C = "", w = 0, v = 0, S = 0;
      if (_.text) {
        let L;
        [w, v, S, L] = pf(_.text);
        const k = this.getEOL();
        L === 0 || L === (k === `\r
` ? 2 : 1) ? C = _.text : C = _.text.replace(/\r\n|\r|\n/g, k);
      }
      l[p] = {
        sortIndex: p,
        identifier: _.identifier || null,
        range: b,
        rangeOffset: this.getOffsetAt(b.startLineNumber, b.startColumn),
        rangeLength: this.getValueLengthInRange(b),
        text: C,
        eolCount: w,
        firstLineLength: v,
        lastLineLength: S,
        forceMoveMarkers: !!_.forceMoveMarkers,
        isAutoWhitespaceEdit: _.isAutoWhitespaceEdit || !1
      };
    }
    l.sort(Vu._sortOpsAscending);
    let c = !1;
    for (let p = 0, _ = l.length - 1; p < _; p++) {
      const b = l[p].range.getEndPosition(), C = l[p + 1].range.getStartPosition();
      if (C.isBeforeOrEqual(b)) {
        if (C.isBefore(b))
          throw new Error("Overlapping ranges are not allowed!");
        c = !0;
      }
    }
    a && (l = this._reduceOperations(l));
    const h = i || t ? Vu._getInverseEditRanges(l) : [], d = [];
    if (t)
      for (let p = 0; p < l.length; p++) {
        const _ = l[p], b = h[p];
        if (_.isAutoWhitespaceEdit && _.range.isEmpty())
          for (let C = b.startLineNumber; C <= b.endLineNumber; C++) {
            let w = "";
            C === b.startLineNumber && (w = this.getLineContent(_.range.startLineNumber), Zn(w) !== -1) || d.push({ lineNumber: C, oldContent: w });
          }
      }
    let u = null;
    if (i) {
      let p = 0;
      u = [];
      for (let _ = 0; _ < l.length; _++) {
        const b = l[_], C = h[_], w = this.getValueInRange(b.range), v = b.rangeOffset + p;
        p += b.text.length - w.length, u[_] = {
          sortIndex: b.sortIndex,
          identifier: b.identifier,
          range: C,
          text: w,
          textChange: new Bi(b.rangeOffset, w, v, b.text)
        };
      }
      c || u.sort((_, b) => _.sortIndex - b.sortIndex);
    }
    this._mightContainRTL = n, this._mightContainUnusualLineTerminators = o, this._mightContainNonBasicASCII = r;
    const f = this._doApplyEdits(l);
    let g = null;
    if (t && d.length > 0) {
      d.sort((p, _) => _.lineNumber - p.lineNumber), g = [];
      for (let p = 0, _ = d.length; p < _; p++) {
        const b = d[p].lineNumber;
        if (p > 0 && d[p - 1].lineNumber === b)
          continue;
        const C = d[p].oldContent, w = this.getLineContent(b);
        w.length === 0 || w === C || Zn(w) !== -1 || g.push(b);
      }
    }
    return this._onDidChangeContent.fire(), new lq(u, f, g);
  }
  /**
   * Transform operations such that they represent the same logic edit,
   * but that they also do not cause OOM crashes.
   */
  _reduceOperations(e) {
    return e.length < 1e3 ? e : [this._toSingleEditOperation(e)];
  }
  _toSingleEditOperation(e) {
    let t = !1;
    const i = e[0].range, n = e[e.length - 1].range, o = new T(i.startLineNumber, i.startColumn, n.endLineNumber, n.endColumn);
    let r = i.startLineNumber, a = i.startColumn;
    const l = [];
    for (let f = 0, g = e.length; f < g; f++) {
      const p = e[f], _ = p.range;
      t = t || p.forceMoveMarkers, l.push(this.getValueInRange(new T(r, a, _.startLineNumber, _.startColumn))), p.text.length > 0 && l.push(p.text), r = _.endLineNumber, a = _.endColumn;
    }
    const c = l.join(""), [h, d, u] = pf(c);
    return {
      sortIndex: 0,
      identifier: e[0].identifier,
      range: o,
      rangeOffset: this.getOffsetAt(o.startLineNumber, o.startColumn),
      rangeLength: this.getValueLengthInRange(
        o,
        0
        /* EndOfLinePreference.TextDefined */
      ),
      text: c,
      eolCount: h,
      firstLineLength: d,
      lastLineLength: u,
      forceMoveMarkers: t,
      isAutoWhitespaceEdit: !1
    };
  }
  _doApplyEdits(e) {
    e.sort(Vu._sortOpsDescending);
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const n = e[i], o = n.range.startLineNumber, r = n.range.startColumn, a = n.range.endLineNumber, l = n.range.endColumn;
      if (o === a && r === l && n.text.length === 0)
        continue;
      n.text ? (this._pieceTree.delete(n.rangeOffset, n.rangeLength), this._pieceTree.insert(n.rangeOffset, n.text, !0)) : this._pieceTree.delete(n.rangeOffset, n.rangeLength);
      const c = new T(o, r, a, l);
      t.push({
        range: c,
        rangeLength: n.rangeLength,
        text: n.text,
        rangeOffset: n.rangeOffset,
        forceMoveMarkers: n.forceMoveMarkers
      });
    }
    return t;
  }
  findMatchesLineByLine(e, t, i, n) {
    return this._pieceTree.findMatchesLineByLine(e, t, i, n);
  }
  /**
   * Assumes `operations` are validated and sorted ascending
   */
  static _getInverseEditRanges(e) {
    const t = [];
    let i = 0, n = 0, o = null;
    for (let r = 0, a = e.length; r < a; r++) {
      const l = e[r];
      let c, h;
      o ? o.range.endLineNumber === l.range.startLineNumber ? (c = i, h = n + (l.range.startColumn - o.range.endColumn)) : (c = i + (l.range.startLineNumber - o.range.endLineNumber), h = l.range.startColumn) : (c = l.range.startLineNumber, h = l.range.startColumn);
      let d;
      if (l.text.length > 0) {
        const u = l.eolCount + 1;
        u === 1 ? d = new T(c, h, c, h + l.firstLineLength) : d = new T(c, h, c + u - 1, l.lastLineLength + 1);
      } else
        d = new T(c, h, c, h);
      i = d.endLineNumber, n = d.endColumn, t.push(d), o = l;
    }
    return t;
  }
  static _sortOpsAscending(e, t) {
    const i = T.compareRangesUsingEnds(e.range, t.range);
    return i === 0 ? e.sortIndex - t.sortIndex : i;
  }
  static _sortOpsDescending(e, t) {
    const i = T.compareRangesUsingEnds(e.range, t.range);
    return i === 0 ? t.sortIndex - e.sortIndex : -i;
  }
}
class lZ {
  constructor(e, t, i, n, o, r, a, l, c) {
    this._chunks = e, this._bom = t, this._cr = i, this._lf = n, this._crlf = o, this._containsRTL = r, this._containsUnusualLineTerminators = a, this._isBasicASCII = l, this._normalizeEOL = c;
  }
  _getEOL(e) {
    const t = this._cr + this._lf + this._crlf, i = this._cr + this._crlf;
    return t === 0 ? e === 1 ? `
` : `\r
` : i > t / 2 ? `\r
` : `
`;
  }
  create(e) {
    const t = this._getEOL(e), i = this._chunks;
    if (this._normalizeEOL && (t === `\r
` && (this._cr > 0 || this._lf > 0) || t === `
` && (this._cr > 0 || this._crlf > 0)))
      for (let o = 0, r = i.length; o < r; o++) {
        const a = i[o].buffer.replace(/\r\n|\r|\n/g, t), l = aa(a);
        i[o] = new Pc(a, l);
      }
    const n = new Vu(i, this._bom, t, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
    return { textBuffer: n, disposable: n };
  }
}
class pF {
  constructor() {
    this.chunks = [], this.BOM = "", this._hasPreviousChar = !1, this._previousChar = 0, this._tmpLineStarts = [], this.cr = 0, this.lf = 0, this.crlf = 0, this.containsRTL = !1, this.containsUnusualLineTerminators = !1, this.isBasicASCII = !0;
  }
  acceptChunk(e) {
    if (e.length === 0)
      return;
    this.chunks.length === 0 && mE(e) && (this.BOM = w8, e = e.substr(1));
    const t = e.charCodeAt(e.length - 1);
    t === 13 || t >= 55296 && t <= 56319 ? (this._acceptChunk1(e.substr(0, e.length - 1), !1), this._hasPreviousChar = !0, this._previousChar = t) : (this._acceptChunk1(e, !1), this._hasPreviousChar = !1, this._previousChar = t);
  }
  _acceptChunk1(e, t) {
    !t && e.length === 0 || (this._hasPreviousChar ? this._acceptChunk2(String.fromCharCode(this._previousChar) + e) : this._acceptChunk2(e));
  }
  _acceptChunk2(e) {
    const t = sZ(this._tmpLineStarts, e);
    this.chunks.push(new Pc(e, t.lineStarts)), this.cr += t.cr, this.lf += t.lf, this.crlf += t.crlf, t.isBasicASCII || (this.isBasicASCII = !1, this.containsRTL || (this.containsRTL = km(e)), this.containsUnusualLineTerminators || (this.containsUnusualLineTerminators = u4(e)));
  }
  finish(e = !0) {
    return this._finish(), new lZ(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, e);
  }
  _finish() {
    if (this.chunks.length === 0 && this._acceptChunk1("", !0), this._hasPreviousChar) {
      this._hasPreviousChar = !1;
      const e = this.chunks[this.chunks.length - 1];
      e.buffer += String.fromCharCode(this._previousChar);
      const t = aa(e.buffer);
      e.lineStarts = t, this._previousChar === 13 && this.cr++;
    }
  }
}
class Ne {
  static addRange(e, t) {
    let i = 0;
    for (; i < t.length && t[i].endExclusive < e.start; )
      i++;
    let n = i;
    for (; n < t.length && t[n].start <= e.endExclusive; )
      n++;
    if (i === n)
      t.splice(i, 0, e);
    else {
      const o = Math.min(e.start, t[i].start), r = Math.max(e.endExclusive, t[n - 1].endExclusive);
      t.splice(i, n - i, new Ne(o, r));
    }
  }
  static tryCreate(e, t) {
    if (!(e > t))
      return new Ne(e, t);
  }
  static ofLength(e) {
    return new Ne(0, e);
  }
  static ofStartAndLength(e, t) {
    return new Ne(e, e + t);
  }
  constructor(e, t) {
    if (this.start = e, this.endExclusive = t, e > t)
      throw new at(`Invalid range: ${this.toString()}`);
  }
  get isEmpty() {
    return this.start === this.endExclusive;
  }
  delta(e) {
    return new Ne(this.start + e, this.endExclusive + e);
  }
  deltaStart(e) {
    return new Ne(this.start + e, this.endExclusive);
  }
  deltaEnd(e) {
    return new Ne(this.start, this.endExclusive + e);
  }
  get length() {
    return this.endExclusive - this.start;
  }
  toString() {
    return `[${this.start}, ${this.endExclusive})`;
  }
  contains(e) {
    return this.start <= e && e < this.endExclusive;
  }
  /**
   * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
   * The joined range is the smallest range that contains both ranges.
   */
  join(e) {
    return new Ne(Math.min(this.start, e.start), Math.max(this.endExclusive, e.endExclusive));
  }
  /**
   * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
   *
   * The resulting range is empty if the ranges do not intersect, but touch.
   * If the ranges don't even touch, the result is undefined.
   */
  intersect(e) {
    const t = Math.max(this.start, e.start), i = Math.min(this.endExclusive, e.endExclusive);
    if (t <= i)
      return new Ne(t, i);
  }
  intersects(e) {
    const t = Math.max(this.start, e.start), i = Math.min(this.endExclusive, e.endExclusive);
    return t < i;
  }
  isBefore(e) {
    return this.endExclusive <= e.start;
  }
  isAfter(e) {
    return this.start >= e.endExclusive;
  }
  slice(e) {
    return e.slice(this.start, this.endExclusive);
  }
  substring(e) {
    return e.substring(this.start, this.endExclusive);
  }
  /**
   * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.
   * The range must not be empty.
   */
  clip(e) {
    if (this.isEmpty)
      throw new at(`Invalid clipping range: ${this.toString()}`);
    return Math.max(this.start, Math.min(this.endExclusive - 1, e));
  }
  /**
   * Returns `r := value + k * length` such that `r` is contained in this range.
   * The range must not be empty.
   *
   * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.
   */
  clipCyclic(e) {
    if (this.isEmpty)
      throw new at(`Invalid clipping range: ${this.toString()}`);
    return e < this.start ? this.endExclusive - (this.start - e) % this.length : e >= this.endExclusive ? this.start + (e - this.start) % this.length : e;
  }
  forEach(e) {
    for (let t = this.start; t < this.endExclusive; t++)
      e(t);
  }
}
class BI {
  constructor() {
    this._sortedRanges = [];
  }
  addRange(e) {
    let t = 0;
    for (; t < this._sortedRanges.length && this._sortedRanges[t].endExclusive < e.start; )
      t++;
    let i = t;
    for (; i < this._sortedRanges.length && this._sortedRanges[i].start <= e.endExclusive; )
      i++;
    if (t === i)
      this._sortedRanges.splice(t, 0, e);
    else {
      const n = Math.min(e.start, this._sortedRanges[t].start), o = Math.max(e.endExclusive, this._sortedRanges[i - 1].endExclusive);
      this._sortedRanges.splice(t, i - t, new Ne(n, o));
    }
  }
  toString() {
    return this._sortedRanges.map((e) => e.toString()).join(", ");
  }
  /**
   * Returns of there is a value that is contained in this instance and the given range.
   */
  intersectsStrict(e) {
    let t = 0;
    for (; t < this._sortedRanges.length && this._sortedRanges[t].endExclusive <= e.start; )
      t++;
    return t < this._sortedRanges.length && this._sortedRanges[t].start < e.endExclusive;
  }
  intersectWithRange(e) {
    const t = new BI();
    for (const i of this._sortedRanges) {
      const n = i.intersect(e);
      n && t.addRange(n);
    }
    return t;
  }
  intersectWithRangeLength(e) {
    return this.intersectWithRange(e).length;
  }
  get length() {
    return this._sortedRanges.reduce((e, t) => e + t.length, 0);
  }
}
class pe {
  static fromRangeInclusive(e) {
    return new pe(e.startLineNumber, e.endLineNumber + 1);
  }
  /**
   * @param lineRanges An array of sorted line ranges.
   */
  static joinMany(e) {
    if (e.length === 0)
      return [];
    let t = new Rs(e[0].slice());
    for (let i = 1; i < e.length; i++)
      t = t.getUnion(new Rs(e[i].slice()));
    return t.ranges;
  }
  static join(e) {
    if (e.length === 0)
      throw new at("lineRanges cannot be empty");
    let t = e[0].startLineNumber, i = e[0].endLineNumberExclusive;
    for (let n = 1; n < e.length; n++)
      t = Math.min(t, e[n].startLineNumber), i = Math.max(i, e[n].endLineNumberExclusive);
    return new pe(t, i);
  }
  static ofLength(e, t) {
    return new pe(e, e + t);
  }
  /**
   * @internal
   */
  static deserialize(e) {
    return new pe(e[0], e[1]);
  }
  constructor(e, t) {
    if (e > t)
      throw new at(`startLineNumber ${e} cannot be after endLineNumberExclusive ${t}`);
    this.startLineNumber = e, this.endLineNumberExclusive = t;
  }
  /**
   * Indicates if this line range contains the given line number.
   */
  contains(e) {
    return this.startLineNumber <= e && e < this.endLineNumberExclusive;
  }
  /**
   * Indicates if this line range is empty.
   */
  get isEmpty() {
    return this.startLineNumber === this.endLineNumberExclusive;
  }
  /**
   * Moves this line range by the given offset of line numbers.
   */
  delta(e) {
    return new pe(this.startLineNumber + e, this.endLineNumberExclusive + e);
  }
  deltaLength(e) {
    return new pe(this.startLineNumber, this.endLineNumberExclusive + e);
  }
  /**
   * The number of lines this line range spans.
   */
  get length() {
    return this.endLineNumberExclusive - this.startLineNumber;
  }
  /**
   * Creates a line range that combines this and the given line range.
   */
  join(e) {
    return new pe(Math.min(this.startLineNumber, e.startLineNumber), Math.max(this.endLineNumberExclusive, e.endLineNumberExclusive));
  }
  toString() {
    return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
  }
  /**
   * The resulting range is empty if the ranges do not intersect, but touch.
   * If the ranges don't even touch, the result is undefined.
   */
  intersect(e) {
    const t = Math.max(this.startLineNumber, e.startLineNumber), i = Math.min(this.endLineNumberExclusive, e.endLineNumberExclusive);
    if (t <= i)
      return new pe(t, i);
  }
  intersectsStrict(e) {
    return this.startLineNumber < e.endLineNumberExclusive && e.startLineNumber < this.endLineNumberExclusive;
  }
  overlapOrTouch(e) {
    return this.startLineNumber <= e.endLineNumberExclusive && e.startLineNumber <= this.endLineNumberExclusive;
  }
  equals(e) {
    return this.startLineNumber === e.startLineNumber && this.endLineNumberExclusive === e.endLineNumberExclusive;
  }
  toInclusiveRange() {
    return this.isEmpty ? null : new T(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
  }
  /**
   * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!
  */
  toExclusiveRange() {
    return new T(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
  }
  mapToLineArray(e) {
    const t = [];
    for (let i = this.startLineNumber; i < this.endLineNumberExclusive; i++)
      t.push(e(i));
    return t;
  }
  forEach(e) {
    for (let t = this.startLineNumber; t < this.endLineNumberExclusive; t++)
      e(t);
  }
  /**
   * @internal
   */
  serialize() {
    return [this.startLineNumber, this.endLineNumberExclusive];
  }
  includes(e) {
    return this.startLineNumber <= e && e < this.endLineNumberExclusive;
  }
  /**
   * Converts this 1-based line range to a 0-based offset range (subtracts 1!).
   * @internal
   */
  toOffsetRange() {
    return new Ne(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
  }
}
class Rs {
  constructor(e = []) {
    this._normalizedRanges = e;
  }
  get ranges() {
    return this._normalizedRanges;
  }
  addRange(e) {
    if (e.length === 0)
      return;
    const t = tL(this._normalizedRanges, (n) => n.endLineNumberExclusive >= e.startLineNumber), i = qm(this._normalizedRanges, (n) => n.startLineNumber <= e.endLineNumberExclusive) + 1;
    if (t === i)
      this._normalizedRanges.splice(t, 0, e);
    else if (t === i - 1) {
      const n = this._normalizedRanges[t];
      this._normalizedRanges[t] = n.join(e);
    } else {
      const n = this._normalizedRanges[t].join(this._normalizedRanges[i - 1]).join(e);
      this._normalizedRanges.splice(t, i - t, n);
    }
  }
  contains(e) {
    const t = mf(this._normalizedRanges, (i) => i.startLineNumber <= e);
    return !!t && t.endLineNumberExclusive > e;
  }
  intersects(e) {
    const t = mf(this._normalizedRanges, (i) => i.startLineNumber < e.endLineNumberExclusive);
    return !!t && t.endLineNumberExclusive > e.startLineNumber;
  }
  getUnion(e) {
    if (this._normalizedRanges.length === 0)
      return e;
    if (e._normalizedRanges.length === 0)
      return this;
    const t = [];
    let i = 0, n = 0, o = null;
    for (; i < this._normalizedRanges.length || n < e._normalizedRanges.length; ) {
      let r = null;
      if (i < this._normalizedRanges.length && n < e._normalizedRanges.length) {
        const a = this._normalizedRanges[i], l = e._normalizedRanges[n];
        a.startLineNumber < l.startLineNumber ? (r = a, i++) : (r = l, n++);
      } else i < this._normalizedRanges.length ? (r = this._normalizedRanges[i], i++) : (r = e._normalizedRanges[n], n++);
      o === null ? o = r : o.endLineNumberExclusive >= r.startLineNumber ? o = new pe(o.startLineNumber, Math.max(o.endLineNumberExclusive, r.endLineNumberExclusive)) : (t.push(o), o = r);
    }
    return o !== null && t.push(o), new Rs(t);
  }
  /**
   * Subtracts all ranges in this set from `range` and returns the result.
   */
  subtractFrom(e) {
    const t = tL(this._normalizedRanges, (r) => r.endLineNumberExclusive >= e.startLineNumber), i = qm(this._normalizedRanges, (r) => r.startLineNumber <= e.endLineNumberExclusive) + 1;
    if (t === i)
      return new Rs([e]);
    const n = [];
    let o = e.startLineNumber;
    for (let r = t; r < i; r++) {
      const a = this._normalizedRanges[r];
      a.startLineNumber > o && n.push(new pe(o, a.startLineNumber)), o = a.endLineNumberExclusive;
    }
    return o < e.endLineNumberExclusive && n.push(new pe(o, e.endLineNumberExclusive)), new Rs(n);
  }
  toString() {
    return this._normalizedRanges.map((e) => e.toString()).join(", ");
  }
  getIntersection(e) {
    const t = [];
    let i = 0, n = 0;
    for (; i < this._normalizedRanges.length && n < e._normalizedRanges.length; ) {
      const o = this._normalizedRanges[i], r = e._normalizedRanges[n], a = o.intersect(r);
      a && !a.isEmpty && t.push(a), o.endLineNumberExclusive < r.endLineNumberExclusive ? i++ : n++;
    }
    return new Rs(t);
  }
  getWithDelta(e) {
    return new Rs(this._normalizedRanges.map((t) => t.delta(e)));
  }
}
const ep = new class {
  clone() {
    return this;
  }
  equals(s) {
    return this === s;
  }
}();
function _F(s, e) {
  return new _I([new Km(0, "", s)], e);
}
function WI(s, e) {
  const t = new Uint32Array(2);
  return t[0] = 0, t[1] = (s << 0 | 0 | 0 | 32768 | 2 << 24) >>> 0, new kw(t, e === null ? ep : e);
}
class cZ {
  constructor(e) {
    this._default = e, this._store = [];
  }
  get(e) {
    return e < this._store.length ? this._store[e] : this._default;
  }
  set(e, t) {
    for (; e >= this._store.length; )
      this._store[this._store.length] = this._default;
    this._store[e] = t;
  }
  replace(e, t, i) {
    if (e >= this._store.length)
      return;
    if (t === 0) {
      this.insert(e, i);
      return;
    } else if (i === 0) {
      this.delete(e, t);
      return;
    }
    const n = this._store.slice(0, e), o = this._store.slice(e + t), r = hZ(i, this._default);
    this._store = n.concat(r, o);
  }
  delete(e, t) {
    t === 0 || e >= this._store.length || this._store.splice(e, t);
  }
  insert(e, t) {
    if (t === 0 || e >= this._store.length)
      return;
    const i = [];
    for (let n = 0; n < t; n++)
      i[n] = this._default;
    this._store = tw(this._store, e, i);
  }
}
function hZ(s, e) {
  const t = [];
  for (let i = 0; i < s; i++)
    t[i] = e;
  return t;
}
class dZ {
  /**
   * (Inclusive) start line number for these tokens.
   */
  get startLineNumber() {
    return this._startLineNumber;
  }
  /**
   * (Inclusive) end line number for these tokens.
   */
  get endLineNumber() {
    return this._startLineNumber + this._tokens.length - 1;
  }
  constructor(e, t) {
    this._startLineNumber = e, this._tokens = t;
  }
  /**
   * @see {@link _tokens}
   */
  getLineTokens(e) {
    return this._tokens[e - this._startLineNumber];
  }
  appendLineTokens(e) {
    this._tokens.push(e);
  }
}
class uL {
  constructor() {
    this._tokens = [];
  }
  add(e, t) {
    if (this._tokens.length > 0) {
      const i = this._tokens[this._tokens.length - 1];
      if (i.endLineNumber + 1 === e) {
        i.appendLineTokens(t);
        return;
      }
    }
    this._tokens.push(new dZ(e, [t]));
  }
  finalize() {
    return this._tokens;
  }
}
class uZ {
  constructor(e, t) {
    this.tokenizationSupport = t, this.initialState = this.tokenizationSupport.getInitialState(), this.store = new fL(e);
  }
  getStartState(e) {
    return this.store.getStartState(e, this.initialState);
  }
  getFirstInvalidLine() {
    return this.store.getFirstInvalidLine(this.initialState);
  }
}
class fZ extends uZ {
  constructor(e, t, i, n) {
    super(e, t), this._textModel = i, this._languageIdCodec = n;
  }
  updateTokensUntilLine(e, t) {
    const i = this._textModel.getLanguageId();
    for (; ; ) {
      const n = this.getFirstInvalidLine();
      if (!n || n.lineNumber > t)
        break;
      const o = this._textModel.getLineContent(n.lineNumber), r = ng(this._languageIdCodec, i, this.tokenizationSupport, o, !0, n.startState);
      e.add(n.lineNumber, r.tokens), this.store.setEndState(n.lineNumber, r.endState);
    }
  }
  /** assumes state is up to date */
  getTokenTypeIfInsertingCharacter(e, t) {
    const i = this.getStartState(e.lineNumber);
    if (!i)
      return 0;
    const n = this._textModel.getLanguageId(), o = this._textModel.getLineContent(e.lineNumber), r = o.substring(0, e.column - 1) + t + o.substring(e.column - 1), a = ng(this._languageIdCodec, n, this.tokenizationSupport, r, !0, i), l = new Ti(a.tokens, r, this._languageIdCodec);
    if (l.getCount() === 0)
      return 0;
    const c = l.findTokenIndexAtOffset(e.column - 1);
    return l.getStandardTokenType(c);
  }
  /** assumes state is up to date */
  tokenizeLineWithEdit(e, t, i) {
    const n = e.lineNumber, o = e.column, r = this.getStartState(n);
    if (!r)
      return null;
    const a = this._textModel.getLineContent(n), l = a.substring(0, o - 1) + i + a.substring(o - 1 + t), c = this._textModel.getLanguageIdAtPosition(n, 0), h = ng(this._languageIdCodec, c, this.tokenizationSupport, l, !0, r);
    return new Ti(h.tokens, l, this._languageIdCodec);
  }
  hasAccurateTokensForLine(e) {
    const t = this.store.getFirstInvalidEndStateLineNumberOrMax();
    return e < t;
  }
  isCheapToTokenize(e) {
    const t = this.store.getFirstInvalidEndStateLineNumberOrMax();
    return e < t || e === t && this._textModel.getLineLength(e) < 2048;
  }
  /**
   * The result is not cached.
   */
  tokenizeHeuristically(e, t, i) {
    if (i <= this.store.getFirstInvalidEndStateLineNumberOrMax())
      return { heuristicTokens: !1 };
    if (t <= this.store.getFirstInvalidEndStateLineNumberOrMax())
      return this.updateTokensUntilLine(e, i), { heuristicTokens: !1 };
    let n = this.guessStartState(t);
    const o = this._textModel.getLanguageId();
    for (let r = t; r <= i; r++) {
      const a = this._textModel.getLineContent(r), l = ng(this._languageIdCodec, o, this.tokenizationSupport, a, !0, n);
      e.add(r, l.tokens), n = l.endState;
    }
    return { heuristicTokens: !0 };
  }
  guessStartState(e) {
    let t = this._textModel.getLineFirstNonWhitespaceColumn(e);
    const i = [];
    let n = null;
    for (let a = e - 1; t > 1 && a >= 1; a--) {
      const l = this._textModel.getLineFirstNonWhitespaceColumn(a);
      if (l !== 0 && l < t && (i.push(this._textModel.getLineContent(a)), t = l, n = this.getStartState(a), n))
        break;
    }
    n || (n = this.tokenizationSupport.getInitialState()), i.reverse();
    const o = this._textModel.getLanguageId();
    let r = n;
    for (const a of i)
      r = ng(this._languageIdCodec, o, this.tokenizationSupport, a, !1, r).endState;
    return r;
  }
}
class fL {
  constructor(e) {
    this.lineCount = e, this._tokenizationStateStore = new gZ(), this._invalidEndStatesLineNumbers = new mZ(), this._invalidEndStatesLineNumbers.addRange(new Ne(1, e + 1));
  }
  getEndState(e) {
    return this._tokenizationStateStore.getEndState(e);
  }
  /**
   * @returns if the end state has changed.
   */
  setEndState(e, t) {
    if (!t)
      throw new at("Cannot set null/undefined state");
    this._invalidEndStatesLineNumbers.delete(e);
    const i = this._tokenizationStateStore.setEndState(e, t);
    return i && e < this.lineCount && this._invalidEndStatesLineNumbers.addRange(new Ne(e + 1, e + 2)), i;
  }
  acceptChange(e, t) {
    this.lineCount += t - e.length, this._tokenizationStateStore.acceptChange(e, t), this._invalidEndStatesLineNumbers.addRangeAndResize(new Ne(e.startLineNumber, e.endLineNumberExclusive), t);
  }
  acceptChanges(e) {
    for (const t of e) {
      const [i] = pf(t.text);
      this.acceptChange(new pe(t.range.startLineNumber, t.range.endLineNumber + 1), i + 1);
    }
  }
  invalidateEndStateRange(e) {
    this._invalidEndStatesLineNumbers.addRange(new Ne(e.startLineNumber, e.endLineNumberExclusive));
  }
  getFirstInvalidEndStateLineNumber() {
    return this._invalidEndStatesLineNumbers.min;
  }
  getFirstInvalidEndStateLineNumberOrMax() {
    return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;
  }
  allStatesValid() {
    return this._invalidEndStatesLineNumbers.min === null;
  }
  getStartState(e, t) {
    return e === 1 ? t : this.getEndState(e - 1);
  }
  getFirstInvalidLine(e) {
    const t = this.getFirstInvalidEndStateLineNumber();
    if (t === null)
      return null;
    const i = this.getStartState(t, e);
    if (!i)
      throw new at("Start state must be defined");
    return { lineNumber: t, startState: i };
  }
}
class gZ {
  constructor() {
    this._lineEndStates = new cZ(null);
  }
  getEndState(e) {
    return this._lineEndStates.get(e);
  }
  setEndState(e, t) {
    const i = this._lineEndStates.get(e);
    return i && i.equals(t) ? !1 : (this._lineEndStates.set(e, t), !0);
  }
  acceptChange(e, t) {
    let i = e.length;
    t > 0 && i > 0 && (i--, t--), this._lineEndStates.replace(e.startLineNumber, i, t);
  }
}
class mZ {
  constructor() {
    this._ranges = [];
  }
  get min() {
    return this._ranges.length === 0 ? null : this._ranges[0].start;
  }
  delete(e) {
    const t = this._ranges.findIndex((i) => i.contains(e));
    if (t !== -1) {
      const i = this._ranges[t];
      i.start === e ? i.endExclusive === e + 1 ? this._ranges.splice(t, 1) : this._ranges[t] = new Ne(e + 1, i.endExclusive) : i.endExclusive === e + 1 ? this._ranges[t] = new Ne(i.start, e) : this._ranges.splice(t, 1, new Ne(i.start, e), new Ne(e + 1, i.endExclusive));
    }
  }
  addRange(e) {
    Ne.addRange(e, this._ranges);
  }
  addRangeAndResize(e, t) {
    let i = 0;
    for (; !(i >= this._ranges.length || e.start <= this._ranges[i].endExclusive); )
      i++;
    let n = i;
    for (; !(n >= this._ranges.length || e.endExclusive < this._ranges[n].start); )
      n++;
    const o = t - e.length;
    for (let r = n; r < this._ranges.length; r++)
      this._ranges[r] = this._ranges[r].delta(o);
    if (i === n) {
      const r = new Ne(e.start, e.start + t);
      r.isEmpty || this._ranges.splice(i, 0, r);
    } else {
      const r = Math.min(e.start, this._ranges[i].start), a = Math.max(e.endExclusive, this._ranges[n - 1].endExclusive), l = new Ne(r, a + o);
      l.isEmpty ? this._ranges.splice(i, n - i) : this._ranges.splice(i, n - i, l);
    }
  }
  toString() {
    return this._ranges.map((e) => e.toString()).join(" + ");
  }
}
function ng(s, e, t, i, n, o) {
  let r = null;
  if (t)
    try {
      r = t.tokenizeEncoded(i, n, o.clone());
    } catch (a) {
      Je(a);
    }
  return r || (r = WI(s.encodeLanguageId(e), o)), Ti.convertToEndOffset(r.tokens, i.length), r;
}
class pZ {
  constructor(e, t) {
    this._tokenizerWithStateStore = e, this._backgroundTokenStore = t, this._isDisposed = !1, this._isScheduled = !1;
  }
  dispose() {
    this._isDisposed = !0;
  }
  handleChanges() {
    this._beginBackgroundTokenization();
  }
  _beginBackgroundTokenization() {
    this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize() || (this._isScheduled = !0, S4((e) => {
      this._isScheduled = !1, this._backgroundTokenizeWithDeadline(e);
    }));
  }
  /**
   * Tokenize until the deadline occurs, but try to yield every 1-2ms.
   */
  _backgroundTokenizeWithDeadline(e) {
    const t = Date.now() + e.timeRemaining(), i = () => {
      this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize() || (this._backgroundTokenizeForAtLeast1ms(), Date.now() < t ? jP(i) : this._beginBackgroundTokenization());
    };
    i();
  }
  /**
   * Tokenize for at least 1ms.
   */
  _backgroundTokenizeForAtLeast1ms() {
    const e = this._tokenizerWithStateStore._textModel.getLineCount(), t = new uL(), i = Ga.create(!1);
    do
      if (i.elapsed() > 1 || this._tokenizeOneInvalidLine(t) >= e)
        break;
    while (this._hasLinesToTokenize());
    this._backgroundTokenStore.setTokens(t.finalize()), this.checkFinished();
  }
  _hasLinesToTokenize() {
    return this._tokenizerWithStateStore ? !this._tokenizerWithStateStore.store.allStatesValid() : !1;
  }
  _tokenizeOneInvalidLine(e) {
    var i;
    const t = (i = this._tokenizerWithStateStore) == null ? void 0 : i.getFirstInvalidLine();
    return t ? (this._tokenizerWithStateStore.updateTokensUntilLine(e, t.lineNumber), t.lineNumber) : this._tokenizerWithStateStore._textModel.getLineCount() + 1;
  }
  checkFinished() {
    this._isDisposed || this._tokenizerWithStateStore.store.allStatesValid() && this._backgroundTokenStore.backgroundTokenizationFinished();
  }
  requestTokens(e, t) {
    this._tokenizerWithStateStore.store.invalidateEndStateRange(new pe(e, t));
  }
}
class _Z {
  constructor() {
    this._onDidChangeVisibleRanges = new A(), this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event, this._views = /* @__PURE__ */ new Set();
  }
  attachView() {
    const e = new bZ((t) => {
      this._onDidChangeVisibleRanges.fire({ view: e, state: t });
    });
    return this._views.add(e), e;
  }
  detachView(e) {
    this._views.delete(e), this._onDidChangeVisibleRanges.fire({ view: e, state: void 0 });
  }
}
class bZ {
  constructor(e) {
    this.handleStateChange = e;
  }
  setVisibleLines(e, t) {
    const i = e.map((n) => new pe(n.startLineNumber, n.endLineNumber + 1));
    this.handleStateChange({ visibleLineRanges: i, stabilized: t });
  }
}
class CZ extends U {
  get lineRanges() {
    return this._lineRanges;
  }
  constructor(e) {
    super(), this._refreshTokens = e, this.runner = this._register(new ai(() => this.update(), 50)), this._computedLineRanges = [], this._lineRanges = [];
  }
  update() {
    li(this._computedLineRanges, this._lineRanges, (e, t) => e.equals(t)) || (this._computedLineRanges = this._lineRanges, this._refreshTokens());
  }
  handleStateChange(e) {
    this._lineRanges = e.visibleLineRanges, e.stabilized ? (this.runner.cancel(), this.update()) : this.runner.schedule();
  }
}
class bF extends U {
  get backgroundTokenizationState() {
    return this._backgroundTokenizationState;
  }
  constructor(e, t, i) {
    super(), this._languageIdCodec = e, this._textModel = t, this.getLanguageId = i, this._backgroundTokenizationState = 1, this._onDidChangeBackgroundTokenizationState = this._register(new A()), this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event, this._onDidChangeTokens = this._register(new A()), this.onDidChangeTokens = this._onDidChangeTokens.event;
  }
  tokenizeIfCheap(e) {
    this.isCheapToTokenize(e) && this.forceTokenization(e);
  }
}
class DM extends bF {
  constructor(e, t, i, n) {
    super(t, i, n), this._treeSitterService = e, this._tokenizationSupport = null, this._initialize();
  }
  _initialize() {
    const e = this.getLanguageId();
    (!this._tokenizationSupport || this._lastLanguageId !== e) && (this._lastLanguageId = e, this._tokenizationSupport = KS.get(e));
  }
  getLineTokens(e) {
    const t = this._textModel.getLineContent(e);
    if (this._tokenizationSupport) {
      const i = this._tokenizationSupport.tokenizeEncoded(e, this._textModel);
      if (i)
        return new Ti(i, t, this._languageIdCodec);
    }
    return Ti.createEmpty(t, this._languageIdCodec);
  }
  resetTokenization(e = !0) {
    e && this._onDidChangeTokens.fire({
      semanticTokensApplied: !1,
      ranges: [
        {
          fromLineNumber: 1,
          toLineNumber: this._textModel.getLineCount()
        }
      ]
    }), this._initialize();
  }
  handleDidChangeAttached() {
  }
  handleDidChangeContent(e) {
    e.isFlush && this.resetTokenization(!1);
  }
  forceTokenization(e) {
  }
  hasAccurateTokensForLine(e) {
    return !0;
  }
  isCheapToTokenize(e) {
    return !0;
  }
  getTokenTypeIfInsertingCharacter(e, t, i) {
    return 0;
  }
  tokenizeLineWithEdit(e, t, i) {
    return null;
  }
  get hasTokens() {
    return this._treeSitterService.getParseResult(this._textModel) !== void 0;
  }
}
const CF = Be("treeSitterParserService"), la = new Uint32Array(0).buffer;
class wr {
  static deleteBeginning(e, t) {
    return e === null || e === la ? e : wr.delete(e, 0, t);
  }
  static deleteEnding(e, t) {
    if (e === null || e === la)
      return e;
    const i = Sa(e), n = i[i.length - 2];
    return wr.delete(e, t, n);
  }
  static delete(e, t, i) {
    if (e === null || e === la || t === i)
      return e;
    const n = Sa(e), o = n.length >>> 1;
    if (t === 0 && n[n.length - 2] === i)
      return la;
    const r = Ti.findIndexInTokensArray(n, t), a = r > 0 ? n[r - 1 << 1] : 0, l = n[r << 1];
    if (i < l) {
      const f = i - t;
      for (let g = r; g < o; g++)
        n[g << 1] -= f;
      return e;
    }
    let c, h;
    a !== t ? (n[r << 1] = t, c = r + 1 << 1, h = t) : (c = r << 1, h = a);
    const d = i - t;
    for (let f = r + 1; f < o; f++) {
      const g = n[f << 1] - d;
      g > h && (n[c++] = g, n[c++] = n[(f << 1) + 1], h = g);
    }
    if (c === n.length)
      return e;
    const u = new Uint32Array(c);
    return u.set(n.subarray(0, c), 0), u.buffer;
  }
  static append(e, t) {
    if (t === la)
      return e;
    if (e === la)
      return t;
    if (e === null)
      return e;
    if (t === null)
      return null;
    const i = Sa(e), n = Sa(t), o = n.length >>> 1, r = new Uint32Array(i.length + n.length);
    r.set(i, 0);
    let a = i.length;
    const l = i[i.length - 2];
    for (let c = 0; c < o; c++)
      r[a++] = n[c << 1] + l, r[a++] = n[(c << 1) + 1];
    return r.buffer;
  }
  static insert(e, t, i) {
    if (e === null || e === la)
      return e;
    const n = Sa(e), o = n.length >>> 1;
    let r = Ti.findIndexInTokensArray(n, t);
    r > 0 && n[r - 1 << 1] === t && r--;
    for (let a = r; a < o; a++)
      n[a << 1] += i;
    return e;
  }
}
function Sa(s) {
  return s instanceof Uint32Array ? s : new Uint32Array(s);
}
class tp {
  constructor(e) {
    this._lineTokens = [], this._len = 0, this._languageIdCodec = e;
  }
  flush() {
    this._lineTokens = [], this._len = 0;
  }
  get hasTokens() {
    return this._lineTokens.length > 0;
  }
  getTokens(e, t, i) {
    let n = null;
    if (t < this._len && (n = this._lineTokens[t]), n !== null && n !== la)
      return new Ti(Sa(n), i, this._languageIdCodec);
    const o = new Uint32Array(2);
    return o[0] = i.length, o[1] = EM(this._languageIdCodec.encodeLanguageId(e)), new Ti(o, i, this._languageIdCodec);
  }
  static _massageTokens(e, t, i) {
    const n = i ? Sa(i) : null;
    if (t === 0) {
      let o = !1;
      if (n && n.length > 1 && (o = Bo.getLanguageId(n[1]) !== e), !o)
        return la;
    }
    if (!n || n.length === 0) {
      const o = new Uint32Array(2);
      return o[0] = t, o[1] = EM(e), o.buffer;
    }
    return n[n.length - 2] = t, n.byteOffset === 0 && n.byteLength === n.buffer.byteLength ? n.buffer : n;
  }
  _ensureLine(e) {
    for (; e >= this._len; )
      this._lineTokens[this._len] = null, this._len++;
  }
  _deleteLines(e, t) {
    t !== 0 && (e + t > this._len && (t = this._len - e), this._lineTokens.splice(e, t), this._len -= t);
  }
  _insertLines(e, t) {
    if (t === 0)
      return;
    const i = [];
    for (let n = 0; n < t; n++)
      i[n] = null;
    this._lineTokens = tw(this._lineTokens, e, i), this._len += t;
  }
  setTokens(e, t, i, n, o) {
    const r = tp._massageTokens(this._languageIdCodec.encodeLanguageId(e), i, n);
    this._ensureLine(t);
    const a = this._lineTokens[t];
    return this._lineTokens[t] = r, o ? !tp._equals(a, r) : !1;
  }
  static _equals(e, t) {
    if (!e || !t)
      return !e && !t;
    const i = Sa(e), n = Sa(t);
    if (i.length !== n.length)
      return !1;
    for (let o = 0, r = i.length; o < r; o++)
      if (i[o] !== n[o])
        return !1;
    return !0;
  }
  //#region Editing
  acceptEdit(e, t, i) {
    this._acceptDeleteRange(e), this._acceptInsertText(new F(e.startLineNumber, e.startColumn), t, i);
  }
  _acceptDeleteRange(e) {
    const t = e.startLineNumber - 1;
    if (t >= this._len)
      return;
    if (e.startLineNumber === e.endLineNumber) {
      if (e.startColumn === e.endColumn)
        return;
      this._lineTokens[t] = wr.delete(this._lineTokens[t], e.startColumn - 1, e.endColumn - 1);
      return;
    }
    this._lineTokens[t] = wr.deleteEnding(this._lineTokens[t], e.startColumn - 1);
    const i = e.endLineNumber - 1;
    let n = null;
    i < this._len && (n = wr.deleteBeginning(this._lineTokens[i], e.endColumn - 1)), this._lineTokens[t] = wr.append(this._lineTokens[t], n), this._deleteLines(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, t, i) {
    if (t === 0 && i === 0)
      return;
    const n = e.lineNumber - 1;
    if (!(n >= this._len)) {
      if (t === 0) {
        this._lineTokens[n] = wr.insert(this._lineTokens[n], e.column - 1, i);
        return;
      }
      this._lineTokens[n] = wr.deleteEnding(this._lineTokens[n], e.column - 1), this._lineTokens[n] = wr.insert(this._lineTokens[n], e.column - 1, i), this._insertLines(e.lineNumber, t);
    }
  }
  //#endregion
  setMultilineTokens(e, t) {
    if (e.length === 0)
      return { changes: [] };
    const i = [];
    for (let n = 0, o = e.length; n < o; n++) {
      const r = e[n];
      let a = 0, l = 0, c = !1;
      for (let h = r.startLineNumber; h <= r.endLineNumber; h++)
        c ? (this.setTokens(t.getLanguageId(), h - 1, t.getLineLength(h), r.getLineTokens(h), !1), l = h) : this.setTokens(t.getLanguageId(), h - 1, t.getLineLength(h), r.getLineTokens(h), !0) && (c = !0, a = h, l = h);
      c && i.push({ fromLineNumber: a, toLineNumber: l });
    }
    return { changes: i };
  }
}
function EM(s) {
  return (s << 0 | 0 | 0 | 32768 | 2 << 24 | 1024) >>> 0;
}
class HI {
  constructor(e) {
    this._pieces = [], this._isComplete = !1, this._languageIdCodec = e;
  }
  flush() {
    this._pieces = [], this._isComplete = !1;
  }
  isEmpty() {
    return this._pieces.length === 0;
  }
  set(e, t) {
    this._pieces = e || [], this._isComplete = t;
  }
  setPartial(e, t) {
    let i = e;
    if (t.length > 0) {
      const o = t[0].getRange(), r = t[t.length - 1].getRange();
      if (!o || !r)
        return e;
      i = e.plusRange(o).plusRange(r);
    }
    let n = null;
    for (let o = 0, r = this._pieces.length; o < r; o++) {
      const a = this._pieces[o];
      if (a.endLineNumber < i.startLineNumber)
        continue;
      if (a.startLineNumber > i.endLineNumber) {
        n = n || { index: o };
        break;
      }
      if (a.removeTokens(i), a.isEmpty()) {
        this._pieces.splice(o, 1), o--, r--;
        continue;
      }
      if (a.endLineNumber < i.startLineNumber)
        continue;
      if (a.startLineNumber > i.endLineNumber) {
        n = n || { index: o };
        continue;
      }
      const [l, c] = a.split(i);
      if (l.isEmpty()) {
        n = n || { index: o };
        continue;
      }
      c.isEmpty() || (this._pieces.splice(o, 1, l, c), o++, r++, n = n || { index: o });
    }
    return n = n || { index: this._pieces.length }, t.length > 0 && (this._pieces = tw(this._pieces, n.index, t)), i;
  }
  isComplete() {
    return this._isComplete;
  }
  addSparseTokens(e, t) {
    if (t.getLineContent().length === 0)
      return t;
    const i = this._pieces;
    if (i.length === 0)
      return t;
    const n = HI._findFirstPieceWithLine(i, e), o = i[n].getLineTokens(e);
    if (!o)
      return t;
    const r = t.getCount(), a = o.getCount();
    let l = 0;
    const c = [];
    let h = 0, d = 0;
    const u = (f, g) => {
      f !== d && (d = f, c[h++] = f, c[h++] = g);
    };
    for (let f = 0; f < a; f++) {
      const g = o.getStartCharacter(f), p = o.getEndCharacter(f), _ = o.getMetadata(f), b = ((_ & 1 ? 2048 : 0) | (_ & 2 ? 4096 : 0) | (_ & 4 ? 8192 : 0) | (_ & 8 ? 16384 : 0) | (_ & 16 ? 16744448 : 0) | (_ & 32 ? 4278190080 : 0)) >>> 0, C = ~b >>> 0;
      for (; l < r && t.getEndOffset(l) <= g; )
        u(t.getEndOffset(l), t.getMetadata(l)), l++;
      for (l < r && t.getStartOffset(l) < g && u(g, t.getMetadata(l)); l < r && t.getEndOffset(l) < p; )
        u(t.getEndOffset(l), t.getMetadata(l) & C | _ & b), l++;
      if (l < r)
        u(p, t.getMetadata(l) & C | _ & b), t.getEndOffset(l) === p && l++;
      else {
        const w = Math.min(Math.max(0, l - 1), r - 1);
        u(p, t.getMetadata(w) & C | _ & b);
      }
    }
    for (; l < r; )
      u(t.getEndOffset(l), t.getMetadata(l)), l++;
    return new Ti(new Uint32Array(c), t.getLineContent(), this._languageIdCodec);
  }
  static _findFirstPieceWithLine(e, t) {
    let i = 0, n = e.length - 1;
    for (; i < n; ) {
      let o = i + Math.floor((n - i) / 2);
      if (e[o].endLineNumber < t)
        i = o + 1;
      else if (e[o].startLineNumber > t)
        n = o - 1;
      else {
        for (; o > i && e[o - 1].startLineNumber <= t && t <= e[o - 1].endLineNumber; )
          o--;
        return o;
      }
    }
    return i;
  }
  acceptEdit(e, t, i, n, o) {
    for (const r of this._pieces)
      r.acceptEdit(e, t, i, n, o);
  }
}
var vZ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, X0 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, db;
let gL = db = class extends X5 {
  constructor(e, t, i, n, o, r, a) {
    super(), this._textModel = e, this._bracketPairsTextModelPart = t, this._languageId = i, this._attachedViews = n, this._languageService = o, this._languageConfigurationService = r, this._treeSitterService = a, this._semanticTokens = new HI(this._languageService.languageIdCodec), this._onDidChangeLanguage = this._register(new A()), this.onDidChangeLanguage = this._onDidChangeLanguage.event, this._onDidChangeLanguageConfiguration = this._register(new A()), this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event, this._onDidChangeTokens = this._register(new A()), this.onDidChangeTokens = this._onDidChangeTokens.event, this._tokensDisposables = this._register(new ne()), this._register(this._languageConfigurationService.onDidChange((l) => {
      l.affects(this._languageId) && this._onDidChangeLanguageConfiguration.fire({});
    })), this._register(ee.filter(KS.onDidChange, (l) => l.changedLanguages.includes(this._languageId))(() => {
      this.createPreferredTokenProvider();
    })), this.createPreferredTokenProvider();
  }
  createGrammarTokens() {
    return this._register(new IM(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));
  }
  createTreeSitterTokens() {
    return this._register(new DM(this._treeSitterService, this._languageService.languageIdCodec, this._textModel, () => this._languageId));
  }
  createTokens(e) {
    var i;
    const t = this._tokens !== void 0;
    (i = this._tokens) == null || i.dispose(), this._tokens = e ? this.createTreeSitterTokens() : this.createGrammarTokens(), this._tokensDisposables.clear(), this._tokensDisposables.add(this._tokens.onDidChangeTokens((n) => {
      this._emitModelTokensChangedEvent(n);
    })), this._tokensDisposables.add(this._tokens.onDidChangeBackgroundTokenizationState((n) => {
      this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();
    })), t && this._tokens.resetTokenization();
  }
  createPreferredTokenProvider() {
    KS.get(this._languageId) ? this._tokens instanceof DM || this.createTokens(!0) : this._tokens instanceof IM || this.createTokens(!1);
  }
  handleLanguageConfigurationServiceChange(e) {
    e.affects(this._languageId) && this._onDidChangeLanguageConfiguration.fire({});
  }
  handleDidChangeContent(e) {
    if (e.isFlush)
      this._semanticTokens.flush();
    else if (!e.isEolChange)
      for (const t of e.changes) {
        const [i, n, o] = pf(t.text);
        this._semanticTokens.acceptEdit(
          t.range,
          i,
          n,
          o,
          t.text.length > 0 ? t.text.charCodeAt(0) : 0
          /* CharCode.Null */
        );
      }
    this._tokens.handleDidChangeContent(e);
  }
  handleDidChangeAttached() {
    this._tokens.handleDidChangeAttached();
  }
  /**
   * Includes grammar and semantic tokens.
   */
  getLineTokens(e) {
    this.validateLineNumber(e);
    const t = this._tokens.getLineTokens(e);
    return this._semanticTokens.addSparseTokens(e, t);
  }
  _emitModelTokensChangedEvent(e) {
    this._textModel._isDisposing() || (this._bracketPairsTextModelPart.handleDidChangeTokens(e), this._onDidChangeTokens.fire(e));
  }
  // #region Grammar Tokens
  validateLineNumber(e) {
    if (e < 1 || e > this._textModel.getLineCount())
      throw new at("Illegal value for lineNumber");
  }
  get hasTokens() {
    return this._tokens.hasTokens;
  }
  resetTokenization() {
    this._tokens.resetTokenization();
  }
  get backgroundTokenizationState() {
    return this._tokens.backgroundTokenizationState;
  }
  forceTokenization(e) {
    this.validateLineNumber(e), this._tokens.forceTokenization(e);
  }
  hasAccurateTokensForLine(e) {
    return this.validateLineNumber(e), this._tokens.hasAccurateTokensForLine(e);
  }
  isCheapToTokenize(e) {
    return this.validateLineNumber(e), this._tokens.isCheapToTokenize(e);
  }
  tokenizeIfCheap(e) {
    this.validateLineNumber(e), this._tokens.tokenizeIfCheap(e);
  }
  getTokenTypeIfInsertingCharacter(e, t, i) {
    return this._tokens.getTokenTypeIfInsertingCharacter(e, t, i);
  }
  tokenizeLineWithEdit(e, t, i) {
    return this._tokens.tokenizeLineWithEdit(e, t, i);
  }
  // #endregion
  // #region Semantic Tokens
  setSemanticTokens(e, t) {
    this._semanticTokens.set(e, t), this._emitModelTokensChangedEvent({
      semanticTokensApplied: e !== null,
      ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }]
    });
  }
  hasCompleteSemanticTokens() {
    return this._semanticTokens.isComplete();
  }
  hasSomeSemanticTokens() {
    return !this._semanticTokens.isEmpty();
  }
  setPartialSemanticTokens(e, t) {
    if (this.hasCompleteSemanticTokens())
      return;
    const i = this._textModel.validateRange(this._semanticTokens.setPartial(e, t));
    this._emitModelTokensChangedEvent({
      semanticTokensApplied: !0,
      ranges: [
        {
          fromLineNumber: i.startLineNumber,
          toLineNumber: i.endLineNumber
        }
      ]
    });
  }
  // #endregion
  // #region Utility Methods
  getWordAtPosition(e) {
    this.assertNotDisposed();
    const t = this._textModel.validatePosition(e), i = this._textModel.getLineContent(t.lineNumber), n = this.getLineTokens(t.lineNumber), o = n.findTokenIndexAtOffset(t.column - 1), [r, a] = db._findLanguageBoundaries(n, o), l = Fm(t.column, this.getLanguageConfiguration(n.getLanguageId(o)).getWordDefinition(), i.substring(r, a), r);
    if (l && l.startColumn <= e.column && e.column <= l.endColumn)
      return l;
    if (o > 0 && r === t.column - 1) {
      const [c, h] = db._findLanguageBoundaries(n, o - 1), d = Fm(t.column, this.getLanguageConfiguration(n.getLanguageId(o - 1)).getWordDefinition(), i.substring(c, h), c);
      if (d && d.startColumn <= e.column && e.column <= d.endColumn)
        return d;
    }
    return null;
  }
  getLanguageConfiguration(e) {
    return this._languageConfigurationService.getLanguageConfiguration(e);
  }
  static _findLanguageBoundaries(e, t) {
    const i = e.getLanguageId(t);
    let n = 0;
    for (let r = t; r >= 0 && e.getLanguageId(r) === i; r--)
      n = e.getStartOffset(r);
    let o = e.getLineContent().length;
    for (let r = t, a = e.getCount(); r < a && e.getLanguageId(r) === i; r++)
      o = e.getEndOffset(r);
    return [n, o];
  }
  getWordUntilPosition(e) {
    const t = this.getWordAtPosition(e);
    return t ? {
      word: t.word.substr(0, e.column - t.startColumn),
      startColumn: t.startColumn,
      endColumn: e.column
    } : { word: "", startColumn: e.column, endColumn: e.column };
  }
  // #endregion
  // #region Language Id handling
  getLanguageId() {
    return this._languageId;
  }
  getLanguageIdAtPosition(e, t) {
    const i = this._textModel.validatePosition(new F(e, t)), n = this.getLineTokens(i.lineNumber);
    return n.getLanguageId(n.findTokenIndexAtOffset(i.column - 1));
  }
  setLanguageId(e, t = "api") {
    if (this._languageId === e)
      return;
    const i = {
      oldLanguage: this._languageId,
      newLanguage: e,
      source: t
    };
    this._languageId = e, this._bracketPairsTextModelPart.handleDidChangeLanguage(i), this._tokens.resetTokenization(), this.createPreferredTokenProvider(), this._onDidChangeLanguage.fire(i), this._onDidChangeLanguageConfiguration.fire({});
  }
};
gL = db = vZ([
  X0(4, ci),
  X0(5, ir),
  X0(6, CF)
], gL);
class IM extends bF {
  constructor(e, t, i, n) {
    super(e, t, i), this._tokenizer = null, this._defaultBackgroundTokenizer = null, this._backgroundTokenizer = this._register(new Hs()), this._tokens = new tp(this._languageIdCodec), this._debugBackgroundTokenizer = this._register(new Hs()), this._attachedViewStates = this._register(new rE()), this._register(ii.onDidChange((o) => {
      const r = this.getLanguageId();
      o.changedLanguages.indexOf(r) !== -1 && this.resetTokenization();
    })), this.resetTokenization(), this._register(n.onDidChangeVisibleRanges(({ view: o, state: r }) => {
      if (r) {
        let a = this._attachedViewStates.get(o);
        a || (a = new CZ(() => this.refreshRanges(a.lineRanges)), this._attachedViewStates.set(o, a)), a.handleStateChange(r);
      } else
        this._attachedViewStates.deleteAndDispose(o);
    }));
  }
  resetTokenization(e = !0) {
    var o;
    this._tokens.flush(), (o = this._debugBackgroundTokens) == null || o.flush(), this._debugBackgroundStates && (this._debugBackgroundStates = new fL(this._textModel.getLineCount())), e && this._onDidChangeTokens.fire({
      semanticTokensApplied: !1,
      ranges: [
        {
          fromLineNumber: 1,
          toLineNumber: this._textModel.getLineCount()
        }
      ]
    });
    const t = () => {
      if (this._textModel.isTooLargeForTokenization())
        return [null, null];
      const r = ii.get(this.getLanguageId());
      if (!r)
        return [null, null];
      let a;
      try {
        a = r.getInitialState();
      } catch (l) {
        return Je(l), [null, null];
      }
      return [r, a];
    }, [i, n] = t();
    if (i && n ? this._tokenizer = new fZ(this._textModel.getLineCount(), i, this._textModel, this._languageIdCodec) : this._tokenizer = null, this._backgroundTokenizer.clear(), this._defaultBackgroundTokenizer = null, this._tokenizer) {
      const r = {
        setTokens: (a) => {
          this.setTokens(a);
        },
        backgroundTokenizationFinished: () => {
          if (this._backgroundTokenizationState === 2)
            return;
          const a = 2;
          this._backgroundTokenizationState = a, this._onDidChangeBackgroundTokenizationState.fire();
        },
        setEndState: (a, l) => {
          var h;
          if (!this._tokenizer)
            return;
          const c = this._tokenizer.store.getFirstInvalidEndStateLineNumber();
          c !== null && a >= c && ((h = this._tokenizer) == null || h.store.setEndState(a, l));
        }
      };
      i && i.createBackgroundTokenizer && !i.backgroundTokenizerShouldOnlyVerifyTokens && (this._backgroundTokenizer.value = i.createBackgroundTokenizer(this._textModel, r)), !this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization() && (this._backgroundTokenizer.value = this._defaultBackgroundTokenizer = new pZ(this._tokenizer, r), this._defaultBackgroundTokenizer.handleChanges()), i != null && i.backgroundTokenizerShouldOnlyVerifyTokens && i.createBackgroundTokenizer ? (this._debugBackgroundTokens = new tp(this._languageIdCodec), this._debugBackgroundStates = new fL(this._textModel.getLineCount()), this._debugBackgroundTokenizer.clear(), this._debugBackgroundTokenizer.value = i.createBackgroundTokenizer(this._textModel, {
        setTokens: (a) => {
          var l;
          (l = this._debugBackgroundTokens) == null || l.setMultilineTokens(a, this._textModel);
        },
        backgroundTokenizationFinished() {
        },
        setEndState: (a, l) => {
          var c;
          (c = this._debugBackgroundStates) == null || c.setEndState(a, l);
        }
      })) : (this._debugBackgroundTokens = void 0, this._debugBackgroundStates = void 0, this._debugBackgroundTokenizer.value = void 0);
    }
    this.refreshAllVisibleLineTokens();
  }
  handleDidChangeAttached() {
    var e;
    (e = this._defaultBackgroundTokenizer) == null || e.handleChanges();
  }
  handleDidChangeContent(e) {
    var t, i, n;
    if (e.isFlush)
      this.resetTokenization(!1);
    else if (!e.isEolChange) {
      for (const o of e.changes) {
        const [r, a] = pf(o.text);
        this._tokens.acceptEdit(o.range, r, a), (t = this._debugBackgroundTokens) == null || t.acceptEdit(o.range, r, a);
      }
      (i = this._debugBackgroundStates) == null || i.acceptChanges(e.changes), this._tokenizer && this._tokenizer.store.acceptChanges(e.changes), (n = this._defaultBackgroundTokenizer) == null || n.handleChanges();
    }
  }
  setTokens(e) {
    const { changes: t } = this._tokens.setMultilineTokens(e, this._textModel);
    return t.length > 0 && this._onDidChangeTokens.fire({ semanticTokensApplied: !1, ranges: t }), { changes: t };
  }
  refreshAllVisibleLineTokens() {
    const e = pe.joinMany([...this._attachedViewStates].map(([t, i]) => i.lineRanges));
    this.refreshRanges(e);
  }
  refreshRanges(e) {
    for (const t of e)
      this.refreshRange(t.startLineNumber, t.endLineNumberExclusive - 1);
  }
  refreshRange(e, t) {
    var r, a;
    if (!this._tokenizer)
      return;
    e = Math.max(1, Math.min(this._textModel.getLineCount(), e)), t = Math.min(this._textModel.getLineCount(), t);
    const i = new uL(), { heuristicTokens: n } = this._tokenizer.tokenizeHeuristically(i, e, t), o = this.setTokens(i.finalize());
    if (n)
      for (const l of o.changes)
        (r = this._backgroundTokenizer.value) == null || r.requestTokens(l.fromLineNumber, l.toLineNumber + 1);
    (a = this._defaultBackgroundTokenizer) == null || a.checkFinished();
  }
  forceTokenization(e) {
    var i, n;
    const t = new uL();
    (i = this._tokenizer) == null || i.updateTokensUntilLine(t, e), this.setTokens(t.finalize()), (n = this._defaultBackgroundTokenizer) == null || n.checkFinished();
  }
  hasAccurateTokensForLine(e) {
    return this._tokenizer ? this._tokenizer.hasAccurateTokensForLine(e) : !0;
  }
  isCheapToTokenize(e) {
    return this._tokenizer ? this._tokenizer.isCheapToTokenize(e) : !0;
  }
  getLineTokens(e) {
    var n;
    const t = this._textModel.getLineContent(e), i = this._tokens.getTokens(this._textModel.getLanguageId(), e - 1, t);
    if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer && this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > e && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > e) {
      const o = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), e - 1, t);
      !i.equals(o) && ((n = this._debugBackgroundTokenizer.value) != null && n.reportMismatchingTokens) && this._debugBackgroundTokenizer.value.reportMismatchingTokens(e);
    }
    return i;
  }
  getTokenTypeIfInsertingCharacter(e, t, i) {
    if (!this._tokenizer)
      return 0;
    const n = this._textModel.validatePosition(new F(e, t));
    return this.forceTokenization(n.lineNumber), this._tokenizer.getTokenTypeIfInsertingCharacter(n, i);
  }
  tokenizeLineWithEdit(e, t, i) {
    if (!this._tokenizer)
      return null;
    const n = this._textModel.validatePosition(e);
    return this.forceTokenization(n.lineNumber), this._tokenizer.tokenizeLineWithEdit(n, t, i);
  }
  get hasTokens() {
    return this._tokens.hasTokens;
  }
}
const VI = Be("undoRedoService");
class vF {
  constructor(e, t) {
    this.resource = e, this.elements = t;
  }
}
const Su = class Su {
  constructor() {
    this.id = Su._ID++, this.order = 1;
  }
  nextOrder() {
    return this.id === 0 ? 0 : this.order++;
  }
};
Su._ID = 0, Su.None = new Su();
let mL = Su;
const Lu = class Lu {
  constructor() {
    this.id = Lu._ID++, this.order = 1;
  }
  nextOrder() {
    return this.id === 0 ? 0 : this.order++;
  }
};
Lu._ID = 0, Lu.None = new Lu();
let Oc = Lu;
var wZ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, x_ = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Sc;
function yZ(s) {
  const e = new pF();
  return e.acceptChunk(s), e.finish();
}
function SZ(s) {
  const e = new pF();
  let t;
  for (; typeof (t = s.read()) == "string"; )
    e.acceptChunk(t);
  return e.finish();
}
function NM(s, e) {
  let t;
  return typeof s == "string" ? t = yZ(s) : rq(s) ? t = SZ(s) : t = s, t.create(e);
}
let D_ = 0;
const LZ = 999, kZ = 1e4;
class xZ {
  constructor(e) {
    this._source = e, this._eos = !1;
  }
  read() {
    if (this._eos)
      return null;
    const e = [];
    let t = 0, i = 0;
    do {
      const n = this._source.read();
      if (n === null)
        return this._eos = !0, t === 0 ? null : e.join("");
      if (n.length > 0 && (e[t++] = n, i += n.length), i >= 64 * 1024)
        return e.join("");
    } while (!0);
  }
}
const sg = () => {
  throw new Error("Invalid change accessor");
};
var Wo;
let ip = (Wo = class extends U {
  static resolveOptions(e, t) {
    if (t.detectIndentation) {
      const i = bM(e, t.tabSize, t.insertSpaces);
      return new hb({
        tabSize: i.tabSize,
        indentSize: "tabSize",
        // TODO@Alex: guess indentSize independent of tabSize
        insertSpaces: i.insertSpaces,
        trimAutoWhitespace: t.trimAutoWhitespace,
        defaultEOL: t.defaultEOL,
        bracketPairColorizationOptions: t.bracketPairColorizationOptions
      });
    }
    return new hb(t);
  }
  get onDidChangeLanguage() {
    return this._tokenizationTextModelPart.onDidChangeLanguage;
  }
  get onDidChangeLanguageConfiguration() {
    return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration;
  }
  get onDidChangeTokens() {
    return this._tokenizationTextModelPart.onDidChangeTokens;
  }
  onDidChangeContent(e) {
    return this._eventEmitter.slowEvent((t) => e(t.contentChangedEvent));
  }
  onDidChangeContentOrInjectedText(e) {
    return ao(this._eventEmitter.fastEvent((t) => e(t)), this._onDidChangeInjectedText.event((t) => e(t)));
  }
  _isDisposing() {
    return this.__isDisposing;
  }
  get tokenization() {
    return this._tokenizationTextModelPart;
  }
  get bracketPairs() {
    return this._bracketPairs;
  }
  get guides() {
    return this._guidesTextModelPart;
  }
  constructor(e, t, i, n = null, o, r, a, l) {
    super(), this._undoRedoService = o, this._languageService = r, this._languageConfigurationService = a, this.instantiationService = l, this._onWillDispose = this._register(new A()), this.onWillDispose = this._onWillDispose.event, this._onDidChangeDecorations = this._register(new MZ((g) => this.handleBeforeFireDecorationsChangedEvent(g))), this.onDidChangeDecorations = this._onDidChangeDecorations.event, this._onDidChangeOptions = this._register(new A()), this.onDidChangeOptions = this._onDidChangeOptions.event, this._onDidChangeAttached = this._register(new A()), this.onDidChangeAttached = this._onDidChangeAttached.event, this._onDidChangeInjectedText = this._register(new A()), this._eventEmitter = this._register(new RZ()), this._languageSelectionListener = this._register(new Hs()), this._deltaDecorationCallCnt = 0, this._attachedViews = new _Z(), D_++, this.id = "$model" + D_, this.isForSimpleWidget = i.isForSimpleWidget, typeof n > "u" || n === null ? this._associatedResource = we.parse("inmemory://model/" + D_) : this._associatedResource = n, this._attachedEditorCount = 0;
    const { textBuffer: c, disposable: h } = NM(e, i.defaultEOL);
    this._buffer = c, this._bufferDisposable = h, this._options = Sc.resolveOptions(this._buffer, i);
    const d = typeof t == "string" ? t : t.languageId;
    typeof t != "string" && (this._languageSelectionListener.value = t.onDidChange(() => this._setLanguage(t.languageId))), this._bracketPairs = this._register(new RG(this, this._languageConfigurationService)), this._guidesTextModelPart = this._register(new wq(this, this._languageConfigurationService)), this._decorationProvider = this._register(new PG(this)), this._tokenizationTextModelPart = this.instantiationService.createInstance(gL, this, this._bracketPairs, d, this._attachedViews);
    const u = this._buffer.getLineCount(), f = this._buffer.getValueLengthInRange(
      new T(1, 1, u, this._buffer.getLineLength(u) + 1),
      0
      /* model.EndOfLinePreference.TextDefined */
    );
    i.largeFileOptimizations ? (this._isTooLargeForTokenization = f > Sc.LARGE_FILE_SIZE_THRESHOLD || u > Sc.LARGE_FILE_LINE_COUNT_THRESHOLD, this._isTooLargeForHeapOperation = f > Sc.LARGE_FILE_HEAP_OPERATION_THRESHOLD) : (this._isTooLargeForTokenization = !1, this._isTooLargeForHeapOperation = !1), this._isTooLargeForSyncing = f > Sc._MODEL_SYNC_LIMIT, this._versionId = 1, this._alternativeVersionId = 1, this._initialUndoRedoSnapshot = null, this._isDisposed = !1, this.__isDisposing = !1, this._instanceId = f4(D_), this._lastDecorationId = 0, this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new TM(), this._commandManager = new RI(this, this._undoRedoService), this._isUndoing = !1, this._isRedoing = !1, this._trimAutoWhitespaceLines = null, this._register(this._decorationProvider.onDidChange(() => {
      this._onDidChangeDecorations.beginDeferredEmit(), this._onDidChangeDecorations.fire(), this._onDidChangeDecorations.endDeferredEmit();
    })), this._languageService.requestRichLanguageFeatures(d), this._register(this._languageConfigurationService.onDidChange((g) => {
      this._bracketPairs.handleLanguageConfigurationServiceChange(g), this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(g);
    }));
  }
  dispose() {
    this.__isDisposing = !0, this._onWillDispose.fire(), this._tokenizationTextModelPart.dispose(), this._isDisposed = !0, super.dispose(), this._bufferDisposable.dispose(), this.__isDisposing = !1;
    const e = new Vu([], "", `
`, !1, !1, !0, !0);
    e.dispose(), this._buffer = e, this._bufferDisposable = U.None;
  }
  _assertNotDisposed() {
    if (this._isDisposed)
      throw new at("Model is disposed!");
  }
  _emitContentChangedEvent(e, t) {
    this.__isDisposing || (this._tokenizationTextModelPart.handleDidChangeContent(t), this._bracketPairs.handleDidChangeContent(t), this._eventEmitter.fire(new fh(e, t)));
  }
  setValue(e) {
    if (this._assertNotDisposed(), e == null)
      throw Tr();
    const { textBuffer: t, disposable: i } = NM(e, this._options.defaultEOL);
    this._setValueFromTextBuffer(t, i);
  }
  _createContentChanged2(e, t, i, n, o, r, a, l) {
    return {
      changes: [{
        range: e,
        rangeOffset: t,
        rangeLength: i,
        text: n
      }],
      eol: this._buffer.getEOL(),
      isEolChange: l,
      versionId: this.getVersionId(),
      isUndoing: o,
      isRedoing: r,
      isFlush: a
    };
  }
  _setValueFromTextBuffer(e, t) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), n = this.getValueLengthInRange(i), o = this.getLineCount(), r = this.getLineMaxColumn(o);
    this._buffer = e, this._bufferDisposable.dispose(), this._bufferDisposable = t, this._increaseVersionId(), this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new TM(), this._commandManager.clear(), this._trimAutoWhitespaceLines = null, this._emitContentChangedEvent(new Bu([
      new tG()
    ], this._versionId, !1, !1), this._createContentChanged2(new T(1, 1, o, r), 0, n, this.getValue(), !1, !1, !0, !1));
  }
  setEOL(e) {
    this._assertNotDisposed();
    const t = e === 1 ? `\r
` : `
`;
    if (this._buffer.getEOL() === t)
      return;
    const i = this.getFullModelRange(), n = this.getValueLengthInRange(i), o = this.getLineCount(), r = this.getLineMaxColumn(o);
    this._onBeforeEOLChange(), this._buffer.setEOL(t), this._increaseVersionId(), this._onAfterEOLChange(), this._emitContentChangedEvent(new Bu([
      new sG()
    ], this._versionId, !1, !1), this._createContentChanged2(new T(1, 1, o, r), 0, n, this.getValue(), !1, !1, !1, !0));
  }
  _onBeforeEOLChange() {
    this._decorationsTree.ensureAllNodesHaveRanges(this);
  }
  _onAfterEOLChange() {
    const e = this.getVersionId(), t = this._decorationsTree.collectNodesPostOrder();
    for (let i = 0, n = t.length; i < n; i++) {
      const o = t[i], r = o.range, a = o.cachedAbsoluteStart - o.start, l = this._buffer.getOffsetAt(r.startLineNumber, r.startColumn), c = this._buffer.getOffsetAt(r.endLineNumber, r.endColumn);
      o.cachedAbsoluteStart = l, o.cachedAbsoluteEnd = c, o.cachedVersionId = e, o.start = l - a, o.end = c - a, Ql(o);
    }
  }
  onBeforeAttached() {
    return this._attachedEditorCount++, this._attachedEditorCount === 1 && (this._tokenizationTextModelPart.handleDidChangeAttached(), this._onDidChangeAttached.fire(void 0)), this._attachedViews.attachView();
  }
  onBeforeDetached(e) {
    this._attachedEditorCount--, this._attachedEditorCount === 0 && (this._tokenizationTextModelPart.handleDidChangeAttached(), this._onDidChangeAttached.fire(void 0)), this._attachedViews.detachView(e);
  }
  isAttachedToEditor() {
    return this._attachedEditorCount > 0;
  }
  getAttachedEditorCount() {
    return this._attachedEditorCount;
  }
  isTooLargeForSyncing() {
    return this._isTooLargeForSyncing;
  }
  isTooLargeForTokenization() {
    return this._isTooLargeForTokenization;
  }
  isTooLargeForHeapOperation() {
    return this._isTooLargeForHeapOperation;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isDominatedByLongLines() {
    if (this._assertNotDisposed(), this.isTooLargeForTokenization())
      return !1;
    let e = 0, t = 0;
    const i = this._buffer.getLineCount();
    for (let n = 1; n <= i; n++) {
      const o = this._buffer.getLineLength(n);
      o >= kZ ? t += o : e += o;
    }
    return t > e;
  }
  get uri() {
    return this._associatedResource;
  }
  //#region Options
  getOptions() {
    return this._assertNotDisposed(), this._options;
  }
  getFormattingOptions() {
    return {
      tabSize: this._options.indentSize,
      insertSpaces: this._options.insertSpaces
    };
  }
  updateOptions(e) {
    this._assertNotDisposed();
    const t = typeof e.tabSize < "u" ? e.tabSize : this._options.tabSize, i = typeof e.indentSize < "u" ? e.indentSize : this._options.originalIndentSize, n = typeof e.insertSpaces < "u" ? e.insertSpaces : this._options.insertSpaces, o = typeof e.trimAutoWhitespace < "u" ? e.trimAutoWhitespace : this._options.trimAutoWhitespace, r = typeof e.bracketColorizationOptions < "u" ? e.bracketColorizationOptions : this._options.bracketPairColorizationOptions, a = new hb({
      tabSize: t,
      indentSize: i,
      insertSpaces: n,
      defaultEOL: this._options.defaultEOL,
      trimAutoWhitespace: o,
      bracketPairColorizationOptions: r
    });
    if (this._options.equals(a))
      return;
    const l = this._options.createChangeEvent(a);
    this._options = a, this._bracketPairs.handleDidChangeOptions(l), this._decorationProvider.handleDidChangeOptions(l), this._onDidChangeOptions.fire(l);
  }
  detectIndentation(e, t) {
    this._assertNotDisposed();
    const i = bM(this._buffer, t, e);
    this.updateOptions({
      insertSpaces: i.insertSpaces,
      tabSize: i.tabSize,
      indentSize: i.tabSize
      // TODO@Alex: guess indentSize independent of tabSize
    });
  }
  normalizeIndentation(e) {
    return this._assertNotDisposed(), M5(e, this._options.indentSize, this._options.insertSpaces);
  }
  //#endregion
  //#region Reading
  getVersionId() {
    return this._assertNotDisposed(), this._versionId;
  }
  mightContainRTL() {
    return this._buffer.mightContainRTL();
  }
  mightContainUnusualLineTerminators() {
    return this._buffer.mightContainUnusualLineTerminators();
  }
  removeUnusualLineTerminators(e = null) {
    const t = this.findMatches(
      d4.source,
      !1,
      !0,
      !1,
      null,
      !1,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
    this._buffer.resetMightContainUnusualLineTerminators(), this.pushEditOperations(e, t.map((i) => ({ range: i.range, text: null })), () => null);
  }
  mightContainNonBasicASCII() {
    return this._buffer.mightContainNonBasicASCII();
  }
  getAlternativeVersionId() {
    return this._assertNotDisposed(), this._alternativeVersionId;
  }
  getInitialUndoRedoSnapshot() {
    return this._assertNotDisposed(), this._initialUndoRedoSnapshot;
  }
  getOffsetAt(e) {
    this._assertNotDisposed();
    const t = this._validatePosition(
      e.lineNumber,
      e.column,
      0
      /* StringOffsetValidationType.Relaxed */
    );
    return this._buffer.getOffsetAt(t.lineNumber, t.column);
  }
  getPositionAt(e) {
    this._assertNotDisposed();
    const t = Math.min(this._buffer.getLength(), Math.max(0, e));
    return this._buffer.getPositionAt(t);
  }
  _increaseVersionId() {
    this._versionId = this._versionId + 1, this._alternativeVersionId = this._versionId;
  }
  _overwriteVersionId(e) {
    this._versionId = e;
  }
  _overwriteAlternativeVersionId(e) {
    this._alternativeVersionId = e;
  }
  _overwriteInitialUndoRedoSnapshot(e) {
    this._initialUndoRedoSnapshot = e;
  }
  getValue(e, t = !1) {
    if (this._assertNotDisposed(), this.isTooLargeForHeapOperation())
      throw new at("Operation would exceed heap memory limits");
    const i = this.getFullModelRange(), n = this.getValueInRange(i, e);
    return t ? this._buffer.getBOM() + n : n;
  }
  createSnapshot(e = !1) {
    return new xZ(this._buffer.createSnapshot(e));
  }
  getValueLength(e, t = !1) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), n = this.getValueLengthInRange(i, e);
    return t ? this._buffer.getBOM().length + n : n;
  }
  getValueInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getValueInRange(this.validateRange(e), t);
  }
  getValueLengthInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getValueLengthInRange(this.validateRange(e), t);
  }
  getCharacterCountInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getCharacterCountInRange(this.validateRange(e), t);
  }
  getLineCount() {
    return this._assertNotDisposed(), this._buffer.getLineCount();
  }
  getLineContent(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new at("Illegal value for lineNumber");
    return this._buffer.getLineContent(e);
  }
  getLineLength(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new at("Illegal value for lineNumber");
    return this._buffer.getLineLength(e);
  }
  getLinesContent() {
    if (this._assertNotDisposed(), this.isTooLargeForHeapOperation())
      throw new at("Operation would exceed heap memory limits");
    return this._buffer.getLinesContent();
  }
  getEOL() {
    return this._assertNotDisposed(), this._buffer.getEOL();
  }
  getEndOfLineSequence() {
    return this._assertNotDisposed(), this._buffer.getEOL() === `
` ? 0 : 1;
  }
  getLineMinColumn(e) {
    return this._assertNotDisposed(), 1;
  }
  getLineMaxColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new at("Illegal value for lineNumber");
    return this._buffer.getLineLength(e) + 1;
  }
  getLineFirstNonWhitespaceColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new at("Illegal value for lineNumber");
    return this._buffer.getLineFirstNonWhitespaceColumn(e);
  }
  getLineLastNonWhitespaceColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new at("Illegal value for lineNumber");
    return this._buffer.getLineLastNonWhitespaceColumn(e);
  }
  /**
   * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.
   * Will try to not allocate if possible.
   */
  _validateRangeRelaxedNoAllocations(e) {
    const t = this._buffer.getLineCount(), i = e.startLineNumber, n = e.startColumn;
    let o = Math.floor(typeof i == "number" && !isNaN(i) ? i : 1), r = Math.floor(typeof n == "number" && !isNaN(n) ? n : 1);
    if (o < 1)
      o = 1, r = 1;
    else if (o > t)
      o = t, r = this.getLineMaxColumn(o);
    else if (r <= 1)
      r = 1;
    else {
      const d = this.getLineMaxColumn(o);
      r >= d && (r = d);
    }
    const a = e.endLineNumber, l = e.endColumn;
    let c = Math.floor(typeof a == "number" && !isNaN(a) ? a : 1), h = Math.floor(typeof l == "number" && !isNaN(l) ? l : 1);
    if (c < 1)
      c = 1, h = 1;
    else if (c > t)
      c = t, h = this.getLineMaxColumn(c);
    else if (h <= 1)
      h = 1;
    else {
      const d = this.getLineMaxColumn(c);
      h >= d && (h = d);
    }
    return i === o && n === r && a === c && l === h && e instanceof T && !(e instanceof Ue) ? e : new T(o, r, c, h);
  }
  _isValidPosition(e, t, i) {
    if (typeof e != "number" || typeof t != "number" || isNaN(e) || isNaN(t) || e < 1 || t < 1 || (e | 0) !== e || (t | 0) !== t)
      return !1;
    const n = this._buffer.getLineCount();
    if (e > n)
      return !1;
    if (t === 1)
      return !0;
    const o = this.getLineMaxColumn(e);
    if (t > o)
      return !1;
    if (i === 1) {
      const r = this._buffer.getLineCharCode(e, t - 2);
      if (Si(r))
        return !1;
    }
    return !0;
  }
  _validatePosition(e, t, i) {
    const n = Math.floor(typeof e == "number" && !isNaN(e) ? e : 1), o = Math.floor(typeof t == "number" && !isNaN(t) ? t : 1), r = this._buffer.getLineCount();
    if (n < 1)
      return new F(1, 1);
    if (n > r)
      return new F(r, this.getLineMaxColumn(r));
    if (o <= 1)
      return new F(n, 1);
    const a = this.getLineMaxColumn(n);
    if (o >= a)
      return new F(n, a);
    if (i === 1) {
      const l = this._buffer.getLineCharCode(n, o - 2);
      if (Si(l))
        return new F(n, o - 1);
    }
    return new F(n, o);
  }
  validatePosition(e) {
    return this._assertNotDisposed(), e instanceof F && this._isValidPosition(e.lineNumber, e.column, 1) ? e : this._validatePosition(e.lineNumber, e.column, 1);
  }
  _isValidRange(e, t) {
    const i = e.startLineNumber, n = e.startColumn, o = e.endLineNumber, r = e.endColumn;
    if (!this._isValidPosition(
      i,
      n,
      0
      /* StringOffsetValidationType.Relaxed */
    ) || !this._isValidPosition(
      o,
      r,
      0
      /* StringOffsetValidationType.Relaxed */
    ))
      return !1;
    if (t === 1) {
      const a = n > 1 ? this._buffer.getLineCharCode(i, n - 2) : 0, l = r > 1 && r <= this._buffer.getLineLength(o) ? this._buffer.getLineCharCode(o, r - 2) : 0, c = Si(a), h = Si(l);
      return !c && !h;
    }
    return !0;
  }
  validateRange(e) {
    if (this._assertNotDisposed(), e instanceof T && !(e instanceof Ue) && this._isValidRange(e, 1))
      return e;
    const i = this._validatePosition(
      e.startLineNumber,
      e.startColumn,
      0
      /* StringOffsetValidationType.Relaxed */
    ), n = this._validatePosition(
      e.endLineNumber,
      e.endColumn,
      0
      /* StringOffsetValidationType.Relaxed */
    ), o = i.lineNumber, r = i.column, a = n.lineNumber, l = n.column;
    {
      const c = r > 1 ? this._buffer.getLineCharCode(o, r - 2) : 0, h = l > 1 && l <= this._buffer.getLineLength(a) ? this._buffer.getLineCharCode(a, l - 2) : 0, d = Si(c), u = Si(h);
      return !d && !u ? new T(o, r, a, l) : o === a && r === l ? new T(o, r - 1, a, l - 1) : d && u ? new T(o, r - 1, a, l + 1) : d ? new T(o, r - 1, a, l) : new T(o, r, a, l + 1);
    }
  }
  modifyPosition(e, t) {
    this._assertNotDisposed();
    const i = this.getOffsetAt(e) + t;
    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, i)));
  }
  getFullModelRange() {
    this._assertNotDisposed();
    const e = this.getLineCount();
    return new T(1, 1, e, this.getLineMaxColumn(e));
  }
  findMatchesLineByLine(e, t, i, n) {
    return this._buffer.findMatchesLineByLine(e, t, i, n);
  }
  findMatches(e, t, i, n, o, r, a = LZ) {
    this._assertNotDisposed();
    let l = null;
    t !== null && (Array.isArray(t) || (t = [t]), t.every((d) => T.isIRange(d)) && (l = t.map((d) => this.validateRange(d)))), l === null && (l = [this.getFullModelRange()]), l = l.sort((d, u) => d.startLineNumber - u.startLineNumber || d.startColumn - u.startColumn);
    const c = [];
    c.push(l.reduce((d, u) => T.areIntersecting(d, u) ? d.plusRange(u) : (c.push(d), u)));
    let h;
    if (!i && e.indexOf(`
`) < 0) {
      const u = new Rd(e, i, n, o).parseSearchRequest();
      if (!u)
        return [];
      h = (f) => this.findMatchesLineByLine(f, u, r, a);
    } else
      h = (d) => k_.findMatches(this, new Rd(e, i, n, o), d, r, a);
    return c.map(h).reduce((d, u) => d.concat(u), []);
  }
  findNextMatch(e, t, i, n, o, r) {
    this._assertNotDisposed();
    const a = this.validatePosition(t);
    if (!i && e.indexOf(`
`) < 0) {
      const c = new Rd(e, i, n, o).parseSearchRequest();
      if (!c)
        return null;
      const h = this.getLineCount();
      let d = new T(a.lineNumber, a.column, h, this.getLineMaxColumn(h)), u = this.findMatchesLineByLine(d, c, r, 1);
      return k_.findNextMatch(this, new Rd(e, i, n, o), a, r), u.length > 0 || (d = new T(1, 1, a.lineNumber, this.getLineMaxColumn(a.lineNumber)), u = this.findMatchesLineByLine(d, c, r, 1), u.length > 0) ? u[0] : null;
    }
    return k_.findNextMatch(this, new Rd(e, i, n, o), a, r);
  }
  findPreviousMatch(e, t, i, n, o, r) {
    this._assertNotDisposed();
    const a = this.validatePosition(t);
    return k_.findPreviousMatch(this, new Rd(e, i, n, o), a, r);
  }
  //#endregion
  //#region Editing
  pushStackElement() {
    this._commandManager.pushStackElement();
  }
  popStackElement() {
    this._commandManager.popStackElement();
  }
  pushEOL(e) {
    if ((this.getEOL() === `
` ? 0 : 1) !== e)
      try {
        this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEOL(e);
      } finally {
        this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
      }
  }
  _validateEditOperation(e) {
    return e instanceof H0 ? e : new H0(e.identifier || null, this.validateRange(e.range), e.text, e.forceMoveMarkers || !1, e.isAutoWhitespaceEdit || !1, e._isTracked || !1);
  }
  _validateEditOperations(e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++)
      t[i] = this._validateEditOperation(e[i]);
    return t;
  }
  pushEditOperations(e, t, i, n) {
    try {
      return this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._pushEditOperations(e, this._validateEditOperations(t), i, n);
    } finally {
      this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _pushEditOperations(e, t, i, n) {
    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
      const o = t.map((a) => ({
        range: this.validateRange(a.range),
        text: a.text
      }));
      let r = !0;
      if (e)
        for (let a = 0, l = e.length; a < l; a++) {
          const c = e[a];
          let h = !1;
          for (let d = 0, u = o.length; d < u; d++) {
            const f = o[d].range, g = f.startLineNumber > c.endLineNumber, p = c.startLineNumber > f.endLineNumber;
            if (!g && !p) {
              h = !0;
              break;
            }
          }
          if (!h) {
            r = !1;
            break;
          }
        }
      if (r)
        for (let a = 0, l = this._trimAutoWhitespaceLines.length; a < l; a++) {
          const c = this._trimAutoWhitespaceLines[a], h = this.getLineMaxColumn(c);
          let d = !0;
          for (let u = 0, f = o.length; u < f; u++) {
            const g = o[u].range, p = o[u].text;
            if (!(c < g.startLineNumber || c > g.endLineNumber) && !(c === g.startLineNumber && g.startColumn === h && g.isEmpty() && p && p.length > 0 && p.charAt(0) === `
`) && !(c === g.startLineNumber && g.startColumn === 1 && g.isEmpty() && p && p.length > 0 && p.charAt(p.length - 1) === `
`)) {
              d = !1;
              break;
            }
          }
          if (d) {
            const u = new T(c, 1, c, h);
            t.push(new H0(null, u, null, !1, !1, !1));
          }
        }
      this._trimAutoWhitespaceLines = null;
    }
    return this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEditOperation(e, t, i, n);
  }
  _applyUndo(e, t, i, n) {
    const o = e.map((r) => {
      const a = this.getPositionAt(r.newPosition), l = this.getPositionAt(r.newEnd);
      return {
        range: new T(a.lineNumber, a.column, l.lineNumber, l.column),
        text: r.oldText
      };
    });
    this._applyUndoRedoEdits(o, t, !0, !1, i, n);
  }
  _applyRedo(e, t, i, n) {
    const o = e.map((r) => {
      const a = this.getPositionAt(r.oldPosition), l = this.getPositionAt(r.oldEnd);
      return {
        range: new T(a.lineNumber, a.column, l.lineNumber, l.column),
        text: r.newText
      };
    });
    this._applyUndoRedoEdits(o, t, !1, !0, i, n);
  }
  _applyUndoRedoEdits(e, t, i, n, o, r) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._isUndoing = i, this._isRedoing = n, this.applyEdits(e, !1), this.setEOL(t), this._overwriteAlternativeVersionId(o);
    } finally {
      this._isUndoing = !1, this._isRedoing = !1, this._eventEmitter.endDeferredEmit(r), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  applyEdits(e, t = !1) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit();
      const i = this._validateEditOperations(e);
      return this._doApplyEdits(i, t);
    } finally {
      this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _doApplyEdits(e, t) {
    const i = this._buffer.getLineCount(), n = this._buffer.applyEdits(e, this._options.trimAutoWhitespace, t), o = this._buffer.getLineCount(), r = n.changes;
    if (this._trimAutoWhitespaceLines = n.trimAutoWhitespaceLineNumbers, r.length !== 0) {
      for (let c = 0, h = r.length; c < h; c++) {
        const d = r[c];
        this._decorationsTree.acceptReplace(d.rangeOffset, d.rangeLength, d.text.length, d.forceMoveMarkers);
      }
      const a = [];
      this._increaseVersionId();
      let l = i;
      for (let c = 0, h = r.length; c < h; c++) {
        const d = r[c], [u] = pf(d.text);
        this._onDidChangeDecorations.fire();
        const f = d.range.startLineNumber, g = d.range.endLineNumber, p = g - f, _ = u, b = Math.min(p, _), C = _ - p, w = o - l - C + f, v = w, S = w + _, L = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new F(v, 1)), this.getOffsetAt(new F(S, this.getLineMaxColumn(S))), 0), k = Zo.fromDecorations(L), x = new $a(k);
        for (let I = b; I >= 0; I--) {
          const K = f + I, B = w + I;
          x.takeFromEndWhile((H) => H.lineNumber > B);
          const W = x.takeFromEndWhile((H) => H.lineNumber === B);
          a.push(new uM(K, this.getLineContent(B), W));
        }
        if (b < p) {
          const I = f + b;
          a.push(new iG(I + 1, g));
        }
        if (b < _) {
          const I = new $a(k), K = f + b, B = _ - b, W = o - l - B + K + 1, H = [], P = [];
          for (let q = 0; q < B; q++) {
            const J = W + q;
            P[q] = this.getLineContent(J), I.takeWhile((oe) => oe.lineNumber < J), H[q] = I.takeWhile((oe) => oe.lineNumber === J);
          }
          a.push(new nG(K + 1, f + _, P, H));
        }
        l += C;
      }
      this._emitContentChangedEvent(new Bu(a, this.getVersionId(), this._isUndoing, this._isRedoing), {
        changes: r,
        eol: this._buffer.getEOL(),
        isEolChange: !1,
        versionId: this.getVersionId(),
        isUndoing: this._isUndoing,
        isRedoing: this._isRedoing,
        isFlush: !1
      });
    }
    return n.reverseEdits === null ? void 0 : n.reverseEdits;
  }
  undo() {
    return this._undoRedoService.undo(this.uri);
  }
  canUndo() {
    return this._undoRedoService.canUndo(this.uri);
  }
  redo() {
    return this._undoRedoService.redo(this.uri);
  }
  canRedo() {
    return this._undoRedoService.canRedo(this.uri);
  }
  //#endregion
  //#region Decorations
  handleBeforeFireDecorationsChangedEvent(e) {
    if (e === null || e.size === 0)
      return;
    const i = Array.from(e).map((n) => new uM(n, this.getLineContent(n), this._getInjectedTextInLine(n)));
    this._onDidChangeInjectedText.fire(new iF(i));
  }
  changeDecorations(e, t = 0) {
    this._assertNotDisposed();
    try {
      return this._onDidChangeDecorations.beginDeferredEmit(), this._changeDecorations(t, e);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _changeDecorations(e, t) {
    const i = {
      addDecoration: (o, r) => this._deltaDecorationsImpl(e, [], [{ range: o, options: r }])[0],
      changeDecoration: (o, r) => {
        this._changeDecorationImpl(o, r);
      },
      changeDecorationOptions: (o, r) => {
        this._changeDecorationOptionsImpl(o, RM(r));
      },
      removeDecoration: (o) => {
        this._deltaDecorationsImpl(e, [o], []);
      },
      deltaDecorations: (o, r) => o.length === 0 && r.length === 0 ? [] : this._deltaDecorationsImpl(e, o, r)
    };
    let n = null;
    try {
      n = t(i);
    } catch (o) {
      Je(o);
    }
    return i.addDecoration = sg, i.changeDecoration = sg, i.changeDecorationOptions = sg, i.removeDecoration = sg, i.deltaDecorations = sg, n;
  }
  deltaDecorations(e, t, i = 0) {
    if (this._assertNotDisposed(), e || (e = []), e.length === 0 && t.length === 0)
      return [];
    try {
      return this._deltaDecorationCallCnt++, this._deltaDecorationCallCnt > 1 && (console.warn("Invoking deltaDecorations recursively could lead to leaking decorations."), Je(new Error("Invoking deltaDecorations recursively could lead to leaking decorations."))), this._onDidChangeDecorations.beginDeferredEmit(), this._deltaDecorationsImpl(i, e, t);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit(), this._deltaDecorationCallCnt--;
    }
  }
  _getTrackedRange(e) {
    return this.getDecorationRange(e);
  }
  _setTrackedRange(e, t, i) {
    const n = e ? this._decorations[e] : null;
    if (!n)
      return t ? this._deltaDecorationsImpl(0, [], [{ range: t, options: MM[i] }], !0)[0] : null;
    if (!t)
      return this._decorationsTree.delete(n), delete this._decorations[n.id], null;
    const o = this._validateRangeRelaxedNoAllocations(t), r = this._buffer.getOffsetAt(o.startLineNumber, o.startColumn), a = this._buffer.getOffsetAt(o.endLineNumber, o.endColumn);
    return this._decorationsTree.delete(n), n.reset(this.getVersionId(), r, a, o), n.setOptions(MM[i]), this._decorationsTree.insert(n), n.id;
  }
  removeAllDecorationsWithOwnerId(e) {
    if (this._isDisposed)
      return;
    const t = this._decorationsTree.collectNodesFromOwner(e);
    for (let i = 0, n = t.length; i < n; i++) {
      const o = t[i];
      this._decorationsTree.delete(o), delete this._decorations[o.id];
    }
  }
  getDecorationOptions(e) {
    const t = this._decorations[e];
    return t ? t.options : null;
  }
  getDecorationRange(e) {
    const t = this._decorations[e];
    return t ? this._decorationsTree.getNodeRange(this, t) : null;
  }
  getLineDecorations(e, t = 0, i = !1) {
    return e < 1 || e > this.getLineCount() ? [] : this.getLinesDecorations(e, e, t, i);
  }
  getLinesDecorations(e, t, i = 0, n = !1, o = !1) {
    const r = this.getLineCount(), a = Math.min(r, Math.max(1, e)), l = Math.min(r, Math.max(1, t)), c = this.getLineMaxColumn(l), h = new T(a, 1, l, c), d = this._getDecorationsInRange(h, i, n, o);
    return aS(d, this._decorationProvider.getDecorationsInRange(h, i, n)), d;
  }
  getDecorationsInRange(e, t = 0, i = !1, n = !1, o = !1) {
    const r = this.validateRange(e), a = this._getDecorationsInRange(r, t, i, o);
    return aS(a, this._decorationProvider.getDecorationsInRange(r, t, i, n)), a;
  }
  getOverviewRulerDecorations(e = 0, t = !1) {
    return this._decorationsTree.getAll(this, e, t, !0, !1);
  }
  getInjectedTextDecorations(e = 0) {
    return this._decorationsTree.getAllInjectedText(this, e);
  }
  _getInjectedTextInLine(e) {
    const t = this._buffer.getOffsetAt(e, 1), i = t + this._buffer.getLineLength(e), n = this._decorationsTree.getInjectedTextInInterval(this, t, i, 0);
    return Zo.fromDecorations(n).filter((o) => o.lineNumber === e);
  }
  getAllDecorations(e = 0, t = !1) {
    let i = this._decorationsTree.getAll(this, e, t, !1, !1);
    return i = i.concat(this._decorationProvider.getAllDecorations(e, t)), i;
  }
  getAllMarginDecorations(e = 0) {
    return this._decorationsTree.getAll(this, e, !1, !1, !0);
  }
  _getDecorationsInRange(e, t, i, n) {
    const o = this._buffer.getOffsetAt(e.startLineNumber, e.startColumn), r = this._buffer.getOffsetAt(e.endLineNumber, e.endColumn);
    return this._decorationsTree.getAllInInterval(this, o, r, t, i, n);
  }
  getRangeAt(e, t) {
    return this._buffer.getRangeAt(e, t - e);
  }
  _changeDecorationImpl(e, t) {
    const i = this._decorations[e];
    if (!i)
      return;
    if (i.options.after) {
      const a = this.getDecorationRange(e);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(a.endLineNumber);
    }
    if (i.options.before) {
      const a = this.getDecorationRange(e);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(a.startLineNumber);
    }
    const n = this._validateRangeRelaxedNoAllocations(t), o = this._buffer.getOffsetAt(n.startLineNumber, n.startColumn), r = this._buffer.getOffsetAt(n.endLineNumber, n.endColumn);
    this._decorationsTree.delete(i), i.reset(this.getVersionId(), o, r, n), this._decorationsTree.insert(i), this._onDidChangeDecorations.checkAffectedAndFire(i.options), i.options.after && this._onDidChangeDecorations.recordLineAffectedByInjectedText(n.endLineNumber), i.options.before && this._onDidChangeDecorations.recordLineAffectedByInjectedText(n.startLineNumber);
  }
  _changeDecorationOptionsImpl(e, t) {
    const i = this._decorations[e];
    if (!i)
      return;
    const n = !!(i.options.overviewRuler && i.options.overviewRuler.color), o = !!(t.overviewRuler && t.overviewRuler.color);
    if (this._onDidChangeDecorations.checkAffectedAndFire(i.options), this._onDidChangeDecorations.checkAffectedAndFire(t), i.options.after || t.after) {
      const l = this._decorationsTree.getNodeRange(this, i);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(l.endLineNumber);
    }
    if (i.options.before || t.before) {
      const l = this._decorationsTree.getNodeRange(this, i);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(l.startLineNumber);
    }
    const r = n !== o, a = EZ(t) !== ub(i);
    r || a ? (this._decorationsTree.delete(i), i.setOptions(t), this._decorationsTree.insert(i)) : i.setOptions(t);
  }
  _deltaDecorationsImpl(e, t, i, n = !1) {
    const o = this.getVersionId(), r = t.length;
    let a = 0;
    const l = i.length;
    let c = 0;
    this._onDidChangeDecorations.beginDeferredEmit();
    try {
      const h = new Array(l);
      for (; a < r || c < l; ) {
        let d = null;
        if (a < r) {
          do
            d = this._decorations[t[a++]];
          while (!d && a < r);
          if (d) {
            if (d.options.after) {
              const u = this._decorationsTree.getNodeRange(this, d);
              this._onDidChangeDecorations.recordLineAffectedByInjectedText(u.endLineNumber);
            }
            if (d.options.before) {
              const u = this._decorationsTree.getNodeRange(this, d);
              this._onDidChangeDecorations.recordLineAffectedByInjectedText(u.startLineNumber);
            }
            this._decorationsTree.delete(d), n || this._onDidChangeDecorations.checkAffectedAndFire(d.options);
          }
        }
        if (c < l) {
          if (!d) {
            const b = ++this._lastDecorationId, C = `${this._instanceId};${b}`;
            d = new uF(C, 0, 0), this._decorations[C] = d;
          }
          const u = i[c], f = this._validateRangeRelaxedNoAllocations(u.range), g = RM(u.options), p = this._buffer.getOffsetAt(f.startLineNumber, f.startColumn), _ = this._buffer.getOffsetAt(f.endLineNumber, f.endColumn);
          d.ownerId = e, d.reset(o, p, _, f), d.setOptions(g), d.options.after && this._onDidChangeDecorations.recordLineAffectedByInjectedText(f.endLineNumber), d.options.before && this._onDidChangeDecorations.recordLineAffectedByInjectedText(f.startLineNumber), n || this._onDidChangeDecorations.checkAffectedAndFire(g), this._decorationsTree.insert(d), h[c] = d.id, c++;
        } else
          d && delete this._decorations[d.id];
      }
      return h;
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  //#endregion
  //#region Tokenization
  // TODO move them to the tokenization part.
  getLanguageId() {
    return this.tokenization.getLanguageId();
  }
  setLanguage(e, t) {
    typeof e == "string" ? (this._languageSelectionListener.clear(), this._setLanguage(e, t)) : (this._languageSelectionListener.value = e.onDidChange(() => this._setLanguage(e.languageId, t)), this._setLanguage(e.languageId, t));
  }
  _setLanguage(e, t) {
    this.tokenization.setLanguageId(e, t), this._languageService.requestRichLanguageFeatures(e);
  }
  getLanguageIdAtPosition(e, t) {
    return this.tokenization.getLanguageIdAtPosition(e, t);
  }
  getWordAtPosition(e) {
    return this._tokenizationTextModelPart.getWordAtPosition(e);
  }
  getWordUntilPosition(e) {
    return this._tokenizationTextModelPart.getWordUntilPosition(e);
  }
  //#endregion
  normalizePosition(e, t) {
    return e;
  }
  /**
   * Gets the column at which indentation stops at a given line.
   * @internal
  */
  getLineIndentColumn(e) {
    return DZ(this.getLineContent(e)) + 1;
  }
}, Sc = Wo, Wo._MODEL_SYNC_LIMIT = 50 * 1024 * 1024, Wo.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024, Wo.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1e3, Wo.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024, Wo.DEFAULT_CREATION_OPTIONS = {
  isForSimpleWidget: !1,
  tabSize: ji.tabSize,
  indentSize: ji.indentSize,
  insertSpaces: ji.insertSpaces,
  detectIndentation: !1,
  defaultEOL: 1,
  trimAutoWhitespace: ji.trimAutoWhitespace,
  largeFileOptimizations: ji.largeFileOptimizations,
  bracketPairColorizationOptions: ji.bracketPairColorizationOptions
}, Wo);
ip = Sc = wZ([
  x_(4, VI),
  x_(5, ci),
  x_(6, ir),
  x_(7, Pe)
], ip);
function DZ(s) {
  let e = 0;
  for (const t of s)
    if (t === " " || t === "	")
      e++;
    else
      break;
  return e;
}
function Q0(s) {
  return !!(s.options.overviewRuler && s.options.overviewRuler.color);
}
function EZ(s) {
  return !!s.after || !!s.before;
}
function ub(s) {
  return !!s.options.after || !!s.options.before;
}
class TM {
  constructor() {
    this._decorationsTree0 = new G0(), this._decorationsTree1 = new G0(), this._injectedTextDecorationsTree = new G0();
  }
  ensureAllNodesHaveRanges(e) {
    this.getAll(e, 0, !1, !1, !1);
  }
  _ensureNodesHaveRanges(e, t) {
    for (const i of t)
      i.range === null && (i.range = e.getRangeAt(i.cachedAbsoluteStart, i.cachedAbsoluteEnd));
    return t;
  }
  getAllInInterval(e, t, i, n, o, r) {
    const a = e.getVersionId(), l = this._intervalSearch(t, i, n, o, a, r);
    return this._ensureNodesHaveRanges(e, l);
  }
  _intervalSearch(e, t, i, n, o, r) {
    const a = this._decorationsTree0.intervalSearch(e, t, i, n, o, r), l = this._decorationsTree1.intervalSearch(e, t, i, n, o, r), c = this._injectedTextDecorationsTree.intervalSearch(e, t, i, n, o, r);
    return a.concat(l).concat(c);
  }
  getInjectedTextInInterval(e, t, i, n) {
    const o = e.getVersionId(), r = this._injectedTextDecorationsTree.intervalSearch(t, i, n, !1, o, !1);
    return this._ensureNodesHaveRanges(e, r).filter((a) => a.options.showIfCollapsed || !a.range.isEmpty());
  }
  getAllInjectedText(e, t) {
    const i = e.getVersionId(), n = this._injectedTextDecorationsTree.search(t, !1, i, !1);
    return this._ensureNodesHaveRanges(e, n).filter((o) => o.options.showIfCollapsed || !o.range.isEmpty());
  }
  getAll(e, t, i, n, o) {
    const r = e.getVersionId(), a = this._search(t, i, n, r, o);
    return this._ensureNodesHaveRanges(e, a);
  }
  _search(e, t, i, n, o) {
    if (i)
      return this._decorationsTree1.search(e, t, n, o);
    {
      const r = this._decorationsTree0.search(e, t, n, o), a = this._decorationsTree1.search(e, t, n, o), l = this._injectedTextDecorationsTree.search(e, t, n, o);
      return r.concat(a).concat(l);
    }
  }
  collectNodesFromOwner(e) {
    const t = this._decorationsTree0.collectNodesFromOwner(e), i = this._decorationsTree1.collectNodesFromOwner(e), n = this._injectedTextDecorationsTree.collectNodesFromOwner(e);
    return t.concat(i).concat(n);
  }
  collectNodesPostOrder() {
    const e = this._decorationsTree0.collectNodesPostOrder(), t = this._decorationsTree1.collectNodesPostOrder(), i = this._injectedTextDecorationsTree.collectNodesPostOrder();
    return e.concat(t).concat(i);
  }
  insert(e) {
    ub(e) ? this._injectedTextDecorationsTree.insert(e) : Q0(e) ? this._decorationsTree1.insert(e) : this._decorationsTree0.insert(e);
  }
  delete(e) {
    ub(e) ? this._injectedTextDecorationsTree.delete(e) : Q0(e) ? this._decorationsTree1.delete(e) : this._decorationsTree0.delete(e);
  }
  getNodeRange(e, t) {
    const i = e.getVersionId();
    return t.cachedVersionId !== i && this._resolveNode(t, i), t.range === null && (t.range = e.getRangeAt(t.cachedAbsoluteStart, t.cachedAbsoluteEnd)), t.range;
  }
  _resolveNode(e, t) {
    ub(e) ? this._injectedTextDecorationsTree.resolveNode(e, t) : Q0(e) ? this._decorationsTree1.resolveNode(e, t) : this._decorationsTree0.resolveNode(e, t);
  }
  acceptReplace(e, t, i, n) {
    this._decorationsTree0.acceptReplace(e, t, i, n), this._decorationsTree1.acceptReplace(e, t, i, n), this._injectedTextDecorationsTree.acceptReplace(e, t, i, n);
  }
}
function cr(s) {
  return s.replace(/[^a-z0-9\-_]/gi, " ");
}
class wF {
  constructor(e) {
    this.color = e.color || "", this.darkColor = e.darkColor || "";
  }
}
class IZ extends wF {
  constructor(e) {
    super(e), this._resolvedColor = null, this.position = typeof e.position == "number" ? e.position : S1.Center;
  }
  getColor(e) {
    return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = null;
  }
  _resolveColor(e, t) {
    if (typeof e == "string")
      return e;
    const i = e ? t.getColor(e.id) : null;
    return i ? i.toString() : "";
  }
}
class NZ {
  constructor(e) {
    this.position = (e == null ? void 0 : e.position) ?? _o.Center, this.persistLane = e == null ? void 0 : e.persistLane;
  }
}
class TZ extends wF {
  constructor(e) {
    super(e), this.position = e.position, this.sectionHeaderStyle = e.sectionHeaderStyle ?? null, this.sectionHeaderText = e.sectionHeaderText ?? null;
  }
  getColor(e) {
    return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = void 0;
  }
  _resolveColor(e, t) {
    return typeof e == "string" ? j.fromHex(e) : t.getColor(e.id);
  }
}
class Jl {
  static from(e) {
    return e instanceof Jl ? e : new Jl(e);
  }
  constructor(e) {
    this.content = e.content || "", this.inlineClassName = e.inlineClassName || null, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || !1, this.attachedData = e.attachedData || null, this.cursorStops = e.cursorStops || null;
  }
}
class Wt {
  static register(e) {
    return new Wt(e);
  }
  static createDynamic(e) {
    return new Wt(e);
  }
  constructor(e) {
    this.description = e.description, this.blockClassName = e.blockClassName ? cr(e.blockClassName) : null, this.blockDoesNotCollapse = e.blockDoesNotCollapse ?? null, this.blockIsAfterEnd = e.blockIsAfterEnd ?? null, this.blockPadding = e.blockPadding ?? null, this.stickiness = e.stickiness || 0, this.zIndex = e.zIndex || 0, this.className = e.className ? cr(e.className) : null, this.shouldFillLineOnLineBreak = e.shouldFillLineOnLineBreak ?? null, this.hoverMessage = e.hoverMessage || null, this.glyphMarginHoverMessage = e.glyphMarginHoverMessage || null, this.lineNumberHoverMessage = e.lineNumberHoverMessage || null, this.isWholeLine = e.isWholeLine || !1, this.showIfCollapsed = e.showIfCollapsed || !1, this.collapseOnReplaceEdit = e.collapseOnReplaceEdit || !1, this.overviewRuler = e.overviewRuler ? new IZ(e.overviewRuler) : null, this.minimap = e.minimap ? new TZ(e.minimap) : null, this.glyphMargin = e.glyphMarginClassName ? new NZ(e.glyphMargin) : null, this.glyphMarginClassName = e.glyphMarginClassName ? cr(e.glyphMarginClassName) : null, this.linesDecorationsClassName = e.linesDecorationsClassName ? cr(e.linesDecorationsClassName) : null, this.lineNumberClassName = e.lineNumberClassName ? cr(e.lineNumberClassName) : null, this.linesDecorationsTooltip = e.linesDecorationsTooltip ? f8(e.linesDecorationsTooltip) : null, this.firstLineDecorationClassName = e.firstLineDecorationClassName ? cr(e.firstLineDecorationClassName) : null, this.marginClassName = e.marginClassName ? cr(e.marginClassName) : null, this.inlineClassName = e.inlineClassName ? cr(e.inlineClassName) : null, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || !1, this.beforeContentClassName = e.beforeContentClassName ? cr(e.beforeContentClassName) : null, this.afterContentClassName = e.afterContentClassName ? cr(e.afterContentClassName) : null, this.after = e.after ? Jl.from(e.after) : null, this.before = e.before ? Jl.from(e.before) : null, this.hideInCommentTokens = e.hideInCommentTokens ?? !1, this.hideInStringTokens = e.hideInStringTokens ?? !1;
  }
}
Wt.EMPTY = Wt.register({ description: "empty" });
const MM = [
  Wt.register({
    description: "tracked-range-always-grows-when-typing-at-edges",
    stickiness: 0
    /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
  }),
  Wt.register({
    description: "tracked-range-never-grows-when-typing-at-edges",
    stickiness: 1
    /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
  }),
  Wt.register({
    description: "tracked-range-grows-only-when-typing-before",
    stickiness: 2
    /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */
  }),
  Wt.register({
    description: "tracked-range-grows-only-when-typing-after",
    stickiness: 3
    /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */
  })
];
function RM(s) {
  return s instanceof Wt ? s : Wt.createDynamic(s);
}
class MZ extends U {
  constructor(e) {
    super(), this.handleBeforeFire = e, this._actual = this._register(new A()), this.event = this._actual.event, this._affectedInjectedTextLines = null, this._deferredCnt = 0, this._shouldFireDeferred = !1, this._affectsMinimap = !1, this._affectsOverviewRuler = !1, this._affectsGlyphMargin = !1, this._affectsLineNumber = !1;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit() {
    var e;
    this._deferredCnt--, this._deferredCnt === 0 && (this._shouldFireDeferred && this.doFire(), (e = this._affectedInjectedTextLines) == null || e.clear(), this._affectedInjectedTextLines = null);
  }
  recordLineAffectedByInjectedText(e) {
    this._affectedInjectedTextLines || (this._affectedInjectedTextLines = /* @__PURE__ */ new Set()), this._affectedInjectedTextLines.add(e);
  }
  checkAffectedAndFire(e) {
    var t, i;
    this._affectsMinimap || (this._affectsMinimap = !!((t = e.minimap) != null && t.position)), this._affectsOverviewRuler || (this._affectsOverviewRuler = !!((i = e.overviewRuler) != null && i.color)), this._affectsGlyphMargin || (this._affectsGlyphMargin = !!e.glyphMarginClassName), this._affectsLineNumber || (this._affectsLineNumber = !!e.lineNumberClassName), this.tryFire();
  }
  fire() {
    this._affectsMinimap = !0, this._affectsOverviewRuler = !0, this._affectsGlyphMargin = !0, this.tryFire();
  }
  tryFire() {
    this._deferredCnt === 0 ? this.doFire() : this._shouldFireDeferred = !0;
  }
  doFire() {
    this.handleBeforeFire(this._affectedInjectedTextLines);
    const e = {
      affectsMinimap: this._affectsMinimap,
      affectsOverviewRuler: this._affectsOverviewRuler,
      affectsGlyphMargin: this._affectsGlyphMargin,
      affectsLineNumber: this._affectsLineNumber
    };
    this._shouldFireDeferred = !1, this._affectsMinimap = !1, this._affectsOverviewRuler = !1, this._affectsGlyphMargin = !1, this._actual.fire(e);
  }
}
class RZ extends U {
  constructor() {
    super(), this._fastEmitter = this._register(new A()), this.fastEvent = this._fastEmitter.event, this._slowEmitter = this._register(new A()), this.slowEvent = this._slowEmitter.event, this._deferredCnt = 0, this._deferredEvent = null;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit(e = null) {
    if (this._deferredCnt--, this._deferredCnt === 0 && this._deferredEvent !== null) {
      this._deferredEvent.rawContentChangedEvent.resultingSelection = e;
      const t = this._deferredEvent;
      this._deferredEvent = null, this._fastEmitter.fire(t), this._slowEmitter.fire(t);
    }
  }
  fire(e) {
    if (this._deferredCnt > 0) {
      this._deferredEvent ? this._deferredEvent = this._deferredEvent.merge(e) : this._deferredEvent = e;
      return;
    }
    this._fastEmitter.fire(e), this._slowEmitter.fire(e);
  }
}
const De = Be("ILanguageFeaturesService");
class zI {
  static create(e) {
    return new zI(e.get(
      135
      /* EditorOption.wordWrapBreakBeforeCharacters */
    ), e.get(
      134
      /* EditorOption.wordWrapBreakAfterCharacters */
    ));
  }
  constructor(e, t) {
    this.classifier = new AZ(e, t);
  }
  createLineBreaksComputer(e, t, i, n, o) {
    const r = [], a = [], l = [];
    return {
      addRequest: (c, h, d) => {
        r.push(c), a.push(h), l.push(d);
      },
      finalize: () => {
        const c = e.typicalFullwidthCharacterWidth / e.typicalHalfwidthCharacterWidth, h = [];
        for (let d = 0, u = r.length; d < u; d++) {
          const f = a[d], g = l[d];
          g && !g.injectionOptions && !f ? h[d] = PZ(this.classifier, g, r[d], t, i, c, n, o) : h[d] = OZ(this.classifier, r[d], f, t, i, c, n, o);
        }
        return pL.length = 0, _L.length = 0, h;
      }
    };
  }
}
class AZ extends Hp {
  constructor(e, t) {
    super(
      0
      /* CharacterClass.NONE */
    );
    for (let i = 0; i < e.length; i++)
      this.set(
        e.charCodeAt(i),
        1
        /* CharacterClass.BREAK_BEFORE */
      );
    for (let i = 0; i < t.length; i++)
      this.set(
        t.charCodeAt(i),
        2
        /* CharacterClass.BREAK_AFTER */
      );
  }
  get(e) {
    return e >= 0 && e < 256 ? this._asciiMap[e] : e >= 12352 && e <= 12543 || e >= 13312 && e <= 19903 || e >= 19968 && e <= 40959 ? 3 : this._map.get(e) || this._defaultValue;
  }
}
let pL = [], _L = [];
function PZ(s, e, t, i, n, o, r, a) {
  if (n === -1)
    return null;
  const l = t.length;
  if (l <= 1)
    return null;
  const c = a === "keepAll", h = e.breakOffsets, d = e.breakOffsetsVisibleColumn, u = yF(t, i, n, o, r), f = n - u, g = pL, p = _L;
  let _ = 0, b = 0, C = 0, w = n;
  const v = h.length;
  let S = 0;
  if (S >= 0) {
    let L = Math.abs(d[S] - w);
    for (; S + 1 < v; ) {
      const k = Math.abs(d[S + 1] - w);
      if (k >= L)
        break;
      L = k, S++;
    }
  }
  for (; S < v; ) {
    let L = S < 0 ? 0 : h[S], k = S < 0 ? 0 : d[S];
    b > L && (L = b, k = C);
    let x = 0, I = 0, K = 0, B = 0;
    if (k <= w) {
      let H = k, P = L === 0 ? 0 : t.charCodeAt(L - 1), q = L === 0 ? 0 : s.get(P), J = !0;
      for (let oe = L; oe < l; oe++) {
        const ae = oe, re = t.charCodeAt(oe);
        let be, Ce;
        if (Si(re) ? (oe++, be = 0, Ce = 2) : (be = s.get(re), Ce = qg(re, H, i, o)), ae > b && bL(P, q, re, be, c) && (x = ae, I = H), H += Ce, H > w) {
          ae > b ? (K = ae, B = H - Ce) : (K = oe + 1, B = H), H - I > f && (x = 0), J = !1;
          break;
        }
        P = re, q = be;
      }
      if (J) {
        _ > 0 && (g[_] = h[h.length - 1], p[_] = d[h.length - 1], _++);
        break;
      }
    }
    if (x === 0) {
      let H = k, P = t.charCodeAt(L), q = s.get(P), J = !1;
      for (let oe = L - 1; oe >= b; oe--) {
        const ae = oe + 1, re = t.charCodeAt(oe);
        if (re === 9) {
          J = !0;
          break;
        }
        let be, Ce;
        if (sf(re) ? (oe--, be = 0, Ce = 2) : (be = s.get(re), Ce = jl(re) ? o : 1), H <= w) {
          if (K === 0 && (K = ae, B = H), H <= w - f)
            break;
          if (bL(re, be, P, q, c)) {
            x = ae, I = H;
            break;
          }
        }
        H -= Ce, P = re, q = be;
      }
      if (x !== 0) {
        const oe = f - (B - I);
        if (oe <= i) {
          const ae = t.charCodeAt(K);
          let re;
          Si(ae) ? re = 2 : re = qg(ae, B, i, o), oe - re < 0 && (x = 0);
        }
      }
      if (J) {
        S--;
        continue;
      }
    }
    if (x === 0 && (x = K, I = B), x <= b) {
      const H = t.charCodeAt(b);
      Si(H) ? (x = b + 2, I = C + 2) : (x = b + 1, I = C + qg(H, C, i, o));
    }
    for (b = x, g[_] = x, C = I, p[_] = I, _++, w = I + f; S < 0 || S < v && d[S] < I; )
      S++;
    let W = Math.abs(d[S] - w);
    for (; S + 1 < v; ) {
      const H = Math.abs(d[S + 1] - w);
      if (H >= W)
        break;
      W = H, S++;
    }
  }
  return _ === 0 ? null : (g.length = _, p.length = _, pL = e.breakOffsets, _L = e.breakOffsetsVisibleColumn, e.breakOffsets = g, e.breakOffsetsVisibleColumn = p, e.wrappedTextIndentLength = u, e);
}
function OZ(s, e, t, i, n, o, r, a) {
  const l = Zo.applyInjectedText(e, t);
  let c, h;
  if (t && t.length > 0 ? (c = t.map((I) => I.options), h = t.map((I) => I.column - 1)) : (c = null, h = null), n === -1)
    return c ? new zg(h, c, [l.length], [], 0) : null;
  const d = l.length;
  if (d <= 1)
    return c ? new zg(h, c, [l.length], [], 0) : null;
  const u = a === "keepAll", f = yF(l, i, n, o, r), g = n - f, p = [], _ = [];
  let b = 0, C = 0, w = 0, v = n, S = l.charCodeAt(0), L = s.get(S), k = qg(S, 0, i, o), x = 1;
  Si(S) && (k += 1, S = l.charCodeAt(1), L = s.get(S), x++);
  for (let I = x; I < d; I++) {
    const K = I, B = l.charCodeAt(I);
    let W, H;
    Si(B) ? (I++, W = 0, H = 2) : (W = s.get(B), H = qg(B, k, i, o)), bL(S, L, B, W, u) && (C = K, w = k), k += H, k > v && ((C === 0 || k - w > g) && (C = K, w = k - H), p[b] = C, _[b] = w, b++, v = w + g, C = 0), S = B, L = W;
  }
  return b === 0 && (!t || t.length === 0) ? null : (p[b] = d, _[b] = k, new zg(h, c, p, _, f));
}
function qg(s, e, t, i) {
  return s === 9 ? t - e % t : jl(s) || s < 32 ? i : 1;
}
function AM(s, e) {
  return e - s % e;
}
function bL(s, e, t, i, n) {
  return t !== 32 && (e === 2 && i !== 2 || e !== 1 && i === 1 || !n && e === 3 && i !== 2 || !n && i === 3 && e !== 1);
}
function yF(s, e, t, i, n) {
  let o = 0;
  if (n !== 0) {
    const r = Zn(s);
    if (r !== -1) {
      for (let l = 0; l < r; l++) {
        const c = s.charCodeAt(l) === 9 ? AM(o, e) : 1;
        o += c;
      }
      const a = n === 3 ? 2 : n === 2 ? 1 : 0;
      for (let l = 0; l < a; l++) {
        const c = AM(o, e);
        o += c;
      }
      o + i > t && (o = 0);
    }
  }
  return o;
}
class M1 {
  constructor(e) {
    this._selTrackedRange = null, this._trackSelection = !0, this._setState(e, new Ei(new T(1, 1, 1, 1), 0, 0, new F(1, 1), 0), new Ei(new T(1, 1, 1, 1), 0, 0, new F(1, 1), 0));
  }
  dispose(e) {
    this._removeTrackedRange(e);
  }
  startTrackingSelection(e) {
    this._trackSelection = !0, this._updateTrackedRange(e);
  }
  stopTrackingSelection(e) {
    this._trackSelection = !1, this._removeTrackedRange(e);
  }
  _updateTrackedRange(e) {
    this._trackSelection && (this._selTrackedRange = e.model._setTrackedRange(
      this._selTrackedRange,
      this.modelState.selection,
      0
      /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
    ));
  }
  _removeTrackedRange(e) {
    this._selTrackedRange = e.model._setTrackedRange(
      this._selTrackedRange,
      null,
      0
      /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
    );
  }
  asCursorState() {
    return new Ve(this.modelState, this.viewState);
  }
  readSelectionFromMarkers(e) {
    const t = e.model._getTrackedRange(this._selTrackedRange);
    return this.modelState.selection.isEmpty() && !t.isEmpty() ? Ue.fromRange(t.collapseToEnd(), this.modelState.selection.getDirection()) : Ue.fromRange(t, this.modelState.selection.getDirection());
  }
  ensureValidState(e) {
    this._setState(e, this.modelState, this.viewState);
  }
  setState(e, t, i) {
    this._setState(e, t, i);
  }
  static _validatePositionWithCache(e, t, i, n) {
    return t.equals(i) ? n : e.normalizePosition(
      t,
      2
      /* PositionAffinity.None */
    );
  }
  static _validateViewState(e, t) {
    const i = t.position, n = t.selectionStart.getStartPosition(), o = t.selectionStart.getEndPosition(), r = e.normalizePosition(
      i,
      2
      /* PositionAffinity.None */
    ), a = this._validatePositionWithCache(e, n, i, r), l = this._validatePositionWithCache(e, o, n, a);
    return i.equals(r) && n.equals(a) && o.equals(l) ? t : new Ei(T.fromPositions(a, l), t.selectionStartKind, t.selectionStartLeftoverVisibleColumns + n.column - a.column, r, t.leftoverVisibleColumns + i.column - r.column);
  }
  _setState(e, t, i) {
    if (i && (i = M1._validateViewState(e.viewModel, i)), t) {
      const n = e.model.validateRange(t.selectionStart), o = t.selectionStart.equalsRange(n) ? t.selectionStartLeftoverVisibleColumns : 0, r = e.model.validatePosition(t.position), a = t.position.equals(r) ? t.leftoverVisibleColumns : 0;
      t = new Ei(n, t.selectionStartKind, o, r, a);
    } else {
      if (!i)
        return;
      const n = e.model.validateRange(e.coordinatesConverter.convertViewRangeToModelRange(i.selectionStart)), o = e.model.validatePosition(e.coordinatesConverter.convertViewPositionToModelPosition(i.position));
      t = new Ei(n, i.selectionStartKind, i.selectionStartLeftoverVisibleColumns, o, i.leftoverVisibleColumns);
    }
    if (i) {
      const n = e.coordinatesConverter.validateViewRange(i.selectionStart, t.selectionStart), o = e.coordinatesConverter.validateViewPosition(i.position, t.position);
      i = new Ei(n, t.selectionStartKind, t.selectionStartLeftoverVisibleColumns, o, t.leftoverVisibleColumns);
    } else {
      const n = e.coordinatesConverter.convertModelPositionToViewPosition(new F(t.selectionStart.startLineNumber, t.selectionStart.startColumn)), o = e.coordinatesConverter.convertModelPositionToViewPosition(new F(t.selectionStart.endLineNumber, t.selectionStart.endColumn)), r = new T(n.lineNumber, n.column, o.lineNumber, o.column), a = e.coordinatesConverter.convertModelPositionToViewPosition(t.position);
      i = new Ei(r, t.selectionStartKind, t.selectionStartLeftoverVisibleColumns, a, t.leftoverVisibleColumns);
    }
    this.modelState = t, this.viewState = i, this._updateTrackedRange(e);
  }
}
class PM {
  constructor(e) {
    this.context = e, this.cursors = [new M1(e)], this.lastAddedCursorIndex = 0;
  }
  dispose() {
    for (const e of this.cursors)
      e.dispose(this.context);
  }
  startTrackingSelections() {
    for (const e of this.cursors)
      e.startTrackingSelection(this.context);
  }
  stopTrackingSelections() {
    for (const e of this.cursors)
      e.stopTrackingSelection(this.context);
  }
  updateContext(e) {
    this.context = e;
  }
  ensureValidState() {
    for (const e of this.cursors)
      e.ensureValidState(this.context);
  }
  readSelectionFromMarkers() {
    return this.cursors.map((e) => e.readSelectionFromMarkers(this.context));
  }
  getAll() {
    return this.cursors.map((e) => e.asCursorState());
  }
  getViewPositions() {
    return this.cursors.map((e) => e.viewState.position);
  }
  getTopMostViewPosition() {
    return Cq(this.cursors, Os((e) => e.viewState.position, F.compare)).viewState.position;
  }
  getBottomMostViewPosition() {
    return bq(this.cursors, Os((e) => e.viewState.position, F.compare)).viewState.position;
  }
  getSelections() {
    return this.cursors.map((e) => e.modelState.selection);
  }
  getViewSelections() {
    return this.cursors.map((e) => e.viewState.selection);
  }
  setSelections(e) {
    this.setStates(Ve.fromModelSelections(e));
  }
  getPrimaryCursor() {
    return this.cursors[0].asCursorState();
  }
  setStates(e) {
    e !== null && (this.cursors[0].setState(this.context, e[0].modelState, e[0].viewState), this._setSecondaryStates(e.slice(1)));
  }
  /**
   * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.
   */
  _setSecondaryStates(e) {
    const t = this.cursors.length - 1, i = e.length;
    if (t < i) {
      const n = i - t;
      for (let o = 0; o < n; o++)
        this._addSecondaryCursor();
    } else if (t > i) {
      const n = t - i;
      for (let o = 0; o < n; o++)
        this._removeSecondaryCursor(this.cursors.length - 2);
    }
    for (let n = 0; n < i; n++)
      this.cursors[n + 1].setState(this.context, e[n].modelState, e[n].viewState);
  }
  killSecondaryCursors() {
    this._setSecondaryStates([]);
  }
  _addSecondaryCursor() {
    this.cursors.push(new M1(this.context)), this.lastAddedCursorIndex = this.cursors.length - 1;
  }
  getLastAddedCursorIndex() {
    return this.cursors.length === 1 || this.lastAddedCursorIndex === 0 ? 0 : this.lastAddedCursorIndex;
  }
  _removeSecondaryCursor(e) {
    this.lastAddedCursorIndex >= e + 1 && this.lastAddedCursorIndex--, this.cursors[e + 1].dispose(this.context), this.cursors.splice(e + 1, 1);
  }
  normalize() {
    if (this.cursors.length === 1)
      return;
    const e = this.cursors.slice(0), t = [];
    for (let i = 0, n = e.length; i < n; i++)
      t.push({
        index: i,
        selection: e[i].modelState.selection
      });
    t.sort(Os((i) => i.selection, T.compareRangesUsingStarts));
    for (let i = 0; i < t.length - 1; i++) {
      const n = t[i], o = t[i + 1], r = n.selection, a = o.selection;
      if (!this.context.cursorConfig.multiCursorMergeOverlapping)
        continue;
      let l;
      if (a.isEmpty() || r.isEmpty() ? l = a.getStartPosition().isBeforeOrEqual(r.getEndPosition()) : l = a.getStartPosition().isBefore(r.getEndPosition()), l) {
        const c = n.index < o.index ? i : i + 1, h = n.index < o.index ? i + 1 : i, d = t[h].index, u = t[c].index, f = t[h].selection, g = t[c].selection;
        if (!f.equalsSelection(g)) {
          const p = f.plusRange(g), _ = f.selectionStartLineNumber === f.startLineNumber && f.selectionStartColumn === f.startColumn, b = g.selectionStartLineNumber === g.startLineNumber && g.selectionStartColumn === g.startColumn;
          let C;
          d === this.lastAddedCursorIndex ? (C = _, this.lastAddedCursorIndex = u) : C = b;
          let w;
          C ? w = new Ue(p.startLineNumber, p.startColumn, p.endLineNumber, p.endColumn) : w = new Ue(p.endLineNumber, p.endColumn, p.startLineNumber, p.startColumn), t[c].selection = w;
          const v = Ve.fromModelSelection(w);
          e[u].setState(this.context, v.modelState, v.viewState);
        }
        for (const p of t)
          p.index > d && p.index--;
        e.splice(d, 1), t.splice(h, 1), this._removeSecondaryCursor(d - 1), i--;
      }
    }
  }
}
class OM {
  constructor(e, t, i, n) {
    this._cursorContextBrand = void 0, this.model = e, this.viewModel = t, this.coordinatesConverter = i, this.cursorConfig = n;
  }
}
class FZ {
  constructor() {
    this.type = 0;
  }
}
class BZ {
  constructor() {
    this.type = 1;
  }
}
class WZ {
  constructor(e) {
    this.type = 2, this._source = e;
  }
  hasChanged(e) {
    return this._source.hasChanged(e);
  }
}
class HZ {
  constructor(e, t, i) {
    this.selections = e, this.modelSelections = t, this.reason = i, this.type = 3;
  }
}
class pc {
  constructor(e) {
    this.type = 4, e ? (this.affectsMinimap = e.affectsMinimap, this.affectsOverviewRuler = e.affectsOverviewRuler, this.affectsGlyphMargin = e.affectsGlyphMargin, this.affectsLineNumber = e.affectsLineNumber) : (this.affectsMinimap = !0, this.affectsOverviewRuler = !0, this.affectsGlyphMargin = !0, this.affectsLineNumber = !0);
  }
}
class E_ {
  constructor() {
    this.type = 5;
  }
}
class VZ {
  constructor(e) {
    this.type = 6, this.isFocused = e;
  }
}
class zZ {
  constructor() {
    this.type = 7;
  }
}
class I_ {
  constructor() {
    this.type = 8;
  }
}
class SF {
  constructor(e, t) {
    this.fromLineNumber = e, this.count = t, this.type = 9;
  }
}
class CL {
  constructor(e, t) {
    this.type = 10, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class vL {
  constructor(e, t) {
    this.type = 11, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class Gg {
  constructor(e, t, i, n, o, r, a) {
    this.source = e, this.minimalReveal = t, this.range = i, this.selections = n, this.verticalType = o, this.revealHorizontal = r, this.scrollType = a, this.type = 12;
  }
}
class UZ {
  constructor(e) {
    this.type = 13, this.scrollWidth = e.scrollWidth, this.scrollLeft = e.scrollLeft, this.scrollHeight = e.scrollHeight, this.scrollTop = e.scrollTop, this.scrollWidthChanged = e.scrollWidthChanged, this.scrollLeftChanged = e.scrollLeftChanged, this.scrollHeightChanged = e.scrollHeightChanged, this.scrollTopChanged = e.scrollTopChanged;
  }
}
class $Z {
  constructor(e) {
    this.theme = e, this.type = 14;
  }
}
class KZ {
  constructor(e) {
    this.type = 15, this.ranges = e;
  }
}
class jZ {
  constructor() {
    this.type = 16;
  }
}
let qZ = class {
  constructor() {
    this.type = 17;
  }
};
class GZ extends U {
  constructor() {
    super(), this._onEvent = this._register(new A()), this.onEvent = this._onEvent.event, this._eventHandlers = [], this._viewEventQueue = null, this._isConsumingViewEventQueue = !1, this._collector = null, this._collectorCnt = 0, this._outgoingEvents = [];
  }
  emitOutgoingEvent(e) {
    this._addOutgoingEvent(e), this._emitOutgoingEvents();
  }
  _addOutgoingEvent(e) {
    for (let t = 0, i = this._outgoingEvents.length; t < i; t++) {
      const n = this._outgoingEvents[t].kind === e.kind ? this._outgoingEvents[t].attemptToMerge(e) : null;
      if (n) {
        this._outgoingEvents[t] = n;
        return;
      }
    }
    this._outgoingEvents.push(e);
  }
  _emitOutgoingEvents() {
    for (; this._outgoingEvents.length > 0; ) {
      if (this._collector || this._isConsumingViewEventQueue)
        return;
      const e = this._outgoingEvents.shift();
      e.isNoOp() || this._onEvent.fire(e);
    }
  }
  addViewEventHandler(e) {
    for (let t = 0, i = this._eventHandlers.length; t < i; t++)
      this._eventHandlers[t] === e && console.warn("Detected duplicate listener in ViewEventDispatcher", e);
    this._eventHandlers.push(e);
  }
  removeViewEventHandler(e) {
    for (let t = 0; t < this._eventHandlers.length; t++)
      if (this._eventHandlers[t] === e) {
        this._eventHandlers.splice(t, 1);
        break;
      }
  }
  beginEmitViewEvents() {
    return this._collectorCnt++, this._collectorCnt === 1 && (this._collector = new ZZ()), this._collector;
  }
  endEmitViewEvents() {
    if (this._collectorCnt--, this._collectorCnt === 0) {
      const e = this._collector.outgoingEvents, t = this._collector.viewEvents;
      this._collector = null;
      for (const i of e)
        this._addOutgoingEvent(i);
      t.length > 0 && this._emitMany(t);
    }
    this._emitOutgoingEvents();
  }
  emitSingleViewEvent(e) {
    try {
      this.beginEmitViewEvents().emitViewEvent(e);
    } finally {
      this.endEmitViewEvents();
    }
  }
  _emitMany(e) {
    this._viewEventQueue ? this._viewEventQueue = this._viewEventQueue.concat(e) : this._viewEventQueue = e, this._isConsumingViewEventQueue || this._consumeViewEventQueue();
  }
  _consumeViewEventQueue() {
    try {
      this._isConsumingViewEventQueue = !0, this._doConsumeQueue();
    } finally {
      this._isConsumingViewEventQueue = !1;
    }
  }
  _doConsumeQueue() {
    for (; this._viewEventQueue; ) {
      const e = this._viewEventQueue;
      this._viewEventQueue = null;
      const t = this._eventHandlers.slice(0);
      for (const i of t)
        i.handleEvents(e);
    }
  }
}
class ZZ {
  constructor() {
    this.viewEvents = [], this.outgoingEvents = [];
  }
  emitViewEvent(e) {
    this.viewEvents.push(e);
  }
  emitOutgoingEvent(e) {
    this.outgoingEvents.push(e);
  }
}
class UI {
  constructor(e, t, i, n) {
    this.kind = 0, this._oldContentWidth = e, this._oldContentHeight = t, this.contentWidth = i, this.contentHeight = n, this.contentWidthChanged = this._oldContentWidth !== this.contentWidth, this.contentHeightChanged = this._oldContentHeight !== this.contentHeight;
  }
  isNoOp() {
    return !this.contentWidthChanged && !this.contentHeightChanged;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new UI(this._oldContentWidth, this._oldContentHeight, e.contentWidth, e.contentHeight);
  }
}
class $I {
  constructor(e, t) {
    this.kind = 1, this.oldHasFocus = e, this.hasFocus = t;
  }
  isNoOp() {
    return this.oldHasFocus === this.hasFocus;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new $I(this.oldHasFocus, e.hasFocus);
  }
}
class KI {
  constructor(e, t, i, n, o, r, a, l) {
    this.kind = 2, this._oldScrollWidth = e, this._oldScrollLeft = t, this._oldScrollHeight = i, this._oldScrollTop = n, this.scrollWidth = o, this.scrollLeft = r, this.scrollHeight = a, this.scrollTop = l, this.scrollWidthChanged = this._oldScrollWidth !== this.scrollWidth, this.scrollLeftChanged = this._oldScrollLeft !== this.scrollLeft, this.scrollHeightChanged = this._oldScrollHeight !== this.scrollHeight, this.scrollTopChanged = this._oldScrollTop !== this.scrollTop;
  }
  isNoOp() {
    return !this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new KI(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop);
  }
}
class YZ {
  constructor() {
    this.kind = 3;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : this;
  }
}
class XZ {
  constructor() {
    this.kind = 4;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : this;
  }
}
class R1 {
  constructor(e, t, i, n, o, r, a) {
    this.kind = 6, this.oldSelections = e, this.selections = t, this.oldModelVersionId = i, this.modelVersionId = n, this.source = o, this.reason = r, this.reachedMaxCursorCount = a;
  }
  static _selectionsAreEqual(e, t) {
    if (!e && !t)
      return !0;
    if (!e || !t)
      return !1;
    const i = e.length, n = t.length;
    if (i !== n)
      return !1;
    for (let o = 0; o < i; o++)
      if (!e[o].equalsSelection(t[o]))
        return !1;
    return !0;
  }
  isNoOp() {
    return R1._selectionsAreEqual(this.oldSelections, this.selections) && this.oldModelVersionId === this.modelVersionId;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new R1(this.oldSelections, e.selections, this.oldModelVersionId, e.modelVersionId, e.source, e.reason, this.reachedMaxCursorCount || e.reachedMaxCursorCount);
  }
}
class QZ {
  constructor() {
    this.kind = 5;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : this;
  }
}
class JZ {
  constructor(e) {
    this.event = e, this.kind = 7;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class eY {
  constructor(e) {
    this.event = e, this.kind = 8;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class tY {
  constructor(e) {
    this.event = e, this.kind = 9;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class iY {
  constructor(e) {
    this.event = e, this.kind = 10;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class nY {
  constructor(e) {
    this.event = e, this.kind = 11;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class sY {
  constructor(e) {
    this.event = e, this.kind = 12;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class oY extends U {
  constructor(e, t, i, n) {
    super(), this._model = e, this._knownModelVersionId = this._model.getVersionId(), this._viewModel = t, this._coordinatesConverter = i, this.context = new OM(this._model, this._viewModel, this._coordinatesConverter, n), this._cursors = new PM(this.context), this._hasFocus = !1, this._isHandling = !1, this._compositionState = null, this._columnSelectData = null, this._autoClosedActions = [], this._prevEditOperationType = 0;
  }
  dispose() {
    this._cursors.dispose(), this._autoClosedActions = Ft(this._autoClosedActions), super.dispose();
  }
  updateConfiguration(e) {
    this.context = new OM(this._model, this._viewModel, this._coordinatesConverter, e), this._cursors.updateContext(this.context);
  }
  onLineMappingChanged(e) {
    this._knownModelVersionId === this._model.getVersionId() && this.setStates(e, "viewModel", 0, this.getCursorStates());
  }
  setHasFocus(e) {
    this._hasFocus = e;
  }
  _validateAutoClosedActions() {
    if (this._autoClosedActions.length > 0) {
      const e = this._cursors.getSelections();
      for (let t = 0; t < this._autoClosedActions.length; t++) {
        const i = this._autoClosedActions[t];
        i.isValid(e) || (i.dispose(), this._autoClosedActions.splice(t, 1), t--);
      }
    }
  }
  // ------ some getters/setters
  getPrimaryCursorState() {
    return this._cursors.getPrimaryCursor();
  }
  getLastAddedCursorIndex() {
    return this._cursors.getLastAddedCursorIndex();
  }
  getCursorStates() {
    return this._cursors.getAll();
  }
  setStates(e, t, i, n) {
    let o = !1;
    const r = this.context.cursorConfig.multiCursorLimit;
    n !== null && n.length > r && (n = n.slice(0, r), o = !0);
    const a = Zg.from(this._model, this);
    return this._cursors.setStates(n), this._cursors.normalize(), this._columnSelectData = null, this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, t, i, a, o);
  }
  setCursorColumnSelectData(e) {
    this._columnSelectData = e;
  }
  revealAll(e, t, i, n, o, r) {
    const a = this._cursors.getViewPositions();
    let l = null, c = null;
    a.length > 1 ? c = this._cursors.getViewSelections() : l = T.fromPositions(a[0], a[0]), e.emitViewEvent(new Gg(t, i, l, c, n, o, r));
  }
  revealPrimary(e, t, i, n, o, r) {
    const l = [this._cursors.getPrimaryCursor().viewState.selection];
    e.emitViewEvent(new Gg(t, i, null, l, n, o, r));
  }
  saveState() {
    const e = [], t = this._cursors.getSelections();
    for (let i = 0, n = t.length; i < n; i++) {
      const o = t[i];
      e.push({
        inSelectionMode: !o.isEmpty(),
        selectionStart: {
          lineNumber: o.selectionStartLineNumber,
          column: o.selectionStartColumn
        },
        position: {
          lineNumber: o.positionLineNumber,
          column: o.positionColumn
        }
      });
    }
    return e;
  }
  restoreState(e, t) {
    const i = [];
    for (let n = 0, o = t.length; n < o; n++) {
      const r = t[n];
      let a = 1, l = 1;
      r.position && r.position.lineNumber && (a = r.position.lineNumber), r.position && r.position.column && (l = r.position.column);
      let c = a, h = l;
      r.selectionStart && r.selectionStart.lineNumber && (c = r.selectionStart.lineNumber), r.selectionStart && r.selectionStart.column && (h = r.selectionStart.column), i.push({
        selectionStartLineNumber: c,
        selectionStartColumn: h,
        positionLineNumber: a,
        positionColumn: l
      });
    }
    this.setStates(e, "restoreState", 0, Ve.fromModelSelections(i)), this.revealAll(
      e,
      "restoreState",
      !1,
      0,
      !0,
      1
      /* editorCommon.ScrollType.Immediate */
    );
  }
  onModelContentChanged(e, t) {
    if (t instanceof iF) {
      if (this._isHandling)
        return;
      this._isHandling = !0;
      try {
        this.setStates(e, "modelChange", 0, this.getCursorStates());
      } finally {
        this._isHandling = !1;
      }
    } else {
      const i = t.rawContentChangedEvent;
      if (this._knownModelVersionId = i.versionId, this._isHandling)
        return;
      const n = i.containsEvent(
        1
        /* RawContentChangedType.Flush */
      );
      if (this._prevEditOperationType = 0, n)
        this._cursors.dispose(), this._cursors = new PM(this.context), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, "model", 1, null, !1);
      else if (this._hasFocus && i.resultingSelection && i.resultingSelection.length > 0) {
        const o = Ve.fromModelSelections(i.resultingSelection);
        this.setStates(e, "modelChange", i.isUndoing ? 5 : i.isRedoing ? 6 : 2, o) && this.revealAll(
          e,
          "modelChange",
          !1,
          0,
          !0,
          0
          /* editorCommon.ScrollType.Smooth */
        );
      } else {
        const o = this._cursors.readSelectionFromMarkers();
        this.setStates(e, "modelChange", 2, Ve.fromModelSelections(o));
      }
    }
  }
  getSelection() {
    return this._cursors.getPrimaryCursor().modelState.selection;
  }
  getTopMostViewPosition() {
    return this._cursors.getTopMostViewPosition();
  }
  getBottomMostViewPosition() {
    return this._cursors.getBottomMostViewPosition();
  }
  getCursorColumnSelectData() {
    if (this._columnSelectData)
      return this._columnSelectData;
    const e = this._cursors.getPrimaryCursor(), t = e.viewState.selectionStart.getStartPosition(), i = e.viewState.position;
    return {
      isReal: !1,
      fromViewLineNumber: t.lineNumber,
      fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, t),
      toViewLineNumber: i.lineNumber,
      toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, i)
    };
  }
  getSelections() {
    return this._cursors.getSelections();
  }
  setSelections(e, t, i, n) {
    this.setStates(e, t, n, Ve.fromModelSelections(i));
  }
  getPrevEditOperationType() {
    return this._prevEditOperationType;
  }
  setPrevEditOperationType(e) {
    this._prevEditOperationType = e;
  }
  // ------ auxiliary handling logic
  _pushAutoClosedAction(e, t) {
    const i = [], n = [];
    for (let a = 0, l = e.length; a < l; a++)
      i.push({
        range: e[a],
        options: {
          description: "auto-closed-character",
          inlineClassName: "auto-closed-character",
          stickiness: 1
          /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
        }
      }), n.push({
        range: t[a],
        options: {
          description: "auto-closed-enclosing",
          stickiness: 1
          /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
        }
      });
    const o = this._model.deltaDecorations([], i), r = this._model.deltaDecorations([], n);
    this._autoClosedActions.push(new FM(this._model, o, r));
  }
  _executeEditOperation(e) {
    if (!e)
      return;
    e.shouldPushStackElementBefore && this._model.pushStackElement();
    const t = rY.executeCommands(this._model, this._cursors.getSelections(), e.commands);
    if (t) {
      this._interpretCommandResult(t);
      const i = [], n = [];
      for (let o = 0; o < e.commands.length; o++) {
        const r = e.commands[o];
        r instanceof SI && r.enclosingRange && r.closeCharacterRange && (i.push(r.closeCharacterRange), n.push(r.enclosingRange));
      }
      i.length > 0 && this._pushAutoClosedAction(i, n), this._prevEditOperationType = e.type;
    }
    e.shouldPushStackElementAfter && this._model.pushStackElement();
  }
  _interpretCommandResult(e) {
    (!e || e.length === 0) && (e = this._cursors.readSelectionFromMarkers()), this._columnSelectData = null, this._cursors.setSelections(e), this._cursors.normalize();
  }
  // -----------------------------------------------------------------------------------------------------------
  // ----- emitting events
  _emitStateChangedIfNecessary(e, t, i, n, o) {
    const r = Zg.from(this._model, this);
    if (r.equals(n))
      return !1;
    const a = this._cursors.getSelections(), l = this._cursors.getViewSelections();
    if (e.emitViewEvent(new HZ(l, a, i)), !n || n.cursorState.length !== r.cursorState.length || r.cursorState.some((c, h) => !c.modelState.equals(n.cursorState[h].modelState))) {
      const c = n ? n.cursorState.map((d) => d.modelState.selection) : null, h = n ? n.modelVersionId : 0;
      e.emitOutgoingEvent(new R1(c, a, h, r.modelVersionId, t || "keyboard", i, o));
    }
    return !0;
  }
  // -----------------------------------------------------------------------------------------------------------
  // ----- handlers beyond this point
  _findAutoClosingPairs(e) {
    if (!e.length)
      return null;
    const t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      if (!o.text || o.text.indexOf(`
`) >= 0)
        return null;
      const r = o.text.match(/([)\]}>'"`])([^)\]}>'"`]*)$/);
      if (!r)
        return null;
      const a = r[1], l = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(a);
      if (!l || l.length !== 1)
        return null;
      const c = l[0].open, h = o.text.length - r[2].length - 1, d = o.text.lastIndexOf(c, h - 1);
      if (d === -1)
        return null;
      t.push([d, h]);
    }
    return t;
  }
  executeEdits(e, t, i, n) {
    let o = null;
    t === "snippet" && (o = this._findAutoClosingPairs(i)), o && (i[0]._isTracked = !0);
    const r = [], a = [], l = this._model.pushEditOperations(this.getSelections(), i, (c) => {
      if (o)
        for (let d = 0, u = o.length; d < u; d++) {
          const [f, g] = o[d], p = c[d], _ = p.range.startLineNumber, b = p.range.startColumn - 1 + f, C = p.range.startColumn - 1 + g;
          r.push(new T(_, C + 1, _, C + 2)), a.push(new T(_, b + 1, _, C + 2));
        }
      const h = n(c);
      return h && (this._isHandling = !0), h;
    });
    l && (this._isHandling = !1, this.setSelections(
      e,
      t,
      l,
      0
      /* CursorChangeReason.NotSet */
    )), r.length > 0 && this._pushAutoClosedAction(r, a);
  }
  _executeEdit(e, t, i, n = 0) {
    if (this.context.cursorConfig.readOnly)
      return;
    const o = Zg.from(this._model, this);
    this._cursors.stopTrackingSelections(), this._isHandling = !0;
    try {
      this._cursors.ensureValidState(), e();
    } catch (r) {
      Je(r);
    }
    this._isHandling = !1, this._cursors.startTrackingSelections(), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(t, i, n, o, !1) && this.revealAll(
      t,
      i,
      !1,
      0,
      !0,
      0
      /* editorCommon.ScrollType.Smooth */
    );
  }
  getAutoClosedCharacters() {
    return FM.getAllAutoClosedCharacters(this._autoClosedActions);
  }
  startComposition(e) {
    this._compositionState = new Yg(this._model, this.getSelections());
  }
  endComposition(e, t) {
    const i = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;
    this._compositionState = null, this._executeEdit(() => {
      t === "keyboard" && this._executeEditOperation(Mc.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, i, this.getSelections(), this.getAutoClosedCharacters()));
    }, e, t);
  }
  type(e, t, i) {
    this._executeEdit(() => {
      if (i === "keyboard") {
        const n = t.length;
        let o = 0;
        for (; o < n; ) {
          const r = uE(t, o), a = t.substr(o, r);
          this._executeEditOperation(Mc.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), a)), o += r;
        }
      } else
        this._executeEditOperation(Mc.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t));
    }, e, i);
  }
  compositionType(e, t, i, n, o, r) {
    if (t.length === 0 && i === 0 && n === 0) {
      if (o !== 0) {
        const a = this.getSelections().map((l) => {
          const c = l.getPosition();
          return new Ue(c.lineNumber, c.column + o, c.lineNumber, c.column + o);
        });
        this.setSelections(
          e,
          r,
          a,
          0
          /* CursorChangeReason.NotSet */
        );
      }
      return;
    }
    this._executeEdit(() => {
      this._executeEditOperation(Mc.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t, i, n, o));
    }, e, r);
  }
  paste(e, t, i, n, o) {
    this._executeEdit(
      () => {
        this._executeEditOperation(Mc.paste(this.context.cursorConfig, this._model, this.getSelections(), t, i, n || []));
      },
      e,
      o,
      4
      /* CursorChangeReason.Paste */
    );
  }
  cut(e, t) {
    this._executeEdit(() => {
      this._executeEditOperation(jh.cut(this.context.cursorConfig, this._model, this.getSelections()));
    }, e, t);
  }
  executeCommand(e, t, i) {
    this._executeEdit(() => {
      this._cursors.killSecondaryCursors(), this._executeEditOperation(new Pn(0, [t], {
        shouldPushStackElementBefore: !1,
        shouldPushStackElementAfter: !1
      }));
    }, e, i);
  }
  executeCommands(e, t, i) {
    this._executeEdit(() => {
      this._executeEditOperation(new Pn(0, t, {
        shouldPushStackElementBefore: !1,
        shouldPushStackElementAfter: !1
      }));
    }, e, i);
  }
}
class Zg {
  static from(e, t) {
    return new Zg(e.getVersionId(), t.getCursorStates());
  }
  constructor(e, t) {
    this.modelVersionId = e, this.cursorState = t;
  }
  equals(e) {
    if (!e || this.modelVersionId !== e.modelVersionId || this.cursorState.length !== e.cursorState.length)
      return !1;
    for (let t = 0, i = this.cursorState.length; t < i; t++)
      if (!this.cursorState[t].equals(e.cursorState[t]))
        return !1;
    return !0;
  }
}
class FM {
  static getAllAutoClosedCharacters(e) {
    let t = [];
    for (const i of e)
      t = t.concat(i.getAutoClosedCharactersRanges());
    return t;
  }
  constructor(e, t, i) {
    this._model = e, this._autoClosedCharactersDecorations = t, this._autoClosedEnclosingDecorations = i;
  }
  dispose() {
    this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []), this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);
  }
  getAutoClosedCharactersRanges() {
    const e = [];
    for (let t = 0; t < this._autoClosedCharactersDecorations.length; t++) {
      const i = this._model.getDecorationRange(this._autoClosedCharactersDecorations[t]);
      i && e.push(i);
    }
    return e;
  }
  isValid(e) {
    const t = [];
    for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {
      const n = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);
      if (n && (t.push(n), n.startLineNumber !== n.endLineNumber))
        return !1;
    }
    t.sort(T.compareRangesUsingStarts), e.sort(T.compareRangesUsingStarts);
    for (let i = 0; i < e.length; i++)
      if (i >= t.length || !t[i].strictContainsRange(e[i]))
        return !1;
    return !0;
  }
}
class rY {
  static executeCommands(e, t, i) {
    const n = {
      model: e,
      selectionsBefore: t,
      trackedRanges: [],
      trackedRangesDirection: []
    }, o = this._innerExecuteCommands(n, i);
    for (let r = 0, a = n.trackedRanges.length; r < a; r++)
      n.model._setTrackedRange(
        n.trackedRanges[r],
        null,
        0
        /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
      );
    return o;
  }
  static _innerExecuteCommands(e, t) {
    if (this._arrayIsEmpty(t))
      return null;
    const i = this._getEditOperations(e, t);
    if (i.operations.length === 0)
      return null;
    const n = i.operations, o = this._getLoserCursorMap(n);
    if (o.hasOwnProperty("0"))
      return console.warn("Ignoring commands"), null;
    const r = [];
    for (let c = 0, h = n.length; c < h; c++)
      o.hasOwnProperty(n[c].identifier.major.toString()) || r.push(n[c]);
    i.hadTrackedEditOperation && r.length > 0 && (r[0]._isTracked = !0);
    let a = e.model.pushEditOperations(e.selectionsBefore, r, (c) => {
      const h = [];
      for (let f = 0; f < e.selectionsBefore.length; f++)
        h[f] = [];
      for (const f of c)
        f.identifier && h[f.identifier.major].push(f);
      const d = (f, g) => f.identifier.minor - g.identifier.minor, u = [];
      for (let f = 0; f < e.selectionsBefore.length; f++)
        h[f].length > 0 ? (h[f].sort(d), u[f] = t[f].computeCursorState(e.model, {
          getInverseEditOperations: () => h[f],
          getTrackedSelection: (g) => {
            const p = parseInt(g, 10), _ = e.model._getTrackedRange(e.trackedRanges[p]);
            return e.trackedRangesDirection[p] === 0 ? new Ue(_.startLineNumber, _.startColumn, _.endLineNumber, _.endColumn) : new Ue(_.endLineNumber, _.endColumn, _.startLineNumber, _.startColumn);
          }
        })) : u[f] = e.selectionsBefore[f];
      return u;
    });
    a || (a = e.selectionsBefore);
    const l = [];
    for (const c in o)
      o.hasOwnProperty(c) && l.push(parseInt(c, 10));
    l.sort((c, h) => h - c);
    for (const c of l)
      a.splice(c, 1);
    return a;
  }
  static _arrayIsEmpty(e) {
    for (let t = 0, i = e.length; t < i; t++)
      if (e[t])
        return !1;
    return !0;
  }
  static _getEditOperations(e, t) {
    let i = [], n = !1;
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o];
      if (a) {
        const l = this._getEditOperationsFromCommand(e, o, a);
        i = i.concat(l.operations), n = n || l.hadTrackedEditOperation;
      }
    }
    return {
      operations: i,
      hadTrackedEditOperation: n
    };
  }
  static _getEditOperationsFromCommand(e, t, i) {
    const n = [];
    let o = 0;
    const r = (d, u, f = !1) => {
      T.isEmpty(d) && u === "" || n.push({
        identifier: {
          major: t,
          minor: o++
        },
        range: d,
        text: u,
        forceMoveMarkers: f,
        isAutoWhitespaceEdit: i.insertsAutoWhitespace
      });
    };
    let a = !1;
    const h = {
      addEditOperation: r,
      addTrackedEditOperation: (d, u, f) => {
        a = !0, r(d, u, f);
      },
      trackSelection: (d, u) => {
        const f = Ue.liftSelection(d);
        let g;
        if (f.isEmpty())
          if (typeof u == "boolean")
            u ? g = 2 : g = 3;
          else {
            const b = e.model.getLineMaxColumn(f.startLineNumber);
            f.startColumn === b ? g = 2 : g = 3;
          }
        else
          g = 1;
        const p = e.trackedRanges.length, _ = e.model._setTrackedRange(null, f, g);
        return e.trackedRanges[p] = _, e.trackedRangesDirection[p] = f.getDirection(), p.toString();
      }
    };
    try {
      i.getEditOperations(e.model, h);
    } catch (d) {
      return Je(d), {
        operations: [],
        hadTrackedEditOperation: !1
      };
    }
    return {
      operations: n,
      hadTrackedEditOperation: a
    };
  }
  static _getLoserCursorMap(e) {
    e = e.slice(0), e.sort((i, n) => -T.compareRangesUsingEnds(i.range, n.range));
    const t = {};
    for (let i = 1; i < e.length; i++) {
      const n = e[i - 1], o = e[i];
      if (T.getStartPosition(n.range).isBefore(T.getEndPosition(o.range))) {
        let r;
        n.identifier.major > o.identifier.major ? r = n.identifier.major : r = o.identifier.major, t[r.toString()] = !0;
        for (let a = 0; a < e.length; a++)
          e[a].identifier.major === r && (e.splice(a, 1), a < i && i--, a--);
        i > 0 && i--;
      }
    }
    return t;
  }
}
class aY {
  constructor(e, t, i) {
    this.text = e, this.startSelection = t, this.endSelection = i;
  }
}
class Yg {
  static _capture(e, t) {
    const i = [];
    for (const n of t) {
      if (n.startLineNumber !== n.endLineNumber)
        return null;
      i.push(new aY(e.getLineContent(n.startLineNumber), n.startColumn - 1, n.endColumn - 1));
    }
    return i;
  }
  constructor(e, t) {
    this._original = Yg._capture(e, t);
  }
  /**
   * Returns the inserted text during this composition.
   * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.
   */
  deduceOutcome(e, t) {
    if (!this._original)
      return null;
    const i = Yg._capture(e, t);
    if (!i || this._original.length !== i.length)
      return null;
    const n = [];
    for (let o = 0, r = this._original.length; o < r; o++)
      n.push(Yg._deduceOutcome(this._original[o], i[o]));
    return n;
  }
  static _deduceOutcome(e, t) {
    const i = Math.min(e.startSelection, t.startSelection, Vb(e.text, t.text)), n = Math.min(e.text.length - e.endSelection, t.text.length - t.endSelection, Vy(e.text, t.text)), o = e.text.substring(i, e.text.length - n), r = t.text.substring(i, t.text.length - n);
    return new qj(o, e.startSelection - i, e.endSelection - i, r, t.startSelection - i, t.endSelection - i);
  }
}
const BM = {
  getInitialState: () => ep,
  tokenizeEncoded: (s, e, t) => WI(0, t)
};
async function lY(s, e, t) {
  if (!t)
    return WM(e, s.languageIdCodec, BM);
  const i = await ii.getOrCreate(t);
  return WM(e, s.languageIdCodec, i || BM);
}
function cY(s, e, t, i, n, o, r) {
  let a = "<div>", l = i, c = 0, h = !0;
  for (let d = 0, u = e.getCount(); d < u; d++) {
    const f = e.getEndOffset(d);
    if (f <= i)
      continue;
    let g = "";
    for (; l < f && l < n; l++) {
      const p = s.charCodeAt(l);
      switch (p) {
        case 9: {
          let _ = o - (l + c) % o;
          for (c += _ - 1; _ > 0; )
            r && h ? (g += "&#160;", h = !1) : (g += " ", h = !0), _--;
          break;
        }
        case 60:
          g += "&lt;", h = !1;
          break;
        case 62:
          g += "&gt;", h = !1;
          break;
        case 38:
          g += "&amp;", h = !1;
          break;
        case 0:
          g += "&#00;", h = !1;
          break;
        case 65279:
        case 8232:
        case 8233:
        case 133:
          g += "�", h = !1;
          break;
        case 13:
          g += "&#8203", h = !1;
          break;
        case 32:
          r && h ? (g += "&#160;", h = !1) : (g += " ", h = !0);
          break;
        default:
          g += String.fromCharCode(p), h = !1;
      }
    }
    if (a += `<span style="${e.getInlineStyle(d, t)}">${g}</span>`, f > n || l >= n)
      break;
  }
  return a += "</div>", a;
}
function WM(s, e, t) {
  let i = '<div class="monaco-tokenized-source">';
  const n = td(s);
  let o = t.getInitialState();
  for (let r = 0, a = n.length; r < a; r++) {
    const l = n[r];
    r > 0 && (i += "<br/>");
    const c = t.tokenizeEncoded(l, !0, o);
    Ti.convertToEndOffset(c.tokens, l.length);
    const d = new Ti(c.tokens, l, e).inflate();
    let u = 0;
    for (let f = 0, g = d.getCount(); f < g; f++) {
      const p = d.getClassName(f), _ = d.getEndOffset(f);
      i += `<span class="${p}">${Ng(l.substring(u, _))}</span>`, u = _;
    }
    o = c.endState;
  }
  return i += "</div>", i;
}
class hY {
  constructor() {
    this._hasPending = !1, this._inserts = [], this._changes = [], this._removes = [];
  }
  insert(e) {
    this._hasPending = !0, this._inserts.push(e);
  }
  change(e) {
    this._hasPending = !0, this._changes.push(e);
  }
  remove(e) {
    this._hasPending = !0, this._removes.push(e);
  }
  mustCommit() {
    return this._hasPending;
  }
  commit(e) {
    if (!this._hasPending)
      return;
    const t = this._inserts, i = this._changes, n = this._removes;
    this._hasPending = !1, this._inserts = [], this._changes = [], this._removes = [], e._commitPendingChanges(t, i, n);
  }
}
class dY {
  constructor(e, t, i, n, o) {
    this.id = e, this.afterLineNumber = t, this.ordinal = i, this.height = n, this.minWidth = o, this.prefixSum = 0;
  }
}
var Pl;
let uY = (Pl = class {
  constructor(e, t, i, n) {
    this._instanceId = f4(++Pl.INSTANCE_COUNT), this._pendingChanges = new hY(), this._lastWhitespaceId = 0, this._arr = [], this._prefixSumValidIndex = -1, this._minWidth = -1, this._lineCount = e, this._lineHeight = t, this._paddingTop = i, this._paddingBottom = n;
  }
  /**
   * Find the insertion index for a new value inside a sorted array of values.
   * If the value is already present in the sorted array, the insertion index will be after the already existing value.
   */
  static findInsertionIndex(e, t, i) {
    let n = 0, o = e.length;
    for (; n < o; ) {
      const r = n + o >>> 1;
      t === e[r].afterLineNumber ? i < e[r].ordinal ? o = r : n = r + 1 : t < e[r].afterLineNumber ? o = r : n = r + 1;
    }
    return n;
  }
  /**
   * Change the height of a line in pixels.
   */
  setLineHeight(e) {
    this._checkPendingChanges(), this._lineHeight = e;
  }
  /**
   * Changes the padding used to calculate vertical offsets.
   */
  setPadding(e, t) {
    this._paddingTop = e, this._paddingBottom = t;
  }
  /**
   * Set the number of lines.
   *
   * @param lineCount New number of lines.
   */
  onFlushed(e) {
    this._checkPendingChanges(), this._lineCount = e;
  }
  changeWhitespace(e) {
    let t = !1;
    try {
      e({
        insertWhitespace: (n, o, r, a) => {
          t = !0, n = n | 0, o = o | 0, r = r | 0, a = a | 0;
          const l = this._instanceId + ++this._lastWhitespaceId;
          return this._pendingChanges.insert(new dY(l, n, o, r, a)), l;
        },
        changeOneWhitespace: (n, o, r) => {
          t = !0, o = o | 0, r = r | 0, this._pendingChanges.change({ id: n, newAfterLineNumber: o, newHeight: r });
        },
        removeWhitespace: (n) => {
          t = !0, this._pendingChanges.remove({ id: n });
        }
      });
    } finally {
      this._pendingChanges.commit(this);
    }
    return t;
  }
  _commitPendingChanges(e, t, i) {
    if ((e.length > 0 || i.length > 0) && (this._minWidth = -1), e.length + t.length + i.length <= 1) {
      for (const l of e)
        this._insertWhitespace(l);
      for (const l of t)
        this._changeOneWhitespace(l.id, l.newAfterLineNumber, l.newHeight);
      for (const l of i) {
        const c = this._findWhitespaceIndex(l.id);
        c !== -1 && this._removeWhitespace(c);
      }
      return;
    }
    const n = /* @__PURE__ */ new Set();
    for (const l of i)
      n.add(l.id);
    const o = /* @__PURE__ */ new Map();
    for (const l of t)
      o.set(l.id, l);
    const r = (l) => {
      const c = [];
      for (const h of l)
        if (!n.has(h.id)) {
          if (o.has(h.id)) {
            const d = o.get(h.id);
            h.afterLineNumber = d.newAfterLineNumber, h.height = d.newHeight;
          }
          c.push(h);
        }
      return c;
    }, a = r(this._arr).concat(r(e));
    a.sort((l, c) => l.afterLineNumber === c.afterLineNumber ? l.ordinal - c.ordinal : l.afterLineNumber - c.afterLineNumber), this._arr = a, this._prefixSumValidIndex = -1;
  }
  _checkPendingChanges() {
    this._pendingChanges.mustCommit() && this._pendingChanges.commit(this);
  }
  _insertWhitespace(e) {
    const t = Pl.findInsertionIndex(this._arr, e.afterLineNumber, e.ordinal);
    this._arr.splice(t, 0, e), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, t - 1);
  }
  _findWhitespaceIndex(e) {
    const t = this._arr;
    for (let i = 0, n = t.length; i < n; i++)
      if (t[i].id === e)
        return i;
    return -1;
  }
  _changeOneWhitespace(e, t, i) {
    const n = this._findWhitespaceIndex(e);
    if (n !== -1 && (this._arr[n].height !== i && (this._arr[n].height = i, this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, n - 1)), this._arr[n].afterLineNumber !== t)) {
      const o = this._arr[n];
      this._removeWhitespace(n), o.afterLineNumber = t, this._insertWhitespace(o);
    }
  }
  _removeWhitespace(e) {
    this._arr.splice(e, 1), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, e - 1);
  }
  /**
   * Notify the layouter that lines have been deleted (a continuous zone of lines).
   *
   * @param fromLineNumber The line number at which the deletion started, inclusive
   * @param toLineNumber The line number at which the deletion ended, inclusive
   */
  onLinesDeleted(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount -= t - e + 1;
    for (let i = 0, n = this._arr.length; i < n; i++) {
      const o = this._arr[i].afterLineNumber;
      e <= o && o <= t ? this._arr[i].afterLineNumber = e - 1 : o > t && (this._arr[i].afterLineNumber -= t - e + 1);
    }
  }
  /**
   * Notify the layouter that lines have been inserted (a continuous zone of lines).
   *
   * @param fromLineNumber The line number at which the insertion started, inclusive
   * @param toLineNumber The line number at which the insertion ended, inclusive.
   */
  onLinesInserted(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount += t - e + 1;
    for (let i = 0, n = this._arr.length; i < n; i++) {
      const o = this._arr[i].afterLineNumber;
      e <= o && (this._arr[i].afterLineNumber += t - e + 1);
    }
  }
  /**
   * Get the sum of all the whitespaces.
   */
  getWhitespacesTotalHeight() {
    return this._checkPendingChanges(), this._arr.length === 0 ? 0 : this.getWhitespacesAccumulatedHeight(this._arr.length - 1);
  }
  /**
   * Return the sum of the heights of the whitespaces at [0..index].
   * This includes the whitespace at `index`.
   *
   * @param index The index of the whitespace.
   * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.
   */
  getWhitespacesAccumulatedHeight(e) {
    this._checkPendingChanges(), e = e | 0;
    let t = Math.max(0, this._prefixSumValidIndex + 1);
    t === 0 && (this._arr[0].prefixSum = this._arr[0].height, t++);
    for (let i = t; i <= e; i++)
      this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;
    return this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, e), this._arr[e].prefixSum;
  }
  /**
   * Get the sum of heights for all objects.
   *
   * @return The sum of heights for all objects.
   */
  getLinesTotalHeight() {
    this._checkPendingChanges();
    const e = this._lineHeight * this._lineCount, t = this.getWhitespacesTotalHeight();
    return e + t + this._paddingTop + this._paddingBottom;
  }
  /**
   * Returns the accumulated height of whitespaces before the given line number.
   *
   * @param lineNumber The line number
   */
  getWhitespaceAccumulatedHeightBeforeLineNumber(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this._findLastWhitespaceBeforeLineNumber(e);
    return t === -1 ? 0 : this.getWhitespacesAccumulatedHeight(t);
  }
  _findLastWhitespaceBeforeLineNumber(e) {
    e = e | 0;
    const t = this._arr;
    let i = 0, n = t.length - 1;
    for (; i <= n; ) {
      const r = (n - i | 0) / 2 | 0, a = i + r | 0;
      if (t[a].afterLineNumber < e) {
        if (a + 1 >= t.length || t[a + 1].afterLineNumber >= e)
          return a;
        i = a + 1 | 0;
      } else
        n = a - 1 | 0;
    }
    return -1;
  }
  _findFirstWhitespaceAfterLineNumber(e) {
    e = e | 0;
    const i = this._findLastWhitespaceBeforeLineNumber(e) + 1;
    return i < this._arr.length ? i : -1;
  }
  /**
   * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.
   * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.
   */
  getFirstWhitespaceIndexAfterLineNumber(e) {
    return this._checkPendingChanges(), e = e | 0, this._findFirstWhitespaceAfterLineNumber(e);
  }
  /**
   * Get the vertical offset (the sum of heights for all objects above) a certain line number.
   *
   * @param lineNumber The line number
   * @return The sum of heights for all objects above `lineNumber`.
   */
  getVerticalOffsetForLineNumber(e, t = !1) {
    this._checkPendingChanges(), e = e | 0;
    let i;
    e > 1 ? i = this._lineHeight * (e - 1) : i = 0;
    const n = this.getWhitespaceAccumulatedHeightBeforeLineNumber(e - (t ? 1 : 0));
    return i + n + this._paddingTop;
  }
  /**
   * Get the vertical offset (the sum of heights for all objects above) a certain line number.
   *
   * @param lineNumber The line number
   * @return The sum of heights for all objects above `lineNumber`.
   */
  getVerticalOffsetAfterLineNumber(e, t = !1) {
    this._checkPendingChanges(), e = e | 0;
    const i = this._lineHeight * e, n = this.getWhitespaceAccumulatedHeightBeforeLineNumber(e + (t ? 1 : 0));
    return i + n + this._paddingTop;
  }
  /**
   * The maximum min width for all whitespaces.
   */
  getWhitespaceMinWidth() {
    if (this._checkPendingChanges(), this._minWidth === -1) {
      let e = 0;
      for (let t = 0, i = this._arr.length; t < i; t++)
        e = Math.max(e, this._arr[t].minWidth);
      this._minWidth = e;
    }
    return this._minWidth;
  }
  /**
   * Check if `verticalOffset` is below all lines.
   */
  isAfterLines(e) {
    this._checkPendingChanges();
    const t = this.getLinesTotalHeight();
    return e > t;
  }
  isInTopPadding(e) {
    return this._paddingTop === 0 ? !1 : (this._checkPendingChanges(), e < this._paddingTop);
  }
  isInBottomPadding(e) {
    if (this._paddingBottom === 0)
      return !1;
    this._checkPendingChanges();
    const t = this.getLinesTotalHeight();
    return e >= t - this._paddingBottom;
  }
  /**
   * Find the first line number that is at or after vertical offset `verticalOffset`.
   * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then
   * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.
   *
   * @param verticalOffset The vertical offset to search at.
   * @return The line number at or after vertical offset `verticalOffset`.
   */
  getLineNumberAtOrAfterVerticalOffset(e) {
    if (this._checkPendingChanges(), e = e | 0, e < 0)
      return 1;
    const t = this._lineCount | 0, i = this._lineHeight;
    let n = 1, o = t;
    for (; n < o; ) {
      const r = (n + o) / 2 | 0, a = this.getVerticalOffsetForLineNumber(r) | 0;
      if (e >= a + i)
        n = r + 1;
      else {
        if (e >= a)
          return r;
        o = r;
      }
    }
    return n > t ? t : n;
  }
  /**
   * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.
   *
   * @param verticalOffset1 The beginning of the viewport.
   * @param verticalOffset2 The end of the viewport.
   * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.
   */
  getLinesViewportData(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0;
    const i = this._lineHeight, n = this.getLineNumberAtOrAfterVerticalOffset(e) | 0, o = this.getVerticalOffsetForLineNumber(n) | 0;
    let r = this._lineCount | 0, a = this.getFirstWhitespaceIndexAfterLineNumber(n) | 0;
    const l = this.getWhitespacesCount() | 0;
    let c, h;
    a === -1 ? (a = l, h = r + 1, c = 0) : (h = this.getAfterLineNumberForWhitespaceIndex(a) | 0, c = this.getHeightForWhitespaceIndex(a) | 0);
    let d = o, u = d;
    const f = 5e5;
    let g = 0;
    o >= f && (g = Math.floor(o / f) * f, g = Math.floor(g / i) * i, u -= g);
    const p = [], _ = e + (t - e) / 2;
    let b = -1;
    for (let S = n; S <= r; S++) {
      if (b === -1) {
        const L = d, k = d + i;
        (L <= _ && _ < k || L > _) && (b = S);
      }
      for (d += i, p[S - n] = u, u += i; h === S; )
        u += c, d += c, a++, a >= l ? h = r + 1 : (h = this.getAfterLineNumberForWhitespaceIndex(a) | 0, c = this.getHeightForWhitespaceIndex(a) | 0);
      if (d >= t) {
        r = S;
        break;
      }
    }
    b === -1 && (b = r);
    const C = this.getVerticalOffsetForLineNumber(r) | 0;
    let w = n, v = r;
    return w < v && o < e && w++, w < v && C + i > t && v--, {
      bigNumbersDelta: g,
      startLineNumber: n,
      endLineNumber: r,
      relativeVerticalOffset: p,
      centeredLineNumber: b,
      completelyVisibleStartLineNumber: w,
      completelyVisibleEndLineNumber: v,
      lineHeight: this._lineHeight
    };
  }
  getVerticalOffsetForWhitespaceIndex(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this.getAfterLineNumberForWhitespaceIndex(e);
    let i;
    t >= 1 ? i = this._lineHeight * t : i = 0;
    let n;
    return e > 0 ? n = this.getWhitespacesAccumulatedHeight(e - 1) : n = 0, i + n + this._paddingTop;
  }
  getWhitespaceIndexAtOrAfterVerticallOffset(e) {
    this._checkPendingChanges(), e = e | 0;
    let t = 0, i = this.getWhitespacesCount() - 1;
    if (i < 0)
      return -1;
    const n = this.getVerticalOffsetForWhitespaceIndex(i), o = this.getHeightForWhitespaceIndex(i);
    if (e >= n + o)
      return -1;
    for (; t < i; ) {
      const r = Math.floor((t + i) / 2), a = this.getVerticalOffsetForWhitespaceIndex(r), l = this.getHeightForWhitespaceIndex(r);
      if (e >= a + l)
        t = r + 1;
      else {
        if (e >= a)
          return r;
        i = r;
      }
    }
    return t;
  }
  /**
   * Get exactly the whitespace that is layouted at `verticalOffset`.
   *
   * @param verticalOffset The vertical offset.
   * @return Precisely the whitespace that is layouted at `verticaloffset` or null.
   */
  getWhitespaceAtVerticalOffset(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this.getWhitespaceIndexAtOrAfterVerticallOffset(e);
    if (t < 0 || t >= this.getWhitespacesCount())
      return null;
    const i = this.getVerticalOffsetForWhitespaceIndex(t);
    if (i > e)
      return null;
    const n = this.getHeightForWhitespaceIndex(t), o = this.getIdForWhitespaceIndex(t), r = this.getAfterLineNumberForWhitespaceIndex(t);
    return {
      id: o,
      afterLineNumber: r,
      verticalOffset: i,
      height: n
    };
  }
  /**
   * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.
   *
   * @param verticalOffset1 The beginning of the viewport.
   * @param verticalOffset2 The end of the viewport.
   * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.
   */
  getWhitespaceViewportData(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0;
    const i = this.getWhitespaceIndexAtOrAfterVerticallOffset(e), n = this.getWhitespacesCount() - 1;
    if (i < 0)
      return [];
    const o = [];
    for (let r = i; r <= n; r++) {
      const a = this.getVerticalOffsetForWhitespaceIndex(r), l = this.getHeightForWhitespaceIndex(r);
      if (a >= t)
        break;
      o.push({
        id: this.getIdForWhitespaceIndex(r),
        afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(r),
        verticalOffset: a,
        height: l
      });
    }
    return o;
  }
  /**
   * Get all whitespaces.
   */
  getWhitespaces() {
    return this._checkPendingChanges(), this._arr.slice(0);
  }
  /**
   * The number of whitespaces.
   */
  getWhitespacesCount() {
    return this._checkPendingChanges(), this._arr.length;
  }
  /**
   * Get the `id` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `id` of whitespace at `index`.
   */
  getIdForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].id;
  }
  /**
   * Get the `afterLineNumber` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `afterLineNumber` of whitespace at `index`.
   */
  getAfterLineNumberForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].afterLineNumber;
  }
  /**
   * Get the `height` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `height` of whitespace at `index`.
   */
  getHeightForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].height;
  }
}, Pl.INSTANCE_COUNT = 0, Pl);
const fY = 125;
class Sg {
  constructor(e, t, i, n) {
    e = e | 0, t = t | 0, i = i | 0, n = n | 0, e < 0 && (e = 0), t < 0 && (t = 0), i < 0 && (i = 0), n < 0 && (n = 0), this.width = e, this.contentWidth = t, this.scrollWidth = Math.max(e, t), this.height = i, this.contentHeight = n, this.scrollHeight = Math.max(i, n);
  }
  equals(e) {
    return this.width === e.width && this.contentWidth === e.contentWidth && this.height === e.height && this.contentHeight === e.contentHeight;
  }
}
class gY extends U {
  constructor(e, t) {
    super(), this._onDidContentSizeChange = this._register(new A()), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._dimensions = new Sg(0, 0, 0, 0), this._scrollable = this._register(new Pf({
      forceIntegerValues: !0,
      smoothScrollDuration: e,
      scheduleAtNextAnimationFrame: t
    })), this.onDidScroll = this._scrollable.onScroll;
  }
  getScrollable() {
    return this._scrollable;
  }
  setSmoothScrollDuration(e) {
    this._scrollable.setSmoothScrollDuration(e);
  }
  validateScrollPosition(e) {
    return this._scrollable.validateScrollPosition(e);
  }
  getScrollDimensions() {
    return this._dimensions;
  }
  setScrollDimensions(e) {
    if (this._dimensions.equals(e))
      return;
    const t = this._dimensions;
    this._dimensions = e, this._scrollable.setScrollDimensions({
      width: e.width,
      scrollWidth: e.scrollWidth,
      height: e.height,
      scrollHeight: e.scrollHeight
    }, !0);
    const i = t.contentWidth !== e.contentWidth, n = t.contentHeight !== e.contentHeight;
    (i || n) && this._onDidContentSizeChange.fire(new UI(t.contentWidth, t.contentHeight, e.contentWidth, e.contentHeight));
  }
  getFutureScrollPosition() {
    return this._scrollable.getFutureScrollPosition();
  }
  getCurrentScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
  setScrollPositionNow(e) {
    this._scrollable.setScrollPositionNow(e);
  }
  setScrollPositionSmooth(e) {
    this._scrollable.setScrollPositionSmooth(e);
  }
  hasPendingScrollAnimation() {
    return this._scrollable.hasPendingScrollAnimation();
  }
}
class mY extends U {
  constructor(e, t, i) {
    super(), this._configuration = e;
    const n = this._configuration.options, o = n.get(
      146
      /* EditorOption.layoutInfo */
    ), r = n.get(
      84
      /* EditorOption.padding */
    );
    this._linesLayout = new uY(t, n.get(
      67
      /* EditorOption.lineHeight */
    ), r.top, r.bottom), this._maxLineWidth = 0, this._overlayWidgetsMinWidth = 0, this._scrollable = this._register(new gY(0, i)), this._configureSmoothScrollDuration(), this._scrollable.setScrollDimensions(new Sg(o.contentWidth, 0, o.height, 0)), this.onDidScroll = this._scrollable.onDidScroll, this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange, this._updateHeight();
  }
  dispose() {
    super.dispose();
  }
  getScrollable() {
    return this._scrollable.getScrollable();
  }
  onHeightMaybeChanged() {
    this._updateHeight();
  }
  _configureSmoothScrollDuration() {
    this._scrollable.setSmoothScrollDuration(this._configuration.options.get(
      115
      /* EditorOption.smoothScrolling */
    ) ? fY : 0);
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const t = this._configuration.options;
    if (e.hasChanged(
      67
      /* EditorOption.lineHeight */
    ) && this._linesLayout.setLineHeight(t.get(
      67
      /* EditorOption.lineHeight */
    )), e.hasChanged(
      84
      /* EditorOption.padding */
    )) {
      const i = t.get(
        84
        /* EditorOption.padding */
      );
      this._linesLayout.setPadding(i.top, i.bottom);
    }
    if (e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    )) {
      const i = t.get(
        146
        /* EditorOption.layoutInfo */
      ), n = i.contentWidth, o = i.height, r = this._scrollable.getScrollDimensions(), a = r.contentWidth;
      this._scrollable.setScrollDimensions(new Sg(n, r.contentWidth, o, this._getContentHeight(n, o, a)));
    } else
      this._updateHeight();
    e.hasChanged(
      115
      /* EditorOption.smoothScrolling */
    ) && this._configureSmoothScrollDuration();
  }
  onFlushed(e) {
    this._linesLayout.onFlushed(e);
  }
  onLinesDeleted(e, t) {
    this._linesLayout.onLinesDeleted(e, t);
  }
  onLinesInserted(e, t) {
    this._linesLayout.onLinesInserted(e, t);
  }
  // ---- end view event handlers
  _getHorizontalScrollbarHeight(e, t) {
    const n = this._configuration.options.get(
      104
      /* EditorOption.scrollbar */
    );
    return n.horizontal === 2 || e >= t ? 0 : n.horizontalScrollbarSize;
  }
  _getContentHeight(e, t, i) {
    const n = this._configuration.options;
    let o = this._linesLayout.getLinesTotalHeight();
    return n.get(
      106
      /* EditorOption.scrollBeyondLastLine */
    ) ? o += Math.max(0, t - n.get(
      67
      /* EditorOption.lineHeight */
    ) - n.get(
      84
      /* EditorOption.padding */
    ).bottom) : n.get(
      104
      /* EditorOption.scrollbar */
    ).ignoreHorizontalScrollbarInContentHeight || (o += this._getHorizontalScrollbarHeight(e, i)), o;
  }
  _updateHeight() {
    const e = this._scrollable.getScrollDimensions(), t = e.width, i = e.height, n = e.contentWidth;
    this._scrollable.setScrollDimensions(new Sg(t, e.contentWidth, i, this._getContentHeight(t, i, n)));
  }
  // ---- Layouting logic
  getCurrentViewport() {
    const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getCurrentScrollPosition();
    return new eM(t.scrollTop, t.scrollLeft, e.width, e.height);
  }
  getFutureViewport() {
    const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getFutureScrollPosition();
    return new eM(t.scrollTop, t.scrollLeft, e.width, e.height);
  }
  _computeContentWidth() {
    const e = this._configuration.options, t = this._maxLineWidth, i = e.get(
      147
      /* EditorOption.wrappingInfo */
    ), n = e.get(
      50
      /* EditorOption.fontInfo */
    ), o = e.get(
      146
      /* EditorOption.layoutInfo */
    );
    if (i.isViewportWrapping) {
      const r = e.get(
        73
        /* EditorOption.minimap */
      );
      return t > o.contentWidth + n.typicalHalfwidthCharacterWidth && r.enabled && r.side === "right" ? t + o.verticalScrollbarWidth : t;
    } else {
      const r = e.get(
        105
        /* EditorOption.scrollBeyondLastColumn */
      ) * n.typicalHalfwidthCharacterWidth, a = this._linesLayout.getWhitespaceMinWidth();
      return Math.max(t + r + o.verticalScrollbarWidth, a, this._overlayWidgetsMinWidth);
    }
  }
  setMaxLineWidth(e) {
    this._maxLineWidth = e, this._updateContentWidth();
  }
  setOverlayWidgetsMinWidth(e) {
    this._overlayWidgetsMinWidth = e, this._updateContentWidth();
  }
  _updateContentWidth() {
    const e = this._scrollable.getScrollDimensions();
    this._scrollable.setScrollDimensions(new Sg(e.width, this._computeContentWidth(), e.height, e.contentHeight)), this._updateHeight();
  }
  // ---- view state
  saveState() {
    const e = this._scrollable.getFutureScrollPosition(), t = e.scrollTop, i = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(t), n = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(i);
    return {
      scrollTop: t,
      scrollTopWithoutViewZones: t - n,
      scrollLeft: e.scrollLeft
    };
  }
  // ----
  changeWhitespace(e) {
    const t = this._linesLayout.changeWhitespace(e);
    return t && this.onHeightMaybeChanged(), t;
  }
  getVerticalOffsetForLineNumber(e, t = !1) {
    return this._linesLayout.getVerticalOffsetForLineNumber(e, t);
  }
  getVerticalOffsetAfterLineNumber(e, t = !1) {
    return this._linesLayout.getVerticalOffsetAfterLineNumber(e, t);
  }
  isAfterLines(e) {
    return this._linesLayout.isAfterLines(e);
  }
  isInTopPadding(e) {
    return this._linesLayout.isInTopPadding(e);
  }
  isInBottomPadding(e) {
    return this._linesLayout.isInBottomPadding(e);
  }
  getLineNumberAtVerticalOffset(e) {
    return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(e);
  }
  getWhitespaceAtVerticalOffset(e) {
    return this._linesLayout.getWhitespaceAtVerticalOffset(e);
  }
  getLinesViewportData() {
    const e = this.getCurrentViewport();
    return this._linesLayout.getLinesViewportData(e.top, e.top + e.height);
  }
  getLinesViewportDataAtScrollTop(e) {
    const t = this._scrollable.getScrollDimensions();
    return e + t.height > t.scrollHeight && (e = t.scrollHeight - t.height), e < 0 && (e = 0), this._linesLayout.getLinesViewportData(e, e + t.height);
  }
  getWhitespaceViewportData() {
    const e = this.getCurrentViewport();
    return this._linesLayout.getWhitespaceViewportData(e.top, e.top + e.height);
  }
  getWhitespaces() {
    return this._linesLayout.getWhitespaces();
  }
  // ----
  getContentWidth() {
    return this._scrollable.getScrollDimensions().contentWidth;
  }
  getScrollWidth() {
    return this._scrollable.getScrollDimensions().scrollWidth;
  }
  getContentHeight() {
    return this._scrollable.getScrollDimensions().contentHeight;
  }
  getScrollHeight() {
    return this._scrollable.getScrollDimensions().scrollHeight;
  }
  getCurrentScrollLeft() {
    return this._scrollable.getCurrentScrollPosition().scrollLeft;
  }
  getCurrentScrollTop() {
    return this._scrollable.getCurrentScrollPosition().scrollTop;
  }
  validateScrollPosition(e) {
    return this._scrollable.validateScrollPosition(e);
  }
  setScrollPosition(e, t) {
    t === 1 ? this._scrollable.setScrollPositionNow(e) : this._scrollable.setScrollPositionSmooth(e);
  }
  hasPendingScrollAnimation() {
    return this._scrollable.hasPendingScrollAnimation();
  }
  deltaScrollNow(e, t) {
    const i = this._scrollable.getCurrentScrollPosition();
    this._scrollable.setScrollPositionNow({
      scrollLeft: i.scrollLeft + e,
      scrollTop: i.scrollTop + t
    });
  }
}
class pY {
  constructor(e, t, i, n, o) {
    this.editorId = e, this.model = t, this.configuration = i, this._linesCollection = n, this._coordinatesConverter = o, this._decorationsCache = /* @__PURE__ */ Object.create(null), this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
  }
  _clearCachedModelDecorationsResolver() {
    this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
  }
  dispose() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  reset() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  onModelDecorationsChanged() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  onLineMappingChanged() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  _getOrCreateViewModelDecoration(e) {
    const t = e.id;
    let i = this._decorationsCache[t];
    if (!i) {
      const n = e.range, o = e.options;
      let r;
      if (o.isWholeLine) {
        const a = this._coordinatesConverter.convertModelPositionToViewPosition(new F(n.startLineNumber, 1), 0, !1, !0), l = this._coordinatesConverter.convertModelPositionToViewPosition(
          new F(n.endLineNumber, this.model.getLineMaxColumn(n.endLineNumber)),
          1
          /* PositionAffinity.Right */
        );
        r = new T(a.lineNumber, a.column, l.lineNumber, l.column);
      } else
        r = this._coordinatesConverter.convertModelRangeToViewRange(
          n,
          1
          /* PositionAffinity.Right */
        );
      i = new eF(r, o), this._decorationsCache[t] = i;
    }
    return i;
  }
  getMinimapDecorationsInRange(e) {
    return this._getDecorationsInRange(e, !0, !1).decorations;
  }
  getDecorationsViewportData(e) {
    let t = this._cachedModelDecorationsResolver !== null;
    return t = t && e.equalsRange(this._cachedModelDecorationsResolverViewRange), t || (this._cachedModelDecorationsResolver = this._getDecorationsInRange(e, !1, !1), this._cachedModelDecorationsResolverViewRange = e), this._cachedModelDecorationsResolver;
  }
  getInlineDecorationsOnLine(e, t = !1, i = !1) {
    const n = new T(e, this._linesCollection.getViewLineMinColumn(e), e, this._linesCollection.getViewLineMaxColumn(e));
    return this._getDecorationsInRange(n, t, i).inlineDecorations[0];
  }
  _getDecorationsInRange(e, t, i) {
    const n = this._linesCollection.getDecorationsInRange(e, this.editorId, r1(this.configuration.options), t, i), o = e.startLineNumber, r = e.endLineNumber, a = [];
    let l = 0;
    const c = [];
    for (let h = o; h <= r; h++)
      c[h - o] = [];
    for (let h = 0, d = n.length; h < d; h++) {
      const u = n[h], f = u.options;
      if (!_Y(this.model, u))
        continue;
      const g = this._getOrCreateViewModelDecoration(u), p = g.range;
      if (a[l++] = g, f.inlineClassName) {
        const _ = new Wg(
          p,
          f.inlineClassName,
          f.inlineClassNameAffectsLetterSpacing ? 3 : 0
          /* InlineDecorationType.Regular */
        ), b = Math.max(o, p.startLineNumber), C = Math.min(r, p.endLineNumber);
        for (let w = b; w <= C; w++)
          c[w - o].push(_);
      }
      if (f.beforeContentClassName && o <= p.startLineNumber && p.startLineNumber <= r) {
        const _ = new Wg(
          new T(p.startLineNumber, p.startColumn, p.startLineNumber, p.startColumn),
          f.beforeContentClassName,
          1
          /* InlineDecorationType.Before */
        );
        c[p.startLineNumber - o].push(_);
      }
      if (f.afterContentClassName && o <= p.endLineNumber && p.endLineNumber <= r) {
        const _ = new Wg(
          new T(p.endLineNumber, p.endColumn, p.endLineNumber, p.endColumn),
          f.afterContentClassName,
          2
          /* InlineDecorationType.After */
        );
        c[p.endLineNumber - o].push(_);
      }
    }
    return {
      decorations: a,
      inlineDecorations: c
    };
  }
}
function _Y(s, e) {
  return !(e.options.hideInCommentTokens && bY(s, e) || e.options.hideInStringTokens && CY(s, e));
}
function bY(s, e) {
  return LF(
    s,
    e.range,
    (t) => t === 1
    /* StandardTokenType.Comment */
  );
}
function CY(s, e) {
  return LF(
    s,
    e.range,
    (t) => t === 2
    /* StandardTokenType.String */
  );
}
function LF(s, e, t) {
  for (let i = e.startLineNumber; i <= e.endLineNumber; i++) {
    const n = s.tokenization.getLineTokens(i), o = i === e.startLineNumber, r = i === e.endLineNumber;
    let a = o ? n.findTokenIndexAtOffset(e.startColumn - 1) : 0;
    for (; a < n.getCount() && !(r && n.getStartOffset(a) > e.endColumn - 1); ) {
      if (!t(n.getStandardTokenType(a)))
        return !1;
      a++;
    }
  }
  return !0;
}
function J0(s, e) {
  return s === null ? e ? A1.INSTANCE : P1.INSTANCE : new vY(s, e);
}
class vY {
  constructor(e, t) {
    this._projectionData = e, this._isVisible = t;
  }
  isVisible() {
    return this._isVisible;
  }
  setVisible(e) {
    return this._isVisible = e, this;
  }
  getProjectionData() {
    return this._projectionData;
  }
  getViewLineCount() {
    return this._isVisible ? this._projectionData.getOutputLineCount() : 0;
  }
  getViewLineContent(e, t, i) {
    this._assertVisible();
    const n = i > 0 ? this._projectionData.breakOffsets[i - 1] : 0, o = this._projectionData.breakOffsets[i];
    let r;
    if (this._projectionData.injectionOffsets !== null) {
      const a = this._projectionData.injectionOffsets.map((c, h) => new Zo(0, 0, c + 1, this._projectionData.injectionOptions[h], 0));
      r = Zo.applyInjectedText(e.getLineContent(t), a).substring(n, o);
    } else
      r = e.getValueInRange({
        startLineNumber: t,
        startColumn: n + 1,
        endLineNumber: t,
        endColumn: o + 1
      });
    return i > 0 && (r = HM(this._projectionData.wrappedTextIndentLength) + r), r;
  }
  getViewLineLength(e, t, i) {
    return this._assertVisible(), this._projectionData.getLineLength(i);
  }
  getViewLineMinColumn(e, t, i) {
    return this._assertVisible(), this._projectionData.getMinOutputOffset(i) + 1;
  }
  getViewLineMaxColumn(e, t, i) {
    return this._assertVisible(), this._projectionData.getMaxOutputOffset(i) + 1;
  }
  /**
   * Try using {@link getViewLinesData} instead.
  */
  getViewLineData(e, t, i) {
    const n = new Array();
    return this.getViewLinesData(e, t, i, 1, 0, [!0], n), n[0];
  }
  getViewLinesData(e, t, i, n, o, r, a) {
    this._assertVisible();
    const l = this._projectionData, c = l.injectionOffsets, h = l.injectionOptions;
    let d = null;
    if (c) {
      d = [];
      let f = 0, g = 0;
      for (let p = 0; p < l.getOutputLineCount(); p++) {
        const _ = new Array();
        d[p] = _;
        const b = p > 0 ? l.breakOffsets[p - 1] : 0, C = l.breakOffsets[p];
        for (; g < c.length; ) {
          const w = h[g].content.length, v = c[g] + f, S = v + w;
          if (v > C)
            break;
          if (b < S) {
            const L = h[g];
            if (L.inlineClassName) {
              const k = p > 0 ? l.wrappedTextIndentLength : 0, x = k + Math.max(v - b, 0), I = k + Math.min(S - b, C - b);
              x !== I && _.push(new Iq(x, I, L.inlineClassName, L.inlineClassNameAffectsLetterSpacing));
            }
          }
          if (S <= C)
            f += w, g++;
          else
            break;
        }
      }
    }
    let u;
    c ? u = e.tokenization.getLineTokens(t).withInserted(c.map((f, g) => ({
      offset: f,
      text: h[g].content,
      tokenMetadata: Ti.defaultTokenMetadata
    }))) : u = e.tokenization.getLineTokens(t);
    for (let f = i; f < i + n; f++) {
      const g = o + f - i;
      if (!r[g]) {
        a[g] = null;
        continue;
      }
      a[g] = this._getViewLineData(u, d ? d[f] : null, f);
    }
  }
  _getViewLineData(e, t, i) {
    this._assertVisible();
    const n = this._projectionData, o = i > 0 ? n.wrappedTextIndentLength : 0, r = i > 0 ? n.breakOffsets[i - 1] : 0, a = n.breakOffsets[i], l = e.sliceAndInflate(r, a, o);
    let c = l.getLineContent();
    i > 0 && (c = HM(n.wrappedTextIndentLength) + c);
    const h = this._projectionData.getMinOutputOffset(i) + 1, d = c.length + 1, u = i + 1 < this.getViewLineCount(), f = i === 0 ? 0 : n.breakOffsetsVisibleColumn[i - 1];
    return new xI(c, u, h, d, f, l, t);
  }
  getModelColumnOfViewPosition(e, t) {
    return this._assertVisible(), this._projectionData.translateToInputOffset(e, t - 1) + 1;
  }
  getViewPositionOfModelPosition(e, t, i = 2) {
    return this._assertVisible(), this._projectionData.translateToOutputPosition(t - 1, i).toPosition(e);
  }
  getViewLineNumberOfModelPosition(e, t) {
    this._assertVisible();
    const i = this._projectionData.translateToOutputPosition(t - 1);
    return e + i.outputLineIndex;
  }
  normalizePosition(e, t, i) {
    const n = t.lineNumber - e;
    return this._projectionData.normalizeOutputPosition(e, t.column - 1, i).toPosition(n);
  }
  getInjectedTextAt(e, t) {
    return this._projectionData.getInjectedText(e, t - 1);
  }
  _assertVisible() {
    if (!this._isVisible)
      throw new Error("Not supported");
  }
}
const av = class av {
  constructor() {
  }
  isVisible() {
    return !0;
  }
  setVisible(e) {
    return e ? this : P1.INSTANCE;
  }
  getProjectionData() {
    return null;
  }
  getViewLineCount() {
    return 1;
  }
  getViewLineContent(e, t, i) {
    return e.getLineContent(t);
  }
  getViewLineLength(e, t, i) {
    return e.getLineLength(t);
  }
  getViewLineMinColumn(e, t, i) {
    return e.getLineMinColumn(t);
  }
  getViewLineMaxColumn(e, t, i) {
    return e.getLineMaxColumn(t);
  }
  getViewLineData(e, t, i) {
    const n = e.tokenization.getLineTokens(t), o = n.getLineContent();
    return new xI(o, !1, 1, o.length + 1, 0, n.inflate(), null);
  }
  getViewLinesData(e, t, i, n, o, r, a) {
    if (!r[o]) {
      a[o] = null;
      return;
    }
    a[o] = this.getViewLineData(e, t, 0);
  }
  getModelColumnOfViewPosition(e, t) {
    return t;
  }
  getViewPositionOfModelPosition(e, t) {
    return new F(e, t);
  }
  getViewLineNumberOfModelPosition(e, t) {
    return e;
  }
  normalizePosition(e, t, i) {
    return t;
  }
  getInjectedTextAt(e, t) {
    return null;
  }
};
av.INSTANCE = new av();
let A1 = av;
const lv = class lv {
  constructor() {
  }
  isVisible() {
    return !1;
  }
  setVisible(e) {
    return e ? A1.INSTANCE : this;
  }
  getProjectionData() {
    return null;
  }
  getViewLineCount() {
    return 0;
  }
  getViewLineContent(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineLength(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineMinColumn(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineMaxColumn(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineData(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLinesData(e, t, i, n, o, r, a) {
    throw new Error("Not supported");
  }
  getModelColumnOfViewPosition(e, t) {
    throw new Error("Not supported");
  }
  getViewPositionOfModelPosition(e, t) {
    throw new Error("Not supported");
  }
  getViewLineNumberOfModelPosition(e, t) {
    throw new Error("Not supported");
  }
  normalizePosition(e, t, i) {
    throw new Error("Not supported");
  }
  getInjectedTextAt(e, t) {
    throw new Error("Not supported");
  }
};
lv.INSTANCE = new lv();
let P1 = lv;
const ey = [""];
function HM(s) {
  if (s >= ey.length)
    for (let e = 1; e <= s; e++)
      ey[e] = wY(e);
  return ey[s];
}
function wY(s) {
  return new Array(s + 1).join(" ");
}
class yY {
  constructor(e) {
    this.values = e, this.prefixSum = new Uint32Array(e.length), this.prefixSumValidIndex = new Int32Array(1), this.prefixSumValidIndex[0] = -1;
  }
  insertValues(e, t) {
    e = Ed(e);
    const i = this.values, n = this.prefixSum, o = t.length;
    return o === 0 ? !1 : (this.values = new Uint32Array(i.length + o), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e), e + o), this.values.set(t, e), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSum = new Uint32Array(this.values.length), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(n.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  setValue(e, t) {
    return e = Ed(e), t = Ed(t), this.values[e] === t ? !1 : (this.values[e] = t, e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), !0);
  }
  removeValues(e, t) {
    e = Ed(e), t = Ed(t);
    const i = this.values, n = this.prefixSum;
    if (e >= i.length)
      return !1;
    const o = i.length - e;
    return t >= o && (t = o), t === 0 ? !1 : (this.values = new Uint32Array(i.length - t), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e + t), e), this.prefixSum = new Uint32Array(this.values.length), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(n.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  getTotalSum() {
    return this.values.length === 0 ? 0 : this._getPrefixSum(this.values.length - 1);
  }
  /**
   * Returns the sum of the first `index + 1` many items.
   * @returns `SUM(0 <= j <= index, values[j])`.
   */
  getPrefixSum(e) {
    return e < 0 ? 0 : (e = Ed(e), this._getPrefixSum(e));
  }
  _getPrefixSum(e) {
    if (e <= this.prefixSumValidIndex[0])
      return this.prefixSum[e];
    let t = this.prefixSumValidIndex[0] + 1;
    t === 0 && (this.prefixSum[0] = this.values[0], t++), e >= this.values.length && (e = this.values.length - 1);
    for (let i = t; i <= e; i++)
      this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
    return this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], e), this.prefixSum[e];
  }
  getIndexOf(e) {
    e = Math.floor(e), this.getTotalSum();
    let t = 0, i = this.values.length - 1, n = 0, o = 0, r = 0;
    for (; t <= i; )
      if (n = t + (i - t) / 2 | 0, o = this.prefixSum[n], r = o - this.values[n], e < r)
        i = n - 1;
      else if (e >= o)
        t = n + 1;
      else
        break;
    return new kF(n, e - r);
  }
}
class SY {
  constructor(e) {
    this._values = e, this._isValid = !1, this._validEndIndex = -1, this._prefixSum = [], this._indexBySum = [];
  }
  /**
   * @returns SUM(0 <= j < values.length, values[j])
   */
  getTotalSum() {
    return this._ensureValid(), this._indexBySum.length;
  }
  /**
   * Returns the sum of the first `count` many items.
   * @returns `SUM(0 <= j < count, values[j])`.
   */
  getPrefixSum(e) {
    return this._ensureValid(), e === 0 ? 0 : this._prefixSum[e - 1];
  }
  /**
   * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`
   */
  getIndexOf(e) {
    this._ensureValid();
    const t = this._indexBySum[e], i = t > 0 ? this._prefixSum[t - 1] : 0;
    return new kF(t, e - i);
  }
  removeValues(e, t) {
    this._values.splice(e, t), this._invalidate(e);
  }
  insertValues(e, t) {
    this._values = tw(this._values, e, t), this._invalidate(e);
  }
  _invalidate(e) {
    this._isValid = !1, this._validEndIndex = Math.min(this._validEndIndex, e - 1);
  }
  _ensureValid() {
    if (!this._isValid) {
      for (let e = this._validEndIndex + 1, t = this._values.length; e < t; e++) {
        const i = this._values[e], n = e > 0 ? this._prefixSum[e - 1] : 0;
        this._prefixSum[e] = n + i;
        for (let o = 0; o < i; o++)
          this._indexBySum[n + o] = e;
      }
      this._prefixSum.length = this._values.length, this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1], this._isValid = !0, this._validEndIndex = this._values.length - 1;
    }
  }
  setValue(e, t) {
    this._values[e] !== t && (this._values[e] = t, this._invalidate(e));
  }
}
class kF {
  constructor(e, t) {
    this.index = e, this.remainder = t, this._prefixSumIndexOfResultBrand = void 0, this.index = e, this.remainder = t;
  }
}
class LY {
  constructor(e, t, i, n, o, r, a, l, c, h) {
    this._editorId = e, this.model = t, this._validModelVersionId = -1, this._domLineBreaksComputerFactory = i, this._monospaceLineBreaksComputerFactory = n, this.fontInfo = o, this.tabSize = r, this.wrappingStrategy = a, this.wrappingColumn = l, this.wrappingIndent = c, this.wordBreak = h, this._constructLines(
      /*resetHiddenAreas*/
      !0,
      null
    );
  }
  dispose() {
    this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);
  }
  createCoordinatesConverter() {
    return new xY(this);
  }
  _constructLines(e, t) {
    this.modelLineProjections = [], e && (this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []));
    const i = this.model.getLinesContent(), n = this.model.getInjectedTextDecorations(this._editorId), o = i.length, r = this.createLineBreaksComputer(), a = new $a(Zo.fromDecorations(n));
    for (let p = 0; p < o; p++) {
      const _ = a.takeWhile((b) => b.lineNumber === p + 1);
      r.addRequest(i[p], _, t ? t[p] : null);
    }
    const l = r.finalize(), c = [], h = this.hiddenAreasDecorationIds.map((p) => this.model.getDecorationRange(p)).sort(T.compareRangesUsingStarts);
    let d = 1, u = 0, f = -1, g = f + 1 < h.length ? u + 1 : o + 2;
    for (let p = 0; p < o; p++) {
      const _ = p + 1;
      _ === g && (f++, d = h[f].startLineNumber, u = h[f].endLineNumber, g = f + 1 < h.length ? u + 1 : o + 2);
      const b = _ >= d && _ <= u, C = J0(l[p], !b);
      c[p] = C.getViewLineCount(), this.modelLineProjections[p] = C;
    }
    this._validModelVersionId = this.model.getVersionId(), this.projectedModelLineLineCounts = new SY(c);
  }
  getHiddenAreas() {
    return this.hiddenAreasDecorationIds.map((e) => this.model.getDecorationRange(e));
  }
  setHiddenAreas(e) {
    const t = e.map((u) => this.model.validateRange(u)), i = kY(t), n = this.hiddenAreasDecorationIds.map((u) => this.model.getDecorationRange(u)).sort(T.compareRangesUsingStarts);
    if (i.length === n.length) {
      let u = !1;
      for (let f = 0; f < i.length; f++)
        if (!i[f].equalsRange(n[f])) {
          u = !0;
          break;
        }
      if (!u)
        return !1;
    }
    const o = i.map((u) => ({
      range: u,
      options: Wt.EMPTY
    }));
    this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, o);
    const r = i;
    let a = 1, l = 0, c = -1, h = c + 1 < r.length ? l + 1 : this.modelLineProjections.length + 2, d = !1;
    for (let u = 0; u < this.modelLineProjections.length; u++) {
      const f = u + 1;
      f === h && (c++, a = r[c].startLineNumber, l = r[c].endLineNumber, h = c + 1 < r.length ? l + 1 : this.modelLineProjections.length + 2);
      let g = !1;
      if (f >= a && f <= l ? this.modelLineProjections[u].isVisible() && (this.modelLineProjections[u] = this.modelLineProjections[u].setVisible(!1), g = !0) : (d = !0, this.modelLineProjections[u].isVisible() || (this.modelLineProjections[u] = this.modelLineProjections[u].setVisible(!0), g = !0)), g) {
        const p = this.modelLineProjections[u].getViewLineCount();
        this.projectedModelLineLineCounts.setValue(u, p);
      }
    }
    return d || this.setHiddenAreas([]), !0;
  }
  modelPositionIsVisible(e, t) {
    return e < 1 || e > this.modelLineProjections.length ? !1 : this.modelLineProjections[e - 1].isVisible();
  }
  getModelLineViewLineCount(e) {
    return e < 1 || e > this.modelLineProjections.length ? 1 : this.modelLineProjections[e - 1].getViewLineCount();
  }
  setTabSize(e) {
    return this.tabSize === e ? !1 : (this.tabSize = e, this._constructLines(
      /*resetHiddenAreas*/
      !1,
      null
    ), !0);
  }
  setWrappingSettings(e, t, i, n, o) {
    const r = this.fontInfo.equals(e), a = this.wrappingStrategy === t, l = this.wrappingColumn === i, c = this.wrappingIndent === n, h = this.wordBreak === o;
    if (r && a && l && c && h)
      return !1;
    const d = r && a && !l && c && h;
    this.fontInfo = e, this.wrappingStrategy = t, this.wrappingColumn = i, this.wrappingIndent = n, this.wordBreak = o;
    let u = null;
    if (d) {
      u = [];
      for (let f = 0, g = this.modelLineProjections.length; f < g; f++)
        u[f] = this.modelLineProjections[f].getProjectionData();
    }
    return this._constructLines(
      /*resetHiddenAreas*/
      !1,
      u
    ), !0;
  }
  createLineBreaksComputer() {
    return (this.wrappingStrategy === "advanced" ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory).createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak);
  }
  onModelFlushed() {
    this._constructLines(
      /*resetHiddenAreas*/
      !0,
      null
    );
  }
  onModelLinesDeleted(e, t, i) {
    if (!e || e <= this._validModelVersionId)
      return null;
    const n = t === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, o = this.projectedModelLineLineCounts.getPrefixSum(i);
    return this.modelLineProjections.splice(t - 1, i - t + 1), this.projectedModelLineLineCounts.removeValues(t - 1, i - t + 1), new CL(n, o);
  }
  onModelLinesInserted(e, t, i, n) {
    if (!e || e <= this._validModelVersionId)
      return null;
    const o = t > 2 && !this.modelLineProjections[t - 2].isVisible(), r = t === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1;
    let a = 0;
    const l = [], c = [];
    for (let h = 0, d = n.length; h < d; h++) {
      const u = J0(n[h], !o);
      l.push(u);
      const f = u.getViewLineCount();
      a += f, c[h] = f;
    }
    return this.modelLineProjections = this.modelLineProjections.slice(0, t - 1).concat(l).concat(this.modelLineProjections.slice(t - 1)), this.projectedModelLineLineCounts.insertValues(t - 1, c), new vL(r, r + a - 1);
  }
  onModelLineChanged(e, t, i) {
    if (e !== null && e <= this._validModelVersionId)
      return [!1, null, null, null];
    const n = t - 1, o = this.modelLineProjections[n].getViewLineCount(), r = this.modelLineProjections[n].isVisible(), a = J0(i, r);
    this.modelLineProjections[n] = a;
    const l = this.modelLineProjections[n].getViewLineCount();
    let c = !1, h = 0, d = -1, u = 0, f = -1, g = 0, p = -1;
    o > l ? (h = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, d = h + l - 1, g = d + 1, p = g + (o - l) - 1, c = !0) : o < l ? (h = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, d = h + o - 1, u = d + 1, f = u + (l - o) - 1, c = !0) : (h = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, d = h + l - 1), this.projectedModelLineLineCounts.setValue(n, l);
    const _ = h <= d ? new SF(h, d - h + 1) : null, b = u <= f ? new vL(u, f) : null, C = g <= p ? new CL(g, p) : null;
    return [c, _, b, C];
  }
  acceptVersionId(e) {
    this._validModelVersionId = e, this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible() && this.setHiddenAreas([]);
  }
  getViewLineCount() {
    return this.projectedModelLineLineCounts.getTotalSum();
  }
  _toValidViewLineNumber(e) {
    if (e < 1)
      return 1;
    const t = this.getViewLineCount();
    return e > t ? t : e | 0;
  }
  getActiveIndentGuide(e, t, i) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t), i = this._toValidViewLineNumber(i);
    const n = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), o = this.convertViewPositionToModelPosition(t, this.getViewLineMinColumn(t)), r = this.convertViewPositionToModelPosition(i, this.getViewLineMinColumn(i)), a = this.model.guides.getActiveIndentGuide(n.lineNumber, o.lineNumber, r.lineNumber), l = this.convertModelPositionToViewPosition(a.startLineNumber, 1), c = this.convertModelPositionToViewPosition(a.endLineNumber, this.model.getLineMaxColumn(a.endLineNumber));
    return {
      startLineNumber: l.lineNumber,
      endLineNumber: c.lineNumber,
      indent: a.indent
    };
  }
  // #region ViewLineInfo
  getViewLineInfo(e) {
    e = this._toValidViewLineNumber(e);
    const t = this.projectedModelLineLineCounts.getIndexOf(e - 1), i = t.index, n = t.remainder;
    return new VM(i + 1, n);
  }
  getMinColumnOfViewLine(e) {
    return this.modelLineProjections[e.modelLineNumber - 1].getViewLineMinColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx);
  }
  getMaxColumnOfViewLine(e) {
    return this.modelLineProjections[e.modelLineNumber - 1].getViewLineMaxColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx);
  }
  getModelStartPositionOfViewLine(e) {
    const t = this.modelLineProjections[e.modelLineNumber - 1], i = t.getViewLineMinColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx), n = t.getModelColumnOfViewPosition(e.modelLineWrappedLineIdx, i);
    return new F(e.modelLineNumber, n);
  }
  getModelEndPositionOfViewLine(e) {
    const t = this.modelLineProjections[e.modelLineNumber - 1], i = t.getViewLineMaxColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx), n = t.getModelColumnOfViewPosition(e.modelLineWrappedLineIdx, i);
    return new F(e.modelLineNumber, n);
  }
  getViewLineInfosGroupedByModelRanges(e, t) {
    const i = this.getViewLineInfo(e), n = this.getViewLineInfo(t), o = new Array();
    let r = this.getModelStartPositionOfViewLine(i), a = new Array();
    for (let l = i.modelLineNumber; l <= n.modelLineNumber; l++) {
      const c = this.modelLineProjections[l - 1];
      if (c.isVisible()) {
        const h = l === i.modelLineNumber ? i.modelLineWrappedLineIdx : 0, d = l === n.modelLineNumber ? n.modelLineWrappedLineIdx + 1 : c.getViewLineCount();
        for (let u = h; u < d; u++)
          a.push(new VM(l, u));
      }
      if (!c.isVisible() && r) {
        const h = new F(l - 1, this.model.getLineMaxColumn(l - 1) + 1), d = T.fromPositions(r, h);
        o.push(new zM(d, a)), a = [], r = null;
      } else c.isVisible() && !r && (r = new F(l, 1));
    }
    if (r) {
      const l = T.fromPositions(r, this.getModelEndPositionOfViewLine(n));
      o.push(new zM(l, a));
    }
    return o;
  }
  // #endregion
  getViewLinesBracketGuides(e, t, i, n) {
    const o = i ? this.convertViewPositionToModelPosition(i.lineNumber, i.column) : null, r = [];
    for (const a of this.getViewLineInfosGroupedByModelRanges(e, t)) {
      const l = a.modelRange.startLineNumber, c = this.model.guides.getLinesBracketGuides(l, a.modelRange.endLineNumber, o, n);
      for (const h of a.viewLines) {
        const u = c[h.modelLineNumber - l].map((f) => {
          if (f.forWrappedLinesAfterColumn !== -1 && this.modelLineProjections[h.modelLineNumber - 1].getViewPositionOfModelPosition(0, f.forWrappedLinesAfterColumn).lineNumber >= h.modelLineWrappedLineIdx || f.forWrappedLinesBeforeOrAtColumn !== -1 && this.modelLineProjections[h.modelLineNumber - 1].getViewPositionOfModelPosition(0, f.forWrappedLinesBeforeOrAtColumn).lineNumber < h.modelLineWrappedLineIdx)
            return;
          if (!f.horizontalLine)
            return f;
          let g = -1;
          if (f.column !== -1) {
            const b = this.modelLineProjections[h.modelLineNumber - 1].getViewPositionOfModelPosition(0, f.column);
            if (b.lineNumber === h.modelLineWrappedLineIdx)
              g = b.column;
            else if (b.lineNumber < h.modelLineWrappedLineIdx)
              g = this.getMinColumnOfViewLine(h);
            else if (b.lineNumber > h.modelLineWrappedLineIdx)
              return;
          }
          const p = this.convertModelPositionToViewPosition(h.modelLineNumber, f.horizontalLine.endColumn), _ = this.modelLineProjections[h.modelLineNumber - 1].getViewPositionOfModelPosition(0, f.horizontalLine.endColumn);
          return _.lineNumber === h.modelLineWrappedLineIdx ? new th(f.visibleColumn, g, f.className, new Bg(f.horizontalLine.top, p.column), -1, -1) : _.lineNumber < h.modelLineWrappedLineIdx || f.visibleColumn !== -1 ? void 0 : new th(f.visibleColumn, g, f.className, new Bg(f.horizontalLine.top, this.getMaxColumnOfViewLine(h)), -1, -1);
        });
        r.push(u.filter((f) => !!f));
      }
    }
    return r;
  }
  getViewLinesIndentGuides(e, t) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
    const i = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), n = this.convertViewPositionToModelPosition(t, this.getViewLineMaxColumn(t));
    let o = [];
    const r = [], a = [], l = i.lineNumber - 1, c = n.lineNumber - 1;
    let h = null;
    for (let g = l; g <= c; g++) {
      const p = this.modelLineProjections[g];
      if (p.isVisible()) {
        const _ = p.getViewLineNumberOfModelPosition(0, g === l ? i.column : 1), b = p.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(g + 1)), C = b - _ + 1;
        let w = 0;
        C > 1 && p.getViewLineMinColumn(this.model, g + 1, b) === 1 && (w = _ === 0 ? 1 : 2), r.push(C), a.push(w), h === null && (h = new F(g + 1, 0));
      } else
        h !== null && (o = o.concat(this.model.guides.getLinesIndentGuides(h.lineNumber, g)), h = null);
    }
    h !== null && (o = o.concat(this.model.guides.getLinesIndentGuides(h.lineNumber, n.lineNumber)), h = null);
    const d = t - e + 1, u = new Array(d);
    let f = 0;
    for (let g = 0, p = o.length; g < p; g++) {
      let _ = o[g];
      const b = Math.min(d - f, r[g]), C = a[g];
      let w;
      C === 2 ? w = 0 : C === 1 ? w = 1 : w = b;
      for (let v = 0; v < b; v++)
        v === w && (_ = 0), u[f++] = _;
    }
    return u;
  }
  getViewLineContent(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineContent(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineLength(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineLength(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineMinColumn(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineMinColumn(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineMaxColumn(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineMaxColumn(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineData(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineData(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLinesData(e, t, i) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
    const n = this.projectedModelLineLineCounts.getIndexOf(e - 1);
    let o = e;
    const r = n.index, a = n.remainder, l = [];
    for (let c = r, h = this.model.getLineCount(); c < h; c++) {
      const d = this.modelLineProjections[c];
      if (!d.isVisible())
        continue;
      const u = c === r ? a : 0;
      let f = d.getViewLineCount() - u, g = !1;
      if (o + f > t && (g = !0, f = t - o + 1), d.getViewLinesData(this.model, c + 1, u, f, o - e, i, l), o += f, g)
        break;
    }
    return l;
  }
  validateViewPosition(e, t, i) {
    e = this._toValidViewLineNumber(e);
    const n = this.projectedModelLineLineCounts.getIndexOf(e - 1), o = n.index, r = n.remainder, a = this.modelLineProjections[o], l = a.getViewLineMinColumn(this.model, o + 1, r), c = a.getViewLineMaxColumn(this.model, o + 1, r);
    t < l && (t = l), t > c && (t = c);
    const h = a.getModelColumnOfViewPosition(r, t);
    return this.model.validatePosition(new F(o + 1, h)).equals(i) ? new F(e, t) : this.convertModelPositionToViewPosition(i.lineNumber, i.column);
  }
  validateViewRange(e, t) {
    const i = this.validateViewPosition(e.startLineNumber, e.startColumn, t.getStartPosition()), n = this.validateViewPosition(e.endLineNumber, e.endColumn, t.getEndPosition());
    return new T(i.lineNumber, i.column, n.lineNumber, n.column);
  }
  convertViewPositionToModelPosition(e, t) {
    const i = this.getViewLineInfo(e), n = this.modelLineProjections[i.modelLineNumber - 1].getModelColumnOfViewPosition(i.modelLineWrappedLineIdx, t);
    return this.model.validatePosition(new F(i.modelLineNumber, n));
  }
  convertViewRangeToModelRange(e) {
    const t = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), i = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
    return new T(t.lineNumber, t.column, i.lineNumber, i.column);
  }
  convertModelPositionToViewPosition(e, t, i = 2, n = !1, o = !1) {
    const r = this.model.validatePosition(new F(e, t)), a = r.lineNumber, l = r.column;
    let c = a - 1, h = !1;
    if (o)
      for (; c < this.modelLineProjections.length && !this.modelLineProjections[c].isVisible(); )
        c++, h = !0;
    else
      for (; c > 0 && !this.modelLineProjections[c].isVisible(); )
        c--, h = !0;
    if (c === 0 && !this.modelLineProjections[c].isVisible())
      return new F(n ? 0 : 1, 1);
    const d = 1 + this.projectedModelLineLineCounts.getPrefixSum(c);
    let u;
    return h ? o ? u = this.modelLineProjections[c].getViewPositionOfModelPosition(d, 1, i) : u = this.modelLineProjections[c].getViewPositionOfModelPosition(d, this.model.getLineMaxColumn(c + 1), i) : u = this.modelLineProjections[a - 1].getViewPositionOfModelPosition(d, l, i), u;
  }
  /**
   * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.
  */
  convertModelRangeToViewRange(e, t = 0) {
    if (e.isEmpty()) {
      const i = this.convertModelPositionToViewPosition(e.startLineNumber, e.startColumn, t);
      return T.fromPositions(i);
    } else {
      const i = this.convertModelPositionToViewPosition(
        e.startLineNumber,
        e.startColumn,
        1
        /* PositionAffinity.Right */
      ), n = this.convertModelPositionToViewPosition(
        e.endLineNumber,
        e.endColumn,
        0
        /* PositionAffinity.Left */
      );
      return new T(i.lineNumber, i.column, n.lineNumber, n.column);
    }
  }
  getViewLineNumberOfModelPosition(e, t) {
    let i = e - 1;
    if (this.modelLineProjections[i].isVisible()) {
      const o = 1 + this.projectedModelLineLineCounts.getPrefixSum(i);
      return this.modelLineProjections[i].getViewLineNumberOfModelPosition(o, t);
    }
    for (; i > 0 && !this.modelLineProjections[i].isVisible(); )
      i--;
    if (i === 0 && !this.modelLineProjections[i].isVisible())
      return 1;
    const n = 1 + this.projectedModelLineLineCounts.getPrefixSum(i);
    return this.modelLineProjections[i].getViewLineNumberOfModelPosition(n, this.model.getLineMaxColumn(i + 1));
  }
  getDecorationsInRange(e, t, i, n, o) {
    const r = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), a = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
    if (a.lineNumber - r.lineNumber <= e.endLineNumber - e.startLineNumber)
      return this.model.getDecorationsInRange(new T(r.lineNumber, 1, a.lineNumber, a.column), t, i, n, o);
    let l = [];
    const c = r.lineNumber - 1, h = a.lineNumber - 1;
    let d = null;
    for (let p = c; p <= h; p++)
      if (this.modelLineProjections[p].isVisible())
        d === null && (d = new F(p + 1, p === c ? r.column : 1));
      else if (d !== null) {
        const b = this.model.getLineMaxColumn(p);
        l = l.concat(this.model.getDecorationsInRange(new T(d.lineNumber, d.column, p, b), t, i, n)), d = null;
      }
    d !== null && (l = l.concat(this.model.getDecorationsInRange(new T(d.lineNumber, d.column, a.lineNumber, a.column), t, i, n)), d = null), l.sort((p, _) => {
      const b = T.compareRangesUsingStarts(p.range, _.range);
      return b === 0 ? p.id < _.id ? -1 : p.id > _.id ? 1 : 0 : b;
    });
    const u = [];
    let f = 0, g = null;
    for (const p of l) {
      const _ = p.id;
      g !== _ && (g = _, u[f++] = p);
    }
    return u;
  }
  getInjectedTextAt(e) {
    const t = this.getViewLineInfo(e.lineNumber);
    return this.modelLineProjections[t.modelLineNumber - 1].getInjectedTextAt(t.modelLineWrappedLineIdx, e.column);
  }
  normalizePosition(e, t) {
    const i = this.getViewLineInfo(e.lineNumber);
    return this.modelLineProjections[i.modelLineNumber - 1].normalizePosition(i.modelLineWrappedLineIdx, e, t);
  }
  getLineIndentColumn(e) {
    const t = this.getViewLineInfo(e);
    return t.modelLineWrappedLineIdx === 0 ? this.model.getLineIndentColumn(t.modelLineNumber) : 0;
  }
}
function kY(s) {
  if (s.length === 0)
    return [];
  const e = s.slice();
  e.sort(T.compareRangesUsingStarts);
  const t = [];
  let i = e[0].startLineNumber, n = e[0].endLineNumber;
  for (let o = 1, r = e.length; o < r; o++) {
    const a = e[o];
    a.startLineNumber > n + 1 ? (t.push(new T(i, 1, n, 1)), i = a.startLineNumber, n = a.endLineNumber) : a.endLineNumber > n && (n = a.endLineNumber);
  }
  return t.push(new T(i, 1, n, 1)), t;
}
class VM {
  constructor(e, t) {
    this.modelLineNumber = e, this.modelLineWrappedLineIdx = t;
  }
}
class zM {
  constructor(e, t) {
    this.modelRange = e, this.viewLines = t;
  }
}
class xY {
  constructor(e) {
    this._lines = e;
  }
  // View -> Model conversion and related methods
  convertViewPositionToModelPosition(e) {
    return this._lines.convertViewPositionToModelPosition(e.lineNumber, e.column);
  }
  convertViewRangeToModelRange(e) {
    return this._lines.convertViewRangeToModelRange(e);
  }
  validateViewPosition(e, t) {
    return this._lines.validateViewPosition(e.lineNumber, e.column, t);
  }
  validateViewRange(e, t) {
    return this._lines.validateViewRange(e, t);
  }
  // Model -> View conversion and related methods
  convertModelPositionToViewPosition(e, t, i, n) {
    return this._lines.convertModelPositionToViewPosition(e.lineNumber, e.column, t, i, n);
  }
  convertModelRangeToViewRange(e, t) {
    return this._lines.convertModelRangeToViewRange(e, t);
  }
  modelPositionIsVisible(e) {
    return this._lines.modelPositionIsVisible(e.lineNumber, e.column);
  }
  getModelLineViewLineCount(e) {
    return this._lines.getModelLineViewLineCount(e);
  }
  getViewLineNumberOfModelPosition(e, t) {
    return this._lines.getViewLineNumberOfModelPosition(e, t);
  }
}
class DY {
  constructor(e) {
    this.model = e;
  }
  dispose() {
  }
  createCoordinatesConverter() {
    return new EY(this);
  }
  getHiddenAreas() {
    return [];
  }
  setHiddenAreas(e) {
    return !1;
  }
  setTabSize(e) {
    return !1;
  }
  setWrappingSettings(e, t, i, n) {
    return !1;
  }
  createLineBreaksComputer() {
    const e = [];
    return {
      addRequest: (t, i, n) => {
        e.push(null);
      },
      finalize: () => e
    };
  }
  onModelFlushed() {
  }
  onModelLinesDeleted(e, t, i) {
    return new CL(t, i);
  }
  onModelLinesInserted(e, t, i, n) {
    return new vL(t, i);
  }
  onModelLineChanged(e, t, i) {
    return [!1, new SF(t, 1), null, null];
  }
  acceptVersionId(e) {
  }
  getViewLineCount() {
    return this.model.getLineCount();
  }
  getActiveIndentGuide(e, t, i) {
    return {
      startLineNumber: e,
      endLineNumber: e,
      indent: 0
    };
  }
  getViewLinesBracketGuides(e, t, i) {
    return new Array(t - e + 1).fill([]);
  }
  getViewLinesIndentGuides(e, t) {
    const i = t - e + 1, n = new Array(i);
    for (let o = 0; o < i; o++)
      n[o] = 0;
    return n;
  }
  getViewLineContent(e) {
    return this.model.getLineContent(e);
  }
  getViewLineLength(e) {
    return this.model.getLineLength(e);
  }
  getViewLineMinColumn(e) {
    return this.model.getLineMinColumn(e);
  }
  getViewLineMaxColumn(e) {
    return this.model.getLineMaxColumn(e);
  }
  getViewLineData(e) {
    const t = this.model.tokenization.getLineTokens(e), i = t.getLineContent();
    return new xI(i, !1, 1, i.length + 1, 0, t.inflate(), null);
  }
  getViewLinesData(e, t, i) {
    const n = this.model.getLineCount();
    e = Math.min(Math.max(1, e), n), t = Math.min(Math.max(1, t), n);
    const o = [];
    for (let r = e; r <= t; r++) {
      const a = r - e;
      o[a] = i[a] ? this.getViewLineData(r) : null;
    }
    return o;
  }
  getDecorationsInRange(e, t, i, n, o) {
    return this.model.getDecorationsInRange(e, t, i, n, o);
  }
  normalizePosition(e, t) {
    return this.model.normalizePosition(e, t);
  }
  getLineIndentColumn(e) {
    return this.model.getLineIndentColumn(e);
  }
  getInjectedTextAt(e) {
    return null;
  }
}
class EY {
  constructor(e) {
    this._lines = e;
  }
  _validPosition(e) {
    return this._lines.model.validatePosition(e);
  }
  _validRange(e) {
    return this._lines.model.validateRange(e);
  }
  // View -> Model conversion and related methods
  convertViewPositionToModelPosition(e) {
    return this._validPosition(e);
  }
  convertViewRangeToModelRange(e) {
    return this._validRange(e);
  }
  validateViewPosition(e, t) {
    return this._validPosition(t);
  }
  validateViewRange(e, t) {
    return this._validRange(t);
  }
  // Model -> View conversion and related methods
  convertModelPositionToViewPosition(e) {
    return this._validPosition(e);
  }
  convertModelRangeToViewRange(e) {
    return this._validRange(e);
  }
  modelPositionIsVisible(e) {
    const t = this._lines.model.getLineCount();
    return !(e.lineNumber < 1 || e.lineNumber > t);
  }
  getModelLineViewLineCount(e) {
    return 1;
  }
  getViewLineNumberOfModelPosition(e, t) {
    return e;
  }
}
const _c = _o.Right;
class IY {
  constructor(e) {
    this.persist = 0, this._requiredLanes = 1, this.lanes = new Uint8Array(Math.ceil((e + 1) * _c / 8));
  }
  reset(e) {
    const t = Math.ceil((e + 1) * _c / 8);
    this.lanes.length < t ? this.lanes = new Uint8Array(t) : this.lanes.fill(0), this._requiredLanes = 1;
  }
  get requiredLanes() {
    return this._requiredLanes;
  }
  push(e, t, i) {
    i && (this.persist |= 1 << e - 1);
    for (let n = t.startLineNumber; n <= t.endLineNumber; n++) {
      const o = _c * n + (e - 1);
      this.lanes[o >>> 3] |= 1 << o % 8, this._requiredLanes = Math.max(this._requiredLanes, this.countAtLine(n));
    }
  }
  getLanesAtLine(e) {
    const t = [];
    let i = _c * e;
    for (let n = 0; n < _c; n++)
      (this.persist & 1 << n || this.lanes[i >>> 3] & 1 << i % 8) && t.push(n + 1), i++;
    return t.length ? t : [_o.Center];
  }
  countAtLine(e) {
    let t = _c * e, i = 0;
    for (let n = 0; n < _c; n++)
      (this.persist & 1 << n || this.lanes[t >>> 3] & 1 << t % 8) && i++, t++;
    return i;
  }
}
let NY = class extends U {
  constructor(e, t, i, n, o, r, a, l, c, h) {
    if (super(), this.languageConfigurationService = a, this._themeService = l, this._attachedView = c, this._transactionalTarget = h, this.hiddenAreasModel = new MY(), this.previousHiddenAreas = [], this._editorId = e, this._configuration = t, this.model = i, this._eventDispatcher = new GZ(), this.onEvent = this._eventDispatcher.onEvent, this.cursorConfig = new Id(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._updateConfigurationViewLineCount = this._register(new ai(() => this._updateConfigurationViewLineCountNow(), 0)), this._hasFocus = !1, this._viewportStart = jI.create(this.model), this.glyphLanes = new IY(0), this.model.isTooLargeForTokenization())
      this._lines = new DY(this.model);
    else {
      const d = this._configuration.options, u = d.get(
        50
        /* EditorOption.fontInfo */
      ), f = d.get(
        140
        /* EditorOption.wrappingStrategy */
      ), g = d.get(
        147
        /* EditorOption.wrappingInfo */
      ), p = d.get(
        139
        /* EditorOption.wrappingIndent */
      ), _ = d.get(
        130
        /* EditorOption.wordBreak */
      );
      this._lines = new LY(this._editorId, this.model, n, o, u, this.model.getOptions().tabSize, f, g.wrappingColumn, p, _);
    }
    this.coordinatesConverter = this._lines.createCoordinatesConverter(), this._cursor = this._register(new oY(i, this, this.coordinatesConverter, this.cursorConfig)), this.viewLayout = this._register(new mY(this._configuration, this.getLineCount(), r)), this._register(this.viewLayout.onDidScroll((d) => {
      d.scrollTopChanged && this._handleVisibleLinesChanged(), d.scrollTopChanged && this._viewportStart.invalidate(), this._eventDispatcher.emitSingleViewEvent(new UZ(d)), this._eventDispatcher.emitOutgoingEvent(new KI(d.oldScrollWidth, d.oldScrollLeft, d.oldScrollHeight, d.oldScrollTop, d.scrollWidth, d.scrollLeft, d.scrollHeight, d.scrollTop));
    })), this._register(this.viewLayout.onDidContentSizeChange((d) => {
      this._eventDispatcher.emitOutgoingEvent(d);
    })), this._decorations = new pY(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter), this._registerModelEvents(), this._register(this._configuration.onDidChangeFast((d) => {
      try {
        const u = this._eventDispatcher.beginEmitViewEvents();
        this._onConfigurationChanged(u, d);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
    })), this._register(x1.getInstance().onDidChange(() => {
      this._eventDispatcher.emitSingleViewEvent(new jZ());
    })), this._register(this._themeService.onDidColorThemeChange((d) => {
      this._invalidateDecorationsColorCache(), this._eventDispatcher.emitSingleViewEvent(new $Z(d));
    })), this._updateConfigurationViewLineCountNow();
  }
  dispose() {
    super.dispose(), this._decorations.dispose(), this._lines.dispose(), this._viewportStart.dispose(), this._eventDispatcher.dispose();
  }
  createLineBreaksComputer() {
    return this._lines.createLineBreaksComputer();
  }
  addViewEventHandler(e) {
    this._eventDispatcher.addViewEventHandler(e);
  }
  removeViewEventHandler(e) {
    this._eventDispatcher.removeViewEventHandler(e);
  }
  _updateConfigurationViewLineCountNow() {
    this._configuration.setViewLineCount(this._lines.getViewLineCount());
  }
  getModelVisibleRanges() {
    const e = this.viewLayout.getLinesViewportData(), t = new T(e.startLineNumber, this.getLineMinColumn(e.startLineNumber), e.endLineNumber, this.getLineMaxColumn(e.endLineNumber));
    return this._toModelVisibleRanges(t);
  }
  visibleLinesStabilized() {
    const e = this.getModelVisibleRanges();
    this._attachedView.setVisibleLines(e, !0);
  }
  _handleVisibleLinesChanged() {
    const e = this.getModelVisibleRanges();
    this._attachedView.setVisibleLines(e, !1);
  }
  setHasFocus(e) {
    this._hasFocus = e, this._cursor.setHasFocus(e), this._eventDispatcher.emitSingleViewEvent(new VZ(e)), this._eventDispatcher.emitOutgoingEvent(new $I(!e, e));
  }
  onCompositionStart() {
    this._eventDispatcher.emitSingleViewEvent(new FZ());
  }
  onCompositionEnd() {
    this._eventDispatcher.emitSingleViewEvent(new BZ());
  }
  _captureStableViewport() {
    if (this._viewportStart.isValid && this.viewLayout.getCurrentScrollTop() > 0) {
      const e = new F(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber)), t = this.coordinatesConverter.convertViewPositionToModelPosition(e);
      return new $M(t, this._viewportStart.startLineDelta);
    }
    return new $M(null, 0);
  }
  _onConfigurationChanged(e, t) {
    const i = this._captureStableViewport(), n = this._configuration.options, o = n.get(
      50
      /* EditorOption.fontInfo */
    ), r = n.get(
      140
      /* EditorOption.wrappingStrategy */
    ), a = n.get(
      147
      /* EditorOption.wrappingInfo */
    ), l = n.get(
      139
      /* EditorOption.wrappingIndent */
    ), c = n.get(
      130
      /* EditorOption.wordBreak */
    );
    this._lines.setWrappingSettings(o, r, a.wrappingColumn, l, c) && (e.emitViewEvent(new E_()), e.emitViewEvent(new I_()), e.emitViewEvent(new pc(null)), this._cursor.onLineMappingChanged(e), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this._updateConfigurationViewLineCount.schedule()), t.hasChanged(
      92
      /* EditorOption.readOnly */
    ) && (this._decorations.reset(), e.emitViewEvent(new pc(null))), t.hasChanged(
      99
      /* EditorOption.renderValidationDecorations */
    ) && (this._decorations.reset(), e.emitViewEvent(new pc(null))), e.emitViewEvent(new WZ(t)), this.viewLayout.onConfigurationChanged(t), i.recoverViewportStart(this.coordinatesConverter, this.viewLayout), Id.shouldRecreate(t) && (this.cursorConfig = new Id(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig));
  }
  _registerModelEvents() {
    this._register(this.model.onDidChangeContentOrInjectedText((e) => {
      try {
        const i = this._eventDispatcher.beginEmitViewEvents();
        let n = !1, o = !1;
        const r = e instanceof fh ? e.rawContentChangedEvent.changes : e.changes, a = e instanceof fh ? e.rawContentChangedEvent.versionId : null, l = this._lines.createLineBreaksComputer();
        for (const d of r)
          switch (d.changeType) {
            case 4: {
              for (let u = 0; u < d.detail.length; u++) {
                const f = d.detail[u];
                let g = d.injectedTexts[u];
                g && (g = g.filter((p) => !p.ownerId || p.ownerId === this._editorId)), l.addRequest(f, g, null);
              }
              break;
            }
            case 2: {
              let u = null;
              d.injectedText && (u = d.injectedText.filter((f) => !f.ownerId || f.ownerId === this._editorId)), l.addRequest(d.detail, u, null);
              break;
            }
          }
        const c = l.finalize(), h = new $a(c);
        for (const d of r)
          switch (d.changeType) {
            case 1: {
              this._lines.onModelFlushed(), i.emitViewEvent(new E_()), this._decorations.reset(), this.viewLayout.onFlushed(this.getLineCount()), n = !0;
              break;
            }
            case 3: {
              const u = this._lines.onModelLinesDeleted(a, d.fromLineNumber, d.toLineNumber);
              u !== null && (i.emitViewEvent(u), this.viewLayout.onLinesDeleted(u.fromLineNumber, u.toLineNumber)), n = !0;
              break;
            }
            case 4: {
              const u = h.takeCount(d.detail.length), f = this._lines.onModelLinesInserted(a, d.fromLineNumber, d.toLineNumber, u);
              f !== null && (i.emitViewEvent(f), this.viewLayout.onLinesInserted(f.fromLineNumber, f.toLineNumber)), n = !0;
              break;
            }
            case 2: {
              const u = h.dequeue(), [f, g, p, _] = this._lines.onModelLineChanged(a, d.lineNumber, u);
              o = f, g && i.emitViewEvent(g), p && (i.emitViewEvent(p), this.viewLayout.onLinesInserted(p.fromLineNumber, p.toLineNumber)), _ && (i.emitViewEvent(_), this.viewLayout.onLinesDeleted(_.fromLineNumber, _.toLineNumber));
              break;
            }
            case 5:
              break;
          }
        a !== null && this._lines.acceptVersionId(a), this.viewLayout.onHeightMaybeChanged(), !n && o && (i.emitViewEvent(new I_()), i.emitViewEvent(new pc(null)), this._cursor.onLineMappingChanged(i), this._decorations.onLineMappingChanged());
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
      const t = this._viewportStart.isValid;
      if (this._viewportStart.invalidate(), this._configuration.setModelLineCount(this.model.getLineCount()), this._updateConfigurationViewLineCountNow(), !this._hasFocus && this.model.getAttachedEditorCount() >= 2 && t) {
        const i = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);
        if (i) {
          const n = this.coordinatesConverter.convertModelPositionToViewPosition(i.getStartPosition()), o = this.viewLayout.getVerticalOffsetForLineNumber(n.lineNumber);
          this.viewLayout.setScrollPosition(
            { scrollTop: o + this._viewportStart.startLineDelta },
            1
            /* ScrollType.Immediate */
          );
        }
      }
      try {
        const i = this._eventDispatcher.beginEmitViewEvents();
        e instanceof fh && i.emitOutgoingEvent(new iY(e.contentChangedEvent)), this._cursor.onModelContentChanged(i, e);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
      this._handleVisibleLinesChanged();
    })), this._register(this.model.onDidChangeTokens((e) => {
      const t = [];
      for (let i = 0, n = e.ranges.length; i < n; i++) {
        const o = e.ranges[i], r = this.coordinatesConverter.convertModelPositionToViewPosition(new F(o.fromLineNumber, 1)).lineNumber, a = this.coordinatesConverter.convertModelPositionToViewPosition(new F(o.toLineNumber, this.model.getLineMaxColumn(o.toLineNumber))).lineNumber;
        t[i] = {
          fromLineNumber: r,
          toLineNumber: a
        };
      }
      this._eventDispatcher.emitSingleViewEvent(new KZ(t)), this._eventDispatcher.emitOutgoingEvent(new sY(e));
    })), this._register(this.model.onDidChangeLanguageConfiguration((e) => {
      this._eventDispatcher.emitSingleViewEvent(new zZ()), this.cursorConfig = new Id(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new tY(e));
    })), this._register(this.model.onDidChangeLanguage((e) => {
      this.cursorConfig = new Id(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new eY(e));
    })), this._register(this.model.onDidChangeOptions((e) => {
      if (this._lines.setTabSize(this.model.getOptions().tabSize)) {
        try {
          const t = this._eventDispatcher.beginEmitViewEvents();
          t.emitViewEvent(new E_()), t.emitViewEvent(new I_()), t.emitViewEvent(new pc(null)), this._cursor.onLineMappingChanged(t), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount());
        } finally {
          this._eventDispatcher.endEmitViewEvents();
        }
        this._updateConfigurationViewLineCount.schedule();
      }
      this.cursorConfig = new Id(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new nY(e));
    })), this._register(this.model.onDidChangeDecorations((e) => {
      this._decorations.onModelDecorationsChanged(), this._eventDispatcher.emitSingleViewEvent(new pc(e)), this._eventDispatcher.emitOutgoingEvent(new JZ(e));
    }));
  }
  setHiddenAreas(e, t) {
    var r;
    this.hiddenAreasModel.setHiddenAreas(t, e);
    const i = this.hiddenAreasModel.getMergedRanges();
    if (i === this.previousHiddenAreas)
      return;
    this.previousHiddenAreas = i;
    const n = this._captureStableViewport();
    let o = !1;
    try {
      const a = this._eventDispatcher.beginEmitViewEvents();
      o = this._lines.setHiddenAreas(i), o && (a.emitViewEvent(new E_()), a.emitViewEvent(new I_()), a.emitViewEvent(new pc(null)), this._cursor.onLineMappingChanged(a), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this.viewLayout.onHeightMaybeChanged());
      const l = (r = n.viewportStartModelPosition) == null ? void 0 : r.lineNumber;
      l && i.some((h) => h.startLineNumber <= l && l <= h.endLineNumber) || n.recoverViewportStart(this.coordinatesConverter, this.viewLayout);
    } finally {
      this._eventDispatcher.endEmitViewEvents();
    }
    this._updateConfigurationViewLineCount.schedule(), o && this._eventDispatcher.emitOutgoingEvent(new XZ());
  }
  getVisibleRangesPlusViewportAboveBelow() {
    const e = this._configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    ), t = this._configuration.options.get(
      67
      /* EditorOption.lineHeight */
    ), i = Math.max(20, Math.round(e.height / t)), n = this.viewLayout.getLinesViewportData(), o = Math.max(1, n.completelyVisibleStartLineNumber - i), r = Math.min(this.getLineCount(), n.completelyVisibleEndLineNumber + i);
    return this._toModelVisibleRanges(new T(o, this.getLineMinColumn(o), r, this.getLineMaxColumn(r)));
  }
  getVisibleRanges() {
    const e = this.getCompletelyVisibleViewRange();
    return this._toModelVisibleRanges(e);
  }
  getHiddenAreas() {
    return this._lines.getHiddenAreas();
  }
  _toModelVisibleRanges(e) {
    const t = this.coordinatesConverter.convertViewRangeToModelRange(e), i = this._lines.getHiddenAreas();
    if (i.length === 0)
      return [t];
    const n = [];
    let o = 0, r = t.startLineNumber, a = t.startColumn;
    const l = t.endLineNumber, c = t.endColumn;
    for (let h = 0, d = i.length; h < d; h++) {
      const u = i[h].startLineNumber, f = i[h].endLineNumber;
      f < r || u > l || (r < u && (n[o++] = new T(r, a, u - 1, this.model.getLineMaxColumn(u - 1))), r = f + 1, a = 1);
    }
    return (r < l || r === l && a < c) && (n[o++] = new T(r, a, l, c)), n;
  }
  getCompletelyVisibleViewRange() {
    const e = this.viewLayout.getLinesViewportData(), t = e.completelyVisibleStartLineNumber, i = e.completelyVisibleEndLineNumber;
    return new T(t, this.getLineMinColumn(t), i, this.getLineMaxColumn(i));
  }
  getCompletelyVisibleViewRangeAtScrollTop(e) {
    const t = this.viewLayout.getLinesViewportDataAtScrollTop(e), i = t.completelyVisibleStartLineNumber, n = t.completelyVisibleEndLineNumber;
    return new T(i, this.getLineMinColumn(i), n, this.getLineMaxColumn(n));
  }
  saveState() {
    const e = this.viewLayout.saveState(), t = e.scrollTop, i = this.viewLayout.getLineNumberAtVerticalOffset(t), n = this.coordinatesConverter.convertViewPositionToModelPosition(new F(i, this.getLineMinColumn(i))), o = this.viewLayout.getVerticalOffsetForLineNumber(i) - t;
    return {
      scrollLeft: e.scrollLeft,
      firstPosition: n,
      firstPositionDeltaTop: o
    };
  }
  reduceRestoreState(e) {
    if (typeof e.firstPosition > "u")
      return this._reduceRestoreStateCompatibility(e);
    const t = this.model.validatePosition(e.firstPosition), i = this.coordinatesConverter.convertModelPositionToViewPosition(t), n = this.viewLayout.getVerticalOffsetForLineNumber(i.lineNumber) - e.firstPositionDeltaTop;
    return {
      scrollLeft: e.scrollLeft,
      scrollTop: n
    };
  }
  _reduceRestoreStateCompatibility(e) {
    return {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTopWithoutViewZones
    };
  }
  getTabSize() {
    return this.model.getOptions().tabSize;
  }
  getLineCount() {
    return this._lines.getViewLineCount();
  }
  /**
   * Gives a hint that a lot of requests are about to come in for these line numbers.
   */
  setViewport(e, t, i) {
    this._viewportStart.update(this, e);
  }
  getActiveIndentGuide(e, t, i) {
    return this._lines.getActiveIndentGuide(e, t, i);
  }
  getLinesIndentGuides(e, t) {
    return this._lines.getViewLinesIndentGuides(e, t);
  }
  getBracketGuidesInRangeByLine(e, t, i, n) {
    return this._lines.getViewLinesBracketGuides(e, t, i, n);
  }
  getLineContent(e) {
    return this._lines.getViewLineContent(e);
  }
  getLineLength(e) {
    return this._lines.getViewLineLength(e);
  }
  getLineMinColumn(e) {
    return this._lines.getViewLineMinColumn(e);
  }
  getLineMaxColumn(e) {
    return this._lines.getViewLineMaxColumn(e);
  }
  getLineFirstNonWhitespaceColumn(e) {
    const t = Zn(this.getLineContent(e));
    return t === -1 ? 0 : t + 1;
  }
  getLineLastNonWhitespaceColumn(e) {
    const t = id(this.getLineContent(e));
    return t === -1 ? 0 : t + 2;
  }
  getMinimapDecorationsInRange(e) {
    return this._decorations.getMinimapDecorationsInRange(e);
  }
  getDecorationsInViewport(e) {
    return this._decorations.getDecorationsViewportData(e).decorations;
  }
  getInjectedTextAt(e) {
    return this._lines.getInjectedTextAt(e);
  }
  getViewportViewLineRenderingData(e, t) {
    const n = this._decorations.getDecorationsViewportData(e).inlineDecorations[t - e.startLineNumber];
    return this._getViewLineRenderingData(t, n);
  }
  getViewLineRenderingData(e) {
    const t = this._decorations.getInlineDecorationsOnLine(e);
    return this._getViewLineRenderingData(e, t);
  }
  _getViewLineRenderingData(e, t) {
    const i = this.model.mightContainRTL(), n = this.model.mightContainNonBasicASCII(), o = this.getTabSize(), r = this._lines.getViewLineData(e);
    return r.inlineDecorations && (t = [
      ...t,
      ...r.inlineDecorations.map((a) => a.toInlineDecoration(e))
    ]), new xs(r.minColumn, r.maxColumn, r.content, r.continuesWithWrappedLine, i, n, r.tokens, t, o, r.startVisibleColumn);
  }
  getViewLineData(e) {
    return this._lines.getViewLineData(e);
  }
  getMinimapLinesRenderingData(e, t, i) {
    const n = this._lines.getViewLinesData(e, t, i);
    return new Eq(this.getTabSize(), n);
  }
  getAllOverviewRulerDecorations(e) {
    const t = this.model.getOverviewRulerDecorations(this._editorId, r1(this._configuration.options)), i = new TY();
    for (const n of t) {
      const o = n.options, r = o.overviewRuler;
      if (!r)
        continue;
      const a = r.position;
      if (a === 0)
        continue;
      const l = r.getColor(e.value), c = this.coordinatesConverter.getViewLineNumberOfModelPosition(n.range.startLineNumber, n.range.startColumn), h = this.coordinatesConverter.getViewLineNumberOfModelPosition(n.range.endLineNumber, n.range.endColumn);
      i.accept(l, o.zIndex, c, h, a);
    }
    return i.asArray;
  }
  _invalidateDecorationsColorCache() {
    const e = this.model.getOverviewRulerDecorations();
    for (const t of e) {
      const i = t.options.overviewRuler;
      i == null || i.invalidateCachedColor();
      const n = t.options.minimap;
      n == null || n.invalidateCachedColor();
    }
  }
  getValueInRange(e, t) {
    const i = this.coordinatesConverter.convertViewRangeToModelRange(e);
    return this.model.getValueInRange(i, t);
  }
  getValueLengthInRange(e, t) {
    const i = this.coordinatesConverter.convertViewRangeToModelRange(e);
    return this.model.getValueLengthInRange(i, t);
  }
  modifyPosition(e, t) {
    const i = this.coordinatesConverter.convertViewPositionToModelPosition(e), n = this.model.modifyPosition(i, t);
    return this.coordinatesConverter.convertModelPositionToViewPosition(n);
  }
  deduceModelPositionRelativeToViewPosition(e, t, i) {
    const n = this.coordinatesConverter.convertViewPositionToModelPosition(e);
    this.model.getEOL().length === 2 && (t < 0 ? t -= i : t += i);
    const r = this.model.getOffsetAt(n) + t;
    return this.model.getPositionAt(r);
  }
  getPlainTextToCopy(e, t, i) {
    const n = i ? `\r
` : this.model.getEOL();
    e = e.slice(0), e.sort(T.compareRangesUsingStarts);
    let o = !1, r = !1;
    for (const l of e)
      l.isEmpty() ? o = !0 : r = !0;
    if (!r) {
      if (!t)
        return "";
      const l = e.map((h) => h.startLineNumber);
      let c = "";
      for (let h = 0; h < l.length; h++)
        h > 0 && l[h - 1] === l[h] || (c += this.model.getLineContent(l[h]) + n);
      return c;
    }
    if (o && t) {
      const l = [];
      let c = 0;
      for (const h of e) {
        const d = h.startLineNumber;
        h.isEmpty() ? d !== c && l.push(this.model.getLineContent(d)) : l.push(this.model.getValueInRange(
          h,
          i ? 2 : 0
          /* EndOfLinePreference.TextDefined */
        )), c = d;
      }
      return l.length === 1 ? l[0] : l;
    }
    const a = [];
    for (const l of e)
      l.isEmpty() || a.push(this.model.getValueInRange(
        l,
        i ? 2 : 0
        /* EndOfLinePreference.TextDefined */
      ));
    return a.length === 1 ? a[0] : a;
  }
  getRichTextToCopy(e, t) {
    const i = this.model.getLanguageId();
    if (i === Fs || e.length !== 1)
      return null;
    let n = e[0];
    if (n.isEmpty()) {
      if (!t)
        return null;
      const h = n.startLineNumber;
      n = new T(h, this.model.getLineMinColumn(h), h, this.model.getLineMaxColumn(h));
    }
    const o = this._configuration.options.get(
      50
      /* EditorOption.fontInfo */
    ), r = this._getColorMap(), l = /[:;\\\/<>]/.test(o.fontFamily) || o.fontFamily === Qn.fontFamily;
    let c;
    return l ? c = Qn.fontFamily : (c = o.fontFamily, c = c.replace(/"/g, "'"), /[,']/.test(c) || /[+ ]/.test(c) && (c = `'${c}'`), c = `${c}, ${Qn.fontFamily}`), {
      mode: i,
      html: `<div style="color: ${r[
        1
        /* ColorId.DefaultForeground */
      ]};background-color: ${r[
        2
        /* ColorId.DefaultBackground */
      ]};font-family: ${c};font-weight: ${o.fontWeight};font-size: ${o.fontSize}px;line-height: ${o.lineHeight}px;white-space: pre;">` + this._getHTMLToCopy(n, r) + "</div>"
    };
  }
  _getHTMLToCopy(e, t) {
    const i = e.startLineNumber, n = e.startColumn, o = e.endLineNumber, r = e.endColumn, a = this.getTabSize();
    let l = "";
    for (let c = i; c <= o; c++) {
      const h = this.model.tokenization.getLineTokens(c), d = h.getLineContent(), u = c === i ? n - 1 : 0, f = c === o ? r - 1 : d.length;
      d === "" ? l += "<br>" : l += cY(d, h.inflate(), t, u, f, a, es);
    }
    return l;
  }
  _getColorMap() {
    const e = ii.getColorMap(), t = ["#000000"];
    if (e)
      for (let i = 1, n = e.length; i < n; i++)
        t[i] = j.Format.CSS.formatHex(e[i]);
    return t;
  }
  //#region cursor operations
  getPrimaryCursorState() {
    return this._cursor.getPrimaryCursorState();
  }
  getLastAddedCursorIndex() {
    return this._cursor.getLastAddedCursorIndex();
  }
  getCursorStates() {
    return this._cursor.getCursorStates();
  }
  setCursorStates(e, t, i) {
    return this._withViewEventsCollector((n) => this._cursor.setStates(n, e, t, i));
  }
  getCursorColumnSelectData() {
    return this._cursor.getCursorColumnSelectData();
  }
  getCursorAutoClosedCharacters() {
    return this._cursor.getAutoClosedCharacters();
  }
  setCursorColumnSelectData(e) {
    this._cursor.setCursorColumnSelectData(e);
  }
  getPrevEditOperationType() {
    return this._cursor.getPrevEditOperationType();
  }
  setPrevEditOperationType(e) {
    this._cursor.setPrevEditOperationType(e);
  }
  getSelection() {
    return this._cursor.getSelection();
  }
  getSelections() {
    return this._cursor.getSelections();
  }
  getPosition() {
    return this._cursor.getPrimaryCursorState().modelState.position;
  }
  setSelections(e, t, i = 0) {
    this._withViewEventsCollector((n) => this._cursor.setSelections(n, e, t, i));
  }
  saveCursorState() {
    return this._cursor.saveState();
  }
  restoreCursorState(e) {
    this._withViewEventsCollector((t) => this._cursor.restoreState(t, e));
  }
  _executeCursorEdit(e) {
    if (this._cursor.context.cursorConfig.readOnly) {
      this._eventDispatcher.emitOutgoingEvent(new QZ());
      return;
    }
    this._withViewEventsCollector(e);
  }
  executeEdits(e, t, i) {
    this._executeCursorEdit((n) => this._cursor.executeEdits(n, e, t, i));
  }
  startComposition() {
    this._executeCursorEdit((e) => this._cursor.startComposition(e));
  }
  endComposition(e) {
    this._executeCursorEdit((t) => this._cursor.endComposition(t, e));
  }
  type(e, t) {
    this._executeCursorEdit((i) => this._cursor.type(i, e, t));
  }
  compositionType(e, t, i, n, o) {
    this._executeCursorEdit((r) => this._cursor.compositionType(r, e, t, i, n, o));
  }
  paste(e, t, i, n) {
    this._executeCursorEdit((o) => this._cursor.paste(o, e, t, i, n));
  }
  cut(e) {
    this._executeCursorEdit((t) => this._cursor.cut(t, e));
  }
  executeCommand(e, t) {
    this._executeCursorEdit((i) => this._cursor.executeCommand(i, e, t));
  }
  executeCommands(e, t) {
    this._executeCursorEdit((i) => this._cursor.executeCommands(i, e, t));
  }
  revealAllCursors(e, t, i = !1) {
    this._withViewEventsCollector((n) => this._cursor.revealAll(
      n,
      e,
      i,
      0,
      t,
      0
      /* ScrollType.Smooth */
    ));
  }
  revealPrimaryCursor(e, t, i = !1) {
    this._withViewEventsCollector((n) => this._cursor.revealPrimary(
      n,
      e,
      i,
      0,
      t,
      0
      /* ScrollType.Smooth */
    ));
  }
  revealTopMostCursor(e) {
    const t = this._cursor.getTopMostViewPosition(), i = new T(t.lineNumber, t.column, t.lineNumber, t.column);
    this._withViewEventsCollector((n) => n.emitViewEvent(new Gg(
      e,
      !1,
      i,
      null,
      0,
      !0,
      0
      /* ScrollType.Smooth */
    )));
  }
  revealBottomMostCursor(e) {
    const t = this._cursor.getBottomMostViewPosition(), i = new T(t.lineNumber, t.column, t.lineNumber, t.column);
    this._withViewEventsCollector((n) => n.emitViewEvent(new Gg(
      e,
      !1,
      i,
      null,
      0,
      !0,
      0
      /* ScrollType.Smooth */
    )));
  }
  revealRange(e, t, i, n, o) {
    this._withViewEventsCollector((r) => r.emitViewEvent(new Gg(e, !1, i, null, n, t, o)));
  }
  //#endregion
  //#region viewLayout
  changeWhitespace(e) {
    this.viewLayout.changeWhitespace(e) && (this._eventDispatcher.emitSingleViewEvent(new qZ()), this._eventDispatcher.emitOutgoingEvent(new YZ()));
  }
  //#endregion
  _withViewEventsCollector(e) {
    return this._transactionalTarget.batchChanges(() => {
      try {
        const t = this._eventDispatcher.beginEmitViewEvents();
        return e(t);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
    });
  }
  batchEvents(e) {
    this._withViewEventsCollector(() => {
      e();
    });
  }
  normalizePosition(e, t) {
    return this._lines.normalizePosition(e, t);
  }
  /**
   * Gets the column at which indentation stops at a given line.
   * @internal
  */
  getLineIndentColumn(e) {
    return this._lines.getLineIndentColumn(e);
  }
};
class jI {
  static create(e) {
    const t = e._setTrackedRange(
      null,
      new T(1, 1, 1, 1),
      1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    );
    return new jI(e, 1, !1, t, 0);
  }
  get viewLineNumber() {
    return this._viewLineNumber;
  }
  get isValid() {
    return this._isValid;
  }
  get modelTrackedRange() {
    return this._modelTrackedRange;
  }
  get startLineDelta() {
    return this._startLineDelta;
  }
  constructor(e, t, i, n, o) {
    this._model = e, this._viewLineNumber = t, this._isValid = i, this._modelTrackedRange = n, this._startLineDelta = o;
  }
  dispose() {
    this._model._setTrackedRange(
      this._modelTrackedRange,
      null,
      1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    );
  }
  update(e, t) {
    const i = e.coordinatesConverter.convertViewPositionToModelPosition(new F(t, e.getLineMinColumn(t))), n = e.model._setTrackedRange(
      this._modelTrackedRange,
      new T(i.lineNumber, i.column, i.lineNumber, i.column),
      1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    ), o = e.viewLayout.getVerticalOffsetForLineNumber(t), r = e.viewLayout.getCurrentScrollTop();
    this._viewLineNumber = t, this._isValid = !0, this._modelTrackedRange = n, this._startLineDelta = r - o;
  }
  invalidate() {
    this._isValid = !1;
  }
}
class TY {
  constructor() {
    this._asMap = /* @__PURE__ */ Object.create(null), this.asArray = [];
  }
  accept(e, t, i, n, o) {
    const r = this._asMap[e];
    if (r) {
      const a = r.data, l = a[a.length - 3], c = a[a.length - 1];
      if (l === o && c + 1 >= i) {
        n > c && (a[a.length - 1] = n);
        return;
      }
      a.push(o, i, n);
    } else {
      const a = new Gm(e, t, [o, i, n]);
      this._asMap[e] = a, this.asArray.push(a);
    }
  }
}
class MY {
  constructor() {
    this.hiddenAreas = /* @__PURE__ */ new Map(), this.shouldRecompute = !1, this.ranges = [];
  }
  setHiddenAreas(e, t) {
    const i = this.hiddenAreas.get(e);
    i && UM(i, t) || (this.hiddenAreas.set(e, t), this.shouldRecompute = !0);
  }
  /**
   * The returned array is immutable.
  */
  getMergedRanges() {
    if (!this.shouldRecompute)
      return this.ranges;
    this.shouldRecompute = !1;
    const e = Array.from(this.hiddenAreas.values()).reduce((t, i) => RY(t, i), []);
    return UM(this.ranges, e) ? this.ranges : (this.ranges = e, this.ranges);
  }
}
function RY(s, e) {
  const t = [];
  let i = 0, n = 0;
  for (; i < s.length && n < e.length; ) {
    const o = s[i], r = e[n];
    if (o.endLineNumber < r.startLineNumber - 1)
      t.push(s[i++]);
    else if (r.endLineNumber < o.startLineNumber - 1)
      t.push(e[n++]);
    else {
      const a = Math.min(o.startLineNumber, r.startLineNumber), l = Math.max(o.endLineNumber, r.endLineNumber);
      t.push(new T(a, 1, l, 1)), i++, n++;
    }
  }
  for (; i < s.length; )
    t.push(s[i++]);
  for (; n < e.length; )
    t.push(e[n++]);
  return t;
}
function UM(s, e) {
  if (s.length !== e.length)
    return !1;
  for (let t = 0; t < s.length; t++)
    if (!s[t].equalsRange(e[t]))
      return !1;
  return !0;
}
class $M {
  constructor(e, t) {
    this.viewportStartModelPosition = e, this.startLineDelta = t;
  }
  recoverViewportStart(e, t) {
    if (!this.viewportStartModelPosition)
      return;
    const i = e.convertModelPositionToViewPosition(this.viewportStartModelPosition), n = t.getVerticalOffsetForLineNumber(i.lineNumber);
    t.setScrollPosition(
      { scrollTop: n + this.startLineDelta },
      1
      /* ScrollType.Immediate */
    );
  }
}
class Hf {
  constructor(...e) {
    this._entries = /* @__PURE__ */ new Map();
    for (const [t, i] of e)
      this.set(t, i);
  }
  set(e, t) {
    const i = this._entries.get(e);
    return this._entries.set(e, t), i;
  }
  get(e) {
    return this._entries.get(e);
  }
}
var np;
(function(s) {
  s[s.Ignore = 0] = "Ignore", s[s.Info = 1] = "Info", s[s.Warning = 2] = "Warning", s[s.Error = 3] = "Error";
})(np || (np = {}));
(function(s) {
  const e = "error", t = "warning", i = "warn", n = "info", o = "ignore";
  function r(l) {
    return l ? Zd(e, l) ? s.Error : Zd(t, l) || Zd(i, l) ? s.Warning : Zd(n, l) ? s.Info : s.Ignore : s.Ignore;
  }
  s.fromValue = r;
  function a(l) {
    switch (l) {
      case s.Error:
        return e;
      case s.Warning:
        return t;
      case s.Info:
        return n;
      default:
        return o;
    }
  }
  s.toString = a;
})(np || (np = {}));
const Gt = np;
var qI = Gt;
const cn = Be("notificationService");
class AY {
}
var PY = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, na = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Lc, ph;
let sp = (ph = class extends U {
  //#endregion
  get isSimpleWidget() {
    return this._configuration.isSimpleWidget;
  }
  get contextMenuId() {
    return this._configuration.contextMenuId;
  }
  constructor(e, t, i, n, o, r, a, l, c, h, d, u) {
    super(), this.languageConfigurationService = d, this._deliveryQueue = i8(), this._contributions = this._register(new lG()), this._onDidDispose = this._register(new A()), this.onDidDispose = this._onDidDispose.event, this._onDidChangeModelContent = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelContent = this._onDidChangeModelContent.event, this._onDidChangeModelLanguage = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelLanguage = this._onDidChangeModelLanguage.event, this._onDidChangeModelLanguageConfiguration = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelLanguageConfiguration = this._onDidChangeModelLanguageConfiguration.event, this._onDidChangeModelOptions = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelOptions = this._onDidChangeModelOptions.event, this._onDidChangeModelDecorations = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelDecorations = this._onDidChangeModelDecorations.event, this._onDidChangeModelTokens = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelTokens = this._onDidChangeModelTokens.event, this._onDidChangeConfiguration = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event, this._onWillChangeModel = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onWillChangeModel = this._onWillChangeModel.event, this._onDidChangeModel = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModel = this._onDidChangeModel.event, this._onDidChangeCursorPosition = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeCursorPosition = this._onDidChangeCursorPosition.event, this._onDidChangeCursorSelection = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeCursorSelection = this._onDidChangeCursorSelection.event, this._onDidAttemptReadOnlyEdit = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onDidAttemptReadOnlyEdit = this._onDidAttemptReadOnlyEdit.event, this._onDidLayoutChange = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidLayoutChange = this._onDidLayoutChange.event, this._editorTextFocus = this._register(new KM({ deliveryQueue: this._deliveryQueue })), this.onDidFocusEditorText = this._editorTextFocus.onDidChangeToTrue, this.onDidBlurEditorText = this._editorTextFocus.onDidChangeToFalse, this._editorWidgetFocus = this._register(new KM({ deliveryQueue: this._deliveryQueue })), this.onDidFocusEditorWidget = this._editorWidgetFocus.onDidChangeToTrue, this.onDidBlurEditorWidget = this._editorWidgetFocus.onDidChangeToFalse, this._onWillType = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onWillType = this._onWillType.event, this._onDidType = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onDidType = this._onDidType.event, this._onDidCompositionStart = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onDidCompositionStart = this._onDidCompositionStart.event, this._onDidCompositionEnd = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onDidCompositionEnd = this._onDidCompositionEnd.event, this._onDidPaste = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onDidPaste = this._onDidPaste.event, this._onMouseUp = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onMouseUp = this._onMouseUp.event, this._onMouseDown = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onMouseDown = this._onMouseDown.event, this._onMouseDrag = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onMouseDrag = this._onMouseDrag.event, this._onMouseDrop = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onMouseDrop = this._onMouseDrop.event, this._onMouseDropCanceled = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onMouseDropCanceled = this._onMouseDropCanceled.event, this._onDropIntoEditor = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onDropIntoEditor = this._onDropIntoEditor.event, this._onContextMenu = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onContextMenu = this._onContextMenu.event, this._onMouseMove = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onMouseMove = this._onMouseMove.event, this._onMouseLeave = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onMouseLeave = this._onMouseLeave.event, this._onMouseWheel = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onMouseWheel = this._onMouseWheel.event, this._onKeyUp = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onKeyUp = this._onKeyUp.event, this._onKeyDown = this._register(new Ji(this._contributions, this._deliveryQueue)), this.onKeyDown = this._onKeyDown.event, this._onDidContentSizeChange = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._onDidScrollChange = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidScrollChange = this._onDidScrollChange.event, this._onDidChangeViewZones = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeViewZones = this._onDidChangeViewZones.event, this._onDidChangeHiddenAreas = this._register(new A({ deliveryQueue: this._deliveryQueue })), this.onDidChangeHiddenAreas = this._onDidChangeHiddenAreas.event, this._updateCounter = 0, this._onBeginUpdate = this._register(new A()), this.onBeginUpdate = this._onBeginUpdate.event, this._onEndUpdate = this._register(new A()), this.onEndUpdate = this._onEndUpdate.event, this._actions = /* @__PURE__ */ new Map(), this._bannerDomNode = null, this._dropIntoEditorDecorations = this.createDecorationsCollection(), o.willCreateCodeEditor();
    const f = { ...t };
    this._domElement = e, this._overflowWidgetsDomNode = f.overflowWidgetsDomNode, delete f.overflowWidgetsDomNode, this._id = ++OY, this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes = {}, this._telemetryData = i.telemetryData, this._configuration = this._register(this._createConfiguration(i.isSimpleWidget || !1, i.contextMenuId ?? (i.isSimpleWidget ? et.SimpleEditorContext : et.EditorContext), f, h)), this._register(this._configuration.onDidChange((_) => {
      this._onDidChangeConfiguration.fire(_);
      const b = this._configuration.options;
      if (_.hasChanged(
        146
        /* EditorOption.layoutInfo */
      )) {
        const C = b.get(
          146
          /* EditorOption.layoutInfo */
        );
        this._onDidLayoutChange.fire(C);
      }
    })), this._contextKeyService = this._register(a.createScoped(this._domElement)), this._notificationService = c, this._codeEditorService = o, this._commandService = r, this._themeService = l, this._register(new BY(this, this._contextKeyService)), this._register(new WY(this, this._contextKeyService, u)), this._instantiationService = this._register(n.createChild(new Hf([Fe, this._contextKeyService]))), this._modelData = null, this._focusTracker = new HY(e, this._overflowWidgetsDomNode), this._register(this._focusTracker.onChange(() => {
      this._editorWidgetFocus.setValue(this._focusTracker.hasFocus());
    })), this._contentWidgets = {}, this._overlayWidgets = {}, this._glyphMarginWidgets = {};
    let g;
    Array.isArray(i.contributions) ? g = i.contributions : g = Tu.getEditorContributions(), this._contributions.initialize(this, g, this._instantiationService);
    for (const _ of Tu.getEditorActions()) {
      if (this._actions.has(_.id)) {
        Je(new Error(`Cannot have two actions with the same id ${_.id}`));
        continue;
      }
      const b = new nF(_.id, _.label, _.alias, _.metadata, _.precondition ?? void 0, (C) => this._instantiationService.invokeFunction((w) => Promise.resolve(_.runEditorCommand(w, this, C))), this._contextKeyService);
      this._actions.set(b.id, b);
    }
    const p = () => !this._configuration.options.get(
      92
      /* EditorOption.readOnly */
    ) && this._configuration.options.get(
      36
      /* EditorOption.dropIntoEditor */
    ).enabled;
    this._register(new lB(this._domElement, {
      onDragOver: (_) => {
        if (!p())
          return;
        const b = this.getTargetAtClientPoint(_.clientX, _.clientY);
        b != null && b.position && this.showDropIndicatorAt(b.position);
      },
      onDrop: async (_) => {
        if (!p() || (this.removeDropIndicator(), !_.dataTransfer))
          return;
        const b = this.getTargetAtClientPoint(_.clientX, _.clientY);
        b != null && b.position && this._onDropIntoEditor.fire({ position: b.position, event: _ });
      },
      onDragLeave: () => {
        this.removeDropIndicator();
      },
      onDragEnd: () => {
        this.removeDropIndicator();
      }
    })), this._codeEditorService.addCodeEditor(this);
  }
  writeScreenReaderContent(e) {
    var t;
    (t = this._modelData) == null || t.view.writeScreenReaderContent(e);
  }
  _createConfiguration(e, t, i, n) {
    return new xS(e, t, i, this._domElement, n);
  }
  getId() {
    return this.getEditorType() + ":" + this._id;
  }
  getEditorType() {
    return Iw.ICodeEditor;
  }
  dispose() {
    this._codeEditorService.removeCodeEditor(this), this._focusTracker.dispose(), this._actions.clear(), this._contentWidgets = {}, this._overlayWidgets = {}, this._removeDecorationTypes(), this._postDetachModelCleanup(this._detachModel()), this._onDidDispose.fire(), super.dispose();
  }
  invokeWithinContext(e) {
    return this._instantiationService.invokeFunction(e);
  }
  updateOptions(e) {
    this._configuration.updateOptions(e || {});
  }
  getOptions() {
    return this._configuration.options;
  }
  getOption(e) {
    return this._configuration.options.get(e);
  }
  getRawOptions() {
    return this._configuration.getRawOptions();
  }
  getOverflowWidgetsDomNode() {
    return this._overflowWidgetsDomNode;
  }
  getConfiguredWordAtPosition(e) {
    return this._modelData ? Jt.getWordAtPosition(this._modelData.model, this._configuration.options.get(
      132
      /* EditorOption.wordSeparators */
    ), this._configuration.options.get(
      131
      /* EditorOption.wordSegmenterLocales */
    ), e) : null;
  }
  getValue(e = null) {
    if (!this._modelData)
      return "";
    const t = !!(e && e.preserveBOM);
    let i = 0;
    return e && e.lineEnding && e.lineEnding === `
` ? i = 1 : e && e.lineEnding && e.lineEnding === `\r
` && (i = 2), this._modelData.model.getValue(i, t);
  }
  setValue(e) {
    try {
      if (this._beginUpdate(), !this._modelData)
        return;
      this._modelData.model.setValue(e);
    } finally {
      this._endUpdate();
    }
  }
  getModel() {
    return this._modelData ? this._modelData.model : null;
  }
  setModel(e = null) {
    var t;
    try {
      this._beginUpdate();
      const i = e;
      if (this._modelData === null && i === null || this._modelData && this._modelData.model === i)
        return;
      const n = {
        oldModelUrl: ((t = this._modelData) == null ? void 0 : t.model.uri) || null,
        newModelUrl: (i == null ? void 0 : i.uri) || null
      };
      this._onWillChangeModel.fire(n);
      const o = this.hasTextFocus(), r = this._detachModel();
      this._attachModel(i), o && this.hasModel() && this.focus(), this._removeDecorationTypes(), this._onDidChangeModel.fire(n), this._postDetachModelCleanup(r), this._contributionsDisposable = this._contributions.onAfterModelAttached();
    } finally {
      this._endUpdate();
    }
  }
  _removeDecorationTypes() {
    if (this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes) {
      for (const e in this._decorationTypeSubtypes) {
        const t = this._decorationTypeSubtypes[e];
        for (const i in t)
          this._removeDecorationType(e + "-" + i);
      }
      this._decorationTypeSubtypes = {};
    }
  }
  getVisibleRanges() {
    return this._modelData ? this._modelData.viewModel.getVisibleRanges() : [];
  }
  getVisibleRangesPlusViewportAboveBelow() {
    return this._modelData ? this._modelData.viewModel.getVisibleRangesPlusViewportAboveBelow() : [];
  }
  getWhitespaces() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getWhitespaces() : [];
  }
  static _getVerticalOffsetAfterPosition(e, t, i, n) {
    const o = e.model.validatePosition({
      lineNumber: t,
      column: i
    }), r = e.viewModel.coordinatesConverter.convertModelPositionToViewPosition(o);
    return e.viewModel.viewLayout.getVerticalOffsetAfterLineNumber(r.lineNumber, n);
  }
  getTopForLineNumber(e, t = !1) {
    return this._modelData ? Lc._getVerticalOffsetForPosition(this._modelData, e, 1, t) : -1;
  }
  getTopForPosition(e, t) {
    return this._modelData ? Lc._getVerticalOffsetForPosition(this._modelData, e, t, !1) : -1;
  }
  static _getVerticalOffsetForPosition(e, t, i, n = !1) {
    const o = e.model.validatePosition({
      lineNumber: t,
      column: i
    }), r = e.viewModel.coordinatesConverter.convertModelPositionToViewPosition(o);
    return e.viewModel.viewLayout.getVerticalOffsetForLineNumber(r.lineNumber, n);
  }
  getBottomForLineNumber(e, t = !1) {
    if (!this._modelData)
      return -1;
    const i = this._modelData.model.getLineMaxColumn(e);
    return Lc._getVerticalOffsetAfterPosition(this._modelData, e, i, t);
  }
  setHiddenAreas(e, t) {
    var i;
    (i = this._modelData) == null || i.viewModel.setHiddenAreas(e.map((n) => T.lift(n)), t);
  }
  getVisibleColumnFromPosition(e) {
    if (!this._modelData)
      return e.column;
    const t = this._modelData.model.validatePosition(e), i = this._modelData.model.getOptions().tabSize;
    return pi.visibleColumnFromColumn(this._modelData.model.getLineContent(t.lineNumber), t.column, i) + 1;
  }
  getPosition() {
    return this._modelData ? this._modelData.viewModel.getPosition() : null;
  }
  setPosition(e, t = "api") {
    if (this._modelData) {
      if (!F.isIPosition(e))
        throw new Error("Invalid arguments");
      this._modelData.viewModel.setSelections(t, [{
        selectionStartLineNumber: e.lineNumber,
        selectionStartColumn: e.column,
        positionLineNumber: e.lineNumber,
        positionColumn: e.column
      }]);
    }
  }
  _sendRevealRange(e, t, i, n) {
    if (!this._modelData)
      return;
    if (!T.isIRange(e))
      throw new Error("Invalid arguments");
    const o = this._modelData.model.validateRange(e), r = this._modelData.viewModel.coordinatesConverter.convertModelRangeToViewRange(o);
    this._modelData.viewModel.revealRange("api", i, r, t, n);
  }
  revealLine(e, t = 0) {
    this._revealLine(e, 0, t);
  }
  revealLineInCenter(e, t = 0) {
    this._revealLine(e, 1, t);
  }
  revealLineInCenterIfOutsideViewport(e, t = 0) {
    this._revealLine(e, 2, t);
  }
  revealLineNearTop(e, t = 0) {
    this._revealLine(e, 5, t);
  }
  _revealLine(e, t, i) {
    if (typeof e != "number")
      throw new Error("Invalid arguments");
    this._sendRevealRange(new T(e, 1, e, 1), t, !1, i);
  }
  revealPosition(e, t = 0) {
    this._revealPosition(e, 0, !0, t);
  }
  revealPositionInCenter(e, t = 0) {
    this._revealPosition(e, 1, !0, t);
  }
  revealPositionInCenterIfOutsideViewport(e, t = 0) {
    this._revealPosition(e, 2, !0, t);
  }
  revealPositionNearTop(e, t = 0) {
    this._revealPosition(e, 5, !0, t);
  }
  _revealPosition(e, t, i, n) {
    if (!F.isIPosition(e))
      throw new Error("Invalid arguments");
    this._sendRevealRange(new T(e.lineNumber, e.column, e.lineNumber, e.column), t, i, n);
  }
  getSelection() {
    return this._modelData ? this._modelData.viewModel.getSelection() : null;
  }
  getSelections() {
    return this._modelData ? this._modelData.viewModel.getSelections() : null;
  }
  setSelection(e, t = "api") {
    const i = Ue.isISelection(e), n = T.isIRange(e);
    if (!i && !n)
      throw new Error("Invalid arguments");
    if (i)
      this._setSelectionImpl(e, t);
    else if (n) {
      const o = {
        selectionStartLineNumber: e.startLineNumber,
        selectionStartColumn: e.startColumn,
        positionLineNumber: e.endLineNumber,
        positionColumn: e.endColumn
      };
      this._setSelectionImpl(o, t);
    }
  }
  _setSelectionImpl(e, t) {
    if (!this._modelData)
      return;
    const i = new Ue(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
    this._modelData.viewModel.setSelections(t, [i]);
  }
  revealLines(e, t, i = 0) {
    this._revealLines(e, t, 0, i);
  }
  revealLinesInCenter(e, t, i = 0) {
    this._revealLines(e, t, 1, i);
  }
  revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
    this._revealLines(e, t, 2, i);
  }
  revealLinesNearTop(e, t, i = 0) {
    this._revealLines(e, t, 5, i);
  }
  _revealLines(e, t, i, n) {
    if (typeof e != "number" || typeof t != "number")
      throw new Error("Invalid arguments");
    this._sendRevealRange(new T(e, 1, t, 1), i, !1, n);
  }
  revealRange(e, t = 0, i = !1, n = !0) {
    this._revealRange(e, i ? 1 : 0, n, t);
  }
  revealRangeInCenter(e, t = 0) {
    this._revealRange(e, 1, !0, t);
  }
  revealRangeInCenterIfOutsideViewport(e, t = 0) {
    this._revealRange(e, 2, !0, t);
  }
  revealRangeNearTop(e, t = 0) {
    this._revealRange(e, 5, !0, t);
  }
  revealRangeNearTopIfOutsideViewport(e, t = 0) {
    this._revealRange(e, 6, !0, t);
  }
  revealRangeAtTop(e, t = 0) {
    this._revealRange(e, 3, !0, t);
  }
  _revealRange(e, t, i, n) {
    if (!T.isIRange(e))
      throw new Error("Invalid arguments");
    this._sendRevealRange(T.lift(e), t, i, n);
  }
  setSelections(e, t = "api", i = 0) {
    if (this._modelData) {
      if (!e || e.length === 0)
        throw new Error("Invalid arguments");
      for (let n = 0, o = e.length; n < o; n++)
        if (!Ue.isISelection(e[n]))
          throw new Error("Invalid arguments");
      this._modelData.viewModel.setSelections(t, e, i);
    }
  }
  getContentWidth() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getContentWidth() : -1;
  }
  getScrollWidth() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getScrollWidth() : -1;
  }
  getScrollLeft() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollLeft() : -1;
  }
  getContentHeight() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getContentHeight() : -1;
  }
  getScrollHeight() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getScrollHeight() : -1;
  }
  getScrollTop() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollTop() : -1;
  }
  setScrollLeft(e, t = 1) {
    if (this._modelData) {
      if (typeof e != "number")
        throw new Error("Invalid arguments");
      this._modelData.viewModel.viewLayout.setScrollPosition({
        scrollLeft: e
      }, t);
    }
  }
  setScrollTop(e, t = 1) {
    if (this._modelData) {
      if (typeof e != "number")
        throw new Error("Invalid arguments");
      this._modelData.viewModel.viewLayout.setScrollPosition({
        scrollTop: e
      }, t);
    }
  }
  setScrollPosition(e, t = 1) {
    this._modelData && this._modelData.viewModel.viewLayout.setScrollPosition(e, t);
  }
  hasPendingScrollAnimation() {
    return this._modelData ? this._modelData.viewModel.viewLayout.hasPendingScrollAnimation() : !1;
  }
  saveViewState() {
    if (!this._modelData)
      return null;
    const e = this._contributions.saveViewState(), t = this._modelData.viewModel.saveCursorState(), i = this._modelData.viewModel.saveState();
    return {
      cursorState: t,
      viewState: i,
      contributionsState: e
    };
  }
  restoreViewState(e) {
    if (!this._modelData || !this._modelData.hasRealView)
      return;
    const t = e;
    if (t && t.cursorState && t.viewState) {
      const i = t.cursorState;
      Array.isArray(i) ? i.length > 0 && this._modelData.viewModel.restoreCursorState(i) : this._modelData.viewModel.restoreCursorState([i]), this._contributions.restoreViewState(t.contributionsState || {});
      const n = this._modelData.viewModel.reduceRestoreState(t.viewState);
      this._modelData.view.restoreState(n);
    }
  }
  handleInitialized() {
    var e;
    (e = this._getViewModel()) == null || e.visibleLinesStabilized();
  }
  getContribution(e) {
    return this._contributions.get(e);
  }
  getActions() {
    return Array.from(this._actions.values());
  }
  getSupportedActions() {
    let e = this.getActions();
    return e = e.filter((t) => t.isSupported()), e;
  }
  getAction(e) {
    return this._actions.get(e) || null;
  }
  trigger(e, t, i) {
    i = i || {};
    try {
      switch (this._beginUpdate(), t) {
        case "compositionStart":
          this._startComposition();
          return;
        case "compositionEnd":
          this._endComposition(e);
          return;
        case "type": {
          const o = i;
          this._type(e, o.text || "");
          return;
        }
        case "replacePreviousChar": {
          const o = i;
          this._compositionType(e, o.text || "", o.replaceCharCnt || 0, 0, 0);
          return;
        }
        case "compositionType": {
          const o = i;
          this._compositionType(e, o.text || "", o.replacePrevCharCnt || 0, o.replaceNextCharCnt || 0, o.positionDelta || 0);
          return;
        }
        case "paste": {
          const o = i;
          this._paste(e, o.text || "", o.pasteOnNewLine || !1, o.multicursorText || null, o.mode || null, o.clipboardEvent);
          return;
        }
        case "cut":
          this._cut(e);
          return;
      }
      const n = this.getAction(t);
      if (n) {
        Promise.resolve(n.run(i)).then(void 0, Je);
        return;
      }
      if (!this._modelData || this._triggerEditorCommand(e, t, i))
        return;
      this._triggerCommand(t, i);
    } finally {
      this._endUpdate();
    }
  }
  _triggerCommand(e, t) {
    this._commandService.executeCommand(e, t);
  }
  _startComposition() {
    this._modelData && (this._modelData.viewModel.startComposition(), this._onDidCompositionStart.fire());
  }
  _endComposition(e) {
    this._modelData && (this._modelData.viewModel.endComposition(e), this._onDidCompositionEnd.fire());
  }
  _type(e, t) {
    !this._modelData || t.length === 0 || (e === "keyboard" && this._onWillType.fire(t), this._modelData.viewModel.type(t, e), e === "keyboard" && this._onDidType.fire(t));
  }
  _compositionType(e, t, i, n, o) {
    this._modelData && this._modelData.viewModel.compositionType(t, i, n, o, e);
  }
  _paste(e, t, i, n, o, r) {
    if (!this._modelData)
      return;
    const a = this._modelData.viewModel, l = a.getSelection().getStartPosition();
    a.paste(t, i, n, e);
    const c = a.getSelection().getStartPosition();
    e === "keyboard" && this._onDidPaste.fire({
      clipboardEvent: r,
      range: new T(l.lineNumber, l.column, c.lineNumber, c.column),
      languageId: o
    });
  }
  _cut(e) {
    this._modelData && this._modelData.viewModel.cut(e);
  }
  _triggerEditorCommand(e, t, i) {
    const n = Tu.getEditorCommand(t);
    return n ? (i = i || {}, i.source = e, this._instantiationService.invokeFunction((o) => {
      Promise.resolve(n.runEditorCommand(o, this, i)).then(void 0, Je);
    }), !0) : !1;
  }
  _getViewModel() {
    return this._modelData ? this._modelData.viewModel : null;
  }
  pushUndoStop() {
    return !this._modelData || this._configuration.options.get(
      92
      /* EditorOption.readOnly */
    ) ? !1 : (this._modelData.model.pushStackElement(), !0);
  }
  popUndoStop() {
    return !this._modelData || this._configuration.options.get(
      92
      /* EditorOption.readOnly */
    ) ? !1 : (this._modelData.model.popStackElement(), !0);
  }
  executeEdits(e, t, i) {
    if (!this._modelData || this._configuration.options.get(
      92
      /* EditorOption.readOnly */
    ))
      return !1;
    let n;
    return i ? Array.isArray(i) ? n = () => i : n = i : n = () => null, this._modelData.viewModel.executeEdits(e, t, n), !0;
  }
  executeCommand(e, t) {
    this._modelData && this._modelData.viewModel.executeCommand(t, e);
  }
  executeCommands(e, t) {
    this._modelData && this._modelData.viewModel.executeCommands(t, e);
  }
  createDecorationsCollection(e) {
    return new VY(this, e);
  }
  changeDecorations(e) {
    return this._modelData ? this._modelData.model.changeDecorations(e, this._id) : null;
  }
  getLineDecorations(e) {
    return this._modelData ? this._modelData.model.getLineDecorations(e, this._id, r1(this._configuration.options)) : null;
  }
  getDecorationsInRange(e) {
    return this._modelData ? this._modelData.model.getDecorationsInRange(e, this._id, r1(this._configuration.options)) : null;
  }
  /**
   * @deprecated
   */
  deltaDecorations(e, t) {
    return this._modelData ? e.length === 0 && t.length === 0 ? e : this._modelData.model.deltaDecorations(e, t, this._id) : [];
  }
  removeDecorations(e) {
    !this._modelData || e.length === 0 || this._modelData.model.changeDecorations((t) => {
      t.deltaDecorations(e, []);
    });
  }
  removeDecorationsByType(e) {
    const t = this._decorationTypeKeysToIds[e];
    t && this.changeDecorations((i) => i.deltaDecorations(t, [])), this._decorationTypeKeysToIds.hasOwnProperty(e) && delete this._decorationTypeKeysToIds[e], this._decorationTypeSubtypes.hasOwnProperty(e) && delete this._decorationTypeSubtypes[e];
  }
  getLayoutInfo() {
    return this._configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
  }
  createOverviewRuler(e) {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.createOverviewRuler(e);
  }
  getContainerDomNode() {
    return this._domElement;
  }
  getDomNode() {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.domNode.domNode;
  }
  delegateVerticalScrollbarPointerDown(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.delegateVerticalScrollbarPointerDown(e);
  }
  delegateScrollFromMouseWheelEvent(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.delegateScrollFromMouseWheelEvent(e);
  }
  layout(e, t = !1) {
    this._configuration.observeContainer(e), t || this.render();
  }
  focus() {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.focus();
  }
  hasTextFocus() {
    return !this._modelData || !this._modelData.hasRealView ? !1 : this._modelData.view.isFocused();
  }
  hasWidgetFocus() {
    return this._focusTracker && this._focusTracker.hasFocus();
  }
  addContentWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._contentWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting a content widget with the same id:" + e.getId()), this._contentWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addContentWidget(t);
  }
  layoutContentWidget(e) {
    const t = e.getId();
    if (this._contentWidgets.hasOwnProperty(t)) {
      const i = this._contentWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutContentWidget(i);
    }
  }
  removeContentWidget(e) {
    const t = e.getId();
    if (this._contentWidgets.hasOwnProperty(t)) {
      const i = this._contentWidgets[t];
      delete this._contentWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeContentWidget(i);
    }
  }
  addOverlayWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._overlayWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting an overlay widget with the same id."), this._overlayWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addOverlayWidget(t);
  }
  layoutOverlayWidget(e) {
    const t = e.getId();
    if (this._overlayWidgets.hasOwnProperty(t)) {
      const i = this._overlayWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutOverlayWidget(i);
    }
  }
  removeOverlayWidget(e) {
    const t = e.getId();
    if (this._overlayWidgets.hasOwnProperty(t)) {
      const i = this._overlayWidgets[t];
      delete this._overlayWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeOverlayWidget(i);
    }
  }
  addGlyphMarginWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._glyphMarginWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting a glyph margin widget with the same id."), this._glyphMarginWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addGlyphMarginWidget(t);
  }
  layoutGlyphMarginWidget(e) {
    const t = e.getId();
    if (this._glyphMarginWidgets.hasOwnProperty(t)) {
      const i = this._glyphMarginWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutGlyphMarginWidget(i);
    }
  }
  removeGlyphMarginWidget(e) {
    const t = e.getId();
    if (this._glyphMarginWidgets.hasOwnProperty(t)) {
      const i = this._glyphMarginWidgets[t];
      delete this._glyphMarginWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeGlyphMarginWidget(i);
    }
  }
  changeViewZones(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.change(e);
  }
  getTargetAtClientPoint(e, t) {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.getTargetAtClientPoint(e, t);
  }
  getScrolledVisiblePosition(e) {
    if (!this._modelData || !this._modelData.hasRealView)
      return null;
    const t = this._modelData.model.validatePosition(e), i = this._configuration.options, n = i.get(
      146
      /* EditorOption.layoutInfo */
    ), o = Lc._getVerticalOffsetForPosition(this._modelData, t.lineNumber, t.column) - this.getScrollTop(), r = this._modelData.view.getOffsetForColumn(t.lineNumber, t.column) + n.glyphMarginWidth + n.lineNumbersWidth + n.decorationsWidth - this.getScrollLeft();
    return {
      top: o,
      left: r,
      height: i.get(
        67
        /* EditorOption.lineHeight */
      )
    };
  }
  getOffsetForColumn(e, t) {
    return !this._modelData || !this._modelData.hasRealView ? -1 : this._modelData.view.getOffsetForColumn(e, t);
  }
  render(e = !1) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.viewModel.batchEvents(() => {
      this._modelData.view.render(!0, e);
    });
  }
  setAriaOptions(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.setAriaOptions(e);
  }
  applyFontInfo(e) {
    Zi(e, this._configuration.options.get(
      50
      /* EditorOption.fontInfo */
    ));
  }
  setBanner(e, t) {
    this._bannerDomNode && this._domElement.contains(this._bannerDomNode) && this._bannerDomNode.remove(), this._bannerDomNode = e, this._configuration.setReservedHeight(e ? t : 0), this._bannerDomNode && this._domElement.prepend(this._bannerDomNode);
  }
  _attachModel(e) {
    if (!e) {
      this._modelData = null;
      return;
    }
    const t = [];
    this._domElement.setAttribute("data-mode-id", e.getLanguageId()), this._configuration.setIsDominatedByLongLines(e.isDominatedByLongLines()), this._configuration.setModelLineCount(e.getLineCount());
    const i = e.onBeforeAttached(), n = new NY(this._id, this._configuration, e, EI.create(fe(this._domElement)), zI.create(this._configuration.options), (a) => ns(fe(this._domElement), a), this.languageConfigurationService, this._themeService, i, {
      batchChanges: (a) => {
        try {
          return this._beginUpdate(), a();
        } finally {
          this._endUpdate();
        }
      }
    });
    t.push(e.onWillDispose(() => this.setModel(null))), t.push(n.onEvent((a) => {
      switch (a.kind) {
        case 0:
          this._onDidContentSizeChange.fire(a);
          break;
        case 1:
          this._editorTextFocus.setValue(a.hasFocus);
          break;
        case 2:
          this._onDidScrollChange.fire(a);
          break;
        case 3:
          this._onDidChangeViewZones.fire();
          break;
        case 4:
          this._onDidChangeHiddenAreas.fire();
          break;
        case 5:
          this._onDidAttemptReadOnlyEdit.fire();
          break;
        case 6: {
          if (a.reachedMaxCursorCount) {
            const d = this.getOption(
              80
              /* EditorOption.multiCursorLimit */
            ), u = m("cursors.maximum", "The number of cursors has been limited to {0}. Consider using [find and replace](https://code.visualstudio.com/docs/editor/codebasics#_find-and-replace) for larger changes or increase the editor multi cursor limit setting.", d);
            this._notificationService.prompt(qI.Warning, u, [
              {
                label: "Find and Replace",
                run: () => {
                  this._commandService.executeCommand("editor.action.startFindReplaceAction");
                }
              },
              {
                label: m("goToSetting", "Increase Multi Cursor Limit"),
                run: () => {
                  this._commandService.executeCommand("workbench.action.openSettings2", {
                    query: "editor.multiCursorLimit"
                  });
                }
              }
            ]);
          }
          const l = [];
          for (let d = 0, u = a.selections.length; d < u; d++)
            l[d] = a.selections[d].getPosition();
          const c = {
            position: l[0],
            secondaryPositions: l.slice(1),
            reason: a.reason,
            source: a.source
          };
          this._onDidChangeCursorPosition.fire(c);
          const h = {
            selection: a.selections[0],
            secondarySelections: a.selections.slice(1),
            modelVersionId: a.modelVersionId,
            oldSelections: a.oldSelections,
            oldModelVersionId: a.oldModelVersionId,
            source: a.source,
            reason: a.reason
          };
          this._onDidChangeCursorSelection.fire(h);
          break;
        }
        case 7:
          this._onDidChangeModelDecorations.fire(a.event);
          break;
        case 8:
          this._domElement.setAttribute("data-mode-id", e.getLanguageId()), this._onDidChangeModelLanguage.fire(a.event);
          break;
        case 9:
          this._onDidChangeModelLanguageConfiguration.fire(a.event);
          break;
        case 10:
          this._onDidChangeModelContent.fire(a.event);
          break;
        case 11:
          this._onDidChangeModelOptions.fire(a.event);
          break;
        case 12:
          this._onDidChangeModelTokens.fire(a.event);
          break;
      }
    }));
    const [o, r] = this._createView(n);
    if (r) {
      this._domElement.appendChild(o.domNode.domNode);
      let a = Object.keys(this._contentWidgets);
      for (let l = 0, c = a.length; l < c; l++) {
        const h = a[l];
        o.addContentWidget(this._contentWidgets[h]);
      }
      a = Object.keys(this._overlayWidgets);
      for (let l = 0, c = a.length; l < c; l++) {
        const h = a[l];
        o.addOverlayWidget(this._overlayWidgets[h]);
      }
      a = Object.keys(this._glyphMarginWidgets);
      for (let l = 0, c = a.length; l < c; l++) {
        const h = a[l];
        o.addGlyphMarginWidget(this._glyphMarginWidgets[h]);
      }
      o.render(!1, !0), o.domNode.domNode.setAttribute("data-uri", e.uri.toString());
    }
    this._modelData = new FY(e, n, o, r, t, i);
  }
  _createView(e) {
    let t;
    this.isSimpleWidget ? t = {
      paste: (o, r, a, l) => {
        this._paste("keyboard", o, r, a, l);
      },
      type: (o) => {
        this._type("keyboard", o);
      },
      compositionType: (o, r, a, l) => {
        this._compositionType("keyboard", o, r, a, l);
      },
      startComposition: () => {
        this._startComposition();
      },
      endComposition: () => {
        this._endComposition("keyboard");
      },
      cut: () => {
        this._cut("keyboard");
      }
    } : t = {
      paste: (o, r, a, l) => {
        const c = { text: o, pasteOnNewLine: r, multicursorText: a, mode: l };
        this._commandService.executeCommand("paste", c);
      },
      type: (o) => {
        const r = { text: o };
        this._commandService.executeCommand("type", r);
      },
      compositionType: (o, r, a, l) => {
        if (a || l) {
          const c = { text: o, replacePrevCharCnt: r, replaceNextCharCnt: a, positionDelta: l };
          this._commandService.executeCommand("compositionType", c);
        } else {
          const c = { text: o, replaceCharCnt: r };
          this._commandService.executeCommand("replacePreviousChar", c);
        }
      },
      startComposition: () => {
        this._commandService.executeCommand("compositionStart", {});
      },
      endComposition: () => {
        this._commandService.executeCommand("compositionEnd", {});
      },
      cut: () => {
        this._commandService.executeCommand("cut", {});
      }
    };
    const i = new Ew(e.coordinatesConverter);
    return i.onKeyDown = (o) => this._onKeyDown.fire(o), i.onKeyUp = (o) => this._onKeyUp.fire(o), i.onContextMenu = (o) => this._onContextMenu.fire(o), i.onMouseMove = (o) => this._onMouseMove.fire(o), i.onMouseLeave = (o) => this._onMouseLeave.fire(o), i.onMouseDown = (o) => this._onMouseDown.fire(o), i.onMouseUp = (o) => this._onMouseUp.fire(o), i.onMouseDrag = (o) => this._onMouseDrag.fire(o), i.onMouseDrop = (o) => this._onMouseDrop.fire(o), i.onMouseDropCanceled = (o) => this._onMouseDropCanceled.fire(o), i.onMouseWheel = (o) => this._onMouseWheel.fire(o), [new oL(t, this._configuration, this._themeService.getColorTheme(), e, i, this._overflowWidgetsDomNode, this._instantiationService), !0];
  }
  _postDetachModelCleanup(e) {
    e == null || e.removeAllDecorationsWithOwnerId(this._id);
  }
  _detachModel() {
    var i;
    if ((i = this._contributionsDisposable) == null || i.dispose(), this._contributionsDisposable = void 0, !this._modelData)
      return null;
    const e = this._modelData.model, t = this._modelData.hasRealView ? this._modelData.view.domNode.domNode : null;
    return this._modelData.dispose(), this._modelData = null, this._domElement.removeAttribute("data-mode-id"), t && this._domElement.contains(t) && t.remove(), this._bannerDomNode && this._domElement.contains(this._bannerDomNode) && this._bannerDomNode.remove(), e;
  }
  _removeDecorationType(e) {
    this._codeEditorService.removeDecorationType(e);
  }
  hasModel() {
    return this._modelData !== null;
  }
  showDropIndicatorAt(e) {
    const t = [{
      range: new T(e.lineNumber, e.column, e.lineNumber, e.column),
      options: Lc.dropIntoEditorDecorationOptions
    }];
    this._dropIntoEditorDecorations.set(t), this.revealPosition(
      e,
      1
      /* editorCommon.ScrollType.Immediate */
    );
  }
  removeDropIndicator() {
    this._dropIntoEditorDecorations.clear();
  }
  setContextValue(e, t) {
    this._contextKeyService.createKey(e, t);
  }
  _beginUpdate() {
    this._updateCounter++, this._updateCounter === 1 && this._onBeginUpdate.fire();
  }
  _endUpdate() {
    this._updateCounter--, this._updateCounter === 0 && this._onEndUpdate.fire();
  }
}, Lc = ph, ph.dropIntoEditorDecorationOptions = Wt.register({
  description: "workbench-dnd-target",
  className: "dnd-target"
}), ph);
sp = Lc = PY([
  na(3, Pe),
  na(4, Tt),
  na(5, fi),
  na(6, Fe),
  na(7, wn),
  na(8, cn),
  na(9, Ks),
  na(10, ir),
  na(11, De)
], sp);
let OY = 0, FY = class {
  constructor(e, t, i, n, o, r) {
    this.model = e, this.viewModel = t, this.view = i, this.hasRealView = n, this.listenersToRemove = o, this.attachedView = r;
  }
  dispose() {
    Ft(this.listenersToRemove), this.model.onBeforeDetached(this.attachedView), this.hasRealView && this.view.dispose(), this.viewModel.dispose();
  }
};
class KM extends U {
  constructor(e) {
    super(), this._emitterOptions = e, this._onDidChangeToTrue = this._register(new A(this._emitterOptions)), this.onDidChangeToTrue = this._onDidChangeToTrue.event, this._onDidChangeToFalse = this._register(new A(this._emitterOptions)), this.onDidChangeToFalse = this._onDidChangeToFalse.event, this._value = 0;
  }
  setValue(e) {
    const t = e ? 2 : 1;
    this._value !== t && (this._value = t, this._value === 2 ? this._onDidChangeToTrue.fire() : this._value === 1 && this._onDidChangeToFalse.fire());
  }
}
class Ji extends A {
  constructor(e, t) {
    super({ deliveryQueue: t }), this._contributions = e;
  }
  fire(e) {
    this._contributions.onBeforeInteractionEvent(), super.fire(e);
  }
}
class BY extends U {
  constructor(e, t) {
    super(), this._editor = e, t.createKey("editorId", e.getId()), this._editorSimpleInput = Z.editorSimpleInput.bindTo(t), this._editorFocus = Z.focus.bindTo(t), this._textInputFocus = Z.textInputFocus.bindTo(t), this._editorTextFocus = Z.editorTextFocus.bindTo(t), this._tabMovesFocus = Z.tabMovesFocus.bindTo(t), this._editorReadonly = Z.readOnly.bindTo(t), this._inDiffEditor = Z.inDiffEditor.bindTo(t), this._editorColumnSelection = Z.columnSelection.bindTo(t), this._hasMultipleSelections = Z.hasMultipleSelections.bindTo(t), this._hasNonEmptySelection = Z.hasNonEmptySelection.bindTo(t), this._canUndo = Z.canUndo.bindTo(t), this._canRedo = Z.canRedo.bindTo(t), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromConfig())), this._register(this._editor.onDidChangeCursorSelection(() => this._updateFromSelection())), this._register(this._editor.onDidFocusEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidFocusEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidChangeModel(() => this._updateFromModel())), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromModel())), this._register(a1.onDidChangeTabFocus((i) => this._tabMovesFocus.set(i))), this._updateFromConfig(), this._updateFromSelection(), this._updateFromFocus(), this._updateFromModel(), this._editorSimpleInput.set(this._editor.isSimpleWidget);
  }
  _updateFromConfig() {
    const e = this._editor.getOptions();
    this._tabMovesFocus.set(a1.getTabFocusMode()), this._editorReadonly.set(e.get(
      92
      /* EditorOption.readOnly */
    )), this._inDiffEditor.set(e.get(
      61
      /* EditorOption.inDiffEditor */
    )), this._editorColumnSelection.set(e.get(
      22
      /* EditorOption.columnSelection */
    ));
  }
  _updateFromSelection() {
    const e = this._editor.getSelections();
    e ? (this._hasMultipleSelections.set(e.length > 1), this._hasNonEmptySelection.set(e.some((t) => !t.isEmpty()))) : (this._hasMultipleSelections.reset(), this._hasNonEmptySelection.reset());
  }
  _updateFromFocus() {
    this._editorFocus.set(this._editor.hasWidgetFocus() && !this._editor.isSimpleWidget), this._editorTextFocus.set(this._editor.hasTextFocus() && !this._editor.isSimpleWidget), this._textInputFocus.set(this._editor.hasTextFocus());
  }
  _updateFromModel() {
    const e = this._editor.getModel();
    this._canUndo.set(!!(e && e.canUndo())), this._canRedo.set(!!(e && e.canRedo()));
  }
}
class WY extends U {
  constructor(e, t, i) {
    super(), this._editor = e, this._contextKeyService = t, this._languageFeaturesService = i, this._langId = Z.languageId.bindTo(t), this._hasCompletionItemProvider = Z.hasCompletionItemProvider.bindTo(t), this._hasCodeActionsProvider = Z.hasCodeActionsProvider.bindTo(t), this._hasCodeLensProvider = Z.hasCodeLensProvider.bindTo(t), this._hasDefinitionProvider = Z.hasDefinitionProvider.bindTo(t), this._hasDeclarationProvider = Z.hasDeclarationProvider.bindTo(t), this._hasImplementationProvider = Z.hasImplementationProvider.bindTo(t), this._hasTypeDefinitionProvider = Z.hasTypeDefinitionProvider.bindTo(t), this._hasHoverProvider = Z.hasHoverProvider.bindTo(t), this._hasDocumentHighlightProvider = Z.hasDocumentHighlightProvider.bindTo(t), this._hasDocumentSymbolProvider = Z.hasDocumentSymbolProvider.bindTo(t), this._hasReferenceProvider = Z.hasReferenceProvider.bindTo(t), this._hasRenameProvider = Z.hasRenameProvider.bindTo(t), this._hasSignatureHelpProvider = Z.hasSignatureHelpProvider.bindTo(t), this._hasInlayHintsProvider = Z.hasInlayHintsProvider.bindTo(t), this._hasDocumentFormattingProvider = Z.hasDocumentFormattingProvider.bindTo(t), this._hasDocumentSelectionFormattingProvider = Z.hasDocumentSelectionFormattingProvider.bindTo(t), this._hasMultipleDocumentFormattingProvider = Z.hasMultipleDocumentFormattingProvider.bindTo(t), this._hasMultipleDocumentSelectionFormattingProvider = Z.hasMultipleDocumentSelectionFormattingProvider.bindTo(t), this._isInEmbeddedEditor = Z.isInEmbeddedEditor.bindTo(t);
    const n = () => this._update();
    this._register(e.onDidChangeModel(n)), this._register(e.onDidChangeModelLanguage(n)), this._register(i.completionProvider.onDidChange(n)), this._register(i.codeActionProvider.onDidChange(n)), this._register(i.codeLensProvider.onDidChange(n)), this._register(i.definitionProvider.onDidChange(n)), this._register(i.declarationProvider.onDidChange(n)), this._register(i.implementationProvider.onDidChange(n)), this._register(i.typeDefinitionProvider.onDidChange(n)), this._register(i.hoverProvider.onDidChange(n)), this._register(i.documentHighlightProvider.onDidChange(n)), this._register(i.documentSymbolProvider.onDidChange(n)), this._register(i.referenceProvider.onDidChange(n)), this._register(i.renameProvider.onDidChange(n)), this._register(i.documentFormattingEditProvider.onDidChange(n)), this._register(i.documentRangeFormattingEditProvider.onDidChange(n)), this._register(i.signatureHelpProvider.onDidChange(n)), this._register(i.inlayHintsProvider.onDidChange(n)), n();
  }
  dispose() {
    super.dispose();
  }
  reset() {
    this._contextKeyService.bufferChangeEvents(() => {
      this._langId.reset(), this._hasCompletionItemProvider.reset(), this._hasCodeActionsProvider.reset(), this._hasCodeLensProvider.reset(), this._hasDefinitionProvider.reset(), this._hasDeclarationProvider.reset(), this._hasImplementationProvider.reset(), this._hasTypeDefinitionProvider.reset(), this._hasHoverProvider.reset(), this._hasDocumentHighlightProvider.reset(), this._hasDocumentSymbolProvider.reset(), this._hasReferenceProvider.reset(), this._hasRenameProvider.reset(), this._hasDocumentFormattingProvider.reset(), this._hasDocumentSelectionFormattingProvider.reset(), this._hasSignatureHelpProvider.reset(), this._isInEmbeddedEditor.reset();
    });
  }
  _update() {
    const e = this._editor.getModel();
    if (!e) {
      this.reset();
      return;
    }
    this._contextKeyService.bufferChangeEvents(() => {
      this._langId.set(e.getLanguageId()), this._hasCompletionItemProvider.set(this._languageFeaturesService.completionProvider.has(e)), this._hasCodeActionsProvider.set(this._languageFeaturesService.codeActionProvider.has(e)), this._hasCodeLensProvider.set(this._languageFeaturesService.codeLensProvider.has(e)), this._hasDefinitionProvider.set(this._languageFeaturesService.definitionProvider.has(e)), this._hasDeclarationProvider.set(this._languageFeaturesService.declarationProvider.has(e)), this._hasImplementationProvider.set(this._languageFeaturesService.implementationProvider.has(e)), this._hasTypeDefinitionProvider.set(this._languageFeaturesService.typeDefinitionProvider.has(e)), this._hasHoverProvider.set(this._languageFeaturesService.hoverProvider.has(e)), this._hasDocumentHighlightProvider.set(this._languageFeaturesService.documentHighlightProvider.has(e)), this._hasDocumentSymbolProvider.set(this._languageFeaturesService.documentSymbolProvider.has(e)), this._hasReferenceProvider.set(this._languageFeaturesService.referenceProvider.has(e)), this._hasRenameProvider.set(this._languageFeaturesService.renameProvider.has(e)), this._hasSignatureHelpProvider.set(this._languageFeaturesService.signatureHelpProvider.has(e)), this._hasInlayHintsProvider.set(this._languageFeaturesService.inlayHintsProvider.has(e)), this._hasDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.has(e) || this._languageFeaturesService.documentRangeFormattingEditProvider.has(e)), this._hasDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.has(e)), this._hasMultipleDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.all(e).length + this._languageFeaturesService.documentRangeFormattingEditProvider.all(e).length > 1), this._hasMultipleDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.all(e).length > 1), this._isInEmbeddedEditor.set(e.uri.scheme === Ie.walkThroughSnippet || e.uri.scheme === Ie.vscodeChatCodeBlock);
    });
  }
}
class HY extends U {
  constructor(e, t) {
    super(), this._onChange = this._register(new A()), this.onChange = this._onChange.event, this._hadFocus = void 0, this._hasDomElementFocus = !1, this._domFocusTracker = this._register(Vh(e)), this._overflowWidgetsDomNodeHasFocus = !1, this._register(this._domFocusTracker.onDidFocus(() => {
      this._hasDomElementFocus = !0, this._update();
    })), this._register(this._domFocusTracker.onDidBlur(() => {
      this._hasDomElementFocus = !1, this._update();
    })), t && (this._overflowWidgetsDomNode = this._register(Vh(t)), this._register(this._overflowWidgetsDomNode.onDidFocus(() => {
      this._overflowWidgetsDomNodeHasFocus = !0, this._update();
    })), this._register(this._overflowWidgetsDomNode.onDidBlur(() => {
      this._overflowWidgetsDomNodeHasFocus = !1, this._update();
    })));
  }
  _update() {
    const e = this._hasDomElementFocus || this._overflowWidgetsDomNodeHasFocus;
    this._hadFocus !== e && (this._hadFocus = e, this._onChange.fire(void 0));
  }
  hasFocus() {
    return this._hadFocus ?? !1;
  }
}
class VY {
  get length() {
    return this._decorationIds.length;
  }
  constructor(e, t) {
    this._editor = e, this._decorationIds = [], this._isChangingDecorations = !1, Array.isArray(t) && t.length > 0 && this.set(t);
  }
  onDidChange(e, t, i) {
    return this._editor.onDidChangeModelDecorations((n) => {
      this._isChangingDecorations || e.call(t, n);
    }, i);
  }
  getRange(e) {
    return !this._editor.hasModel() || e >= this._decorationIds.length ? null : this._editor.getModel().getDecorationRange(this._decorationIds[e]);
  }
  getRanges() {
    if (!this._editor.hasModel())
      return [];
    const e = this._editor.getModel(), t = [];
    for (const i of this._decorationIds) {
      const n = e.getDecorationRange(i);
      n && t.push(n);
    }
    return t;
  }
  has(e) {
    return this._decorationIds.includes(e.id);
  }
  clear() {
    this._decorationIds.length !== 0 && this.set([]);
  }
  set(e) {
    try {
      this._isChangingDecorations = !0, this._editor.changeDecorations((t) => {
        this._decorationIds = t.deltaDecorations(this._decorationIds, e);
      });
    } finally {
      this._isChangingDecorations = !1;
    }
    return this._decorationIds;
  }
  append(e) {
    let t = [];
    try {
      this._isChangingDecorations = !0, this._editor.changeDecorations((i) => {
        t = i.deltaDecorations([], e), this._decorationIds = this._decorationIds.concat(t);
      });
    } finally {
      this._isChangingDecorations = !1;
    }
    return t;
  }
}
const zY = encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 6 3' enable-background='new 0 0 6 3' height='3' width='6'><g fill='"), UY = encodeURIComponent("'><polygon points='5.5,0 2.5,3 1.1,3 4.1,0'/><polygon points='4,0 6,2 6,0.6 5.4,0'/><polygon points='0,2 1,3 2.4,3 0,0.6'/></g></svg>");
function ty(s) {
  return zY + encodeURIComponent(s.toString()) + UY;
}
const $Y = encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" height="3" width="12"><g fill="'), KY = encodeURIComponent('"><circle cx="1" cy="1" r="1"/><circle cx="5" cy="1" r="1"/><circle cx="9" cy="1" r="1"/></g></svg>');
function jY(s) {
  return $Y + encodeURIComponent(s.toString()) + KY;
}
tr((s, e) => {
  const t = s.getColor(_w);
  t && e.addRule(`.monaco-editor .squiggly-error { background: url("data:image/svg+xml,${ty(t)}") repeat-x bottom left; }`);
  const i = s.getColor(Ka);
  i && e.addRule(`.monaco-editor .squiggly-warning { background: url("data:image/svg+xml,${ty(i)}") repeat-x bottom left; }`);
  const n = s.getColor(Wr);
  n && e.addRule(`.monaco-editor .squiggly-info { background: url("data:image/svg+xml,${ty(n)}") repeat-x bottom left; }`);
  const o = s.getColor(Tz);
  o && e.addRule(`.monaco-editor .squiggly-hint { background: url("data:image/svg+xml,${jY(o)}") no-repeat bottom left; }`);
  const r = s.getColor(bK);
  r && e.addRule(`.monaco-editor.showUnused .squiggly-inline-unnecessary { opacity: ${r.rgba.a}; }`);
});
var qY = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, sa = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let _f = class extends sp {
  constructor(e, t, i, n, o, r, a, l, c, h, d, u, f) {
    super(e, { ...n.getRawOptions(), overflowWidgetsDomNode: n.getOverflowWidgetsDomNode() }, i, o, r, a, l, c, h, d, u, f), this._parentEditor = n, this._overwriteOptions = t, super.updateOptions(this._overwriteOptions), this._register(n.onDidChangeConfiguration((g) => this._onParentConfigurationChanged(g)));
  }
  getParentEditor() {
    return this._parentEditor;
  }
  _onParentConfigurationChanged(e) {
    super.updateOptions(this._parentEditor.getRawOptions()), super.updateOptions(this._overwriteOptions);
  }
  updateOptions(e) {
    sw(this._overwriteOptions, e, !0), super.updateOptions(this._overwriteOptions);
  }
};
_f = qY([
  sa(4, Pe),
  sa(5, Tt),
  sa(6, fi),
  sa(7, Fe),
  sa(8, wn),
  sa(9, cn),
  sa(10, Ks),
  sa(11, ir),
  sa(12, De)
], _f);
var Vf = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
};
const GY = !1;
var O1;
(function(s) {
  s.North = "north", s.South = "south", s.East = "east", s.West = "west";
})(O1 || (O1 = {}));
let ZY = 4;
const YY = new A();
let XY = 300;
const QY = new A();
class GI {
  constructor(e) {
    this.el = e, this.disposables = new ne();
  }
  get onPointerMove() {
    return this.disposables.add(new He(fe(this.el), "mousemove")).event;
  }
  get onPointerUp() {
    return this.disposables.add(new He(fe(this.el), "mouseup")).event;
  }
  dispose() {
    this.disposables.dispose();
  }
}
Vf([
  Yt
], GI.prototype, "onPointerMove", null);
Vf([
  Yt
], GI.prototype, "onPointerUp", null);
class ZI {
  get onPointerMove() {
    return this.disposables.add(new He(this.el, vt.Change)).event;
  }
  get onPointerUp() {
    return this.disposables.add(new He(this.el, vt.End)).event;
  }
  constructor(e) {
    this.el = e, this.disposables = new ne();
  }
  dispose() {
    this.disposables.dispose();
  }
}
Vf([
  Yt
], ZI.prototype, "onPointerMove", null);
Vf([
  Yt
], ZI.prototype, "onPointerUp", null);
class F1 {
  get onPointerMove() {
    return this.factory.onPointerMove;
  }
  get onPointerUp() {
    return this.factory.onPointerUp;
  }
  constructor(e) {
    this.factory = e;
  }
  dispose() {
  }
}
Vf([
  Yt
], F1.prototype, "onPointerMove", null);
Vf([
  Yt
], F1.prototype, "onPointerUp", null);
const jM = "pointer-events-disabled";
class on extends U {
  get state() {
    return this._state;
  }
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  /**
   * The state of a sash defines whether it can be interacted with by the user
   * as well as what mouse cursor to use, when hovered.
   */
  set state(e) {
    this._state !== e && (this.el.classList.toggle(
      "disabled",
      e === 0
      /* SashState.Disabled */
    ), this.el.classList.toggle(
      "minimum",
      e === 1
      /* SashState.AtMinimum */
    ), this.el.classList.toggle(
      "maximum",
      e === 2
      /* SashState.AtMaximum */
    ), this._state = e, this.onDidEnablementChange.fire(e));
  }
  /**
   * A reference to another sash, perpendicular to this one, which
   * aligns at the start of this one. A corner sash will be created
   * automatically at that location.
   *
   * The start of a horizontal sash is its left-most position.
   * The start of a vertical sash is its top-most position.
   */
  set orthogonalStartSash(e) {
    if (this._orthogonalStartSash !== e) {
      if (this.orthogonalStartDragHandleDisposables.clear(), this.orthogonalStartSashDisposables.clear(), e) {
        const t = (i) => {
          this.orthogonalStartDragHandleDisposables.clear(), i !== 0 && (this._orthogonalStartDragHandle = te(this.el, he(".orthogonal-drag-handle.start")), this.orthogonalStartDragHandleDisposables.add(_e(() => this._orthogonalStartDragHandle.remove())), this.orthogonalStartDragHandleDisposables.add(new He(this._orthogonalStartDragHandle, "mouseenter")).event(() => on.onMouseEnter(e), void 0, this.orthogonalStartDragHandleDisposables), this.orthogonalStartDragHandleDisposables.add(new He(this._orthogonalStartDragHandle, "mouseleave")).event(() => on.onMouseLeave(e), void 0, this.orthogonalStartDragHandleDisposables));
        };
        this.orthogonalStartSashDisposables.add(e.onDidEnablementChange.event(t, this)), t(e.state);
      }
      this._orthogonalStartSash = e;
    }
  }
  /**
   * A reference to another sash, perpendicular to this one, which
   * aligns at the end of this one. A corner sash will be created
   * automatically at that location.
   *
   * The end of a horizontal sash is its right-most position.
   * The end of a vertical sash is its bottom-most position.
   */
  set orthogonalEndSash(e) {
    if (this._orthogonalEndSash !== e) {
      if (this.orthogonalEndDragHandleDisposables.clear(), this.orthogonalEndSashDisposables.clear(), e) {
        const t = (i) => {
          this.orthogonalEndDragHandleDisposables.clear(), i !== 0 && (this._orthogonalEndDragHandle = te(this.el, he(".orthogonal-drag-handle.end")), this.orthogonalEndDragHandleDisposables.add(_e(() => this._orthogonalEndDragHandle.remove())), this.orthogonalEndDragHandleDisposables.add(new He(this._orthogonalEndDragHandle, "mouseenter")).event(() => on.onMouseEnter(e), void 0, this.orthogonalEndDragHandleDisposables), this.orthogonalEndDragHandleDisposables.add(new He(this._orthogonalEndDragHandle, "mouseleave")).event(() => on.onMouseLeave(e), void 0, this.orthogonalEndDragHandleDisposables));
        };
        this.orthogonalEndSashDisposables.add(e.onDidEnablementChange.event(t, this)), t(e.state);
      }
      this._orthogonalEndSash = e;
    }
  }
  constructor(e, t, i) {
    super(), this.hoverDelay = XY, this.hoverDelayer = this._register(new Np(this.hoverDelay)), this._state = 3, this.onDidEnablementChange = this._register(new A()), this._onDidStart = this._register(new A()), this._onDidChange = this._register(new A()), this._onDidReset = this._register(new A()), this._onDidEnd = this._register(new A()), this.orthogonalStartSashDisposables = this._register(new ne()), this.orthogonalStartDragHandleDisposables = this._register(new ne()), this.orthogonalEndSashDisposables = this._register(new ne()), this.orthogonalEndDragHandleDisposables = this._register(new ne()), this.onDidStart = this._onDidStart.event, this.onDidChange = this._onDidChange.event, this.onDidReset = this._onDidReset.event, this.onDidEnd = this._onDidEnd.event, this.linkedSash = void 0, this.el = te(e, he(".monaco-sash")), i.orthogonalEdge && this.el.classList.add(`orthogonal-edge-${i.orthogonalEdge}`), $e && this.el.classList.add("mac");
    const n = this._register(new He(this.el, "mousedown")).event;
    this._register(n((d) => this.onPointerStart(d, new GI(e)), this));
    const o = this._register(new He(this.el, "dblclick")).event;
    this._register(o(this.onPointerDoublePress, this));
    const r = this._register(new He(this.el, "mouseenter")).event;
    this._register(r(() => on.onMouseEnter(this)));
    const a = this._register(new He(this.el, "mouseleave")).event;
    this._register(a(() => on.onMouseLeave(this))), this._register(ln.addTarget(this.el));
    const l = this._register(new He(this.el, vt.Start)).event;
    this._register(l((d) => this.onPointerStart(d, new ZI(this.el)), this));
    const c = this._register(new He(this.el, vt.Tap)).event;
    let h;
    this._register(c((d) => {
      if (h) {
        clearTimeout(h), h = void 0, this.onPointerDoublePress(d);
        return;
      }
      clearTimeout(h), h = setTimeout(() => h = void 0, 250);
    }, this)), typeof i.size == "number" ? (this.size = i.size, i.orientation === 0 ? this.el.style.width = `${this.size}px` : this.el.style.height = `${this.size}px`) : (this.size = ZY, this._register(YY.event((d) => {
      this.size = d, this.layout();
    }))), this._register(QY.event((d) => this.hoverDelay = d)), this.layoutProvider = t, this.orthogonalStartSash = i.orthogonalStartSash, this.orthogonalEndSash = i.orthogonalEndSash, this.orientation = i.orientation || 0, this.orientation === 1 ? (this.el.classList.add("horizontal"), this.el.classList.remove("vertical")) : (this.el.classList.remove("horizontal"), this.el.classList.add("vertical")), this.el.classList.toggle("debug", GY), this.layout();
  }
  onPointerStart(e, t) {
    Ge.stop(e);
    let i = !1;
    if (!e.__orthogonalSashEvent) {
      const g = this.getOrthogonalSash(e);
      g && (i = !0, e.__orthogonalSashEvent = !0, g.onPointerStart(e, new F1(t)));
    }
    if (this.linkedSash && !e.__linkedSashEvent && (e.__linkedSashEvent = !0, this.linkedSash.onPointerStart(e, new F1(t))), !this.state)
      return;
    const n = this.el.ownerDocument.getElementsByTagName("iframe");
    for (const g of n)
      g.classList.add(jM);
    const o = e.pageX, r = e.pageY, a = e.altKey, l = { startX: o, currentX: o, startY: r, currentY: r, altKey: a };
    this.el.classList.add("active"), this._onDidStart.fire(l);
    const c = Us(this.el), h = () => {
      let g = "";
      i ? g = "all-scroll" : this.orientation === 1 ? this.state === 1 ? g = "s-resize" : this.state === 2 ? g = "n-resize" : g = $e ? "row-resize" : "ns-resize" : this.state === 1 ? g = "e-resize" : this.state === 2 ? g = "w-resize" : g = $e ? "col-resize" : "ew-resize", c.textContent = `* { cursor: ${g} !important; }`;
    }, d = new ne();
    h(), i || this.onDidEnablementChange.event(h, null, d);
    const u = (g) => {
      Ge.stop(g, !1);
      const p = { startX: o, currentX: g.pageX, startY: r, currentY: g.pageY, altKey: a };
      this._onDidChange.fire(p);
    }, f = (g) => {
      Ge.stop(g, !1), c.remove(), this.el.classList.remove("active"), this._onDidEnd.fire(), d.dispose();
      for (const p of n)
        p.classList.remove(jM);
    };
    t.onPointerMove(u, null, d), t.onPointerUp(f, null, d), d.add(t);
  }
  onPointerDoublePress(e) {
    const t = this.getOrthogonalSash(e);
    t && t._onDidReset.fire(), this.linkedSash && this.linkedSash._onDidReset.fire(), this._onDidReset.fire();
  }
  static onMouseEnter(e, t = !1) {
    e.el.classList.contains("active") ? (e.hoverDelayer.cancel(), e.el.classList.add("hover")) : e.hoverDelayer.trigger(() => e.el.classList.add("hover"), e.hoverDelay).then(void 0, () => {
    }), !t && e.linkedSash && on.onMouseEnter(e.linkedSash, !0);
  }
  static onMouseLeave(e, t = !1) {
    e.hoverDelayer.cancel(), e.el.classList.remove("hover"), !t && e.linkedSash && on.onMouseLeave(e.linkedSash, !0);
  }
  /**
   * Forcefully stop any user interactions with this sash.
   * Useful when hiding a parent component, while the user is still
   * interacting with the sash.
   */
  clearSashHoverState() {
    on.onMouseLeave(this);
  }
  /**
   * Layout the sash. The sash will size and position itself
   * based on its provided {@link ISashLayoutProvider layout provider}.
   */
  layout() {
    if (this.orientation === 0) {
      const e = this.layoutProvider;
      this.el.style.left = e.getVerticalSashLeft(this) - this.size / 2 + "px", e.getVerticalSashTop && (this.el.style.top = e.getVerticalSashTop(this) + "px"), e.getVerticalSashHeight && (this.el.style.height = e.getVerticalSashHeight(this) + "px");
    } else {
      const e = this.layoutProvider;
      this.el.style.top = e.getHorizontalSashTop(this) - this.size / 2 + "px", e.getHorizontalSashLeft && (this.el.style.left = e.getHorizontalSashLeft(this) + "px"), e.getHorizontalSashWidth && (this.el.style.width = e.getHorizontalSashWidth(this) + "px");
    }
  }
  getOrthogonalSash(e) {
    const t = e.initialTarget ?? e.target;
    if (!(!t || !ki(t)) && t.classList.contains("orthogonal-drag-handle"))
      return t.classList.contains("start") ? this.orthogonalStartSash : this.orthogonalEndSash;
  }
  dispose() {
    super.dispose(), this.el.remove();
  }
}
const qM = new j(new ze(0, 122, 204)), JY = {
  showArrow: !0,
  showFrame: !0,
  className: "",
  frameColor: qM,
  arrowColor: qM,
  keepEditorSelection: !1
}, eX = "vs.editor.contrib.zoneWidget";
class tX {
  constructor(e, t, i, n, o, r, a, l) {
    this.id = "", this.domNode = e, this.afterLineNumber = t, this.afterColumn = i, this.heightInLines = n, this.showInHiddenAreas = a, this.ordinal = l, this._onDomNodeTop = o, this._onComputedHeight = r;
  }
  onDomNodeTop(e) {
    this._onDomNodeTop(e);
  }
  onComputedHeight(e) {
    this._onComputedHeight(e);
  }
}
class iX {
  constructor(e, t) {
    this._id = e, this._domNode = t;
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return null;
  }
}
const cv = class cv {
  constructor(e) {
    this._editor = e, this._ruleName = cv._IdGenerator.nextId(), this._decorations = this._editor.createDecorationsCollection(), this._color = null, this._height = -1;
  }
  dispose() {
    this.hide(), Jy(this._ruleName);
  }
  set color(e) {
    this._color !== e && (this._color = e, this._updateStyle());
  }
  set height(e) {
    this._height !== e && (this._height = e, this._updateStyle());
  }
  _updateStyle() {
    Jy(this._ruleName), Gb(`.monaco-editor ${this._ruleName}`, `border-style: solid; border-color: transparent; border-bottom-color: ${this._color}; border-width: ${this._height}px; bottom: -${this._height}px !important; margin-left: -${this._height}px; `);
  }
  show(e) {
    e.column === 1 && (e = { lineNumber: e.lineNumber, column: 2 }), this._decorations.set([{
      range: T.fromPositions(e),
      options: {
        description: "zone-widget-arrow",
        className: this._ruleName,
        stickiness: 1
        /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
      }
    }]);
  }
  hide() {
    this._decorations.clear();
  }
};
cv._IdGenerator = new $E(".arrow-decoration-");
let wL = cv;
class nX {
  constructor(e, t = {}) {
    this._arrow = null, this._overlayWidget = null, this._resizeSash = null, this._viewZone = null, this._disposables = new ne(), this.container = null, this._isShowing = !1, this.editor = e, this._positionMarkerId = this.editor.createDecorationsCollection(), this.options = pa(t), sw(this.options, JY, !1), this.domNode = document.createElement("div"), this.options.isAccessible || (this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setAttribute("role", "presentation")), this._disposables.add(this.editor.onDidLayoutChange((i) => {
      const n = this._getWidth(i);
      this.domNode.style.width = n + "px", this.domNode.style.left = this._getLeft(i) + "px", this._onWidth(n);
    }));
  }
  dispose() {
    this._overlayWidget && (this.editor.removeOverlayWidget(this._overlayWidget), this._overlayWidget = null), this._viewZone && this.editor.changeViewZones((e) => {
      this._viewZone && e.removeZone(this._viewZone.id), this._viewZone = null;
    }), this._positionMarkerId.clear(), this._disposables.dispose();
  }
  create() {
    this.domNode.classList.add("zone-widget"), this.options.className && this.domNode.classList.add(this.options.className), this.container = document.createElement("div"), this.container.classList.add("zone-widget-container"), this.domNode.appendChild(this.container), this.options.showArrow && (this._arrow = new wL(this.editor), this._disposables.add(this._arrow)), this._fillContainer(this.container), this._initSash(), this._applyStyles();
  }
  style(e) {
    e.frameColor && (this.options.frameColor = e.frameColor), e.arrowColor && (this.options.arrowColor = e.arrowColor), this._applyStyles();
  }
  _applyStyles() {
    if (this.container && this.options.frameColor) {
      const e = this.options.frameColor.toString();
      this.container.style.borderTopColor = e, this.container.style.borderBottomColor = e;
    }
    if (this._arrow && this.options.arrowColor) {
      const e = this.options.arrowColor.toString();
      this._arrow.color = e;
    }
  }
  _getWidth(e) {
    return e.width - e.minimap.minimapWidth - e.verticalScrollbarWidth;
  }
  _getLeft(e) {
    return e.minimap.minimapWidth > 0 && e.minimap.minimapLeft === 0 ? e.minimap.minimapWidth : 0;
  }
  _onViewZoneTop(e) {
    this.domNode.style.top = e + "px";
  }
  _onViewZoneHeight(e) {
    var t;
    if (this.domNode.style.height = `${e}px`, this.container) {
      const i = e - this._decoratingElementsHeight();
      this.container.style.height = `${i}px`;
      const n = this.editor.getLayoutInfo();
      this._doLayout(i, this._getWidth(n));
    }
    (t = this._resizeSash) == null || t.layout();
  }
  get position() {
    const e = this._positionMarkerId.getRange(0);
    if (e)
      return e.getStartPosition();
  }
  show(e, t) {
    const i = T.isIRange(e) ? T.lift(e) : T.fromPositions(e);
    this._isShowing = !0, this._showImpl(i, t), this._isShowing = !1, this._positionMarkerId.set([{ range: i, options: Wt.EMPTY }]);
  }
  hide() {
    var e;
    this._viewZone && (this.editor.changeViewZones((t) => {
      this._viewZone && t.removeZone(this._viewZone.id);
    }), this._viewZone = null), this._overlayWidget && (this.editor.removeOverlayWidget(this._overlayWidget), this._overlayWidget = null), (e = this._arrow) == null || e.hide(), this._positionMarkerId.clear();
  }
  _decoratingElementsHeight() {
    const e = this.editor.getOption(
      67
      /* EditorOption.lineHeight */
    );
    let t = 0;
    if (this.options.showArrow) {
      const i = Math.round(e / 3);
      t += 2 * i;
    }
    if (this.options.showFrame) {
      const i = Math.round(e / 9);
      t += 2 * i;
    }
    return t;
  }
  _showImpl(e, t) {
    const i = e.getStartPosition(), n = this.editor.getLayoutInfo(), o = this._getWidth(n);
    this.domNode.style.width = `${o}px`, this.domNode.style.left = this._getLeft(n) + "px";
    const r = document.createElement("div");
    r.style.overflow = "hidden";
    const a = this.editor.getOption(
      67
      /* EditorOption.lineHeight */
    );
    if (!this.options.allowUnlimitedHeight) {
      const u = Math.max(12, this.editor.getLayoutInfo().height / a * 0.8);
      t = Math.min(t, u);
    }
    let l = 0, c = 0;
    if (this._arrow && this.options.showArrow && (l = Math.round(a / 3), this._arrow.height = l, this._arrow.show(i)), this.options.showFrame && (c = Math.round(a / 9)), this.editor.changeViewZones((u) => {
      this._viewZone && u.removeZone(this._viewZone.id), this._overlayWidget && (this.editor.removeOverlayWidget(this._overlayWidget), this._overlayWidget = null), this.domNode.style.top = "-1000px", this._viewZone = new tX(r, i.lineNumber, i.column, t, (f) => this._onViewZoneTop(f), (f) => this._onViewZoneHeight(f), this.options.showInHiddenAreas, this.options.ordinal), this._viewZone.id = u.addZone(this._viewZone), this._overlayWidget = new iX(eX + this._viewZone.id, this.domNode), this.editor.addOverlayWidget(this._overlayWidget);
    }), this.container && this.options.showFrame) {
      const u = this.options.frameWidth ? this.options.frameWidth : c;
      this.container.style.borderTopWidth = u + "px", this.container.style.borderBottomWidth = u + "px";
    }
    const h = t * a - this._decoratingElementsHeight();
    this.container && (this.container.style.top = l + "px", this.container.style.height = h + "px", this.container.style.overflow = "hidden"), this._doLayout(h, o), this.options.keepEditorSelection || this.editor.setSelection(e);
    const d = this.editor.getModel();
    if (d) {
      const u = d.validateRange(new T(e.startLineNumber, 1, e.endLineNumber + 1, 1));
      this.revealRange(u, u.startLineNumber === d.getLineCount());
    }
  }
  revealRange(e, t) {
    t ? this.editor.revealLineNearTop(
      e.endLineNumber,
      0
      /* ScrollType.Smooth */
    ) : this.editor.revealRange(
      e,
      0
      /* ScrollType.Smooth */
    );
  }
  setCssClass(e, t) {
    this.container && (t && this.container.classList.remove(t), this.container.classList.add(e));
  }
  _onWidth(e) {
  }
  _doLayout(e, t) {
  }
  _relayout(e) {
    this._viewZone && this._viewZone.heightInLines !== e && this.editor.changeViewZones((t) => {
      this._viewZone && (this._viewZone.heightInLines = e, t.layoutZone(this._viewZone.id));
    });
  }
  // --- sash
  _initSash() {
    if (this._resizeSash)
      return;
    this._resizeSash = this._disposables.add(new on(this.domNode, this, {
      orientation: 1
      /* Orientation.HORIZONTAL */
    })), this.options.isResizeable || (this._resizeSash.state = 0);
    let e;
    this._disposables.add(this._resizeSash.onDidStart((t) => {
      this._viewZone && (e = {
        startY: t.startY,
        heightInLines: this._viewZone.heightInLines
      });
    })), this._disposables.add(this._resizeSash.onDidEnd(() => {
      e = void 0;
    })), this._disposables.add(this._resizeSash.onDidChange((t) => {
      if (e) {
        const i = (t.currentY - e.startY) / this.editor.getOption(
          67
          /* EditorOption.lineHeight */
        ), n = i < 0 ? Math.ceil(i) : Math.floor(i), o = e.heightInLines + n;
        o > 5 && o < 35 && this._relayout(o);
      }
    }));
  }
  getHorizontalSashLeft() {
    return 0;
  }
  getHorizontalSashTop() {
    return (this.domNode.style.height === null ? 0 : parseInt(this.domNode.style.height)) - this._decoratingElementsHeight() / 2;
  }
  getHorizontalSashWidth() {
    const e = this.editor.getLayoutInfo();
    return e.width - e.minimap.minimapWidth;
  }
}
class sX extends Fh {
  constructor(e, t) {
    super(), this._onDidChangeVisibility = this._register(new A()), this.onDidChangeVisibility = this._onDidChangeVisibility.event, this._element = te(e, he(".monaco-dropdown")), this._label = te(this._element, he(".dropdown-label"));
    let i = t.labelRenderer;
    i || (i = (o) => (o.textContent = t.label || "", null));
    for (const o of [X.CLICK, X.MOUSE_DOWN, vt.Tap])
      this._register(z(this.element, o, (r) => Ge.stop(r, !0)));
    for (const o of [X.MOUSE_DOWN, vt.Tap])
      this._register(z(this._label, o, (r) => {
        IE(r) && (r.detail > 1 || r.button !== 0) || (this.visible ? this.hide() : this.show());
      }));
    this._register(z(this._label, X.KEY_UP, (o) => {
      const r = new Dt(o);
      (r.equals(
        3
        /* KeyCode.Enter */
      ) || r.equals(
        10
        /* KeyCode.Space */
      )) && (Ge.stop(o, !0), this.visible ? this.hide() : this.show());
    }));
    const n = i(this._label);
    n && this._register(n), this._register(ln.addTarget(this._label));
  }
  get element() {
    return this._element;
  }
  show() {
    this.visible || (this.visible = !0, this._onDidChangeVisibility.fire(!0));
  }
  hide() {
    this.visible && (this.visible = !1, this._onDidChangeVisibility.fire(!1));
  }
  dispose() {
    super.dispose(), this.hide(), this.boxContainer && (this.boxContainer.remove(), this.boxContainer = void 0), this.contents && (this.contents.remove(), this.contents = void 0), this._label && (this._label.remove(), this._label = void 0);
  }
}
class oX extends sX {
  constructor(e, t) {
    super(e, t), this._options = t, this._actions = [], this.actions = t.actions || [];
  }
  set menuOptions(e) {
    this._menuOptions = e;
  }
  get menuOptions() {
    return this._menuOptions;
  }
  get actions() {
    return this._options.actionProvider ? this._options.actionProvider.getActions() : this._actions;
  }
  set actions(e) {
    this._actions = e;
  }
  show() {
    super.show(), this.element.classList.add("active"), this._options.contextMenuProvider.showContextMenu({
      getAnchor: () => this.element,
      getActions: () => this.actions,
      getActionsContext: () => this.menuOptions ? this.menuOptions.context : null,
      getActionViewItem: (e, t) => this.menuOptions && this.menuOptions.actionViewItemProvider ? this.menuOptions.actionViewItemProvider(e, t) : void 0,
      getKeyBinding: (e) => this.menuOptions && this.menuOptions.getKeyBinding ? this.menuOptions.getKeyBinding(e) : void 0,
      getMenuClassName: () => this._options.menuClassName || "",
      onHide: () => this.onHide(),
      actionRunner: this.menuOptions ? this.menuOptions.actionRunner : void 0,
      anchorAlignment: this.menuOptions ? this.menuOptions.anchorAlignment : 0,
      domForShadowRoot: this._options.menuAsChild ? this.element : void 0,
      skipTelemetry: this._options.skipTelemetry
    });
  }
  hide() {
    super.hide();
  }
  onHide() {
    this.hide(), this.element.classList.remove("active");
  }
}
class B1 extends Fo {
  constructor(e, t, i, n = /* @__PURE__ */ Object.create(null)) {
    super(null, e, n), this.actionItem = null, this._onDidChangeVisibility = this._register(new A()), this.onDidChangeVisibility = this._onDidChangeVisibility.event, this.menuActionsOrProvider = t, this.contextMenuProvider = i, this.options = n, this.options.actionRunner && (this.actionRunner = this.options.actionRunner);
  }
  render(e) {
    this.actionItem = e;
    const t = (o) => {
      this.element = te(o, he("a.action-label"));
      let r = [];
      return typeof this.options.classNames == "string" ? r = this.options.classNames.split(/\s+/g).filter((a) => !!a) : this.options.classNames && (r = this.options.classNames), r.find((a) => a === "icon") || r.push("codicon"), this.element.classList.add(...r), this.element.setAttribute("role", "button"), this.element.setAttribute("aria-haspopup", "true"), this.element.setAttribute("aria-expanded", "false"), this._action.label && this._register(jr().setupManagedHover(this.options.hoverDelegate ?? $s("mouse"), this.element, this._action.label)), this.element.ariaLabel = this._action.label || "", null;
    }, i = Array.isArray(this.menuActionsOrProvider), n = {
      contextMenuProvider: this.contextMenuProvider,
      labelRenderer: t,
      menuAsChild: this.options.menuAsChild,
      actions: i ? this.menuActionsOrProvider : void 0,
      actionProvider: i ? void 0 : this.menuActionsOrProvider,
      skipTelemetry: this.options.skipTelemetry
    };
    if (this.dropdownMenu = this._register(new oX(e, n)), this._register(this.dropdownMenu.onDidChangeVisibility((o) => {
      var r;
      (r = this.element) == null || r.setAttribute("aria-expanded", `${o}`), this._onDidChangeVisibility.fire(o);
    })), this.dropdownMenu.menuOptions = {
      actionViewItemProvider: this.options.actionViewItemProvider,
      actionRunner: this.actionRunner,
      getKeyBinding: this.options.keybindingProvider,
      context: this._context
    }, this.options.anchorAlignmentProvider) {
      const o = this;
      this.dropdownMenu.menuOptions = {
        ...this.dropdownMenu.menuOptions,
        get anchorAlignment() {
          return o.options.anchorAlignmentProvider();
        }
      };
    }
    this.updateTooltip(), this.updateEnabled();
  }
  getTooltip() {
    let e = null;
    return this.action.tooltip ? e = this.action.tooltip : this.action.label && (e = this.action.label), e ?? void 0;
  }
  setActionContext(e) {
    super.setActionContext(e), this.dropdownMenu && (this.dropdownMenu.menuOptions ? this.dropdownMenu.menuOptions.context = e : this.dropdownMenu.menuOptions = { context: e });
  }
  show() {
    var e;
    (e = this.dropdownMenu) == null || e.show();
  }
  updateEnabled() {
    var t, i;
    const e = !this.action.enabled;
    (t = this.actionItem) == null || t.classList.toggle("disabled", e), (i = this.element) == null || i.classList.toggle("disabled", e);
  }
}
class Nw {
  constructor(e, t, i = t) {
    this.modifierLabels = [null], this.modifierLabels[
      2
      /* OperatingSystem.Macintosh */
    ] = e, this.modifierLabels[
      1
      /* OperatingSystem.Windows */
    ] = t, this.modifierLabels[
      3
      /* OperatingSystem.Linux */
    ] = i;
  }
  toLabel(e, t, i) {
    if (t.length === 0)
      return null;
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = i(a);
      if (l === null)
        return null;
      n[o] = cX(a, l, this.modifierLabels[e]);
    }
    return n.join(" ");
  }
}
const YI = new Nw({
  ctrlKey: "⌃",
  shiftKey: "⇧",
  altKey: "⌥",
  metaKey: "⌘",
  separator: ""
}, {
  ctrlKey: m({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
  shiftKey: m({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
  altKey: m({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: m({ key: "windowsKey", comment: ["This is the short form for the Windows key on the keyboard"] }, "Windows"),
  separator: "+"
}, {
  ctrlKey: m({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
  shiftKey: m({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
  altKey: m({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: m({ key: "superKey", comment: ["This is the short form for the Super key on the keyboard"] }, "Super"),
  separator: "+"
}), rX = new Nw({
  ctrlKey: m({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: m({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: m({ key: "optKey.long", comment: ["This is the long form for the Alt/Option key on the keyboard"] }, "Option"),
  metaKey: m({ key: "cmdKey.long", comment: ["This is the long form for the Command key on the keyboard"] }, "Command"),
  separator: "+"
}, {
  ctrlKey: m({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: m({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: m({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: m({ key: "windowsKey.long", comment: ["This is the long form for the Windows key on the keyboard"] }, "Windows"),
  separator: "+"
}, {
  ctrlKey: m({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: m({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: m({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: m({ key: "superKey.long", comment: ["This is the long form for the Super key on the keyboard"] }, "Super"),
  separator: "+"
}), aX = new Nw({
  ctrlKey: "Ctrl",
  shiftKey: "Shift",
  altKey: "Alt",
  metaKey: "Cmd",
  separator: "+"
}, {
  ctrlKey: "Ctrl",
  shiftKey: "Shift",
  altKey: "Alt",
  metaKey: "Super",
  separator: "+"
}), lX = new Nw({
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "cmd",
  separator: "+"
}, {
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "win",
  separator: "+"
}, {
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "meta",
  separator: "+"
});
function cX(s, e, t) {
  if (e === null)
    return "";
  const i = [];
  return s.ctrlKey && i.push(t.ctrlKey), s.shiftKey && i.push(t.shiftKey), s.altKey && i.push(t.altKey), s.metaKey && i.push(t.metaKey), e !== "" && i.push(e), i.join(t.separator);
}
function hX(s) {
  return s ? s.condition !== void 0 : !1;
}
const fd = Be("contextViewService"), nr = Be("contextMenuService");
var zu;
(function(s) {
  s[s.STORAGE_DOES_NOT_EXIST = 0] = "STORAGE_DOES_NOT_EXIST", s[s.STORAGE_IN_MEMORY = 1] = "STORAGE_IN_MEMORY";
})(zu || (zu = {}));
var ru;
(function(s) {
  s[s.None = 0] = "None", s[s.Initialized = 1] = "Initialized", s[s.Closed = 2] = "Closed";
})(ru || (ru = {}));
const hv = class hv extends U {
  constructor(e, t = /* @__PURE__ */ Object.create(null)) {
    super(), this.database = e, this.options = t, this._onDidChangeStorage = this._register(new Sm()), this.onDidChangeStorage = this._onDidChangeStorage.event, this.state = ru.None, this.cache = /* @__PURE__ */ new Map(), this.flushDelayer = this._register(new y4(hv.DEFAULT_FLUSH_DELAY)), this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.whenFlushedCallbacks = [], this.registerListeners();
  }
  registerListeners() {
    this._register(this.database.onDidChangeItemsExternal((e) => this.onDidChangeItemsExternal(e)));
  }
  onDidChangeItemsExternal(e) {
    var t, i;
    this._onDidChangeStorage.pause();
    try {
      (t = e.changed) == null || t.forEach((n, o) => this.acceptExternal(o, n)), (i = e.deleted) == null || i.forEach((n) => this.acceptExternal(n, void 0));
    } finally {
      this._onDidChangeStorage.resume();
    }
  }
  acceptExternal(e, t) {
    if (this.state === ru.Closed)
      return;
    let i = !1;
    ms(t) ? i = this.cache.delete(e) : this.cache.get(e) !== t && (this.cache.set(e, t), i = !0), i && this._onDidChangeStorage.fire({ key: e, external: !0 });
  }
  get(e, t) {
    const i = this.cache.get(e);
    return ms(i) ? t : i;
  }
  getBoolean(e, t) {
    const i = this.get(e);
    return ms(i) ? t : i === "true";
  }
  getNumber(e, t) {
    const i = this.get(e);
    return ms(i) ? t : parseInt(i, 10);
  }
  async set(e, t, i = !1) {
    if (this.state === ru.Closed)
      return;
    if (ms(t))
      return this.delete(e, i);
    const n = Wi(t) || Array.isArray(t) ? yW(t) : String(t);
    if (this.cache.get(e) !== n)
      return this.cache.set(e, n), this.pendingInserts.set(e, n), this.pendingDeletes.delete(e), this._onDidChangeStorage.fire({ key: e, external: i }), this.doFlush();
  }
  async delete(e, t = !1) {
    if (!(this.state === ru.Closed || !this.cache.delete(e)))
      return this.pendingDeletes.has(e) || this.pendingDeletes.add(e), this.pendingInserts.delete(e), this._onDidChangeStorage.fire({ key: e, external: t }), this.doFlush();
  }
  get hasPending() {
    return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;
  }
  async flushPending() {
    if (!this.hasPending)
      return;
    const e = { insert: this.pendingInserts, delete: this.pendingDeletes };
    return this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.database.updateItems(e).finally(() => {
      var t;
      if (!this.hasPending)
        for (; this.whenFlushedCallbacks.length; )
          (t = this.whenFlushedCallbacks.pop()) == null || t();
    });
  }
  async doFlush(e) {
    return this.options.hint === zu.STORAGE_IN_MEMORY ? this.flushPending() : this.flushDelayer.trigger(() => this.flushPending(), e);
  }
};
hv.DEFAULT_FLUSH_DELAY = 100;
let Xg = hv;
class iy {
  constructor() {
    this.onDidChangeItemsExternal = ee.None, this.items = /* @__PURE__ */ new Map();
  }
  async updateItems(e) {
    var t, i;
    (t = e.insert) == null || t.forEach((n, o) => this.items.set(o, n)), (i = e.delete) == null || i.forEach((n) => this.items.delete(n));
  }
}
const fb = "__$__targetStorageMarker", zp = Be("storageService");
var GM;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.SHUTDOWN = 1] = "SHUTDOWN";
})(GM || (GM = {}));
function dX(s) {
  const e = s.get(fb);
  if (e)
    try {
      return JSON.parse(e);
    } catch {
    }
  return /* @__PURE__ */ Object.create(null);
}
const dv = class dv extends U {
  // every minute
  constructor(e = { flushInterval: dv.DEFAULT_FLUSH_INTERVAL }) {
    super(), this.options = e, this._onDidChangeValue = this._register(new Sm()), this._onDidChangeTarget = this._register(new Sm()), this._onWillSaveState = this._register(new A()), this.onWillSaveState = this._onWillSaveState.event, this._workspaceKeyTargets = void 0, this._profileKeyTargets = void 0, this._applicationKeyTargets = void 0;
  }
  onDidChangeValue(e, t, i) {
    return ee.filter(this._onDidChangeValue.event, (n) => n.scope === e && (t === void 0 || n.key === t), i);
  }
  emitDidChangeValue(e, t) {
    const { key: i, external: n } = t;
    if (i === fb) {
      switch (e) {
        case -1:
          this._applicationKeyTargets = void 0;
          break;
        case 0:
          this._profileKeyTargets = void 0;
          break;
        case 1:
          this._workspaceKeyTargets = void 0;
          break;
      }
      this._onDidChangeTarget.fire({ scope: e });
    } else
      this._onDidChangeValue.fire({ scope: e, key: i, target: this.getKeyTargets(e)[i], external: n });
  }
  get(e, t, i) {
    var n;
    return (n = this.getStorage(t)) == null ? void 0 : n.get(e, i);
  }
  getBoolean(e, t, i) {
    var n;
    return (n = this.getStorage(t)) == null ? void 0 : n.getBoolean(e, i);
  }
  getNumber(e, t, i) {
    var n;
    return (n = this.getStorage(t)) == null ? void 0 : n.getNumber(e, i);
  }
  store(e, t, i, n, o = !1) {
    if (ms(t)) {
      this.remove(e, i, o);
      return;
    }
    this.withPausedEmitters(() => {
      var r;
      this.updateKeyTarget(e, i, n), (r = this.getStorage(i)) == null || r.set(e, t, o);
    });
  }
  remove(e, t, i = !1) {
    this.withPausedEmitters(() => {
      var n;
      this.updateKeyTarget(e, t, void 0), (n = this.getStorage(t)) == null || n.delete(e, i);
    });
  }
  withPausedEmitters(e) {
    this._onDidChangeValue.pause(), this._onDidChangeTarget.pause();
    try {
      e();
    } finally {
      this._onDidChangeValue.resume(), this._onDidChangeTarget.resume();
    }
  }
  updateKeyTarget(e, t, i, n = !1) {
    var r, a;
    const o = this.getKeyTargets(t);
    typeof i == "number" ? o[e] !== i && (o[e] = i, (r = this.getStorage(t)) == null || r.set(fb, JSON.stringify(o), n)) : typeof o[e] == "number" && (delete o[e], (a = this.getStorage(t)) == null || a.set(fb, JSON.stringify(o), n));
  }
  get workspaceKeyTargets() {
    return this._workspaceKeyTargets || (this._workspaceKeyTargets = this.loadKeyTargets(
      1
      /* StorageScope.WORKSPACE */
    )), this._workspaceKeyTargets;
  }
  get profileKeyTargets() {
    return this._profileKeyTargets || (this._profileKeyTargets = this.loadKeyTargets(
      0
      /* StorageScope.PROFILE */
    )), this._profileKeyTargets;
  }
  get applicationKeyTargets() {
    return this._applicationKeyTargets || (this._applicationKeyTargets = this.loadKeyTargets(
      -1
      /* StorageScope.APPLICATION */
    )), this._applicationKeyTargets;
  }
  getKeyTargets(e) {
    switch (e) {
      case -1:
        return this.applicationKeyTargets;
      case 0:
        return this.profileKeyTargets;
      default:
        return this.workspaceKeyTargets;
    }
  }
  loadKeyTargets(e) {
    const t = this.getStorage(e);
    return t ? dX(t) : /* @__PURE__ */ Object.create(null);
  }
};
dv.DEFAULT_FLUSH_INTERVAL = 60 * 1e3;
let yL = dv;
class uX extends yL {
  constructor() {
    super(), this.applicationStorage = this._register(new Xg(new iy(), { hint: zu.STORAGE_IN_MEMORY })), this.profileStorage = this._register(new Xg(new iy(), { hint: zu.STORAGE_IN_MEMORY })), this.workspaceStorage = this._register(new Xg(new iy(), { hint: zu.STORAGE_IN_MEMORY })), this._register(this.workspaceStorage.onDidChangeStorage((e) => this.emitDidChangeValue(1, e))), this._register(this.profileStorage.onDidChangeStorage((e) => this.emitDidChangeValue(0, e))), this._register(this.applicationStorage.onDidChangeStorage((e) => this.emitDidChangeValue(-1, e)));
  }
  getStorage(e) {
    switch (e) {
      case -1:
        return this.applicationStorage;
      case 0:
        return this.profileStorage;
      default:
        return this.workspaceStorage;
    }
  }
}
function fX(s, e) {
  const t = { ...e };
  for (const i in s) {
    const n = s[i];
    t[i] = n !== void 0 ? se(n) : void 0;
  }
  return t;
}
const gX = {
  keybindingLabelBackground: se(NU),
  keybindingLabelForeground: se(TU),
  keybindingLabelBorder: se(MU),
  keybindingLabelBottomBorder: se(RU),
  keybindingLabelShadow: se(Op)
}, mX = {
  buttonForeground: se(n5),
  buttonSeparator: se(pU),
  buttonBackground: se(Cg),
  buttonHoverBackground: se(_U),
  buttonSecondaryForeground: se(CU),
  buttonSecondaryBackground: se(RS),
  buttonSecondaryHoverBackground: se(vU),
  buttonBorder: se(bU)
}, pX = {
  progressBarBackground: se(Ez)
}, xF = {
  inputActiveOptionBorder: se(t5),
  inputActiveOptionForeground: se(i5),
  inputActiveOptionBackground: se(lI)
};
se(vg), se(wU), se(yU), se(SU), se(LU), se(kU), se(xU);
se(DU), se(IU), se(EU);
se(oo), se(pw), se(Op), se(Ke), se(qz), se(Gz), se(Zz), se(xz);
const DF = {
  inputBackground: se(iU),
  inputForeground: se(nU),
  inputBorder: se(sU),
  inputValidationInfoBorder: se(lU),
  inputValidationInfoBackground: se(rU),
  inputValidationInfoForeground: se(aU),
  inputValidationWarningBorder: se(dU),
  inputValidationWarningBackground: se(cU),
  inputValidationWarningForeground: se(hU),
  inputValidationErrorBorder: se(gU),
  inputValidationErrorBackground: se(uU),
  inputValidationErrorForeground: se(fU)
}, _X = {
  listFilterWidgetBackground: se(KU),
  listFilterWidgetOutline: se(jU),
  listFilterWidgetNoMatchesOutline: se(qU),
  listFilterWidgetShadow: se(GU),
  inputBoxStyles: DF,
  toggleStyles: xF
}, EF = {
  badgeBackground: se(ob),
  badgeForeground: se(Dz),
  badgeBorder: se(Ke)
};
se(Kz), se($z), se(_T), se(_T), se(jz);
const gd = {
  listBackground: void 0,
  listInactiveFocusForeground: void 0,
  listFocusBackground: se(AU),
  listFocusForeground: se(PU),
  listFocusOutline: se(OU),
  listActiveSelectionBackground: se(Kh),
  listActiveSelectionForeground: se(Um),
  listActiveSelectionIconForeground: se(s5),
  listFocusAndSelectionOutline: se(FU),
  listFocusAndSelectionBackground: se(Kh),
  listFocusAndSelectionForeground: se(Um),
  listInactiveSelectionBackground: se(BU),
  listInactiveSelectionIconForeground: se(HU),
  listInactiveSelectionForeground: se(WU),
  listInactiveFocusBackground: se(VU),
  listInactiveFocusOutline: se(zU),
  listHoverBackground: se(o5),
  listHoverForeground: se(r5),
  listDropOverBackground: se(UU),
  listDropBetweenBackground: se($U),
  listSelectionOutline: se(Ut),
  listHoverOutline: se(Ut),
  treeIndentGuidesStroke: se(a5),
  treeInactiveIndentGuidesStroke: se(ZU),
  treeStickyScrollBackground: void 0,
  treeStickyScrollBorder: void 0,
  treeStickyScrollShadow: se(sI),
  tableColumnsBorder: se(YU),
  tableOddRowsBackgroundColor: se(XU)
};
function Up(s) {
  return fX(s, gd);
}
const bX = {
  selectBackground: se(bw),
  selectListBackground: se(mU),
  selectForeground: se(cI),
  decoratorRightForeground: se(l5),
  selectBorder: se(hI),
  focusBorder: se(Br),
  listFocusBackground: se(PS),
  listInactiveSelectionIconForeground: se(c5),
  listFocusForeground: se(AS),
  listFocusOutline: vz(Ut, j.transparent.toString()),
  listHoverBackground: se(o5),
  listHoverForeground: se(r5),
  listHoverOutline: se(Ut),
  selectListBorder: se(YO),
  listBackground: void 0,
  listActiveSelectionBackground: void 0,
  listActiveSelectionForeground: void 0,
  listActiveSelectionIconForeground: void 0,
  listFocusAndSelectionBackground: void 0,
  listDropOverBackground: void 0,
  listDropBetweenBackground: void 0,
  listInactiveSelectionBackground: void 0,
  listInactiveSelectionForeground: void 0,
  listInactiveFocusBackground: void 0,
  listInactiveFocusOutline: void 0,
  listSelectionOutline: void 0,
  listFocusAndSelectionForeground: void 0,
  listFocusAndSelectionOutline: void 0,
  listInactiveFocusForeground: void 0,
  tableColumnsBorder: void 0,
  tableOddRowsBackgroundColor: void 0,
  treeIndentGuidesStroke: void 0,
  treeInactiveIndentGuidesStroke: void 0,
  treeStickyScrollBackground: void 0,
  treeStickyScrollBorder: void 0,
  treeStickyScrollShadow: void 0
}, CX = {
  shadowColor: se(Op),
  borderColor: se(QU),
  foregroundColor: se(JU),
  backgroundColor: se(e$),
  selectionForegroundColor: se(t$),
  selectionBackgroundColor: se(i$),
  selectionBorderColor: se(n$),
  separatorColor: se(s$),
  scrollbarShadow: se(sI),
  scrollbarSliderBackground: se(qO),
  scrollbarSliderHoverBackground: se(GO),
  scrollbarSliderActiveBackground: se(ZO)
};
var Tw = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, In = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
function vX(s, e, t, i) {
  let n, o, r;
  if (Array.isArray(s))
    r = s, n = e, o = t;
  else {
    const c = e;
    r = s.getActions(c), n = t, o = i;
  }
  const a = xa.getInstance(), l = a.keyStatus.altKey || (es || Rn) && a.keyStatus.shiftKey;
  IF(r, n, l, o ? (c) => c === o : (c) => c === "navigation");
}
function XI(s, e, t, i, n, o) {
  let r, a, l, c, h;
  if (Array.isArray(s))
    h = s, r = e, a = t, l = i, c = n;
  else {
    const u = e;
    h = s.getActions(u), r = t, a = i, l = n, c = o;
  }
  IF(h, r, !1, typeof a == "string" ? (u) => u === a : a, l, c);
}
function IF(s, e, t, i = (r) => r === "navigation", n = () => !1, o = !1) {
  let r, a;
  Array.isArray(e) ? (r = e, a = e) : (r = e.primary, a = e.secondary);
  const l = /* @__PURE__ */ new Set();
  for (const [c, h] of s) {
    let d;
    i(c) ? (d = r, d.length > 0 && o && d.push(new Vi())) : (d = a, d.length > 0 && d.push(new Vi()));
    for (let u of h) {
      t && (u = u instanceof lo && u.alt ? u.alt : u);
      const f = d.push(u);
      u instanceof Wv && l.add({ group: c, action: u, index: f - 1 });
    }
  }
  for (const { group: c, action: h, index: d } of l) {
    const u = i(c) ? r : a, f = h.actions;
    n(h, c, u.length) && u.splice(d, 1, ...f);
  }
}
let bf = class extends uw {
  constructor(e, t, i, n, o, r, a, l) {
    super(void 0, e, { icon: !!(e.class || e.item.icon), label: !e.class && !e.item.icon, draggable: t == null ? void 0 : t.draggable, keybinding: t == null ? void 0 : t.keybinding, hoverDelegate: t == null ? void 0 : t.hoverDelegate }), this._options = t, this._keybindingService = i, this._notificationService = n, this._contextKeyService = o, this._themeService = r, this._contextMenuService = a, this._accessibilityService = l, this._wantsAltCommand = !1, this._itemClassDispose = this._register(new Hs()), this._altKey = xa.getInstance();
  }
  get _menuItemAction() {
    return this._action;
  }
  get _commandAction() {
    return this._wantsAltCommand && this._menuItemAction.alt || this._menuItemAction;
  }
  async onClick(e) {
    e.preventDefault(), e.stopPropagation();
    try {
      await this.actionRunner.run(this._commandAction, this._context);
    } catch (t) {
      this._notificationService.error(t);
    }
  }
  render(e) {
    if (super.render(e), e.classList.add("menu-entry"), this.options.icon && this._updateItemClass(this._menuItemAction.item), this._menuItemAction.alt) {
      let t = !1;
      const i = () => {
        var o;
        const n = !!((o = this._menuItemAction.alt) != null && o.enabled) && (!this._accessibilityService.isMotionReduced() || t) && (this._altKey.keyStatus.altKey || this._altKey.keyStatus.shiftKey && t);
        n !== this._wantsAltCommand && (this._wantsAltCommand = n, this.updateLabel(), this.updateTooltip(), this.updateClass());
      };
      this._register(this._altKey.event(i)), this._register(z(e, "mouseleave", (n) => {
        t = !1, i();
      })), this._register(z(e, "mouseenter", (n) => {
        t = !0, i();
      })), i();
    }
  }
  updateLabel() {
    this.options.label && this.label && (this.label.textContent = this._commandAction.label);
  }
  getTooltip() {
    var o;
    const e = this._keybindingService.lookupKeybinding(this._commandAction.id, this._contextKeyService), t = e && e.getLabel(), i = this._commandAction.tooltip || this._commandAction.label;
    let n = t ? m("titleAndKb", "{0} ({1})", i, t) : i;
    if (!this._wantsAltCommand && ((o = this._menuItemAction.alt) != null && o.enabled)) {
      const r = this._menuItemAction.alt.tooltip || this._menuItemAction.alt.label, a = this._keybindingService.lookupKeybinding(this._menuItemAction.alt.id, this._contextKeyService), l = a && a.getLabel(), c = l ? m("titleAndKb", "{0} ({1})", r, l) : r;
      n = m("titleAndKbAndAlt", `{0}
[{1}] {2}`, n, YI.modifierLabels[bs].altKey, c);
    }
    return n;
  }
  updateClass() {
    this.options.icon && (this._commandAction !== this._menuItemAction ? this._menuItemAction.alt && this._updateItemClass(this._menuItemAction.alt.item) : this._updateItemClass(this._menuItemAction.item));
  }
  _updateItemClass(e) {
    this._itemClassDispose.value = void 0;
    const { element: t, label: i } = this;
    if (!t || !i)
      return;
    const n = this._commandAction.checked && hX(e.toggled) && e.toggled.icon ? e.toggled.icon : e.icon;
    if (n)
      if (Te.isThemeIcon(n)) {
        const o = Te.asClassNameArray(n);
        i.classList.add(...o), this._itemClassDispose.value = _e(() => {
          i.classList.remove(...o);
        });
      } else
        i.style.backgroundImage = Sw(this._themeService.getColorTheme().type) ? Ua(n.dark) : Ua(n.light), i.classList.add("icon"), this._itemClassDispose.value = ao(_e(() => {
          i.style.backgroundImage = "", i.classList.remove("icon");
        }), this._themeService.onDidColorThemeChange(() => {
          this.updateClass();
        }));
  }
};
bf = Tw([
  In(2, Lt),
  In(3, cn),
  In(4, Fe),
  In(5, wn),
  In(6, nr),
  In(7, Ks)
], bf);
let SL = class extends B1 {
  constructor(e, t, i, n, o) {
    const r = {
      ...t,
      menuAsChild: (t == null ? void 0 : t.menuAsChild) ?? !1,
      classNames: (t == null ? void 0 : t.classNames) ?? (Te.isThemeIcon(e.item.icon) ? Te.asClassName(e.item.icon) : void 0),
      keybindingProvider: (t == null ? void 0 : t.keybindingProvider) ?? ((a) => i.lookupKeybinding(a.id))
    };
    super(e, { getActions: () => e.actions }, n, r), this._keybindingService = i, this._contextMenuService = n, this._themeService = o;
  }
  render(e) {
    super.render(e), qi(this.element), e.classList.add("menu-entry");
    const t = this._action, { icon: i } = t.item;
    if (i && !Te.isThemeIcon(i)) {
      this.element.classList.add("icon");
      const n = () => {
        this.element && (this.element.style.backgroundImage = Sw(this._themeService.getColorTheme().type) ? Ua(i.dark) : Ua(i.light));
      };
      n(), this._register(this._themeService.onDidColorThemeChange(() => {
        n();
      }));
    }
  }
};
SL = Tw([
  In(2, Lt),
  In(3, nr),
  In(4, wn)
], SL);
let LL = class extends Fo {
  constructor(e, t, i, n, o, r, a, l) {
    super(null, e), this._keybindingService = i, this._notificationService = n, this._contextMenuService = o, this._menuService = r, this._instaService = a, this._storageService = l, this._container = null, this._options = t, this._storageKey = `${e.item.submenu.id}_lastActionId`;
    let c;
    const h = t != null && t.persistLastActionId ? l.get(
      this._storageKey,
      1
      /* StorageScope.WORKSPACE */
    ) : void 0;
    h && (c = e.actions.find((u) => h === u.id)), c || (c = e.actions[0]), this._defaultAction = this._instaService.createInstance(bf, c, { keybinding: this._getDefaultActionKeybindingLabel(c) });
    const d = {
      keybindingProvider: (u) => this._keybindingService.lookupKeybinding(u.id),
      ...t,
      menuAsChild: (t == null ? void 0 : t.menuAsChild) ?? !0,
      classNames: (t == null ? void 0 : t.classNames) ?? ["codicon", "codicon-chevron-down"],
      actionRunner: (t == null ? void 0 : t.actionRunner) ?? new Fh()
    };
    this._dropdown = new B1(e, e.actions, this._contextMenuService, d), this._register(this._dropdown.actionRunner.onDidRun((u) => {
      u.action instanceof lo && this.update(u.action);
    }));
  }
  update(e) {
    var t;
    (t = this._options) != null && t.persistLastActionId && this._storageService.store(
      this._storageKey,
      e.id,
      1,
      1
      /* StorageTarget.MACHINE */
    ), this._defaultAction.dispose(), this._defaultAction = this._instaService.createInstance(bf, e, { keybinding: this._getDefaultActionKeybindingLabel(e) }), this._defaultAction.actionRunner = new class extends Fh {
      async runAction(i, n) {
        await i.run(void 0);
      }
    }(), this._container && this._defaultAction.render(NE(this._container, he(".action-container")));
  }
  _getDefaultActionKeybindingLabel(e) {
    var i;
    let t;
    if ((i = this._options) != null && i.renderKeybindingWithDefaultActionLabel) {
      const n = this._keybindingService.lookupKeybinding(e.id);
      n && (t = `(${n.getLabel()})`);
    }
    return t;
  }
  setActionContext(e) {
    super.setActionContext(e), this._defaultAction.setActionContext(e), this._dropdown.setActionContext(e);
  }
  render(e) {
    this._container = e, super.render(this._container), this._container.classList.add("monaco-dropdown-with-default");
    const t = he(".action-container");
    this._defaultAction.render(te(this._container, t)), this._register(z(t, X.KEY_DOWN, (n) => {
      const o = new Dt(n);
      o.equals(
        17
        /* KeyCode.RightArrow */
      ) && (this._defaultAction.element.tabIndex = -1, this._dropdown.focus(), o.stopPropagation());
    }));
    const i = he(".dropdown-action-container");
    this._dropdown.render(te(this._container, i)), this._register(z(i, X.KEY_DOWN, (n) => {
      var r;
      const o = new Dt(n);
      o.equals(
        15
        /* KeyCode.LeftArrow */
      ) && (this._defaultAction.element.tabIndex = 0, this._dropdown.setFocusable(!1), (r = this._defaultAction.element) == null || r.focus(), o.stopPropagation());
    }));
  }
  focus(e) {
    e ? this._dropdown.focus() : (this._defaultAction.element.tabIndex = 0, this._defaultAction.element.focus());
  }
  blur() {
    this._defaultAction.element.tabIndex = -1, this._dropdown.blur(), this._container.blur();
  }
  setFocusable(e) {
    e ? this._defaultAction.element.tabIndex = 0 : (this._defaultAction.element.tabIndex = -1, this._dropdown.setFocusable(!1));
  }
  dispose() {
    this._defaultAction.dispose(), this._dropdown.dispose(), super.dispose();
  }
};
LL = Tw([
  In(2, Lt),
  In(3, cn),
  In(4, nr),
  In(5, $r),
  In(6, Pe),
  In(7, zp)
], LL);
let kL = class extends iV {
  constructor(e, t) {
    super(null, e, e.actions.map((i) => ({
      text: i.id === Vi.ID ? "─────────" : i.label,
      isDisabled: !i.enabled
    })), 0, t, bX, { ariaLabel: e.tooltip, optionsAsChildren: !0 }), this.select(Math.max(0, e.actions.findIndex((i) => i.checked)));
  }
  render(e) {
    super.render(e), e.style.borderColor = se(hI);
  }
  runAction(e, t) {
    const i = this.action.actions[t];
    i && this.actionRunner.run(i);
  }
};
kL = Tw([
  In(1, fd)
], kL);
function NF(s, e, t) {
  return e instanceof lo ? s.createInstance(bf, e, t) : e instanceof Rg ? e.item.isSelection ? s.createInstance(kL, e) : e.item.rememberDefaultAction ? s.createInstance(LL, e, { ...t, persistLastActionId: !0 }) : s.createInstance(SL, e, t) : void 0;
}
var TF = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, MF = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const RF = Be("IPeekViewService");
Ze(
  RF,
  class {
    constructor() {
      this._widgets = /* @__PURE__ */ new Map();
    }
    addExclusiveWidget(s, e) {
      const t = this._widgets.get(s);
      t && (t.listener.dispose(), t.widget.dispose());
      const i = () => {
        const n = this._widgets.get(s);
        n && n.widget === e && (n.listener.dispose(), this._widgets.delete(s));
      };
      this._widgets.set(s, { widget: e, listener: e.onDidClose(i) });
    }
  },
  1
  /* InstantiationType.Delayed */
);
var On;
(function(s) {
  s.inPeekEditor = new ce("inReferenceSearchEditor", !0, m("inReferenceSearchEditor", "Whether the current code editor is embedded inside peek")), s.notInPeekEditor = s.inPeekEditor.toNegated();
})(On || (On = {}));
var Xu;
let W1 = (Xu = class {
  constructor(e, t) {
    e instanceof _f && On.inPeekEditor.bindTo(t);
  }
  dispose() {
  }
}, Xu.ID = "editor.contrib.referenceController", Xu);
W1 = TF([
  MF(1, Fe)
], W1);
Xa(
  W1.ID,
  W1,
  0
  /* EditorContributionInstantiation.Eager */
);
function wX(s) {
  const e = s.get(Tt).getFocusedCodeEditor();
  return e instanceof _f ? e.getParentEditor() : e;
}
const yX = {
  headerBackgroundColor: j.white,
  primaryHeadingColor: j.fromHex("#333333"),
  secondaryHeadingColor: j.fromHex("#6c6c6cb3")
};
let H1 = class extends nX {
  constructor(e, t, i) {
    super(e, t), this.instantiationService = i, this._onDidClose = new A(), this.onDidClose = this._onDidClose.event, sw(this.options, yX, !1);
  }
  dispose() {
    this.disposed || (this.disposed = !0, super.dispose(), this._onDidClose.fire(this));
  }
  style(e) {
    const t = this.options;
    e.headerBackgroundColor && (t.headerBackgroundColor = e.headerBackgroundColor), e.primaryHeadingColor && (t.primaryHeadingColor = e.primaryHeadingColor), e.secondaryHeadingColor && (t.secondaryHeadingColor = e.secondaryHeadingColor), super.style(e);
  }
  _applyStyles() {
    super._applyStyles();
    const e = this.options;
    this._headElement && e.headerBackgroundColor && (this._headElement.style.backgroundColor = e.headerBackgroundColor.toString()), this._primaryHeading && e.primaryHeadingColor && (this._primaryHeading.style.color = e.primaryHeadingColor.toString()), this._secondaryHeading && e.secondaryHeadingColor && (this._secondaryHeading.style.color = e.secondaryHeadingColor.toString()), this._bodyElement && e.frameColor && (this._bodyElement.style.borderColor = e.frameColor.toString());
  }
  _fillContainer(e) {
    this.setCssClass("peekview-widget"), this._headElement = he(".head"), this._bodyElement = he(".body"), this._fillHead(this._headElement), this._fillBody(this._bodyElement), e.appendChild(this._headElement), e.appendChild(this._bodyElement);
  }
  _fillHead(e, t) {
    this._titleElement = he(".peekview-title"), this.options.supportOnTitleClick && (this._titleElement.classList.add("clickable"), Zt(this._titleElement, "click", (o) => this._onTitleClick(o))), te(this._headElement, this._titleElement), this._fillTitleIcon(this._titleElement), this._primaryHeading = he("span.filename"), this._secondaryHeading = he("span.dirname"), this._metaHeading = he("span.meta"), te(this._titleElement, this._primaryHeading, this._secondaryHeading, this._metaHeading);
    const i = he(".peekview-actions");
    te(this._headElement, i);
    const n = this._getActionBarOptions();
    this._actionbarWidget = new $o(i, n), this._disposables.add(this._actionbarWidget), t || this._actionbarWidget.push(new ys("peekview.close", m("label.close", "Close"), Te.asClassName(ie.close), !0, () => (this.dispose(), Promise.resolve())), { label: !1, icon: !0 });
  }
  _fillTitleIcon(e) {
  }
  _getActionBarOptions() {
    return {
      actionViewItemProvider: NF.bind(void 0, this.instantiationService),
      orientation: 0
      /* ActionsOrientation.HORIZONTAL */
    };
  }
  _onTitleClick(e) {
  }
  setTitle(e, t) {
    this._primaryHeading && this._secondaryHeading && (this._primaryHeading.innerText = e, this._primaryHeading.setAttribute("title", e), t ? this._secondaryHeading.innerText = t : ks(this._secondaryHeading));
  }
  setMetaTitle(e) {
    this._metaHeading && (e ? (this._metaHeading.innerText = e, oh(this._metaHeading)) : yl(this._metaHeading));
  }
  _doLayout(e, t) {
    if (!this._isShowing && e < 0) {
      this.dispose();
      return;
    }
    const i = Math.ceil(this.editor.getOption(
      67
      /* EditorOption.lineHeight */
    ) * 1.2), n = Math.round(e - (i + 2));
    this._doLayoutHead(i, t), this._doLayoutBody(n, t);
  }
  _doLayoutHead(e, t) {
    this._headElement && (this._headElement.style.height = `${e}px`, this._headElement.style.lineHeight = this._headElement.style.height);
  }
  _doLayoutBody(e, t) {
    this._bodyElement && (this._bodyElement.style.height = `${e}px`);
  }
};
H1 = TF([
  MF(2, Pe)
], H1);
const SX = E("peekViewTitle.background", { dark: "#252526", light: "#F3F3F3", hcDark: j.black, hcLight: j.white }, m("peekViewTitleBackground", "Background color of the peek view title area.")), AF = E("peekViewTitleLabel.foreground", { dark: j.white, light: j.black, hcDark: j.white, hcLight: Ja }, m("peekViewTitleForeground", "Color of the peek view title.")), PF = E("peekViewTitleDescription.foreground", { dark: "#ccccccb3", light: "#616161", hcDark: "#FFFFFF99", hcLight: "#292929" }, m("peekViewTitleInfoForeground", "Color of the peek view title info.")), LX = E("peekView.border", { dark: Wr, light: Wr, hcDark: Ke, hcLight: Ke }, m("peekViewBorder", "Color of the peek view borders and arrow.")), kX = E("peekViewResult.background", { dark: "#252526", light: "#F3F3F3", hcDark: j.black, hcLight: j.white }, m("peekViewResultsBackground", "Background color of the peek view result list."));
E("peekViewResult.lineForeground", { dark: "#bbbbbb", light: "#646465", hcDark: j.white, hcLight: Ja }, m("peekViewResultsMatchForeground", "Foreground color for line nodes in the peek view result list."));
E("peekViewResult.fileForeground", { dark: j.white, light: "#1E1E1E", hcDark: j.white, hcLight: Ja }, m("peekViewResultsFileForeground", "Foreground color for file nodes in the peek view result list."));
E("peekViewResult.selectionBackground", { dark: "#3399ff33", light: "#3399ff33", hcDark: null, hcLight: null }, m("peekViewResultsSelectionBackground", "Background color of the selected entry in the peek view result list."));
E("peekViewResult.selectionForeground", { dark: j.white, light: "#6C6C6C", hcDark: j.white, hcLight: Ja }, m("peekViewResultsSelectionForeground", "Foreground color of the selected entry in the peek view result list."));
const OF = E("peekViewEditor.background", { dark: "#001F33", light: "#F2F8FC", hcDark: j.black, hcLight: j.white }, m("peekViewEditorBackground", "Background color of the peek view editor."));
E("peekViewEditorGutter.background", OF, m("peekViewEditorGutterBackground", "Background color of the gutter in the peek view editor."));
E("peekViewEditorStickyScroll.background", OF, m("peekViewEditorStickScrollBackground", "Background color of sticky scroll in the peek view editor."));
E("peekViewResult.matchHighlightBackground", { dark: "#ea5c004d", light: "#ea5c004d", hcDark: null, hcLight: null }, m("peekViewResultsMatchHighlight", "Match highlight color in the peek view result list."));
E("peekViewEditor.matchHighlightBackground", { dark: "#ff8f0099", light: "#f5d802de", hcDark: null, hcLight: null }, m("peekViewEditorMatchHighlight", "Match highlight color in the peek view editor."));
E("peekViewEditor.matchHighlightBorder", { dark: null, light: null, hcDark: Ut, hcLight: Ut }, m("peekViewEditorMatchHighlightBorder", "Match highlight border in the peek view editor."));
function FF(s) {
  return s && typeof s.getEditorType == "function" ? s.getEditorType() === Iw.ICodeEditor : !1;
}
class xX {
  get templateId() {
    return this.renderer.templateId;
  }
  constructor(e, t) {
    this.renderer = e, this.modelProvider = t;
  }
  renderTemplate(e) {
    return { data: this.renderer.renderTemplate(e), disposable: U.None };
  }
  renderElement(e, t, i, n) {
    var l;
    if ((l = i.disposable) == null || l.dispose(), !i.data)
      return;
    const o = this.modelProvider();
    if (o.isResolved(e))
      return this.renderer.renderElement(o.get(e), e, i.data, n);
    const r = new Vs(), a = o.resolve(e, r.token);
    i.disposable = { dispose: () => r.cancel() }, this.renderer.renderPlaceholder(e, i.data), a.then((c) => this.renderer.renderElement(c, e, i.data, n));
  }
  disposeTemplate(e) {
    e.disposable && (e.disposable.dispose(), e.disposable = void 0), e.data && (this.renderer.disposeTemplate(e.data), e.data = void 0);
  }
}
class DX {
  constructor(e, t) {
    this.modelProvider = e, this.accessibilityProvider = t;
  }
  getWidgetAriaLabel() {
    return this.accessibilityProvider.getWidgetAriaLabel();
  }
  getAriaLabel(e) {
    const t = this.modelProvider();
    return t.isResolved(e) ? this.accessibilityProvider.getAriaLabel(t.get(e)) : null;
  }
}
function EX(s, e) {
  return {
    ...e,
    accessibilityProvider: e.accessibilityProvider && new DX(s, e.accessibilityProvider)
  };
}
class IX {
  constructor(e, t, i, n, o = {}) {
    const r = () => this.model, a = n.map((l) => new xX(l, r));
    this.list = new wo(e, t, i, a, EX(r, o));
  }
  updateOptions(e) {
    this.list.updateOptions(e);
  }
  getHTMLElement() {
    return this.list.getHTMLElement();
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get widget() {
    return this.list;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  get onMouseDblClick() {
    return ee.map(this.list.onMouseDblClick, ({ element: e, index: t, browserEvent: i }) => ({ element: e === void 0 ? void 0 : this._model.get(e), index: t, browserEvent: i }));
  }
  get onPointer() {
    return ee.map(this.list.onPointer, ({ element: e, index: t, browserEvent: i }) => ({ element: e === void 0 ? void 0 : this._model.get(e), index: t, browserEvent: i }));
  }
  get onDidChangeSelection() {
    return ee.map(this.list.onDidChangeSelection, ({ elements: e, indexes: t, browserEvent: i }) => ({ elements: e.map((n) => this._model.get(n)), indexes: t, browserEvent: i }));
  }
  get model() {
    return this._model;
  }
  set model(e) {
    this._model = e, this.list.splice(0, this.list.length, xn(e.length));
  }
  getFocus() {
    return this.list.getFocus();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getSelectedElements() {
    return this.getSelection().map((e) => this.model.get(e));
  }
  style(e) {
    this.list.style(e);
  }
  dispose() {
    this.list.dispose();
  }
}
const NX = {
  separatorBorder: j.transparent
};
class BF {
  set size(e) {
    this._size = e;
  }
  get size() {
    return this._size;
  }
  get visible() {
    return typeof this._cachedVisibleSize > "u";
  }
  setVisible(e, t) {
    var i, n;
    if (e !== this.visible) {
      e ? (this.size = Dn(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize), this._cachedVisibleSize = void 0) : (this._cachedVisibleSize = typeof t == "number" ? t : this.size, this.size = 0), this.container.classList.toggle("visible", e);
      try {
        (n = (i = this.view).setVisible) == null || n.call(i, e);
      } catch (o) {
        console.error("Splitview: Failed to set visible view"), console.error(o);
      }
    }
  }
  get minimumSize() {
    return this.visible ? this.view.minimumSize : 0;
  }
  get viewMinimumSize() {
    return this.view.minimumSize;
  }
  get maximumSize() {
    return this.visible ? this.view.maximumSize : 0;
  }
  get viewMaximumSize() {
    return this.view.maximumSize;
  }
  get priority() {
    return this.view.priority;
  }
  get proportionalLayout() {
    return this.view.proportionalLayout ?? !0;
  }
  get snap() {
    return !!this.view.snap;
  }
  set enabled(e) {
    this.container.style.pointerEvents = e ? "" : "none";
  }
  constructor(e, t, i, n) {
    this.container = e, this.view = t, this.disposable = n, this._cachedVisibleSize = void 0, typeof i == "number" ? (this._size = i, this._cachedVisibleSize = void 0, e.classList.add("visible")) : (this._size = 0, this._cachedVisibleSize = i.cachedVisibleSize);
  }
  layout(e, t) {
    this.layoutContainer(e);
    try {
      this.view.layout(this.size, e, t);
    } catch (i) {
      console.error("Splitview: Failed to layout view"), console.error(i);
    }
  }
  dispose() {
    this.disposable.dispose();
  }
}
class TX extends BF {
  layoutContainer(e) {
    this.container.style.top = `${e}px`, this.container.style.height = `${this.size}px`;
  }
}
class MX extends BF {
  layoutContainer(e) {
    this.container.style.left = `${e}px`, this.container.style.width = `${this.size}px`;
  }
}
var ca;
(function(s) {
  s[s.Idle = 0] = "Idle", s[s.Busy = 1] = "Busy";
})(ca || (ca = {}));
var V1;
(function(s) {
  s.Distribute = { type: "distribute" };
  function e(n) {
    return { type: "split", index: n };
  }
  s.Split = e;
  function t(n) {
    return { type: "auto", index: n };
  }
  s.Auto = t;
  function i(n) {
    return { type: "invisible", cachedVisibleSize: n };
  }
  s.Invisible = i;
})(V1 || (V1 = {}));
class WF extends U {
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  get startSnappingEnabled() {
    return this._startSnappingEnabled;
  }
  get endSnappingEnabled() {
    return this._endSnappingEnabled;
  }
  /**
   * A reference to a sash, perpendicular to all sashes in this {@link SplitView},
   * located at the left- or top-most side of the SplitView.
   * Corner sashes will be created automatically at the intersections.
   */
  set orthogonalStartSash(e) {
    for (const t of this.sashItems)
      t.sash.orthogonalStartSash = e;
    this._orthogonalStartSash = e;
  }
  /**
   * A reference to a sash, perpendicular to all sashes in this {@link SplitView},
   * located at the right- or bottom-most side of the SplitView.
   * Corner sashes will be created automatically at the intersections.
   */
  set orthogonalEndSash(e) {
    for (const t of this.sashItems)
      t.sash.orthogonalEndSash = e;
    this._orthogonalEndSash = e;
  }
  /**
   * Enable/disable snapping at the beginning of this {@link SplitView}.
   */
  set startSnappingEnabled(e) {
    this._startSnappingEnabled !== e && (this._startSnappingEnabled = e, this.updateSashEnablement());
  }
  /**
   * Enable/disable snapping at the end of this {@link SplitView}.
   */
  set endSnappingEnabled(e) {
    this._endSnappingEnabled !== e && (this._endSnappingEnabled = e, this.updateSashEnablement());
  }
  /**
   * Create a new {@link SplitView} instance.
   */
  constructor(e, t = {}) {
    super(), this.size = 0, this._contentSize = 0, this.proportions = void 0, this.viewItems = [], this.sashItems = [], this.state = ca.Idle, this._onDidSashChange = this._register(new A()), this._onDidSashReset = this._register(new A()), this._startSnappingEnabled = !0, this._endSnappingEnabled = !0, this.onDidSashChange = this._onDidSashChange.event, this.onDidSashReset = this._onDidSashReset.event, this.orientation = t.orientation ?? 0, this.inverseAltBehavior = t.inverseAltBehavior ?? !1, this.proportionalLayout = t.proportionalLayout ?? !0, this.getSashOrthogonalSize = t.getSashOrthogonalSize, this.el = document.createElement("div"), this.el.classList.add("monaco-split-view2"), this.el.classList.add(this.orientation === 0 ? "vertical" : "horizontal"), e.appendChild(this.el), this.sashContainer = te(this.el, he(".sash-container")), this.viewContainer = he(".split-view-container"), this.scrollable = this._register(new Pf({
      forceIntegerValues: !0,
      smoothScrollDuration: 125,
      scheduleAtNextAnimationFrame: (n) => ns(fe(this.el), n)
    })), this.scrollableElement = this._register(new rw(this.viewContainer, {
      vertical: this.orientation === 0 ? t.scrollbarVisibility ?? 1 : 2,
      horizontal: this.orientation === 1 ? t.scrollbarVisibility ?? 1 : 2
      /* ScrollbarVisibility.Hidden */
    }, this.scrollable));
    const i = this._register(new He(this.viewContainer, "scroll")).event;
    this._register(i((n) => {
      const o = this.scrollableElement.getScrollPosition(), r = Math.abs(this.viewContainer.scrollLeft - o.scrollLeft) <= 1 ? void 0 : this.viewContainer.scrollLeft, a = Math.abs(this.viewContainer.scrollTop - o.scrollTop) <= 1 ? void 0 : this.viewContainer.scrollTop;
      (r !== void 0 || a !== void 0) && this.scrollableElement.setScrollPosition({ scrollLeft: r, scrollTop: a });
    })), this.onDidScroll = this.scrollableElement.onScroll, this._register(this.onDidScroll((n) => {
      n.scrollTopChanged && (this.viewContainer.scrollTop = n.scrollTop), n.scrollLeftChanged && (this.viewContainer.scrollLeft = n.scrollLeft);
    })), te(this.el, this.scrollableElement.getDomNode()), this.style(t.styles || NX), t.descriptor && (this.size = t.descriptor.size, t.descriptor.views.forEach((n, o) => {
      const r = As(n.visible) || n.visible ? n.size : { type: "invisible", cachedVisibleSize: n.size }, a = n.view;
      this.doAddView(a, r, o, !0);
    }), this._contentSize = this.viewItems.reduce((n, o) => n + o.size, 0), this.saveProportions());
  }
  style(e) {
    e.separatorBorder.isTransparent() ? (this.el.classList.remove("separator-border"), this.el.style.removeProperty("--separator-border")) : (this.el.classList.add("separator-border"), this.el.style.setProperty("--separator-border", e.separatorBorder.toString()));
  }
  /**
   * Add a {@link IView view} to this {@link SplitView}.
   *
   * @param view The view to add.
   * @param size Either a fixed size, or a dynamic {@link Sizing} strategy.
   * @param index The index to insert the view on.
   * @param skipLayout Whether layout should be skipped.
   */
  addView(e, t, i = this.viewItems.length, n) {
    this.doAddView(e, t, i, n);
  }
  /**
   * Layout the {@link SplitView}.
   *
   * @param size The entire size of the {@link SplitView}.
   * @param layoutContext An optional layout context to pass along to {@link IView views}.
   */
  layout(e, t) {
    const i = Math.max(this.size, this._contentSize);
    if (this.size = e, this.layoutContext = t, this.proportions) {
      let n = 0;
      for (let o = 0; o < this.viewItems.length; o++) {
        const r = this.viewItems[o], a = this.proportions[o];
        typeof a == "number" ? n += a : e -= r.size;
      }
      for (let o = 0; o < this.viewItems.length; o++) {
        const r = this.viewItems[o], a = this.proportions[o];
        typeof a == "number" && n > 0 && (r.size = Dn(Math.round(a * e / n), r.minimumSize, r.maximumSize));
      }
    } else {
      const n = xn(this.viewItems.length), o = n.filter(
        (a) => this.viewItems[a].priority === 1
        /* LayoutPriority.Low */
      ), r = n.filter(
        (a) => this.viewItems[a].priority === 2
        /* LayoutPriority.High */
      );
      this.resize(this.viewItems.length - 1, e - i, void 0, o, r);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  saveProportions() {
    this.proportionalLayout && this._contentSize > 0 && (this.proportions = this.viewItems.map((e) => e.proportionalLayout && e.visible ? e.size / this._contentSize : void 0));
  }
  onSashStart({ sash: e, start: t, alt: i }) {
    for (const a of this.viewItems)
      a.enabled = !1;
    const n = this.sashItems.findIndex((a) => a.sash === e), o = ao(z(this.el.ownerDocument.body, "keydown", (a) => r(this.sashDragState.current, a.altKey)), z(this.el.ownerDocument.body, "keyup", () => r(this.sashDragState.current, !1))), r = (a, l) => {
      const c = this.viewItems.map((g) => g.size);
      let h = Number.NEGATIVE_INFINITY, d = Number.POSITIVE_INFINITY;
      if (this.inverseAltBehavior && (l = !l), l)
        if (n === this.sashItems.length - 1) {
          const p = this.viewItems[n];
          h = (p.minimumSize - p.size) / 2, d = (p.maximumSize - p.size) / 2;
        } else {
          const p = this.viewItems[n + 1];
          h = (p.size - p.maximumSize) / 2, d = (p.size - p.minimumSize) / 2;
        }
      let u, f;
      if (!l) {
        const g = xn(n, -1), p = xn(n + 1, this.viewItems.length), _ = g.reduce((x, I) => x + (this.viewItems[I].minimumSize - c[I]), 0), b = g.reduce((x, I) => x + (this.viewItems[I].viewMaximumSize - c[I]), 0), C = p.length === 0 ? Number.POSITIVE_INFINITY : p.reduce((x, I) => x + (c[I] - this.viewItems[I].minimumSize), 0), w = p.length === 0 ? Number.NEGATIVE_INFINITY : p.reduce((x, I) => x + (c[I] - this.viewItems[I].viewMaximumSize), 0), v = Math.max(_, w), S = Math.min(C, b), L = this.findFirstSnapIndex(g), k = this.findFirstSnapIndex(p);
        if (typeof L == "number") {
          const x = this.viewItems[L], I = Math.floor(x.viewMinimumSize / 2);
          u = {
            index: L,
            limitDelta: x.visible ? v - I : v + I,
            size: x.size
          };
        }
        if (typeof k == "number") {
          const x = this.viewItems[k], I = Math.floor(x.viewMinimumSize / 2);
          f = {
            index: k,
            limitDelta: x.visible ? S + I : S - I,
            size: x.size
          };
        }
      }
      this.sashDragState = { start: a, current: a, index: n, sizes: c, minDelta: h, maxDelta: d, alt: l, snapBefore: u, snapAfter: f, disposable: o };
    };
    r(t, i);
  }
  onSashChange({ current: e }) {
    const { index: t, start: i, sizes: n, alt: o, minDelta: r, maxDelta: a, snapBefore: l, snapAfter: c } = this.sashDragState;
    this.sashDragState.current = e;
    const h = e - i, d = this.resize(t, h, n, void 0, void 0, r, a, l, c);
    if (o) {
      const u = t === this.sashItems.length - 1, f = this.viewItems.map((w) => w.size), g = u ? t : t + 1, p = this.viewItems[g], _ = p.size - p.maximumSize, b = p.size - p.minimumSize, C = u ? t - 1 : t + 1;
      this.resize(C, -d, f, void 0, void 0, _, b);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  onSashEnd(e) {
    this._onDidSashChange.fire(e), this.sashDragState.disposable.dispose(), this.saveProportions();
    for (const t of this.viewItems)
      t.enabled = !0;
  }
  onViewChange(e, t) {
    const i = this.viewItems.indexOf(e);
    i < 0 || i >= this.viewItems.length || (t = typeof t == "number" ? t : e.size, t = Dn(t, e.minimumSize, e.maximumSize), this.inverseAltBehavior && i > 0 ? (this.resize(i - 1, Math.floor((e.size - t) / 2)), this.distributeEmptySpace(), this.layoutViews()) : (e.size = t, this.relayout([i], void 0)));
  }
  /**
   * Resize a {@link IView view} within the {@link SplitView}.
   *
   * @param index The {@link IView view} index.
   * @param size The {@link IView view} size.
   */
  resizeView(e, t) {
    if (!(e < 0 || e >= this.viewItems.length)) {
      if (this.state !== ca.Idle)
        throw new Error("Cant modify splitview");
      this.state = ca.Busy;
      try {
        const i = xn(this.viewItems.length).filter((a) => a !== e), n = [...i.filter(
          (a) => this.viewItems[a].priority === 1
          /* LayoutPriority.Low */
        ), e], o = i.filter(
          (a) => this.viewItems[a].priority === 2
          /* LayoutPriority.High */
        ), r = this.viewItems[e];
        t = Math.round(t), t = Dn(t, r.minimumSize, Math.min(r.maximumSize, this.size)), r.size = t, this.relayout(n, o);
      } finally {
        this.state = ca.Idle;
      }
    }
  }
  /**
   * Distribute the entire {@link SplitView} size among all {@link IView views}.
   */
  distributeViewSizes() {
    const e = [];
    let t = 0;
    for (const a of this.viewItems)
      a.maximumSize - a.minimumSize > 0 && (e.push(a), t += a.size);
    const i = Math.floor(t / e.length);
    for (const a of e)
      a.size = Dn(i, a.minimumSize, a.maximumSize);
    const n = xn(this.viewItems.length), o = n.filter(
      (a) => this.viewItems[a].priority === 1
      /* LayoutPriority.Low */
    ), r = n.filter(
      (a) => this.viewItems[a].priority === 2
      /* LayoutPriority.High */
    );
    this.relayout(o, r);
  }
  /**
   * Returns the size of a {@link IView view}.
   */
  getViewSize(e) {
    return e < 0 || e >= this.viewItems.length ? -1 : this.viewItems[e].size;
  }
  doAddView(e, t, i = this.viewItems.length, n) {
    if (this.state !== ca.Idle)
      throw new Error("Cant modify splitview");
    this.state = ca.Busy;
    try {
      const o = he(".split-view-view");
      i === this.viewItems.length ? this.viewContainer.appendChild(o) : this.viewContainer.insertBefore(o, this.viewContainer.children.item(i));
      const r = e.onDidChange((u) => this.onViewChange(h, u)), a = _e(() => o.remove()), l = ao(r, a);
      let c;
      typeof t == "number" ? c = t : (t.type === "auto" && (this.areViewsDistributed() ? t = { type: "distribute" } : t = { type: "split", index: t.index }), t.type === "split" ? c = this.getViewSize(t.index) / 2 : t.type === "invisible" ? c = { cachedVisibleSize: t.cachedVisibleSize } : c = e.minimumSize);
      const h = this.orientation === 0 ? new TX(o, e, c, l) : new MX(o, e, c, l);
      if (this.viewItems.splice(i, 0, h), this.viewItems.length > 1) {
        const u = { orthogonalStartSash: this.orthogonalStartSash, orthogonalEndSash: this.orthogonalEndSash }, f = this.orientation === 0 ? new on(this.sashContainer, { getHorizontalSashTop: (x) => this.getSashPosition(x), getHorizontalSashWidth: this.getSashOrthogonalSize }, {
          ...u,
          orientation: 1
          /* Orientation.HORIZONTAL */
        }) : new on(this.sashContainer, { getVerticalSashLeft: (x) => this.getSashPosition(x), getVerticalSashHeight: this.getSashOrthogonalSize }, {
          ...u,
          orientation: 0
          /* Orientation.VERTICAL */
        }), g = this.orientation === 0 ? (x) => ({ sash: f, start: x.startY, current: x.currentY, alt: x.altKey }) : (x) => ({ sash: f, start: x.startX, current: x.currentX, alt: x.altKey }), _ = ee.map(f.onDidStart, g)(this.onSashStart, this), C = ee.map(f.onDidChange, g)(this.onSashChange, this), v = ee.map(f.onDidEnd, () => this.sashItems.findIndex((x) => x.sash === f))(this.onSashEnd, this), S = f.onDidReset(() => {
          const x = this.sashItems.findIndex((H) => H.sash === f), I = xn(x, -1), K = xn(x + 1, this.viewItems.length), B = this.findFirstSnapIndex(I), W = this.findFirstSnapIndex(K);
          typeof B == "number" && !this.viewItems[B].visible || typeof W == "number" && !this.viewItems[W].visible || this._onDidSashReset.fire(x);
        }), L = ao(_, C, v, S, f), k = { sash: f, disposable: L };
        this.sashItems.splice(i - 1, 0, k);
      }
      o.appendChild(e.element);
      let d;
      typeof t != "number" && t.type === "split" && (d = [t.index]), n || this.relayout([i], d), !n && typeof t != "number" && t.type === "distribute" && this.distributeViewSizes();
    } finally {
      this.state = ca.Idle;
    }
  }
  relayout(e, t) {
    const i = this.viewItems.reduce((n, o) => n + o.size, 0);
    this.resize(this.viewItems.length - 1, this.size - i, void 0, e, t), this.distributeEmptySpace(), this.layoutViews(), this.saveProportions();
  }
  resize(e, t, i = this.viewItems.map((h) => h.size), n, o, r = Number.NEGATIVE_INFINITY, a = Number.POSITIVE_INFINITY, l, c) {
    if (e < 0 || e >= this.viewItems.length)
      return 0;
    const h = xn(e, -1), d = xn(e + 1, this.viewItems.length);
    if (o)
      for (const k of o)
        S0(h, k), S0(d, k);
    if (n)
      for (const k of n)
        u_(h, k), u_(d, k);
    const u = h.map((k) => this.viewItems[k]), f = h.map((k) => i[k]), g = d.map((k) => this.viewItems[k]), p = d.map((k) => i[k]), _ = h.reduce((k, x) => k + (this.viewItems[x].minimumSize - i[x]), 0), b = h.reduce((k, x) => k + (this.viewItems[x].maximumSize - i[x]), 0), C = d.length === 0 ? Number.POSITIVE_INFINITY : d.reduce((k, x) => k + (i[x] - this.viewItems[x].minimumSize), 0), w = d.length === 0 ? Number.NEGATIVE_INFINITY : d.reduce((k, x) => k + (i[x] - this.viewItems[x].maximumSize), 0), v = Math.max(_, w, r), S = Math.min(C, b, a);
    let L = !1;
    if (l) {
      const k = this.viewItems[l.index], x = t >= l.limitDelta;
      L = x !== k.visible, k.setVisible(x, l.size);
    }
    if (!L && c) {
      const k = this.viewItems[c.index], x = t < c.limitDelta;
      L = x !== k.visible, k.setVisible(x, c.size);
    }
    if (L)
      return this.resize(e, t, i, n, o, r, a);
    t = Dn(t, v, S);
    for (let k = 0, x = t; k < u.length; k++) {
      const I = u[k], K = Dn(f[k] + x, I.minimumSize, I.maximumSize), B = K - f[k];
      x -= B, I.size = K;
    }
    for (let k = 0, x = t; k < g.length; k++) {
      const I = g[k], K = Dn(p[k] - x, I.minimumSize, I.maximumSize), B = K - p[k];
      x += B, I.size = K;
    }
    return t;
  }
  distributeEmptySpace(e) {
    const t = this.viewItems.reduce((a, l) => a + l.size, 0);
    let i = this.size - t;
    const n = xn(this.viewItems.length - 1, -1), o = n.filter(
      (a) => this.viewItems[a].priority === 1
      /* LayoutPriority.Low */
    ), r = n.filter(
      (a) => this.viewItems[a].priority === 2
      /* LayoutPriority.High */
    );
    for (const a of r)
      S0(n, a);
    for (const a of o)
      u_(n, a);
    typeof e == "number" && u_(n, e);
    for (let a = 0; i !== 0 && a < n.length; a++) {
      const l = this.viewItems[n[a]], c = Dn(l.size + i, l.minimumSize, l.maximumSize), h = c - l.size;
      i -= h, l.size = c;
    }
  }
  layoutViews() {
    this._contentSize = this.viewItems.reduce((t, i) => t + i.size, 0);
    let e = 0;
    for (const t of this.viewItems)
      t.layout(e, this.layoutContext), e += t.size;
    this.sashItems.forEach((t) => t.sash.layout()), this.updateSashEnablement(), this.updateScrollableElement();
  }
  updateScrollableElement() {
    this.orientation === 0 ? this.scrollableElement.setScrollDimensions({
      height: this.size,
      scrollHeight: this._contentSize
    }) : this.scrollableElement.setScrollDimensions({
      width: this.size,
      scrollWidth: this._contentSize
    });
  }
  updateSashEnablement() {
    let e = !1;
    const t = this.viewItems.map((l) => e = l.size - l.minimumSize > 0 || e);
    e = !1;
    const i = this.viewItems.map((l) => e = l.maximumSize - l.size > 0 || e), n = [...this.viewItems].reverse();
    e = !1;
    const o = n.map((l) => e = l.size - l.minimumSize > 0 || e).reverse();
    e = !1;
    const r = n.map((l) => e = l.maximumSize - l.size > 0 || e).reverse();
    let a = 0;
    for (let l = 0; l < this.sashItems.length; l++) {
      const { sash: c } = this.sashItems[l], h = this.viewItems[l];
      a += h.size;
      const d = !(t[l] && r[l + 1]), u = !(i[l] && o[l + 1]);
      if (d && u) {
        const f = xn(l, -1), g = xn(l + 1, this.viewItems.length), p = this.findFirstSnapIndex(f), _ = this.findFirstSnapIndex(g), b = typeof p == "number" && !this.viewItems[p].visible, C = typeof _ == "number" && !this.viewItems[_].visible;
        b && o[l] && (a > 0 || this.startSnappingEnabled) ? c.state = 1 : C && t[l] && (a < this._contentSize || this.endSnappingEnabled) ? c.state = 2 : c.state = 0;
      } else d && !u ? c.state = 1 : !d && u ? c.state = 2 : c.state = 3;
    }
  }
  getSashPosition(e) {
    let t = 0;
    for (let i = 0; i < this.sashItems.length; i++)
      if (t += this.viewItems[i].size, this.sashItems[i].sash === e)
        return t;
    return 0;
  }
  findFirstSnapIndex(e) {
    for (const t of e) {
      const i = this.viewItems[t];
      if (i.visible && i.snap)
        return t;
    }
    for (const t of e) {
      const i = this.viewItems[t];
      if (i.visible && i.maximumSize - i.minimumSize > 0)
        return;
      if (!i.visible && i.snap)
        return t;
    }
  }
  areViewsDistributed() {
    let e, t;
    for (const i of this.viewItems)
      if (e = e === void 0 ? i.size : Math.min(e, i.size), t = t === void 0 ? i.size : Math.max(t, i.size), t - e > 2)
        return !1;
    return !0;
  }
  dispose() {
    var e;
    (e = this.sashDragState) == null || e.disposable.dispose(), Ft(this.viewItems), this.viewItems = [], this.sashItems.forEach((t) => t.disposable.dispose()), this.sashItems = [], super.dispose();
  }
}
const uv = class uv {
  constructor(e, t, i) {
    this.columns = e, this.getColumnSize = i, this.templateId = uv.TemplateId, this.renderedTemplates = /* @__PURE__ */ new Set();
    const n = new Map(t.map((o) => [o.templateId, o]));
    this.renderers = [];
    for (const o of e) {
      const r = n.get(o.templateId);
      if (!r)
        throw new Error(`Table cell renderer for template id ${o.templateId} not found.`);
      this.renderers.push(r);
    }
  }
  renderTemplate(e) {
    const t = te(e, he(".monaco-table-tr")), i = [], n = [];
    for (let r = 0; r < this.columns.length; r++) {
      const a = this.renderers[r], l = te(t, he(".monaco-table-td", { "data-col-index": r }));
      l.style.width = `${this.getColumnSize(r)}px`, i.push(l), n.push(a.renderTemplate(l));
    }
    const o = { container: e, cellContainers: i, cellTemplateData: n };
    return this.renderedTemplates.add(o), o;
  }
  renderElement(e, t, i, n) {
    for (let o = 0; o < this.columns.length; o++) {
      const a = this.columns[o].project(e);
      this.renderers[o].renderElement(a, t, i.cellTemplateData[o], n);
    }
  }
  disposeElement(e, t, i, n) {
    for (let o = 0; o < this.columns.length; o++) {
      const r = this.renderers[o];
      if (r.disposeElement) {
        const l = this.columns[o].project(e);
        r.disposeElement(l, t, i.cellTemplateData[o], n);
      }
    }
  }
  disposeTemplate(e) {
    for (let t = 0; t < this.columns.length; t++)
      this.renderers[t].disposeTemplate(e.cellTemplateData[t]);
    ks(e.container), this.renderedTemplates.delete(e);
  }
  layoutColumn(e, t) {
    for (const { cellContainers: i } of this.renderedTemplates)
      i[e].style.width = `${t}px`;
  }
};
uv.TemplateId = "row";
let z1 = uv;
function RX(s) {
  return {
    getHeight(e) {
      return s.getHeight(e);
    },
    getTemplateId() {
      return z1.TemplateId;
    }
  };
}
class AX extends U {
  get minimumSize() {
    return this.column.minimumWidth ?? 120;
  }
  get maximumSize() {
    return this.column.maximumWidth ?? Number.POSITIVE_INFINITY;
  }
  get onDidChange() {
    return this.column.onDidChangeWidthConstraints ?? ee.None;
  }
  constructor(e, t) {
    super(), this.column = e, this.index = t, this._onDidLayout = new A(), this.onDidLayout = this._onDidLayout.event, this.element = he(".monaco-table-th", { "data-col-index": t }, e.label), e.tooltip && this._register(jr().setupManagedHover($s("mouse"), this.element, e.tooltip));
  }
  layout(e) {
    this._onDidLayout.fire([this.index, e]);
  }
}
const fv = class fv {
  get onDidChangeFocus() {
    return this.list.onDidChangeFocus;
  }
  get onDidChangeSelection() {
    return this.list.onDidChangeSelection;
  }
  get onDidScroll() {
    return this.list.onDidScroll;
  }
  get onMouseDblClick() {
    return this.list.onMouseDblClick;
  }
  get onPointer() {
    return this.list.onPointer;
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get scrollTop() {
    return this.list.scrollTop;
  }
  set scrollTop(e) {
    this.list.scrollTop = e;
  }
  get scrollHeight() {
    return this.list.scrollHeight;
  }
  get renderHeight() {
    return this.list.renderHeight;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  constructor(e, t, i, n, o, r) {
    this.virtualDelegate = i, this.columns = n, this.domId = `table_id_${++fv.InstanceCount}`, this.disposables = new ne(), this.cachedWidth = 0, this.cachedHeight = 0, this.domNode = te(t, he(`.monaco-table.${this.domId}`));
    const a = n.map((h, d) => this.disposables.add(new AX(h, d))), l = {
      size: a.reduce((h, d) => h + d.column.weight, 0),
      views: a.map((h) => ({ size: h.column.weight, view: h }))
    };
    this.splitview = this.disposables.add(new WF(this.domNode, {
      orientation: 1,
      scrollbarVisibility: 2,
      getSashOrthogonalSize: () => this.cachedHeight,
      descriptor: l
    })), this.splitview.el.style.height = `${i.headerRowHeight}px`, this.splitview.el.style.lineHeight = `${i.headerRowHeight}px`;
    const c = new z1(n, o, (h) => this.splitview.getViewSize(h));
    this.list = this.disposables.add(new wo(e, this.domNode, RX(i), [c], r)), ee.any(...a.map((h) => h.onDidLayout))(([h, d]) => c.layoutColumn(h, d), null, this.disposables), this.splitview.onDidSashReset((h) => {
      const d = n.reduce((f, g) => f + g.weight, 0), u = n[h].weight / d * this.cachedWidth;
      this.splitview.resizeView(h, u);
    }, null, this.disposables), this.styleElement = Us(this.domNode), this.style(jH);
  }
  updateOptions(e) {
    this.list.updateOptions(e);
  }
  splice(e, t, i = []) {
    this.list.splice(e, t, i);
  }
  getHTMLElement() {
    return this.domNode;
  }
  style(e) {
    const t = [];
    t.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {
			top: ${this.virtualDelegate.headerRowHeight + 1}px;
			height: calc(100% - ${this.virtualDelegate.headerRowHeight}px);
		}`), this.styleElement.textContent = t.join(`
`), this.list.style(e);
  }
  getSelectedElements() {
    return this.list.getSelectedElements();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getFocus() {
    return this.list.getFocus();
  }
  dispose() {
    this.disposables.dispose();
  }
};
fv.InstanceCount = 0;
let xL = fv;
class Mw extends qr {
  constructor(e) {
    super(), this._onChange = this._register(new A()), this.onChange = this._onChange.event, this._onKeyDown = this._register(new A()), this.onKeyDown = this._onKeyDown.event, this._opts = e, this._checked = this._opts.isChecked;
    const t = ["monaco-custom-toggle"];
    this._opts.icon && (this._icon = this._opts.icon, t.push(...Te.asClassNameArray(this._icon))), this._opts.actionClassName && t.push(...this._opts.actionClassName.split(" ")), this._checked && t.push("checked"), this.domNode = document.createElement("div"), this._hover = this._register(jr().setupManagedHover(e.hoverDelegate ?? $s("mouse"), this.domNode, this._opts.title)), this.domNode.classList.add(...t), this._opts.notFocusable || (this.domNode.tabIndex = 0), this.domNode.setAttribute("role", "checkbox"), this.domNode.setAttribute("aria-checked", String(this._checked)), this.domNode.setAttribute("aria-label", this._opts.title), this.applyStyles(), this.onclick(this.domNode, (i) => {
      this.enabled && (this.checked = !this._checked, this._onChange.fire(!1), i.preventDefault());
    }), this._register(this.ignoreGesture(this.domNode)), this.onkeydown(this.domNode, (i) => {
      if (i.keyCode === 10 || i.keyCode === 3) {
        this.checked = !this._checked, this._onChange.fire(!0), i.preventDefault(), i.stopPropagation();
        return;
      }
      this._onKeyDown.fire(i);
    });
  }
  get enabled() {
    return this.domNode.getAttribute("aria-disabled") !== "true";
  }
  focus() {
    this.domNode.focus();
  }
  get checked() {
    return this._checked;
  }
  set checked(e) {
    this._checked = e, this.domNode.setAttribute("aria-checked", String(this._checked)), this.domNode.classList.toggle("checked", this._checked), this.applyStyles();
  }
  width() {
    return 22;
  }
  applyStyles() {
    this.domNode && (this.domNode.style.borderColor = this._checked && this._opts.inputActiveOptionBorder || "", this.domNode.style.color = this._checked && this._opts.inputActiveOptionForeground || "inherit", this.domNode.style.backgroundColor = this._checked && this._opts.inputActiveOptionBackground || "");
  }
  enable() {
    this.domNode.setAttribute("aria-disabled", String(!1));
  }
  disable() {
    this.domNode.setAttribute("aria-disabled", String(!0));
  }
}
const PX = m("caseDescription", "Match Case"), OX = m("wordsDescription", "Match Whole Word"), FX = m("regexDescription", "Use Regular Expression");
class BX extends Mw {
  constructor(e) {
    super({
      icon: ie.caseSensitive,
      title: PX + e.appendTitle,
      isChecked: e.isChecked,
      hoverDelegate: e.hoverDelegate ?? $s("element"),
      inputActiveOptionBorder: e.inputActiveOptionBorder,
      inputActiveOptionForeground: e.inputActiveOptionForeground,
      inputActiveOptionBackground: e.inputActiveOptionBackground
    });
  }
}
class WX extends Mw {
  constructor(e) {
    super({
      icon: ie.wholeWord,
      title: OX + e.appendTitle,
      isChecked: e.isChecked,
      hoverDelegate: e.hoverDelegate ?? $s("element"),
      inputActiveOptionBorder: e.inputActiveOptionBorder,
      inputActiveOptionForeground: e.inputActiveOptionForeground,
      inputActiveOptionBackground: e.inputActiveOptionBackground
    });
  }
}
class HX extends Mw {
  constructor(e) {
    super({
      icon: ie.regex,
      title: FX + e.appendTitle,
      isChecked: e.isChecked,
      hoverDelegate: e.hoverDelegate ?? $s("element"),
      inputActiveOptionBorder: e.inputActiveOptionBorder,
      inputActiveOptionForeground: e.inputActiveOptionForeground,
      inputActiveOptionBackground: e.inputActiveOptionBackground
    });
  }
}
class VX {
  constructor(e, t = 0, i = e.length, n = t - 1) {
    this.items = e, this.start = t, this.end = i, this.index = n;
  }
  current() {
    return this.index === this.start - 1 || this.index === this.end ? null : this.items[this.index];
  }
  next() {
    return this.index = Math.min(this.index + 1, this.end), this.current();
  }
  previous() {
    return this.index = Math.max(this.index - 1, this.start - 1), this.current();
  }
  first() {
    return this.index = this.start, this.current();
  }
  last() {
    return this.index = this.end - 1, this.current();
  }
}
class zX {
  constructor(e = [], t = 10) {
    this._initialize(e), this._limit = t, this._onChange();
  }
  getHistory() {
    return this._elements;
  }
  add(e) {
    this._history.delete(e), this._history.add(e), this._onChange();
  }
  next() {
    return this._navigator.next();
  }
  previous() {
    return this._currentPosition() !== 0 ? this._navigator.previous() : null;
  }
  current() {
    return this._navigator.current();
  }
  first() {
    return this._navigator.first();
  }
  last() {
    return this._navigator.last();
  }
  isLast() {
    return this._currentPosition() >= this._elements.length - 1;
  }
  isNowhere() {
    return this._navigator.current() === null;
  }
  has(e) {
    return this._history.has(e);
  }
  _onChange() {
    this._reduceToLimit();
    const e = this._elements;
    this._navigator = new VX(e, 0, e.length, e.length);
  }
  _reduceToLimit() {
    const e = this._elements;
    e.length > this._limit && this._initialize(e.slice(e.length - this._limit));
  }
  _currentPosition() {
    const e = this._navigator.current();
    return e ? this._elements.indexOf(e) : -1;
  }
  _initialize(e) {
    this._history = /* @__PURE__ */ new Set();
    for (const t of e)
      this._history.add(t);
  }
  get _elements() {
    const e = [];
    return this._history.forEach((t) => e.push(t)), e;
  }
}
const og = he;
let UX = class extends qr {
  constructor(e, t, i) {
    super(), this.state = "idle", this.maxHeight = Number.POSITIVE_INFINITY, this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, this._onDidHeightChange = this._register(new A()), this.onDidHeightChange = this._onDidHeightChange.event, this.contextViewProvider = t, this.options = i, this.message = null, this.placeholder = this.options.placeholder || "", this.tooltip = this.options.tooltip ?? (this.placeholder || ""), this.ariaLabel = this.options.ariaLabel || "", this.options.validationOptions && (this.validation = this.options.validationOptions.validation), this.element = te(e, og(".monaco-inputbox.idle"));
    const n = this.options.flexibleHeight ? "textarea" : "input", o = te(this.element, og(".ibwrapper"));
    if (this.input = te(o, og(n + ".input.empty")), this.input.setAttribute("autocorrect", "off"), this.input.setAttribute("autocapitalize", "off"), this.input.setAttribute("spellcheck", "false"), this.onfocus(this.input, () => this.element.classList.add("synthetic-focus")), this.onblur(this.input, () => this.element.classList.remove("synthetic-focus")), this.options.flexibleHeight) {
      this.maxHeight = typeof this.options.flexibleMaxHeight == "number" ? this.options.flexibleMaxHeight : Number.POSITIVE_INFINITY, this.mirror = te(o, og("div.mirror")), this.mirror.innerText = " ", this.scrollableElement = new LO(this.element, {
        vertical: 1
        /* ScrollbarVisibility.Auto */
      }), this.options.flexibleWidth && (this.input.setAttribute("wrap", "off"), this.mirror.style.whiteSpace = "pre", this.mirror.style.wordWrap = "initial"), te(e, this.scrollableElement.getDomNode()), this._register(this.scrollableElement), this._register(this.scrollableElement.onScroll((l) => this.input.scrollTop = l.scrollTop));
      const r = this._register(new He(e.ownerDocument, "selectionchange")), a = ee.filter(r.event, () => {
        const l = e.ownerDocument.getSelection();
        return (l == null ? void 0 : l.anchorNode) === o;
      });
      this._register(a(this.updateScrollDimensions, this)), this._register(this.onDidHeightChange(this.updateScrollDimensions, this));
    } else
      this.input.type = this.options.type || "text", this.input.setAttribute("wrap", "off");
    this.ariaLabel && this.input.setAttribute("aria-label", this.ariaLabel), this.placeholder && !this.options.showPlaceholderOnFocus && this.setPlaceHolder(this.placeholder), this.tooltip && this.setTooltip(this.tooltip), this.oninput(this.input, () => this.onValueChange()), this.onblur(this.input, () => this.onBlur()), this.onfocus(this.input, () => this.onFocus()), this._register(this.ignoreGesture(this.input)), setTimeout(() => this.updateMirror(), 0), this.options.actions && (this.actionbar = this._register(new $o(this.element)), this.actionbar.push(this.options.actions, { icon: !0, label: !1 })), this.applyStyles();
  }
  onBlur() {
    this._hideMessage(), this.options.showPlaceholderOnFocus && this.input.setAttribute("placeholder", "");
  }
  onFocus() {
    this._showMessage(), this.options.showPlaceholderOnFocus && this.input.setAttribute("placeholder", this.placeholder || "");
  }
  setPlaceHolder(e) {
    this.placeholder = e, this.input.setAttribute("placeholder", e);
  }
  setTooltip(e) {
    this.tooltip = e, this.hover ? this.hover.update(e) : this.hover = this._register(jr().setupManagedHover($s("mouse"), this.input, e));
  }
  get inputElement() {
    return this.input;
  }
  get value() {
    return this.input.value;
  }
  set value(e) {
    this.input.value !== e && (this.input.value = e, this.onValueChange());
  }
  get height() {
    return typeof this.cachedHeight == "number" ? this.cachedHeight : Xc(this.element);
  }
  focus() {
    this.input.focus();
  }
  blur() {
    this.input.blur();
  }
  hasFocus() {
    return xE(this.input);
  }
  select(e = null) {
    this.input.select(), e && (this.input.setSelectionRange(e.start, e.end), e.end === this.input.value.length && (this.input.scrollLeft = this.input.scrollWidth));
  }
  isSelectionAtEnd() {
    return this.input.selectionEnd === this.input.value.length && this.input.selectionStart === this.input.selectionEnd;
  }
  getSelection() {
    const e = this.input.selectionStart;
    if (e === null)
      return null;
    const t = this.input.selectionEnd ?? e;
    return {
      start: e,
      end: t
    };
  }
  enable() {
    this.input.removeAttribute("disabled");
  }
  disable() {
    this.blur(), this.input.disabled = !0, this._hideMessage();
  }
  set paddingRight(e) {
    this.input.style.width = `calc(100% - ${e}px)`, this.mirror && (this.mirror.style.paddingRight = e + "px");
  }
  updateScrollDimensions() {
    if (typeof this.cachedContentHeight != "number" || typeof this.cachedHeight != "number" || !this.scrollableElement)
      return;
    const e = this.cachedContentHeight, t = this.cachedHeight, i = this.input.scrollTop;
    this.scrollableElement.setScrollDimensions({ scrollHeight: e, height: t }), this.scrollableElement.setScrollPosition({ scrollTop: i });
  }
  showMessage(e, t) {
    if (this.state === "open" && Xn(this.message, e))
      return;
    this.message = e, this.element.classList.remove("idle"), this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add(this.classForType(e.type));
    const i = this.stylesForType(this.message.type);
    this.element.style.border = `1px solid ${Fa(i.border, "transparent")}`, this.message.content && (this.hasFocus() || t) && this._showMessage();
  }
  hideMessage() {
    this.message = null, this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add("idle"), this._hideMessage(), this.applyStyles();
  }
  validate() {
    let e = null;
    return this.validation && (e = this.validation(this.value), e ? (this.inputElement.setAttribute("aria-invalid", "true"), this.showMessage(e)) : this.inputElement.hasAttribute("aria-invalid") && (this.inputElement.removeAttribute("aria-invalid"), this.hideMessage())), e == null ? void 0 : e.type;
  }
  stylesForType(e) {
    const t = this.options.inputBoxStyles;
    switch (e) {
      case 1:
        return { border: t.inputValidationInfoBorder, background: t.inputValidationInfoBackground, foreground: t.inputValidationInfoForeground };
      case 2:
        return { border: t.inputValidationWarningBorder, background: t.inputValidationWarningBackground, foreground: t.inputValidationWarningForeground };
      default:
        return { border: t.inputValidationErrorBorder, background: t.inputValidationErrorBackground, foreground: t.inputValidationErrorForeground };
    }
  }
  classForType(e) {
    switch (e) {
      case 1:
        return "info";
      case 2:
        return "warning";
      default:
        return "error";
    }
  }
  _showMessage() {
    if (!this.contextViewProvider || !this.message)
      return;
    let e;
    const t = () => e.style.width = Nm(this.element) + "px";
    this.contextViewProvider.showContextView({
      getAnchor: () => this.element,
      anchorAlignment: 1,
      render: (n) => {
        if (!this.message)
          return null;
        e = te(n, og(".monaco-inputbox-container")), t();
        const o = {
          inline: !0,
          className: "monaco-inputbox-message"
        }, r = this.message.formatContent ? fW(this.message.content, o) : uW(this.message.content, o);
        r.classList.add(this.classForType(this.message.type));
        const a = this.stylesForType(this.message.type);
        return r.style.backgroundColor = a.background ?? "", r.style.color = a.foreground ?? "", r.style.border = a.border ? `1px solid ${a.border}` : "", te(e, r), null;
      },
      onHide: () => {
        this.state = "closed";
      },
      layout: t
    });
    let i;
    this.message.type === 3 ? i = m("alertErrorMessage", "Error: {0}", this.message.content) : this.message.type === 2 ? i = m("alertWarningMessage", "Warning: {0}", this.message.content) : i = m("alertInfoMessage", "Info: {0}", this.message.content), Uh(i), this.state = "open";
  }
  _hideMessage() {
    this.contextViewProvider && (this.state === "open" && this.contextViewProvider.hideContextView(), this.state = "idle");
  }
  onValueChange() {
    this._onDidChange.fire(this.value), this.validate(), this.updateMirror(), this.input.classList.toggle("empty", !this.value), this.state === "open" && this.contextViewProvider && this.contextViewProvider.layout();
  }
  updateMirror() {
    if (!this.mirror)
      return;
    const e = this.value, i = e.charCodeAt(e.length - 1) === 10 ? " " : "";
    (e + i).replace(/\u000c/g, "") ? this.mirror.textContent = e + i : this.mirror.innerText = " ", this.layout();
  }
  applyStyles() {
    const e = this.options.inputBoxStyles, t = e.inputBackground ?? "", i = e.inputForeground ?? "", n = e.inputBorder ?? "";
    this.element.style.backgroundColor = t, this.element.style.color = i, this.input.style.backgroundColor = "inherit", this.input.style.color = i, this.element.style.border = `1px solid ${Fa(n, "transparent")}`;
  }
  layout() {
    if (!this.mirror)
      return;
    const e = this.cachedContentHeight;
    this.cachedContentHeight = Xc(this.mirror), e !== this.cachedContentHeight && (this.cachedHeight = Math.min(this.cachedContentHeight, this.maxHeight), this.input.style.height = this.cachedHeight + "px", this._onDidHeightChange.fire(this.cachedContentHeight));
  }
  insertAtCursor(e) {
    const t = this.inputElement, i = t.selectionStart, n = t.selectionEnd, o = t.value;
    i !== null && n !== null && (this.value = o.substr(0, i) + e + o.substr(n), t.setSelectionRange(i + 1, i + 1), this.layout());
  }
  dispose() {
    var e;
    this._hideMessage(), this.message = null, (e = this.actionbar) == null || e.dispose(), super.dispose();
  }
};
class $X extends UX {
  constructor(e, t, i) {
    const n = m({
      key: "history.inputbox.hint.suffix.noparens",
      comment: ['Text is the suffix of an input field placeholder coming after the action the input field performs, this will be used when the input field ends in a closing parenthesis ")", for example "Filter (e.g. text, !exclude)". The character inserted into the final string is ⇅ to represent the up and down arrow keys.']
    }, " or {0} for history", "⇅"), o = m({
      key: "history.inputbox.hint.suffix.inparens",
      comment: ['Text is the suffix of an input field placeholder coming after the action the input field performs, this will be used when the input field does NOT end in a closing parenthesis (eg. "Find"). The character inserted into the final string is ⇅ to represent the up and down arrow keys.']
    }, " ({0} for history)", "⇅");
    super(e, t, i), this._onDidFocus = this._register(new A()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new A()), this.onDidBlur = this._onDidBlur.event, this.history = new zX(i.history, 100);
    const r = () => {
      if (i.showHistoryHint && i.showHistoryHint() && !this.placeholder.endsWith(n) && !this.placeholder.endsWith(o) && this.history.getHistory().length) {
        const a = this.placeholder.endsWith(")") ? n : o, l = this.placeholder + a;
        i.showPlaceholderOnFocus && !xE(this.input) ? this.placeholder = l : this.setPlaceHolder(l);
      }
    };
    this.observer = new MutationObserver((a, l) => {
      a.forEach((c) => {
        c.target.textContent || r();
      });
    }), this.observer.observe(this.input, { attributeFilter: ["class"] }), this.onfocus(this.input, () => r()), this.onblur(this.input, () => {
      const a = (l) => {
        if (this.placeholder.endsWith(l)) {
          const c = this.placeholder.slice(0, this.placeholder.length - l.length);
          return i.showPlaceholderOnFocus ? this.placeholder = c : this.setPlaceHolder(c), !0;
        } else
          return !1;
      };
      a(o) || a(n);
    });
  }
  dispose() {
    super.dispose(), this.observer && (this.observer.disconnect(), this.observer = void 0);
  }
  addToHistory(e) {
    this.value && (e || this.value !== this.getCurrentValue()) && this.history.add(this.value);
  }
  isAtLastInHistory() {
    return this.history.isLast();
  }
  isNowhereInHistory() {
    return this.history.isNowhere();
  }
  showNextValue() {
    this.history.has(this.value) || this.addToHistory();
    let e = this.getNextValue();
    e && (e = e === this.value ? this.getNextValue() : e), this.value = e ?? "", Rm(this.value ? this.value : m("clearedInput", "Cleared Input"));
  }
  showPreviousValue() {
    this.history.has(this.value) || this.addToHistory();
    let e = this.getPreviousValue();
    e && (e = e === this.value ? this.getPreviousValue() : e), e && (this.value = e, Rm(this.value));
  }
  setPlaceHolder(e) {
    super.setPlaceHolder(e), this.setTooltip(e);
  }
  onBlur() {
    super.onBlur(), this._onDidBlur.fire();
  }
  onFocus() {
    super.onFocus(), this._onDidFocus.fire();
  }
  getCurrentValue() {
    let e = this.history.current();
    return e || (e = this.history.last(), this.history.next()), e;
  }
  getPreviousValue() {
    return this.history.previous() || this.history.first();
  }
  getNextValue() {
    return this.history.next();
  }
}
const KX = m("defaultLabel", "input");
class jX extends qr {
  constructor(e, t, i) {
    super(), this.fixFocusOnOptionClickEnabled = !0, this.imeSessionInProgress = !1, this.additionalTogglesDisposables = this._register(new Hs()), this.additionalToggles = [], this._onDidOptionChange = this._register(new A()), this.onDidOptionChange = this._onDidOptionChange.event, this._onKeyDown = this._register(new A()), this.onKeyDown = this._onKeyDown.event, this._onMouseDown = this._register(new A()), this.onMouseDown = this._onMouseDown.event, this._onInput = this._register(new A()), this._onKeyUp = this._register(new A()), this._onCaseSensitiveKeyDown = this._register(new A()), this.onCaseSensitiveKeyDown = this._onCaseSensitiveKeyDown.event, this._onRegexKeyDown = this._register(new A()), this.onRegexKeyDown = this._onRegexKeyDown.event, this._lastHighlightFindOptions = 0, this.placeholder = i.placeholder || "", this.validation = i.validation, this.label = i.label || KX, this.showCommonFindToggles = !!i.showCommonFindToggles;
    const n = i.appendCaseSensitiveLabel || "", o = i.appendWholeWordsLabel || "", r = i.appendRegexLabel || "", a = i.history || [], l = !!i.flexibleHeight, c = !!i.flexibleWidth, h = i.flexibleMaxHeight;
    this.domNode = document.createElement("div"), this.domNode.classList.add("monaco-findInput"), this.inputBox = this._register(new $X(this.domNode, t, {
      placeholder: this.placeholder || "",
      ariaLabel: this.label || "",
      validationOptions: {
        validation: this.validation
      },
      history: a,
      showHistoryHint: i.showHistoryHint,
      flexibleHeight: l,
      flexibleWidth: c,
      flexibleMaxHeight: h,
      inputBoxStyles: i.inputBoxStyles
    }));
    const d = this._register(zE());
    if (this.showCommonFindToggles) {
      this.regex = this._register(new HX({
        appendTitle: r,
        isChecked: !1,
        hoverDelegate: d,
        ...i.toggleStyles
      })), this._register(this.regex.onChange((f) => {
        this._onDidOptionChange.fire(f), !f && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
      })), this._register(this.regex.onKeyDown((f) => {
        this._onRegexKeyDown.fire(f);
      })), this.wholeWords = this._register(new WX({
        appendTitle: o,
        isChecked: !1,
        hoverDelegate: d,
        ...i.toggleStyles
      })), this._register(this.wholeWords.onChange((f) => {
        this._onDidOptionChange.fire(f), !f && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
      })), this.caseSensitive = this._register(new BX({
        appendTitle: n,
        isChecked: !1,
        hoverDelegate: d,
        ...i.toggleStyles
      })), this._register(this.caseSensitive.onChange((f) => {
        this._onDidOptionChange.fire(f), !f && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
      })), this._register(this.caseSensitive.onKeyDown((f) => {
        this._onCaseSensitiveKeyDown.fire(f);
      }));
      const u = [this.caseSensitive.domNode, this.wholeWords.domNode, this.regex.domNode];
      this.onkeydown(this.domNode, (f) => {
        if (f.equals(
          15
          /* KeyCode.LeftArrow */
        ) || f.equals(
          17
          /* KeyCode.RightArrow */
        ) || f.equals(
          9
          /* KeyCode.Escape */
        )) {
          const g = u.indexOf(this.domNode.ownerDocument.activeElement);
          if (g >= 0) {
            let p = -1;
            f.equals(
              17
              /* KeyCode.RightArrow */
            ) ? p = (g + 1) % u.length : f.equals(
              15
              /* KeyCode.LeftArrow */
            ) && (g === 0 ? p = u.length - 1 : p = g - 1), f.equals(
              9
              /* KeyCode.Escape */
            ) ? (u[g].blur(), this.inputBox.focus()) : p >= 0 && u[p].focus(), Ge.stop(f, !0);
          }
        }
      });
    }
    this.controls = document.createElement("div"), this.controls.className = "controls", this.controls.style.display = this.showCommonFindToggles ? "" : "none", this.caseSensitive && this.controls.append(this.caseSensitive.domNode), this.wholeWords && this.controls.appendChild(this.wholeWords.domNode), this.regex && this.controls.appendChild(this.regex.domNode), this.setAdditionalToggles(i == null ? void 0 : i.additionalToggles), this.controls && this.domNode.appendChild(this.controls), e == null || e.appendChild(this.domNode), this._register(z(this.inputBox.inputElement, "compositionstart", (u) => {
      this.imeSessionInProgress = !0;
    })), this._register(z(this.inputBox.inputElement, "compositionend", (u) => {
      this.imeSessionInProgress = !1, this._onInput.fire();
    })), this.onkeydown(this.inputBox.inputElement, (u) => this._onKeyDown.fire(u)), this.onkeyup(this.inputBox.inputElement, (u) => this._onKeyUp.fire(u)), this.oninput(this.inputBox.inputElement, (u) => this._onInput.fire()), this.onmousedown(this.inputBox.inputElement, (u) => this._onMouseDown.fire(u));
  }
  get onDidChange() {
    return this.inputBox.onDidChange;
  }
  layout(e) {
    this.inputBox.layout(), this.updateInputBoxPadding(e.collapsedFindWidget);
  }
  enable() {
    var e, t, i;
    this.domNode.classList.remove("disabled"), this.inputBox.enable(), (e = this.regex) == null || e.enable(), (t = this.wholeWords) == null || t.enable(), (i = this.caseSensitive) == null || i.enable();
    for (const n of this.additionalToggles)
      n.enable();
  }
  disable() {
    var e, t, i;
    this.domNode.classList.add("disabled"), this.inputBox.disable(), (e = this.regex) == null || e.disable(), (t = this.wholeWords) == null || t.disable(), (i = this.caseSensitive) == null || i.disable();
    for (const n of this.additionalToggles)
      n.disable();
  }
  setFocusInputOnOptionClick(e) {
    this.fixFocusOnOptionClickEnabled = e;
  }
  setEnabled(e) {
    e ? this.enable() : this.disable();
  }
  setAdditionalToggles(e) {
    for (const t of this.additionalToggles)
      t.domNode.remove();
    this.additionalToggles = [], this.additionalTogglesDisposables.value = new ne();
    for (const t of e ?? [])
      this.additionalTogglesDisposables.value.add(t), this.controls.appendChild(t.domNode), this.additionalTogglesDisposables.value.add(t.onChange((i) => {
        this._onDidOptionChange.fire(i), !i && this.fixFocusOnOptionClickEnabled && this.inputBox.focus();
      })), this.additionalToggles.push(t);
    this.additionalToggles.length > 0 && (this.controls.style.display = ""), this.updateInputBoxPadding();
  }
  updateInputBoxPadding(e = !1) {
    var t, i, n;
    e ? this.inputBox.paddingRight = 0 : this.inputBox.paddingRight = (((t = this.caseSensitive) == null ? void 0 : t.width()) ?? 0) + (((i = this.wholeWords) == null ? void 0 : i.width()) ?? 0) + (((n = this.regex) == null ? void 0 : n.width()) ?? 0) + this.additionalToggles.reduce((o, r) => o + r.width(), 0);
  }
  getValue() {
    return this.inputBox.value;
  }
  setValue(e) {
    this.inputBox.value !== e && (this.inputBox.value = e);
  }
  select() {
    this.inputBox.select();
  }
  focus() {
    this.inputBox.focus();
  }
  getCaseSensitive() {
    var e;
    return ((e = this.caseSensitive) == null ? void 0 : e.checked) ?? !1;
  }
  setCaseSensitive(e) {
    this.caseSensitive && (this.caseSensitive.checked = e);
  }
  getWholeWords() {
    var e;
    return ((e = this.wholeWords) == null ? void 0 : e.checked) ?? !1;
  }
  setWholeWords(e) {
    this.wholeWords && (this.wholeWords.checked = e);
  }
  getRegex() {
    var e;
    return ((e = this.regex) == null ? void 0 : e.checked) ?? !1;
  }
  setRegex(e) {
    this.regex && (this.regex.checked = e, this.validate());
  }
  focusOnCaseSensitive() {
    var e;
    (e = this.caseSensitive) == null || e.focus();
  }
  highlightFindOptions() {
    this.domNode.classList.remove("highlight-" + this._lastHighlightFindOptions), this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions, this.domNode.classList.add("highlight-" + this._lastHighlightFindOptions);
  }
  validate() {
    this.inputBox.validate();
  }
  showMessage(e) {
    this.inputBox.showMessage(e);
  }
  clearMessage() {
    this.inputBox.hideMessage();
  }
}
var us;
(function(s) {
  s[s.Expanded = 0] = "Expanded", s[s.Collapsed = 1] = "Collapsed", s[s.PreserveOrExpanded = 2] = "PreserveOrExpanded", s[s.PreserveOrCollapsed = 3] = "PreserveOrCollapsed";
})(us || (us = {}));
var ih;
(function(s) {
  s[s.Unknown = 0] = "Unknown", s[s.Twistie = 1] = "Twistie", s[s.Element = 2] = "Element", s[s.Filter = 3] = "Filter";
})(ih || (ih = {}));
class ps extends Error {
  constructor(e, t) {
    super(`TreeError [${e}] ${t}`);
  }
}
class QI {
  constructor(e) {
    this.fn = e, this._map = /* @__PURE__ */ new WeakMap();
  }
  map(e) {
    let t = this._map.get(e);
    return t || (t = this.fn(e), this._map.set(e, t)), t;
  }
}
class hl {
  /**
   * Constructs a new DiffChange with the given sequence information
   * and content.
   */
  constructor(e, t, i, n) {
    this.originalStart = e, this.originalLength = t, this.modifiedStart = i, this.modifiedLength = n;
  }
  /**
   * The end point (exclusive) of the change in the original sequence.
   */
  getOriginalEnd() {
    return this.originalStart + this.originalLength;
  }
  /**
   * The end point (exclusive) of the change in the modified sequence.
   */
  getModifiedEnd() {
    return this.modifiedStart + this.modifiedLength;
  }
}
class ZM {
  constructor(e) {
    this.source = e;
  }
  getElements() {
    const e = this.source, t = new Int32Array(e.length);
    for (let i = 0, n = e.length; i < n; i++)
      t[i] = e.charCodeAt(i);
    return t;
  }
}
function qX(s, e, t) {
  return new La(new ZM(s), new ZM(e)).ComputeDiff(t).changes;
}
class Ad {
  static Assert(e, t) {
    if (!e)
      throw new Error(t);
  }
}
class Pd {
  /**
   * Copies a range of elements from an Array starting at the specified source index and pastes
   * them to another Array starting at the specified destination index. The length and the indexes
   * are specified as 64-bit integers.
   * sourceArray:
   *		The Array that contains the data to copy.
   * sourceIndex:
   *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
   * destinationArray:
   *		The Array that receives the data.
   * destinationIndex:
   *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
   * length:
   *		A 64-bit integer that represents the number of elements to copy.
   */
  static Copy(e, t, i, n, o) {
    for (let r = 0; r < o; r++)
      i[n + r] = e[t + r];
  }
  static Copy2(e, t, i, n, o) {
    for (let r = 0; r < o; r++)
      i[n + r] = e[t + r];
  }
}
class YM {
  /**
   * Constructs a new DiffChangeHelper for the given DiffSequences.
   */
  constructor() {
    this.m_changes = [], this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824, this.m_originalCount = 0, this.m_modifiedCount = 0;
  }
  /**
   * Marks the beginning of the next change in the set of differences.
   */
  MarkNextChange() {
    (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.m_changes.push(new hl(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount)), this.m_originalCount = 0, this.m_modifiedCount = 0, this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824;
  }
  /**
   * Adds the original element at the given position to the elements
   * affected by the current change. The modified index gives context
   * to the change position with respect to the original sequence.
   * @param originalIndex The index of the original element to add.
   * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
   */
  AddOriginalElement(e, t) {
    this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, t), this.m_originalCount++;
  }
  /**
   * Adds the modified element at the given position to the elements
   * affected by the current change. The original index gives context
   * to the change position with respect to the modified sequence.
   * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
   * @param modifiedIndex The index of the modified element to add.
   */
  AddModifiedElement(e, t) {
    this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, t), this.m_modifiedCount++;
  }
  /**
   * Retrieves all of the changes marked by the class.
   */
  getChanges() {
    return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes;
  }
  /**
   * Retrieves all of the changes marked by the class in the reverse order
   */
  getReverseChanges() {
    return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes.reverse(), this.m_changes;
  }
}
class La {
  /**
   * Constructs the DiffFinder
   */
  constructor(e, t, i = null) {
    this.ContinueProcessingPredicate = i, this._originalSequence = e, this._modifiedSequence = t;
    const [n, o, r] = La._getElements(e), [a, l, c] = La._getElements(t);
    this._hasStrings = r && c, this._originalStringElements = n, this._originalElementsOrHash = o, this._modifiedStringElements = a, this._modifiedElementsOrHash = l, this.m_forwardHistory = [], this.m_reverseHistory = [];
  }
  static _isStringArray(e) {
    return e.length > 0 && typeof e[0] == "string";
  }
  static _getElements(e) {
    const t = e.getElements();
    if (La._isStringArray(t)) {
      const i = new Int32Array(t.length);
      for (let n = 0, o = t.length; n < o; n++)
        i[n] = SE(t[n], 0);
      return [t, i, !0];
    }
    return t instanceof Int32Array ? [[], t, !1] : [[], new Int32Array(t), !1];
  }
  ElementsAreEqual(e, t) {
    return this._originalElementsOrHash[e] !== this._modifiedElementsOrHash[t] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._modifiedStringElements[t] : !0;
  }
  ElementsAreStrictEqual(e, t) {
    if (!this.ElementsAreEqual(e, t))
      return !1;
    const i = La._getStrictElement(this._originalSequence, e), n = La._getStrictElement(this._modifiedSequence, t);
    return i === n;
  }
  static _getStrictElement(e, t) {
    return typeof e.getStrictElement == "function" ? e.getStrictElement(t) : null;
  }
  OriginalElementsAreEqual(e, t) {
    return this._originalElementsOrHash[e] !== this._originalElementsOrHash[t] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._originalStringElements[t] : !0;
  }
  ModifiedElementsAreEqual(e, t) {
    return this._modifiedElementsOrHash[e] !== this._modifiedElementsOrHash[t] ? !1 : this._hasStrings ? this._modifiedStringElements[e] === this._modifiedStringElements[t] : !0;
  }
  ComputeDiff(e) {
    return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, e);
  }
  /**
   * Computes the differences between the original and modified input
   * sequences on the bounded range.
   * @returns An array of the differences between the two input sequences.
   */
  _ComputeDiff(e, t, i, n, o) {
    const r = [!1];
    let a = this.ComputeDiffRecursive(e, t, i, n, r);
    return o && (a = this.PrettifyChanges(a)), {
      quitEarly: r[0],
      changes: a
    };
  }
  /**
   * Private helper method which computes the differences on the bounded range
   * recursively.
   * @returns An array of the differences between the two input sequences.
   */
  ComputeDiffRecursive(e, t, i, n, o) {
    for (o[0] = !1; e <= t && i <= n && this.ElementsAreEqual(e, i); )
      e++, i++;
    for (; t >= e && n >= i && this.ElementsAreEqual(t, n); )
      t--, n--;
    if (e > t || i > n) {
      let d;
      return i <= n ? (Ad.Assert(e === t + 1, "originalStart should only be one more than originalEnd"), d = [
        new hl(e, 0, i, n - i + 1)
      ]) : e <= t ? (Ad.Assert(i === n + 1, "modifiedStart should only be one more than modifiedEnd"), d = [
        new hl(e, t - e + 1, i, 0)
      ]) : (Ad.Assert(e === t + 1, "originalStart should only be one more than originalEnd"), Ad.Assert(i === n + 1, "modifiedStart should only be one more than modifiedEnd"), d = []), d;
    }
    const r = [0], a = [0], l = this.ComputeRecursionPoint(e, t, i, n, r, a, o), c = r[0], h = a[0];
    if (l !== null)
      return l;
    if (!o[0]) {
      const d = this.ComputeDiffRecursive(e, c, i, h, o);
      let u = [];
      return o[0] ? u = [
        new hl(c + 1, t - (c + 1) + 1, h + 1, n - (h + 1) + 1)
      ] : u = this.ComputeDiffRecursive(c + 1, t, h + 1, n, o), this.ConcatenateChanges(d, u);
    }
    return [
      new hl(e, t - e + 1, i, n - i + 1)
    ];
  }
  WALKTRACE(e, t, i, n, o, r, a, l, c, h, d, u, f, g, p, _, b, C) {
    let w = null, v = null, S = new YM(), L = t, k = i, x = f[0] - _[0] - n, I = -1073741824, K = this.m_forwardHistory.length - 1;
    do {
      const B = x + e;
      B === L || B < k && c[B - 1] < c[B + 1] ? (d = c[B + 1], g = d - x - n, d < I && S.MarkNextChange(), I = d, S.AddModifiedElement(d + 1, g), x = B + 1 - e) : (d = c[B - 1] + 1, g = d - x - n, d < I && S.MarkNextChange(), I = d - 1, S.AddOriginalElement(d, g + 1), x = B - 1 - e), K >= 0 && (c = this.m_forwardHistory[K], e = c[0], L = 1, k = c.length - 1);
    } while (--K >= -1);
    if (w = S.getReverseChanges(), C[0]) {
      let B = f[0] + 1, W = _[0] + 1;
      if (w !== null && w.length > 0) {
        const H = w[w.length - 1];
        B = Math.max(B, H.getOriginalEnd()), W = Math.max(W, H.getModifiedEnd());
      }
      v = [
        new hl(B, u - B + 1, W, p - W + 1)
      ];
    } else {
      S = new YM(), L = r, k = a, x = f[0] - _[0] - l, I = 1073741824, K = b ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
      do {
        const B = x + o;
        B === L || B < k && h[B - 1] >= h[B + 1] ? (d = h[B + 1] - 1, g = d - x - l, d > I && S.MarkNextChange(), I = d + 1, S.AddOriginalElement(d + 1, g + 1), x = B + 1 - o) : (d = h[B - 1], g = d - x - l, d > I && S.MarkNextChange(), I = d, S.AddModifiedElement(d + 1, g + 1), x = B - 1 - o), K >= 0 && (h = this.m_reverseHistory[K], o = h[0], L = 1, k = h.length - 1);
      } while (--K >= -1);
      v = S.getChanges();
    }
    return this.ConcatenateChanges(w, v);
  }
  /**
   * Given the range to compute the diff on, this method finds the point:
   * (midOriginal, midModified)
   * that exists in the middle of the LCS of the two sequences and
   * is the point at which the LCS problem may be broken down recursively.
   * This method will try to keep the LCS trace in memory. If the LCS recursion
   * point is calculated and the full trace is available in memory, then this method
   * will return the change list.
   * @param originalStart The start bound of the original sequence range
   * @param originalEnd The end bound of the original sequence range
   * @param modifiedStart The start bound of the modified sequence range
   * @param modifiedEnd The end bound of the modified sequence range
   * @param midOriginal The middle point of the original sequence range
   * @param midModified The middle point of the modified sequence range
   * @returns The diff changes, if available, otherwise null
   */
  ComputeRecursionPoint(e, t, i, n, o, r, a) {
    let l = 0, c = 0, h = 0, d = 0, u = 0, f = 0;
    e--, i--, o[0] = 0, r[0] = 0, this.m_forwardHistory = [], this.m_reverseHistory = [];
    const g = t - e + (n - i), p = g + 1, _ = new Int32Array(p), b = new Int32Array(p), C = n - i, w = t - e, v = e - i, S = t - n, k = (w - C) % 2 === 0;
    _[C] = e, b[w] = t, a[0] = !1;
    for (let x = 1; x <= g / 2 + 1; x++) {
      let I = 0, K = 0;
      h = this.ClipDiagonalBound(C - x, x, C, p), d = this.ClipDiagonalBound(C + x, x, C, p);
      for (let W = h; W <= d; W += 2) {
        W === h || W < d && _[W - 1] < _[W + 1] ? l = _[W + 1] : l = _[W - 1] + 1, c = l - (W - C) - v;
        const H = l;
        for (; l < t && c < n && this.ElementsAreEqual(l + 1, c + 1); )
          l++, c++;
        if (_[W] = l, l + c > I + K && (I = l, K = c), !k && Math.abs(W - w) <= x - 1 && l >= b[W])
          return o[0] = l, r[0] = c, H <= b[W] && x <= 1448 ? this.WALKTRACE(C, h, d, v, w, u, f, S, _, b, l, t, o, c, n, r, k, a) : null;
      }
      const B = (I - e + (K - i) - x) / 2;
      if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(I, B))
        return a[0] = !0, o[0] = I, r[0] = K, B > 0 && x <= 1448 ? this.WALKTRACE(C, h, d, v, w, u, f, S, _, b, l, t, o, c, n, r, k, a) : (e++, i++, [
          new hl(e, t - e + 1, i, n - i + 1)
        ]);
      u = this.ClipDiagonalBound(w - x, x, w, p), f = this.ClipDiagonalBound(w + x, x, w, p);
      for (let W = u; W <= f; W += 2) {
        W === u || W < f && b[W - 1] >= b[W + 1] ? l = b[W + 1] - 1 : l = b[W - 1], c = l - (W - w) - S;
        const H = l;
        for (; l > e && c > i && this.ElementsAreEqual(l, c); )
          l--, c--;
        if (b[W] = l, k && Math.abs(W - C) <= x && l <= _[W])
          return o[0] = l, r[0] = c, H >= _[W] && x <= 1448 ? this.WALKTRACE(C, h, d, v, w, u, f, S, _, b, l, t, o, c, n, r, k, a) : null;
      }
      if (x <= 1447) {
        let W = new Int32Array(d - h + 2);
        W[0] = C - h + 1, Pd.Copy2(_, h, W, 1, d - h + 1), this.m_forwardHistory.push(W), W = new Int32Array(f - u + 2), W[0] = w - u + 1, Pd.Copy2(b, u, W, 1, f - u + 1), this.m_reverseHistory.push(W);
      }
    }
    return this.WALKTRACE(C, h, d, v, w, u, f, S, _, b, l, t, o, c, n, r, k, a);
  }
  /**
   * Shifts the given changes to provide a more intuitive diff.
   * While the first element in a diff matches the first element after the diff,
   * we shift the diff down.
   *
   * @param changes The list of changes to shift
   * @returns The shifted changes
   */
  PrettifyChanges(e) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t], n = t < e.length - 1 ? e[t + 1].originalStart : this._originalElementsOrHash.length, o = t < e.length - 1 ? e[t + 1].modifiedStart : this._modifiedElementsOrHash.length, r = i.originalLength > 0, a = i.modifiedLength > 0;
      for (; i.originalStart + i.originalLength < n && i.modifiedStart + i.modifiedLength < o && (!r || this.OriginalElementsAreEqual(i.originalStart, i.originalStart + i.originalLength)) && (!a || this.ModifiedElementsAreEqual(i.modifiedStart, i.modifiedStart + i.modifiedLength)); ) {
        const c = this.ElementsAreStrictEqual(i.originalStart, i.modifiedStart);
        if (this.ElementsAreStrictEqual(i.originalStart + i.originalLength, i.modifiedStart + i.modifiedLength) && !c)
          break;
        i.originalStart++, i.modifiedStart++;
      }
      const l = [null];
      if (t < e.length - 1 && this.ChangesOverlap(e[t], e[t + 1], l)) {
        e[t] = l[0], e.splice(t + 1, 1), t--;
        continue;
      }
    }
    for (let t = e.length - 1; t >= 0; t--) {
      const i = e[t];
      let n = 0, o = 0;
      if (t > 0) {
        const d = e[t - 1];
        n = d.originalStart + d.originalLength, o = d.modifiedStart + d.modifiedLength;
      }
      const r = i.originalLength > 0, a = i.modifiedLength > 0;
      let l = 0, c = this._boundaryScore(i.originalStart, i.originalLength, i.modifiedStart, i.modifiedLength);
      for (let d = 1; ; d++) {
        const u = i.originalStart - d, f = i.modifiedStart - d;
        if (u < n || f < o || r && !this.OriginalElementsAreEqual(u, u + i.originalLength) || a && !this.ModifiedElementsAreEqual(f, f + i.modifiedLength))
          break;
        const p = (u === n && f === o ? 5 : 0) + this._boundaryScore(u, i.originalLength, f, i.modifiedLength);
        p > c && (c = p, l = d);
      }
      i.originalStart -= l, i.modifiedStart -= l;
      const h = [null];
      if (t > 0 && this.ChangesOverlap(e[t - 1], e[t], h)) {
        e[t - 1] = h[0], e.splice(t, 1), t++;
        continue;
      }
    }
    if (this._hasStrings)
      for (let t = 1, i = e.length; t < i; t++) {
        const n = e[t - 1], o = e[t], r = o.originalStart - n.originalStart - n.originalLength, a = n.originalStart, l = o.originalStart + o.originalLength, c = l - a, h = n.modifiedStart, d = o.modifiedStart + o.modifiedLength, u = d - h;
        if (r < 5 && c < 20 && u < 20) {
          const f = this._findBetterContiguousSequence(a, c, h, u, r);
          if (f) {
            const [g, p] = f;
            (g !== n.originalStart + n.originalLength || p !== n.modifiedStart + n.modifiedLength) && (n.originalLength = g - n.originalStart, n.modifiedLength = p - n.modifiedStart, o.originalStart = g + r, o.modifiedStart = p + r, o.originalLength = l - o.originalStart, o.modifiedLength = d - o.modifiedStart);
          }
        }
      }
    return e;
  }
  _findBetterContiguousSequence(e, t, i, n, o) {
    if (t < o || n < o)
      return null;
    const r = e + t - o + 1, a = i + n - o + 1;
    let l = 0, c = 0, h = 0;
    for (let d = e; d < r; d++)
      for (let u = i; u < a; u++) {
        const f = this._contiguousSequenceScore(d, u, o);
        f > 0 && f > l && (l = f, c = d, h = u);
      }
    return l > 0 ? [c, h] : null;
  }
  _contiguousSequenceScore(e, t, i) {
    let n = 0;
    for (let o = 0; o < i; o++) {
      if (!this.ElementsAreEqual(e + o, t + o))
        return 0;
      n += this._originalStringElements[e + o].length;
    }
    return n;
  }
  _OriginalIsBoundary(e) {
    return e <= 0 || e >= this._originalElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._originalStringElements[e]);
  }
  _OriginalRegionIsBoundary(e, t) {
    if (this._OriginalIsBoundary(e) || this._OriginalIsBoundary(e - 1))
      return !0;
    if (t > 0) {
      const i = e + t;
      if (this._OriginalIsBoundary(i - 1) || this._OriginalIsBoundary(i))
        return !0;
    }
    return !1;
  }
  _ModifiedIsBoundary(e) {
    return e <= 0 || e >= this._modifiedElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._modifiedStringElements[e]);
  }
  _ModifiedRegionIsBoundary(e, t) {
    if (this._ModifiedIsBoundary(e) || this._ModifiedIsBoundary(e - 1))
      return !0;
    if (t > 0) {
      const i = e + t;
      if (this._ModifiedIsBoundary(i - 1) || this._ModifiedIsBoundary(i))
        return !0;
    }
    return !1;
  }
  _boundaryScore(e, t, i, n) {
    const o = this._OriginalRegionIsBoundary(e, t) ? 1 : 0, r = this._ModifiedRegionIsBoundary(i, n) ? 1 : 0;
    return o + r;
  }
  /**
   * Concatenates the two input DiffChange lists and returns the resulting
   * list.
   * @param The left changes
   * @param The right changes
   * @returns The concatenated list
   */
  ConcatenateChanges(e, t) {
    const i = [];
    if (e.length === 0 || t.length === 0)
      return t.length > 0 ? t : e;
    if (this.ChangesOverlap(e[e.length - 1], t[0], i)) {
      const n = new Array(e.length + t.length - 1);
      return Pd.Copy(e, 0, n, 0, e.length - 1), n[e.length - 1] = i[0], Pd.Copy(t, 1, n, e.length, t.length - 1), n;
    } else {
      const n = new Array(e.length + t.length);
      return Pd.Copy(e, 0, n, 0, e.length), Pd.Copy(t, 0, n, e.length, t.length), n;
    }
  }
  /**
   * Returns true if the two changes overlap and can be merged into a single
   * change
   * @param left The left change
   * @param right The right change
   * @param mergedChange The merged change if the two overlap, null otherwise
   * @returns True if the two changes overlap
   */
  ChangesOverlap(e, t, i) {
    if (Ad.Assert(e.originalStart <= t.originalStart, "Left change is not less than or equal to right change"), Ad.Assert(e.modifiedStart <= t.modifiedStart, "Left change is not less than or equal to right change"), e.originalStart + e.originalLength >= t.originalStart || e.modifiedStart + e.modifiedLength >= t.modifiedStart) {
      const n = e.originalStart;
      let o = e.originalLength;
      const r = e.modifiedStart;
      let a = e.modifiedLength;
      return e.originalStart + e.originalLength >= t.originalStart && (o = t.originalStart + t.originalLength - e.originalStart), e.modifiedStart + e.modifiedLength >= t.modifiedStart && (a = t.modifiedStart + t.modifiedLength - e.modifiedStart), i[0] = new hl(n, o, r, a), !0;
    } else
      return i[0] = null, !1;
  }
  /**
   * Helper method used to clip a diagonal index to the range of valid
   * diagonals. This also decides whether or not the diagonal index,
   * if it exceeds the boundary, should be clipped to the boundary or clipped
   * one inside the boundary depending on the Even/Odd status of the boundary
   * and numDifferences.
   * @param diagonal The index of the diagonal to clip.
   * @param numDifferences The current number of differences being iterated upon.
   * @param diagonalBaseIndex The base reference diagonal.
   * @param numDiagonals The total number of diagonals.
   * @returns The clipped diagonal index.
   */
  ClipDiagonalBound(e, t, i, n) {
    if (e >= 0 && e < n)
      return e;
    const o = i, r = n - i - 1, a = t % 2 === 0;
    if (e < 0) {
      const l = o % 2 === 0;
      return a === l ? 0 : 1;
    } else {
      const l = r % 2 === 0;
      return a === l ? n - 1 : n - 2;
    }
  }
}
function JI(s) {
  return typeof s == "object" && "visibility" in s && "data" in s;
}
function op(s) {
  switch (s) {
    case !0:
      return 1;
    case !1:
      return 0;
    default:
      return s;
  }
}
function ny(s) {
  return typeof s.collapsible == "boolean";
}
class GX {
  constructor(e, t, i, n = {}) {
    this.user = e, this.list = t, this.rootRef = [], this.eventBufferer = new xp(), this._onDidChangeCollapseState = new A(), this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event), this._onDidChangeRenderNodeCount = new A(), this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event), this._onDidSplice = new A(), this.onDidSplice = this._onDidSplice.event, this.refilterDelayer = new Np(w4), this.collapseByDefault = typeof n.collapseByDefault > "u" ? !1 : n.collapseByDefault, this.allowNonCollapsibleParents = n.allowNonCollapsibleParents ?? !1, this.filter = n.filter, this.autoExpandSingleChildren = typeof n.autoExpandSingleChildren > "u" ? !1 : n.autoExpandSingleChildren, this.root = {
      parent: void 0,
      element: i,
      children: [],
      depth: 0,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: !1,
      collapsed: !1,
      renderNodeCount: 0,
      visibility: 1,
      visible: !0,
      filterData: void 0
    };
  }
  splice(e, t, i = nt.empty(), n = {}) {
    if (e.length === 0)
      throw new ps(this.user, "Invalid tree location");
    n.diffIdentityProvider ? this.spliceSmart(n.diffIdentityProvider, e, t, i, n) : this.spliceSimple(e, t, i, n);
  }
  spliceSmart(e, t, i, n = nt.empty(), o, r = o.diffDepth ?? 0) {
    const { parentNode: a } = this.getParentNodeWithListIndex(t);
    if (!a.lastDiffIds)
      return this.spliceSimple(t, i, n, o);
    const l = [...n], c = t[t.length - 1], h = new La({ getElements: () => a.lastDiffIds }, {
      getElements: () => [
        ...a.children.slice(0, c),
        ...l,
        ...a.children.slice(c + i)
      ].map((p) => e.getId(p.element).toString())
    }).ComputeDiff(!1);
    if (h.quitEarly)
      return a.lastDiffIds = void 0, this.spliceSimple(t, i, l, o);
    const d = t.slice(0, -1), u = (p, _, b) => {
      if (r > 0)
        for (let C = 0; C < b; C++)
          p--, _--, this.spliceSmart(e, [...d, p, 0], Number.MAX_SAFE_INTEGER, l[_].children, o, r - 1);
    };
    let f = Math.min(a.children.length, c + i), g = l.length;
    for (const p of h.changes.sort((_, b) => b.originalStart - _.originalStart))
      u(f, g, f - (p.originalStart + p.originalLength)), f = p.originalStart, g = p.modifiedStart - c, this.spliceSimple([...d, f], p.originalLength, nt.slice(l, g, g + p.modifiedLength), o);
    u(f, g, f);
  }
  spliceSimple(e, t, i = nt.empty(), { onDidCreateNode: n, onDidDeleteNode: o, diffIdentityProvider: r }) {
    const { parentNode: a, listIndex: l, revealed: c, visible: h } = this.getParentNodeWithListIndex(e), d = [], u = nt.map(i, (S) => this.createTreeNode(S, a, a.visible ? 1 : 0, c, d, n)), f = e[e.length - 1];
    let g = 0;
    for (let S = f; S >= 0 && S < a.children.length; S--) {
      const L = a.children[S];
      if (L.visible) {
        g = L.visibleChildIndex;
        break;
      }
    }
    const p = [];
    let _ = 0, b = 0;
    for (const S of u)
      p.push(S), b += S.renderNodeCount, S.visible && (S.visibleChildIndex = g + _++);
    const C = Z2(a.children, f, t, p);
    r ? a.lastDiffIds ? Z2(a.lastDiffIds, f, t, p.map((S) => r.getId(S.element).toString())) : a.lastDiffIds = a.children.map((S) => r.getId(S.element).toString()) : a.lastDiffIds = void 0;
    let w = 0;
    for (const S of C)
      S.visible && w++;
    if (w !== 0)
      for (let S = f + p.length; S < a.children.length; S++) {
        const L = a.children[S];
        L.visible && (L.visibleChildIndex -= w);
      }
    if (a.visibleChildrenCount += _ - w, c && h) {
      const S = C.reduce((L, k) => L + (k.visible ? k.renderNodeCount : 0), 0);
      this._updateAncestorsRenderNodeCount(a, b - S), this.list.splice(l, S, d);
    }
    if (C.length > 0 && o) {
      const S = (L) => {
        o(L), L.children.forEach(S);
      };
      C.forEach(S);
    }
    this._onDidSplice.fire({ insertedNodes: p, deletedNodes: C });
    let v = a;
    for (; v; ) {
      if (v.visibility === 2) {
        this.refilterDelayer.trigger(() => this.refilter());
        break;
      }
      v = v.parent;
    }
  }
  rerender(e) {
    if (e.length === 0)
      throw new ps(this.user, "Invalid tree location");
    const { node: t, listIndex: i, revealed: n } = this.getTreeNodeWithListIndex(e);
    t.visible && n && this.list.splice(i, 1, [t]);
  }
  has(e) {
    return this.hasTreeNode(e);
  }
  getListIndex(e) {
    const { listIndex: t, visible: i, revealed: n } = this.getTreeNodeWithListIndex(e);
    return i && n ? t : -1;
  }
  getListRenderCount(e) {
    return this.getTreeNode(e).renderNodeCount;
  }
  isCollapsible(e) {
    return this.getTreeNode(e).collapsible;
  }
  setCollapsible(e, t) {
    const i = this.getTreeNode(e);
    typeof t > "u" && (t = !i.collapsible);
    const n = { collapsible: t };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, n));
  }
  isCollapsed(e) {
    return this.getTreeNode(e).collapsed;
  }
  setCollapsed(e, t, i) {
    const n = this.getTreeNode(e);
    typeof t > "u" && (t = !n.collapsed);
    const o = { collapsed: t, recursive: i || !1 };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, o));
  }
  _setCollapseState(e, t) {
    const { node: i, listIndex: n, revealed: o } = this.getTreeNodeWithListIndex(e), r = this._setListNodeCollapseState(i, n, o, t);
    if (i !== this.root && this.autoExpandSingleChildren && r && !ny(t) && i.collapsible && !i.collapsed && !t.recursive) {
      let a = -1;
      for (let l = 0; l < i.children.length; l++)
        if (i.children[l].visible)
          if (a > -1) {
            a = -1;
            break;
          } else
            a = l;
      a > -1 && this._setCollapseState([...e, a], t);
    }
    return r;
  }
  _setListNodeCollapseState(e, t, i, n) {
    const o = this._setNodeCollapseState(e, n, !1);
    if (!i || !e.visible || !o)
      return o;
    const r = e.renderNodeCount, a = this.updateNodeAfterCollapseChange(e), l = r - (t === -1 ? 0 : 1);
    return this.list.splice(t + 1, l, a.slice(1)), o;
  }
  _setNodeCollapseState(e, t, i) {
    let n;
    if (e === this.root ? n = !1 : (ny(t) ? (n = e.collapsible !== t.collapsible, e.collapsible = t.collapsible) : e.collapsible ? (n = e.collapsed !== t.collapsed, e.collapsed = t.collapsed) : n = !1, n && this._onDidChangeCollapseState.fire({ node: e, deep: i })), !ny(t) && t.recursive)
      for (const o of e.children)
        n = this._setNodeCollapseState(o, t, !0) || n;
    return n;
  }
  expandTo(e) {
    this.eventBufferer.bufferEvents(() => {
      let t = this.getTreeNode(e);
      for (; t.parent; )
        t = t.parent, e = e.slice(0, e.length - 1), t.collapsed && this._setCollapseState(e, { collapsed: !1, recursive: !1 });
    });
  }
  refilter() {
    const e = this.root.renderNodeCount, t = this.updateNodeAfterFilterChange(this.root);
    this.list.splice(0, e, t), this.refilterDelayer.cancel();
  }
  createTreeNode(e, t, i, n, o, r) {
    const a = {
      parent: t,
      element: e.element,
      children: [],
      depth: t.depth + 1,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: typeof e.collapsible == "boolean" ? e.collapsible : typeof e.collapsed < "u",
      collapsed: typeof e.collapsed > "u" ? this.collapseByDefault : e.collapsed,
      renderNodeCount: 1,
      visibility: 1,
      visible: !0,
      filterData: void 0
    }, l = this._filterNode(a, i);
    a.visibility = l, n && o.push(a);
    const c = e.children || nt.empty(), h = n && l !== 0 && !a.collapsed;
    let d = 0, u = 1;
    for (const f of c) {
      const g = this.createTreeNode(f, a, l, h, o, r);
      a.children.push(g), u += g.renderNodeCount, g.visible && (g.visibleChildIndex = d++);
    }
    return this.allowNonCollapsibleParents || (a.collapsible = a.collapsible || a.children.length > 0), a.visibleChildrenCount = d, a.visible = l === 2 ? d > 0 : l === 1, a.visible ? a.collapsed || (a.renderNodeCount = u) : (a.renderNodeCount = 0, n && o.pop()), r == null || r(a), a;
  }
  updateNodeAfterCollapseChange(e) {
    const t = e.renderNodeCount, i = [];
    return this._updateNodeAfterCollapseChange(e, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
  }
  _updateNodeAfterCollapseChange(e, t) {
    if (e.visible === !1)
      return 0;
    if (t.push(e), e.renderNodeCount = 1, !e.collapsed)
      for (const i of e.children)
        e.renderNodeCount += this._updateNodeAfterCollapseChange(i, t);
    return this._onDidChangeRenderNodeCount.fire(e), e.renderNodeCount;
  }
  updateNodeAfterFilterChange(e) {
    const t = e.renderNodeCount, i = [];
    return this._updateNodeAfterFilterChange(e, e.visible ? 1 : 0, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
  }
  _updateNodeAfterFilterChange(e, t, i, n = !0) {
    let o;
    if (e !== this.root) {
      if (o = this._filterNode(e, t), o === 0)
        return e.visible = !1, e.renderNodeCount = 0, !1;
      n && i.push(e);
    }
    const r = i.length;
    e.renderNodeCount = e === this.root ? 0 : 1;
    let a = !1;
    if (!e.collapsed || o !== 0) {
      let l = 0;
      for (const c of e.children)
        a = this._updateNodeAfterFilterChange(c, o, i, n && !e.collapsed) || a, c.visible && (c.visibleChildIndex = l++);
      e.visibleChildrenCount = l;
    } else
      e.visibleChildrenCount = 0;
    return e !== this.root && (e.visible = o === 2 ? a : o === 1, e.visibility = o), e.visible ? e.collapsed || (e.renderNodeCount += i.length - r) : (e.renderNodeCount = 0, n && i.pop()), this._onDidChangeRenderNodeCount.fire(e), e.visible;
  }
  _updateAncestorsRenderNodeCount(e, t) {
    if (t !== 0)
      for (; e; )
        e.renderNodeCount += t, this._onDidChangeRenderNodeCount.fire(e), e = e.parent;
  }
  _filterNode(e, t) {
    const i = this.filter ? this.filter.filter(e.element, t) : 1;
    return typeof i == "boolean" ? (e.filterData = void 0, i ? 1 : 0) : JI(i) ? (e.filterData = i.data, op(i.visibility)) : (e.filterData = void 0, op(i));
  }
  // cheap
  hasTreeNode(e, t = this.root) {
    if (!e || e.length === 0)
      return !0;
    const [i, ...n] = e;
    return i < 0 || i > t.children.length ? !1 : this.hasTreeNode(n, t.children[i]);
  }
  // cheap
  getTreeNode(e, t = this.root) {
    if (!e || e.length === 0)
      return t;
    const [i, ...n] = e;
    if (i < 0 || i > t.children.length)
      throw new ps(this.user, "Invalid tree location");
    return this.getTreeNode(n, t.children[i]);
  }
  // expensive
  getTreeNodeWithListIndex(e) {
    if (e.length === 0)
      return { node: this.root, listIndex: -1, revealed: !0, visible: !1 };
    const { parentNode: t, listIndex: i, revealed: n, visible: o } = this.getParentNodeWithListIndex(e), r = e[e.length - 1];
    if (r < 0 || r > t.children.length)
      throw new ps(this.user, "Invalid tree location");
    const a = t.children[r];
    return { node: a, listIndex: i, revealed: n, visible: o && a.visible };
  }
  getParentNodeWithListIndex(e, t = this.root, i = 0, n = !0, o = !0) {
    const [r, ...a] = e;
    if (r < 0 || r > t.children.length)
      throw new ps(this.user, "Invalid tree location");
    for (let l = 0; l < r; l++)
      i += t.children[l].renderNodeCount;
    return n = n && !t.collapsed, o = o && t.visible, a.length === 0 ? { parentNode: t, listIndex: i, revealed: n, visible: o } : this.getParentNodeWithListIndex(a, t.children[r], i + 1, n, o);
  }
  getNode(e = []) {
    return this.getTreeNode(e);
  }
  // TODO@joao perf!
  getNodeLocation(e) {
    const t = [];
    let i = e;
    for (; i.parent; )
      t.push(i.parent.children.indexOf(i)), i = i.parent;
    return t.reverse();
  }
  getParentNodeLocation(e) {
    if (e.length !== 0)
      return e.length === 1 ? [] : QB(e)[0];
  }
  getFirstElementChild(e) {
    const t = this.getTreeNode(e);
    if (t.children.length !== 0)
      return t.children[0].element;
  }
}
class ZX extends Mp {
  constructor(e) {
    super(e.elements.map((t) => t.element)), this.data = e;
  }
}
function sy(s) {
  return s instanceof Mp ? new ZX(s) : s;
}
class YX {
  constructor(e, t) {
    this.modelProvider = e, this.dnd = t, this.autoExpandDisposable = U.None, this.disposables = new ne();
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e.element);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e.map((i) => i.element), t);
  }
  onDragStart(e, t) {
    var i, n;
    (n = (i = this.dnd).onDragStart) == null || n.call(i, sy(e), t);
  }
  onDragOver(e, t, i, n, o, r = !0) {
    const a = this.dnd.onDragOver(sy(e), t && t.element, i, n, o), l = this.autoExpandNode !== t;
    if (l && (this.autoExpandDisposable.dispose(), this.autoExpandNode = t), typeof t > "u")
      return a;
    if (l && typeof a != "boolean" && a.autoExpand && (this.autoExpandDisposable = Kb(() => {
      const f = this.modelProvider(), g = f.getNodeLocation(t);
      f.isCollapsed(g) && f.setCollapsed(g, !1), this.autoExpandNode = void 0;
    }, 500, this.disposables)), typeof a == "boolean" || !a.accept || typeof a.bubble > "u" || a.feedback) {
      if (!r) {
        const f = typeof a == "boolean" ? a : a.accept, g = typeof a == "boolean" ? void 0 : a.effect;
        return { accept: f, effect: g, feedback: [i] };
      }
      return a;
    }
    if (a.bubble === 1) {
      const f = this.modelProvider(), g = f.getNodeLocation(t), p = f.getParentNodeLocation(g), _ = f.getNode(p), b = p && f.getListIndex(p);
      return this.onDragOver(e, _, b, n, o, !1);
    }
    const c = this.modelProvider(), h = c.getNodeLocation(t), d = c.getListIndex(h), u = c.getListRenderCount(h);
    return { ...a, feedback: xn(d, d + u) };
  }
  drop(e, t, i, n, o) {
    this.autoExpandDisposable.dispose(), this.autoExpandNode = void 0, this.dnd.drop(sy(e), t && t.element, i, n, o);
  }
  onDragEnd(e) {
    var t, i;
    (i = (t = this.dnd).onDragEnd) == null || i.call(t, e);
  }
  dispose() {
    this.disposables.dispose(), this.dnd.dispose();
  }
}
function XX(s, e) {
  return e && {
    ...e,
    identityProvider: e.identityProvider && {
      getId(t) {
        return e.identityProvider.getId(t.element);
      }
    },
    dnd: e.dnd && new YX(s, e.dnd),
    multipleSelectionController: e.multipleSelectionController && {
      isSelectionSingleChangeEvent(t) {
        return e.multipleSelectionController.isSelectionSingleChangeEvent({ ...t, element: t.element });
      },
      isSelectionRangeChangeEvent(t) {
        return e.multipleSelectionController.isSelectionRangeChangeEvent({ ...t, element: t.element });
      }
    },
    accessibilityProvider: e.accessibilityProvider && {
      ...e.accessibilityProvider,
      getSetSize(t) {
        const i = s(), n = i.getNodeLocation(t), o = i.getParentNodeLocation(n);
        return i.getNode(o).visibleChildrenCount;
      },
      getPosInSet(t) {
        return t.visibleChildIndex + 1;
      },
      isChecked: e.accessibilityProvider && e.accessibilityProvider.isChecked ? (t) => e.accessibilityProvider.isChecked(t.element) : void 0,
      getRole: e.accessibilityProvider && e.accessibilityProvider.getRole ? (t) => e.accessibilityProvider.getRole(t.element) : () => "treeitem",
      getAriaLabel(t) {
        return e.accessibilityProvider.getAriaLabel(t.element);
      },
      getWidgetAriaLabel() {
        return e.accessibilityProvider.getWidgetAriaLabel();
      },
      getWidgetRole: e.accessibilityProvider && e.accessibilityProvider.getWidgetRole ? () => e.accessibilityProvider.getWidgetRole() : () => "tree",
      getAriaLevel: e.accessibilityProvider && e.accessibilityProvider.getAriaLevel ? (t) => e.accessibilityProvider.getAriaLevel(t.element) : (t) => t.depth,
      getActiveDescendantId: e.accessibilityProvider.getActiveDescendantId && ((t) => e.accessibilityProvider.getActiveDescendantId(t.element))
    },
    keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
      ...e.keyboardNavigationLabelProvider,
      getKeyboardNavigationLabel(t) {
        return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t.element);
      }
    }
  };
}
class eN {
  constructor(e) {
    this.delegate = e;
  }
  getHeight(e) {
    return this.delegate.getHeight(e.element);
  }
  getTemplateId(e) {
    return this.delegate.getTemplateId(e.element);
  }
  hasDynamicHeight(e) {
    return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(e.element);
  }
  setDynamicHeight(e, t) {
    var i, n;
    (n = (i = this.delegate).setDynamicHeight) == null || n.call(i, e.element, t);
  }
}
var Cf;
(function(s) {
  s.None = "none", s.OnHover = "onHover", s.Always = "always";
})(Cf || (Cf = {}));
class QX {
  get elements() {
    return this._elements;
  }
  constructor(e, t = []) {
    this._elements = t, this.disposables = new ne(), this.onDidChange = ee.forEach(e, (i) => this._elements = i, this.disposables);
  }
  dispose() {
    this.disposables.dispose();
  }
}
const um = class um {
  constructor(e, t, i, n, o, r = {}) {
    var a;
    this.renderer = e, this.modelProvider = t, this.activeNodes = n, this.renderedIndentGuides = o, this.renderedElements = /* @__PURE__ */ new Map(), this.renderedNodes = /* @__PURE__ */ new Map(), this.indent = um.DefaultIndent, this.hideTwistiesOfChildlessElements = !1, this.shouldRenderIndentGuides = !1, this.activeIndentNodes = /* @__PURE__ */ new Set(), this.indentGuidesDisposable = U.None, this.disposables = new ne(), this.templateId = e.templateId, this.updateOptions(r), ee.map(i, (l) => l.node)(this.onDidChangeNodeTwistieState, this, this.disposables), (a = e.onDidChangeTwistieState) == null || a.call(e, this.onDidChangeTwistieState, this, this.disposables);
  }
  updateOptions(e = {}) {
    if (typeof e.indent < "u") {
      const t = Dn(e.indent, 0, 40);
      if (t !== this.indent) {
        this.indent = t;
        for (const [i, n] of this.renderedNodes)
          this.renderTreeElement(i, n);
      }
    }
    if (typeof e.renderIndentGuides < "u") {
      const t = e.renderIndentGuides !== Cf.None;
      if (t !== this.shouldRenderIndentGuides) {
        this.shouldRenderIndentGuides = t;
        for (const [i, n] of this.renderedNodes)
          this._renderIndentGuides(i, n);
        if (this.indentGuidesDisposable.dispose(), t) {
          const i = new ne();
          this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, i), this.indentGuidesDisposable = i, this._onDidChangeActiveNodes(this.activeNodes.elements);
        }
      }
    }
    typeof e.hideTwistiesOfChildlessElements < "u" && (this.hideTwistiesOfChildlessElements = e.hideTwistiesOfChildlessElements);
  }
  renderTemplate(e) {
    const t = te(e, he(".monaco-tl-row")), i = te(t, he(".monaco-tl-indent")), n = te(t, he(".monaco-tl-twistie")), o = te(t, he(".monaco-tl-contents")), r = this.renderer.renderTemplate(o);
    return { container: e, indent: i, twistie: n, indentGuidesDisposable: U.None, templateData: r };
  }
  renderElement(e, t, i, n) {
    this.renderedNodes.set(e, i), this.renderedElements.set(e.element, e), this.renderTreeElement(e, i), this.renderer.renderElement(e, t, i.templateData, n);
  }
  disposeElement(e, t, i, n) {
    var o, r;
    i.indentGuidesDisposable.dispose(), (r = (o = this.renderer).disposeElement) == null || r.call(o, e, t, i.templateData, n), typeof n == "number" && (this.renderedNodes.delete(e), this.renderedElements.delete(e.element));
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  onDidChangeTwistieState(e) {
    const t = this.renderedElements.get(e);
    t && this.onDidChangeNodeTwistieState(t);
  }
  onDidChangeNodeTwistieState(e) {
    const t = this.renderedNodes.get(e);
    t && (this._onDidChangeActiveNodes(this.activeNodes.elements), this.renderTreeElement(e, t));
  }
  renderTreeElement(e, t) {
    const i = um.DefaultIndent + (e.depth - 1) * this.indent;
    t.twistie.style.paddingLeft = `${i}px`, t.indent.style.width = `${i + this.indent - 16}px`, e.collapsible ? t.container.setAttribute("aria-expanded", String(!e.collapsed)) : t.container.removeAttribute("aria-expanded"), t.twistie.classList.remove(...Te.asClassNameArray(ie.treeItemExpanded));
    let n = !1;
    this.renderer.renderTwistie && (n = this.renderer.renderTwistie(e.element, t.twistie)), e.collapsible && (!this.hideTwistiesOfChildlessElements || e.visibleChildrenCount > 0) ? (n || t.twistie.classList.add(...Te.asClassNameArray(ie.treeItemExpanded)), t.twistie.classList.add("collapsible"), t.twistie.classList.toggle("collapsed", e.collapsed)) : t.twistie.classList.remove("collapsible", "collapsed"), this._renderIndentGuides(e, t);
  }
  _renderIndentGuides(e, t) {
    if (ks(t.indent), t.indentGuidesDisposable.dispose(), !this.shouldRenderIndentGuides)
      return;
    const i = new ne(), n = this.modelProvider();
    for (; ; ) {
      const o = n.getNodeLocation(e), r = n.getParentNodeLocation(o);
      if (!r)
        break;
      const a = n.getNode(r), l = he(".indent-guide", { style: `width: ${this.indent}px` });
      this.activeIndentNodes.has(a) && l.classList.add("active"), t.indent.childElementCount === 0 ? t.indent.appendChild(l) : t.indent.insertBefore(l, t.indent.firstElementChild), this.renderedIndentGuides.add(a, l), i.add(_e(() => this.renderedIndentGuides.delete(a, l))), e = a;
    }
    t.indentGuidesDisposable = i;
  }
  _onDidChangeActiveNodes(e) {
    if (!this.shouldRenderIndentGuides)
      return;
    const t = /* @__PURE__ */ new Set(), i = this.modelProvider();
    e.forEach((n) => {
      const o = i.getNodeLocation(n);
      try {
        const r = i.getParentNodeLocation(o);
        n.collapsible && n.children.length > 0 && !n.collapsed ? t.add(n) : r && t.add(i.getNode(r));
      } catch {
      }
    }), this.activeIndentNodes.forEach((n) => {
      t.has(n) || this.renderedIndentGuides.forEach(n, (o) => o.classList.remove("active"));
    }), t.forEach((n) => {
      this.activeIndentNodes.has(n) || this.renderedIndentGuides.forEach(n, (o) => o.classList.add("active"));
    }), this.activeIndentNodes = t;
  }
  dispose() {
    this.renderedNodes.clear(), this.renderedElements.clear(), this.indentGuidesDisposable.dispose(), Ft(this.disposables);
  }
};
um.DefaultIndent = 8;
let DL = um;
class JX {
  get totalCount() {
    return this._totalCount;
  }
  get matchCount() {
    return this._matchCount;
  }
  constructor(e, t, i) {
    this.tree = e, this.keyboardNavigationLabelProvider = t, this._filter = i, this._totalCount = 0, this._matchCount = 0, this._pattern = "", this._lowercasePattern = "", this.disposables = new ne(), e.onWillRefilter(this.reset, this, this.disposables);
  }
  filter(e, t) {
    let i = 1;
    if (this._filter) {
      const r = this._filter.filter(e, t);
      if (typeof r == "boolean" ? i = r ? 1 : 0 : JI(r) ? i = op(r.visibility) : i = r, i === 0)
        return !1;
    }
    if (this._totalCount++, !this._pattern)
      return this._matchCount++, { data: rh.Default, visibility: i };
    const n = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e), o = Array.isArray(n) ? n : [n];
    for (const r of o) {
      const a = r && r.toString();
      if (typeof a > "u")
        return { data: rh.Default, visibility: i };
      let l;
      if (this.tree.findMatchType === Gh.Contiguous) {
        const c = a.toLowerCase().indexOf(this._lowercasePattern);
        if (c > -1) {
          l = [Number.MAX_SAFE_INTEGER, 0];
          for (let h = this._lowercasePattern.length; h > 0; h--)
            l.push(c + h - 1);
        }
      } else
        l = nO(this._pattern, this._lowercasePattern, 0, a, a.toLowerCase(), 0, { firstMatchCanBeWeak: !0, boostFullMatch: !0 });
      if (l)
        return this._matchCount++, o.length === 1 ? { data: l, visibility: i } : { data: { label: a, score: l }, visibility: i };
    }
    return this.tree.findMode === Na.Filter ? typeof this.tree.options.defaultFindVisibility == "number" ? this.tree.options.defaultFindVisibility : this.tree.options.defaultFindVisibility ? this.tree.options.defaultFindVisibility(e) : 2 : { data: rh.Default, visibility: i };
  }
  reset() {
    this._totalCount = 0, this._matchCount = 0;
  }
  dispose() {
    Ft(this.disposables);
  }
}
var Na;
(function(s) {
  s[s.Highlight = 0] = "Highlight", s[s.Filter = 1] = "Filter";
})(Na || (Na = {}));
var Gh;
(function(s) {
  s[s.Fuzzy = 0] = "Fuzzy", s[s.Contiguous = 1] = "Contiguous";
})(Gh || (Gh = {}));
class eQ {
  get pattern() {
    return this._pattern;
  }
  get mode() {
    return this._mode;
  }
  set mode(e) {
    e !== this._mode && (this._mode = e, this.widget && (this.widget.mode = this._mode), this.tree.refilter(), this.render(), this._onDidChangeMode.fire(e));
  }
  get matchType() {
    return this._matchType;
  }
  set matchType(e) {
    e !== this._matchType && (this._matchType = e, this.widget && (this.widget.matchType = this._matchType), this.tree.refilter(), this.render(), this._onDidChangeMatchType.fire(e));
  }
  constructor(e, t, i, n, o, r = {}) {
    this.tree = e, this.view = i, this.filter = n, this.contextViewProvider = o, this.options = r, this._pattern = "", this.width = 0, this._onDidChangeMode = new A(), this.onDidChangeMode = this._onDidChangeMode.event, this._onDidChangeMatchType = new A(), this.onDidChangeMatchType = this._onDidChangeMatchType.event, this._onDidChangePattern = new A(), this._onDidChangeOpenState = new A(), this.onDidChangeOpenState = this._onDidChangeOpenState.event, this.enabledDisposables = new ne(), this.disposables = new ne(), this._mode = e.options.defaultFindMode ?? Na.Highlight, this._matchType = e.options.defaultFindMatchType ?? Gh.Fuzzy, t.onDidSplice(this.onDidSpliceModel, this, this.disposables);
  }
  updateOptions(e = {}) {
    e.defaultFindMode !== void 0 && (this.mode = e.defaultFindMode), e.defaultFindMatchType !== void 0 && (this.matchType = e.defaultFindMatchType);
  }
  onDidSpliceModel() {
    !this.widget || this.pattern.length === 0 || (this.tree.refilter(), this.render());
  }
  render() {
    var t, i, n;
    const e = this.filter.totalCount > 0 && this.filter.matchCount === 0;
    this.pattern && e ? (Uh(m("replFindNoResults", "No results")), this.tree.options.showNotFoundMessage ?? !0 ? (t = this.widget) == null || t.showMessage({ type: 2, content: m("not found", "No elements found.") }) : (i = this.widget) == null || i.showMessage({
      type: 2
      /* MessageType.WARNING */
    })) : ((n = this.widget) == null || n.clearMessage(), this.pattern && Uh(m("replFindResults", "{0} results", this.filter.matchCount)));
  }
  shouldAllowFocus(e) {
    return !this.widget || !this.pattern || this.filter.totalCount > 0 && this.filter.matchCount <= 1 ? !0 : !rh.isDefault(e.filterData);
  }
  layout(e) {
    var t;
    this.width = e, (t = this.widget) == null || t.layout(e);
  }
  dispose() {
    this._history = void 0, this._onDidChangePattern.dispose(), this.enabledDisposables.dispose(), this.disposables.dispose();
  }
}
function tQ(s, e) {
  return s.position === e.position && HF(s, e);
}
function HF(s, e) {
  return s.node.element === e.node.element && s.startIndex === e.startIndex && s.height === e.height && s.endIndex === e.endIndex;
}
class iQ {
  constructor(e = []) {
    this.stickyNodes = e;
  }
  get count() {
    return this.stickyNodes.length;
  }
  equal(e) {
    return li(this.stickyNodes, e.stickyNodes, tQ);
  }
  lastNodePartiallyVisible() {
    if (this.count === 0)
      return !1;
    const e = this.stickyNodes[this.count - 1];
    if (this.count === 1)
      return e.position !== 0;
    const t = this.stickyNodes[this.count - 2];
    return t.position + t.height !== e.position;
  }
  animationStateChanged(e) {
    if (!li(this.stickyNodes, e.stickyNodes, HF) || this.count === 0)
      return !1;
    const t = this.stickyNodes[this.count - 1], i = e.stickyNodes[e.count - 1];
    return t.position !== i.position;
  }
}
class nQ {
  constrainStickyScrollNodes(e, t, i) {
    for (let n = 0; n < e.length; n++) {
      const o = e[n];
      if (o.position + o.height > i || n >= t)
        return e.slice(0, n);
    }
    return e;
  }
}
class XM extends U {
  constructor(e, t, i, n, o, r = {}) {
    super(), this.tree = e, this.model = t, this.view = i, this.treeDelegate = o, this.maxWidgetViewRatio = 0.4;
    const a = this.validateStickySettings(r);
    this.stickyScrollMaxItemCount = a.stickyScrollMaxItemCount, this.stickyScrollDelegate = r.stickyScrollDelegate ?? new nQ(), this._widget = this._register(new sQ(i.getScrollableElement(), i, e, n, o, r.accessibilityProvider)), this.onDidChangeHasFocus = this._widget.onDidChangeHasFocus, this.onContextMenu = this._widget.onContextMenu, this._register(i.onDidScroll(() => this.update())), this._register(i.onDidChangeContentHeight(() => this.update())), this._register(e.onDidChangeCollapseState(() => this.update())), this.update();
  }
  get height() {
    return this._widget.height;
  }
  getNodeAtHeight(e) {
    let t;
    if (e === 0 ? t = this.view.firstVisibleIndex : t = this.view.indexAt(e + this.view.scrollTop), !(t < 0 || t >= this.view.length))
      return this.view.element(t);
  }
  update() {
    const e = this.getNodeAtHeight(0);
    if (!e || this.tree.scrollTop === 0) {
      this._widget.setState(void 0);
      return;
    }
    const t = this.findStickyState(e);
    this._widget.setState(t);
  }
  findStickyState(e) {
    const t = [];
    let i = e, n = 0, o = this.getNextStickyNode(i, void 0, n);
    for (; o && (t.push(o), n += o.height, !(t.length <= this.stickyScrollMaxItemCount && (i = this.getNextVisibleNode(o), !i))); )
      o = this.getNextStickyNode(i, o.node, n);
    const r = this.constrainStickyNodes(t);
    return r.length ? new iQ(r) : void 0;
  }
  getNextVisibleNode(e) {
    return this.getNodeAtHeight(e.position + e.height);
  }
  getNextStickyNode(e, t, i) {
    const n = this.getAncestorUnderPrevious(e, t);
    if (n && !(n === e && (!this.nodeIsUncollapsedParent(e) || this.nodeTopAlignsWithStickyNodesBottom(e, i))))
      return this.createStickyScrollNode(n, i);
  }
  nodeTopAlignsWithStickyNodesBottom(e, t) {
    const i = this.getNodeIndex(e), n = this.view.getElementTop(i), o = t;
    return this.view.scrollTop === n - o;
  }
  createStickyScrollNode(e, t) {
    const i = this.treeDelegate.getHeight(e), { startIndex: n, endIndex: o } = this.getNodeRange(e), r = this.calculateStickyNodePosition(o, t, i);
    return { node: e, position: r, height: i, startIndex: n, endIndex: o };
  }
  getAncestorUnderPrevious(e, t = void 0) {
    let i = e, n = this.getParentNode(i);
    for (; n; ) {
      if (n === t)
        return i;
      i = n, n = this.getParentNode(i);
    }
    if (t === void 0)
      return i;
  }
  calculateStickyNodePosition(e, t, i) {
    let n = this.view.getRelativeTop(e);
    if (n === null && this.view.firstVisibleIndex === e && e + 1 < this.view.length) {
      const c = this.treeDelegate.getHeight(this.view.element(e)), h = this.view.getRelativeTop(e + 1);
      n = h ? h - c / this.view.renderHeight : null;
    }
    if (n === null)
      return t;
    const o = this.view.element(e), r = this.treeDelegate.getHeight(o), l = n * this.view.renderHeight + r;
    return t + i > l && t <= l ? l - i : t;
  }
  constrainStickyNodes(e) {
    if (e.length === 0)
      return [];
    const t = this.view.renderHeight * this.maxWidgetViewRatio, i = e[e.length - 1];
    if (e.length <= this.stickyScrollMaxItemCount && i.position + i.height <= t)
      return e;
    const n = this.stickyScrollDelegate.constrainStickyScrollNodes(e, this.stickyScrollMaxItemCount, t);
    if (!n.length)
      return [];
    const o = n[n.length - 1];
    if (n.length > this.stickyScrollMaxItemCount || o.position + o.height > t)
      throw new Error("stickyScrollDelegate violates constraints");
    return n;
  }
  getParentNode(e) {
    const t = this.model.getNodeLocation(e), i = this.model.getParentNodeLocation(t);
    return i ? this.model.getNode(i) : void 0;
  }
  nodeIsUncollapsedParent(e) {
    const t = this.model.getNodeLocation(e);
    return this.model.getListRenderCount(t) > 1;
  }
  getNodeIndex(e) {
    const t = this.model.getNodeLocation(e);
    return this.model.getListIndex(t);
  }
  getNodeRange(e) {
    const t = this.model.getNodeLocation(e), i = this.model.getListIndex(t);
    if (i < 0)
      throw new Error("Node not found in tree");
    const n = this.model.getListRenderCount(t), o = i + n - 1;
    return { startIndex: i, endIndex: o };
  }
  nodePositionTopBelowWidget(e) {
    const t = [];
    let i = this.getParentNode(e);
    for (; i; )
      t.push(i), i = this.getParentNode(i);
    let n = 0;
    for (let o = 0; o < t.length && o < this.stickyScrollMaxItemCount; o++)
      n += this.treeDelegate.getHeight(t[o]);
    return n;
  }
  domFocus() {
    this._widget.domFocus();
  }
  // Whether sticky scroll was the last focused part in the tree or not
  focusedLast() {
    return this._widget.focusedLast();
  }
  updateOptions(e = {}) {
    if (!e.stickyScrollMaxItemCount)
      return;
    const t = this.validateStickySettings(e);
    this.stickyScrollMaxItemCount !== t.stickyScrollMaxItemCount && (this.stickyScrollMaxItemCount = t.stickyScrollMaxItemCount, this.update());
  }
  validateStickySettings(e) {
    let t = 7;
    return typeof e.stickyScrollMaxItemCount == "number" && (t = Math.max(e.stickyScrollMaxItemCount, 1)), { stickyScrollMaxItemCount: t };
  }
}
class sQ {
  constructor(e, t, i, n, o, r) {
    this.view = t, this.tree = i, this.treeRenderers = n, this.treeDelegate = o, this.accessibilityProvider = r, this._previousElements = [], this._previousStateDisposables = new ne(), this._rootDomNode = he(".monaco-tree-sticky-container.empty"), e.appendChild(this._rootDomNode);
    const a = he(".monaco-tree-sticky-container-shadow");
    this._rootDomNode.appendChild(a), this.stickyScrollFocus = new oQ(this._rootDomNode, t), this.onDidChangeHasFocus = this.stickyScrollFocus.onDidChangeHasFocus, this.onContextMenu = this.stickyScrollFocus.onContextMenu;
  }
  get height() {
    if (!this._previousState)
      return 0;
    const e = this._previousState.stickyNodes[this._previousState.count - 1];
    return e.position + e.height;
  }
  setState(e) {
    const t = !!this._previousState && this._previousState.count > 0, i = !!e && e.count > 0;
    if (!t && !i || t && i && this._previousState.equal(e))
      return;
    if (t !== i && this.setVisible(i), !i) {
      this._previousState = void 0, this._previousElements = [], this._previousStateDisposables.clear();
      return;
    }
    const n = e.stickyNodes[e.count - 1];
    if (this._previousState && e.animationStateChanged(this._previousState))
      this._previousElements[this._previousState.count - 1].style.top = `${n.position}px`;
    else {
      this._previousStateDisposables.clear();
      const o = Array(e.count);
      for (let r = e.count - 1; r >= 0; r--) {
        const a = e.stickyNodes[r], { element: l, disposable: c } = this.createElement(a, r, e.count);
        o[r] = l, this._rootDomNode.appendChild(l), this._previousStateDisposables.add(c);
      }
      this.stickyScrollFocus.updateElements(o, e), this._previousElements = o;
    }
    this._previousState = e, this._rootDomNode.style.height = `${n.position + n.height}px`;
  }
  createElement(e, t, i) {
    const n = e.startIndex, o = document.createElement("div");
    o.style.top = `${e.position}px`, this.tree.options.setRowHeight !== !1 && (o.style.height = `${e.height}px`), this.tree.options.setRowLineHeight !== !1 && (o.style.lineHeight = `${e.height}px`), o.classList.add("monaco-tree-sticky-row"), o.classList.add("monaco-list-row"), o.setAttribute("data-index", `${n}`), o.setAttribute("data-parity", n % 2 === 0 ? "even" : "odd"), o.setAttribute("id", this.view.getElementID(n));
    const r = this.setAccessibilityAttributes(o, e.node.element, t, i), a = this.treeDelegate.getTemplateId(e.node), l = this.treeRenderers.find((u) => u.templateId === a);
    if (!l)
      throw new Error(`No renderer found for template id ${a}`);
    let c = e.node;
    c === this.tree.getNode(this.tree.getNodeLocation(e.node)) && (c = new Proxy(e.node, {}));
    const h = l.renderTemplate(o);
    l.renderElement(c, e.startIndex, h, e.height);
    const d = _e(() => {
      r.dispose(), l.disposeElement(c, e.startIndex, h, e.height), l.disposeTemplate(h), o.remove();
    });
    return { element: o, disposable: d };
  }
  setAccessibilityAttributes(e, t, i, n) {
    if (!this.accessibilityProvider)
      return U.None;
    this.accessibilityProvider.getSetSize && e.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(t, i, n))), this.accessibilityProvider.getPosInSet && e.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(t, i))), this.accessibilityProvider.getRole && e.setAttribute("role", this.accessibilityProvider.getRole(t) ?? "treeitem");
    const o = this.accessibilityProvider.getAriaLabel(t), r = o && typeof o != "string" ? o : n1(o), a = Qe((c) => {
      const h = c.readObservable(r);
      h ? e.setAttribute("aria-label", h) : e.removeAttribute("aria-label");
    });
    typeof o == "string" || o && e.setAttribute("aria-label", o.get());
    const l = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(t);
    return typeof l == "number" && e.setAttribute("aria-level", `${l}`), e.setAttribute("aria-selected", String(!1)), a;
  }
  setVisible(e) {
    this._rootDomNode.classList.toggle("empty", !e), e || this.stickyScrollFocus.updateElements([], void 0);
  }
  domFocus() {
    this.stickyScrollFocus.domFocus();
  }
  focusedLast() {
    return this.stickyScrollFocus.focusedLast();
  }
  dispose() {
    this.stickyScrollFocus.dispose(), this._previousStateDisposables.dispose(), this._rootDomNode.remove();
  }
}
class oQ extends U {
  get domHasFocus() {
    return this._domHasFocus;
  }
  set domHasFocus(e) {
    e !== this._domHasFocus && (this._onDidChangeHasFocus.fire(e), this._domHasFocus = e);
  }
  constructor(e, t) {
    super(), this.container = e, this.view = t, this.focusedIndex = -1, this.elements = [], this._onDidChangeHasFocus = new A(), this.onDidChangeHasFocus = this._onDidChangeHasFocus.event, this._onContextMenu = new A(), this.onContextMenu = this._onContextMenu.event, this._domHasFocus = !1, this._register(z(this.container, "focus", () => this.onFocus())), this._register(z(this.container, "blur", () => this.onBlur())), this._register(this.view.onDidFocus(() => this.toggleStickyScrollFocused(!1))), this._register(this.view.onKeyDown((i) => this.onKeyDown(i))), this._register(this.view.onMouseDown((i) => this.onMouseDown(i))), this._register(this.view.onContextMenu((i) => this.handleContextMenu(i)));
  }
  handleContextMenu(e) {
    const t = e.browserEvent.target;
    if (!Pm(t) && !Pg(t)) {
      this.focusedLast() && this.view.domFocus();
      return;
    }
    if (!ma(e.browserEvent)) {
      if (!this.state)
        throw new Error("Context menu should not be triggered when state is undefined");
      const r = this.state.stickyNodes.findIndex((a) => {
        var l;
        return a.node.element === ((l = e.element) == null ? void 0 : l.element);
      });
      if (r === -1)
        throw new Error("Context menu should not be triggered when element is not in sticky scroll widget");
      this.container.focus(), this.setFocus(r);
      return;
    }
    if (!this.state || this.focusedIndex < 0)
      throw new Error("Context menu key should not be triggered when focus is not in sticky scroll widget");
    const n = this.state.stickyNodes[this.focusedIndex].node.element, o = this.elements[this.focusedIndex];
    this._onContextMenu.fire({ element: n, anchor: o, browserEvent: e.browserEvent, isStickyScroll: !0 });
  }
  onKeyDown(e) {
    if (this.domHasFocus && this.state) {
      if (e.key === "ArrowUp")
        this.setFocusedElement(Math.max(0, this.focusedIndex - 1)), e.preventDefault(), e.stopPropagation();
      else if (e.key === "ArrowDown" || e.key === "ArrowRight") {
        if (this.focusedIndex >= this.state.count - 1) {
          const t = this.state.stickyNodes[this.state.count - 1].startIndex + 1;
          this.view.domFocus(), this.view.setFocus([t]), this.scrollNodeUnderWidget(t, this.state);
        } else
          this.setFocusedElement(this.focusedIndex + 1);
        e.preventDefault(), e.stopPropagation();
      }
    }
  }
  onMouseDown(e) {
    const t = e.browserEvent.target;
    !Pm(t) && !Pg(t) || (e.browserEvent.preventDefault(), e.browserEvent.stopPropagation());
  }
  updateElements(e, t) {
    if (t && t.count === 0)
      throw new Error("Sticky scroll state must be undefined when there are no sticky nodes");
    if (t && t.count !== e.length)
      throw new Error("Sticky scroll focus received illigel state");
    const i = this.focusedIndex;
    if (this.removeFocus(), this.elements = e, this.state = t, t) {
      const n = Dn(i, 0, t.count - 1);
      this.setFocus(n);
    } else
      this.domHasFocus && this.view.domFocus();
    this.container.tabIndex = t ? 0 : -1;
  }
  setFocusedElement(e) {
    const t = this.state;
    if (!t)
      throw new Error("Cannot set focus when state is undefined");
    if (this.setFocus(e), !(e < t.count - 1) && t.lastNodePartiallyVisible()) {
      const i = t.stickyNodes[e];
      this.scrollNodeUnderWidget(i.endIndex + 1, t);
    }
  }
  scrollNodeUnderWidget(e, t) {
    const i = t.stickyNodes[t.count - 1], n = t.count > 1 ? t.stickyNodes[t.count - 2] : void 0, o = this.view.getElementTop(e), r = n ? n.position + n.height + i.height : i.height;
    this.view.scrollTop = o - r;
  }
  domFocus() {
    if (!this.state)
      throw new Error("Cannot focus when state is undefined");
    this.container.focus();
  }
  focusedLast() {
    return this.state ? this.view.getHTMLElement().classList.contains("sticky-scroll-focused") : !1;
  }
  removeFocus() {
    this.focusedIndex !== -1 && (this.toggleElementFocus(this.elements[this.focusedIndex], !1), this.focusedIndex = -1);
  }
  setFocus(e) {
    if (0 > e)
      throw new Error("addFocus() can not remove focus");
    if (!this.state && e >= 0)
      throw new Error("Cannot set focus index when state is undefined");
    if (this.state && e >= this.state.count)
      throw new Error("Cannot set focus index to an index that does not exist");
    const t = this.focusedIndex;
    t >= 0 && this.toggleElementFocus(this.elements[t], !1), e >= 0 && this.toggleElementFocus(this.elements[e], !0), this.focusedIndex = e;
  }
  toggleElementFocus(e, t) {
    this.toggleElementActiveFocus(e, t && this.domHasFocus), this.toggleElementPassiveFocus(e, t);
  }
  toggleCurrentElementActiveFocus(e) {
    this.focusedIndex !== -1 && this.toggleElementActiveFocus(this.elements[this.focusedIndex], e);
  }
  toggleElementActiveFocus(e, t) {
    e.classList.toggle("focused", t);
  }
  toggleElementPassiveFocus(e, t) {
    e.classList.toggle("passive-focused", t);
  }
  toggleStickyScrollFocused(e) {
    this.view.getHTMLElement().classList.toggle("sticky-scroll-focused", e);
  }
  onFocus() {
    if (!this.state || this.elements.length === 0)
      throw new Error("Cannot focus when state is undefined or elements are empty");
    this.domHasFocus = !0, this.toggleStickyScrollFocused(!0), this.toggleCurrentElementActiveFocus(!0), this.focusedIndex === -1 && this.setFocus(0);
  }
  onBlur() {
    this.domHasFocus = !1, this.toggleCurrentElementActiveFocus(!1);
  }
  dispose() {
    this.toggleStickyScrollFocused(!1), this._onDidChangeHasFocus.fire(!1), super.dispose();
  }
}
function N_(s) {
  let e = ih.Unknown;
  return p0(s.browserEvent.target, "monaco-tl-twistie", "monaco-tl-row") ? e = ih.Twistie : p0(s.browserEvent.target, "monaco-tl-contents", "monaco-tl-row") ? e = ih.Element : p0(s.browserEvent.target, "monaco-tree-type-filter", "monaco-list") && (e = ih.Filter), {
    browserEvent: s.browserEvent,
    element: s.element ? s.element.element : null,
    target: e
  };
}
function rQ(s) {
  const e = Pm(s.browserEvent.target);
  return {
    element: s.element ? s.element.element : null,
    browserEvent: s.browserEvent,
    anchor: s.anchor,
    isStickyScroll: e
  };
}
function gb(s, e) {
  e(s), s.children.forEach((t) => gb(t, e));
}
class oy {
  get nodeSet() {
    return this._nodeSet || (this._nodeSet = this.createNodeSet()), this._nodeSet;
  }
  constructor(e, t) {
    this.getFirstViewElementWithTrait = e, this.identityProvider = t, this.nodes = [], this._onDidChange = new A(), this.onDidChange = this._onDidChange.event;
  }
  set(e, t) {
    !(t != null && t.__forceEvent) && li(this.nodes, e) || this._set(e, !1, t);
  }
  _set(e, t, i) {
    if (this.nodes = [...e], this.elements = void 0, this._nodeSet = void 0, !t) {
      const n = this;
      this._onDidChange.fire({ get elements() {
        return n.get();
      }, browserEvent: i });
    }
  }
  get() {
    return this.elements || (this.elements = this.nodes.map((e) => e.element)), [...this.elements];
  }
  getNodes() {
    return this.nodes;
  }
  has(e) {
    return this.nodeSet.has(e);
  }
  onDidModelSplice({ insertedNodes: e, deletedNodes: t }) {
    if (!this.identityProvider) {
      const l = this.createNodeSet(), c = (h) => l.delete(h);
      t.forEach((h) => gb(h, c)), this.set([...l.values()]);
      return;
    }
    const i = /* @__PURE__ */ new Set(), n = (l) => i.add(this.identityProvider.getId(l.element).toString());
    t.forEach((l) => gb(l, n));
    const o = /* @__PURE__ */ new Map(), r = (l) => o.set(this.identityProvider.getId(l.element).toString(), l);
    e.forEach((l) => gb(l, r));
    const a = [];
    for (const l of this.nodes) {
      const c = this.identityProvider.getId(l.element).toString();
      if (!i.has(c))
        a.push(l);
      else {
        const d = o.get(c);
        d && d.visible && a.push(d);
      }
    }
    if (this.nodes.length > 0 && a.length === 0) {
      const l = this.getFirstViewElementWithTrait();
      l && a.push(l);
    }
    this._set(a, !0);
  }
  createNodeSet() {
    const e = /* @__PURE__ */ new Set();
    for (const t of this.nodes)
      e.add(t);
    return e;
  }
}
class aQ extends OO {
  constructor(e, t, i) {
    super(e), this.tree = t, this.stickyScrollProvider = i;
  }
  onViewPointer(e) {
    if (MO(e.browserEvent.target) || Rl(e.browserEvent.target) || bg(e.browserEvent.target) || e.browserEvent.isHandledByList)
      return;
    const t = e.element;
    if (!t)
      return super.onViewPointer(e);
    if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e))
      return super.onViewPointer(e);
    const i = e.browserEvent.target, n = i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && e.browserEvent.offsetX < 16, o = Pg(e.browserEvent.target);
    let r = !1;
    if (o ? r = !0 : typeof this.tree.expandOnlyOnTwistieClick == "function" ? r = this.tree.expandOnlyOnTwistieClick(t.element) : r = !!this.tree.expandOnlyOnTwistieClick, o)
      this.handleStickyScrollMouseEvent(e, t);
    else {
      if (r && !n && e.browserEvent.detail !== 2)
        return super.onViewPointer(e);
      if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2)
        return super.onViewPointer(e);
    }
    if (t.collapsible && (!o || n)) {
      const a = this.tree.getNodeLocation(t), l = e.browserEvent.altKey;
      if (this.tree.setFocus([a]), this.tree.toggleCollapsed(a, l), n) {
        e.browserEvent.isHandledByList = !0;
        return;
      }
    }
    o || super.onViewPointer(e);
  }
  handleStickyScrollMouseEvent(e, t) {
    if (HH(e.browserEvent.target) || VH(e.browserEvent.target))
      return;
    const i = this.stickyScrollProvider();
    if (!i)
      throw new Error("Sticky scroll controller not found");
    const n = this.list.indexOf(t), o = this.list.getElementTop(n), r = i.nodePositionTopBelowWidget(t);
    this.tree.scrollTop = o - r, this.list.domFocus(), this.list.setFocus([n]), this.list.setSelection([n]);
  }
  onDoubleClick(e) {
    e.browserEvent.target.classList.contains("monaco-tl-twistie") || !this.tree.expandOnDoubleClick || e.browserEvent.isHandledByList || super.onDoubleClick(e);
  }
  // to make sure dom focus is not stolen (for example with context menu)
  onMouseDown(e) {
    const t = e.browserEvent.target;
    if (!Pm(t) && !Pg(t)) {
      super.onMouseDown(e);
      return;
    }
  }
  onContextMenu(e) {
    const t = e.browserEvent.target;
    if (!Pm(t) && !Pg(t)) {
      super.onContextMenu(e);
      return;
    }
  }
}
class lQ extends wo {
  constructor(e, t, i, n, o, r, a, l) {
    super(e, t, i, n, l), this.focusTrait = o, this.selectionTrait = r, this.anchorTrait = a;
  }
  createMouseController(e) {
    return new aQ(this, e.tree, e.stickyScrollProvider);
  }
  splice(e, t, i = []) {
    if (super.splice(e, t, i), i.length === 0)
      return;
    const n = [], o = [];
    let r;
    i.forEach((a, l) => {
      this.focusTrait.has(a) && n.push(e + l), this.selectionTrait.has(a) && o.push(e + l), this.anchorTrait.has(a) && (r = e + l);
    }), n.length > 0 && super.setFocus(zh([...super.getFocus(), ...n])), o.length > 0 && super.setSelection(zh([...super.getSelection(), ...o])), typeof r == "number" && super.setAnchor(r);
  }
  setFocus(e, t, i = !1) {
    super.setFocus(e, t), i || this.focusTrait.set(e.map((n) => this.element(n)), t);
  }
  setSelection(e, t, i = !1) {
    super.setSelection(e, t), i || this.selectionTrait.set(e.map((n) => this.element(n)), t);
  }
  setAnchor(e, t = !1) {
    super.setAnchor(e), t || (typeof e > "u" ? this.anchorTrait.set([]) : this.anchorTrait.set([this.element(e)]));
  }
}
class VF {
  get onDidScroll() {
    return this.view.onDidScroll;
  }
  get onDidChangeFocus() {
    return this.eventBufferer.wrapEvent(this.focus.onDidChange);
  }
  get onDidChangeSelection() {
    return this.eventBufferer.wrapEvent(this.selection.onDidChange);
  }
  get onMouseDblClick() {
    return ee.filter(ee.map(this.view.onMouseDblClick, N_), (e) => e.target !== ih.Filter);
  }
  get onMouseOver() {
    return ee.map(this.view.onMouseOver, N_);
  }
  get onMouseOut() {
    return ee.map(this.view.onMouseOut, N_);
  }
  get onContextMenu() {
    var e;
    return ee.any(ee.filter(ee.map(this.view.onContextMenu, rQ), (t) => !t.isStickyScroll), ((e = this.stickyScrollController) == null ? void 0 : e.onContextMenu) ?? ee.None);
  }
  get onPointer() {
    return ee.map(this.view.onPointer, N_);
  }
  get onKeyDown() {
    return this.view.onKeyDown;
  }
  get onDidFocus() {
    return this.view.onDidFocus;
  }
  get onDidChangeModel() {
    return ee.signal(this.model.onDidSplice);
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get findMode() {
    var e;
    return ((e = this.findController) == null ? void 0 : e.mode) ?? Na.Highlight;
  }
  set findMode(e) {
    this.findController && (this.findController.mode = e);
  }
  get findMatchType() {
    var e;
    return ((e = this.findController) == null ? void 0 : e.matchType) ?? Gh.Fuzzy;
  }
  set findMatchType(e) {
    this.findController && (this.findController.matchType = e);
  }
  get expandOnDoubleClick() {
    return typeof this._options.expandOnDoubleClick > "u" ? !0 : this._options.expandOnDoubleClick;
  }
  get expandOnlyOnTwistieClick() {
    return typeof this._options.expandOnlyOnTwistieClick > "u" ? !0 : this._options.expandOnlyOnTwistieClick;
  }
  get onDidDispose() {
    return this.view.onDidDispose;
  }
  constructor(e, t, i, n, o = {}) {
    this._user = e, this._options = o, this.eventBufferer = new xp(), this.onDidChangeFindOpenState = ee.None, this.onDidChangeStickyScrollFocused = ee.None, this.disposables = new ne(), this._onWillRefilter = new A(), this.onWillRefilter = this._onWillRefilter.event, this._onDidUpdateOptions = new A(), this.treeDelegate = new eN(i);
    const r = new d2(), a = new d2(), l = this.disposables.add(new QX(a.event)), c = new G4();
    this.renderers = n.map((g) => new DL(g, () => this.model, r.event, l, c, o));
    for (const g of this.renderers)
      this.disposables.add(g);
    let h;
    o.keyboardNavigationLabelProvider && (h = new JX(this, o.keyboardNavigationLabelProvider, o.filter), o = { ...o, filter: h }, this.disposables.add(h)), this.focus = new oy(() => this.view.getFocusedElements()[0], o.identityProvider), this.selection = new oy(() => this.view.getSelectedElements()[0], o.identityProvider), this.anchor = new oy(() => this.view.getAnchorElement(), o.identityProvider), this.view = new lQ(e, t, this.treeDelegate, this.renderers, this.focus, this.selection, this.anchor, { ...XX(() => this.model, o), tree: this, stickyScrollProvider: () => this.stickyScrollController }), this.model = this.createModel(e, this.view, o), r.input = this.model.onDidChangeCollapseState;
    const d = ee.forEach(this.model.onDidSplice, (g) => {
      this.eventBufferer.bufferEvents(() => {
        this.focus.onDidModelSplice(g), this.selection.onDidModelSplice(g);
      });
    }, this.disposables);
    d(() => null, null, this.disposables);
    const u = this.disposables.add(new A()), f = this.disposables.add(new Np(0));
    if (this.disposables.add(ee.any(d, this.focus.onDidChange, this.selection.onDidChange)(() => {
      f.trigger(() => {
        const g = /* @__PURE__ */ new Set();
        for (const p of this.focus.getNodes())
          g.add(p);
        for (const p of this.selection.getNodes())
          g.add(p);
        u.fire([...g.values()]);
      });
    })), a.input = u.event, o.keyboardSupport !== !1) {
      const g = ee.chain(this.view.onKeyDown, (p) => p.filter((_) => !Rl(_.target)).map((_) => new Dt(_)));
      ee.chain(g, (p) => p.filter(
        (_) => _.keyCode === 15
        /* KeyCode.LeftArrow */
      ))(this.onLeftArrow, this, this.disposables), ee.chain(g, (p) => p.filter(
        (_) => _.keyCode === 17
        /* KeyCode.RightArrow */
      ))(this.onRightArrow, this, this.disposables), ee.chain(g, (p) => p.filter(
        (_) => _.keyCode === 10
        /* KeyCode.Space */
      ))(this.onSpace, this, this.disposables);
    }
    if ((o.findWidgetEnabled ?? !0) && o.keyboardNavigationLabelProvider && o.contextViewProvider) {
      const g = this.options.findWidgetStyles ? { styles: this.options.findWidgetStyles } : void 0;
      this.findController = new eQ(this, this.model, this.view, h, o.contextViewProvider, g), this.focusNavigationFilter = (p) => this.findController.shouldAllowFocus(p), this.onDidChangeFindOpenState = this.findController.onDidChangeOpenState, this.disposables.add(this.findController), this.onDidChangeFindMode = this.findController.onDidChangeMode, this.onDidChangeFindMatchType = this.findController.onDidChangeMatchType;
    } else
      this.onDidChangeFindMode = ee.None, this.onDidChangeFindMatchType = ee.None;
    o.enableStickyScroll && (this.stickyScrollController = new XM(this, this.model, this.view, this.renderers, this.treeDelegate, o), this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus), this.styleElement = Us(this.view.getHTMLElement()), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === Cf.Always);
  }
  updateOptions(e = {}) {
    var t;
    this._options = { ...this._options, ...e };
    for (const i of this.renderers)
      i.updateOptions(e);
    this.view.updateOptions(this._options), (t = this.findController) == null || t.updateOptions(e), this.updateStickyScroll(e), this._onDidUpdateOptions.fire(this._options), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === Cf.Always);
  }
  get options() {
    return this._options;
  }
  updateStickyScroll(e) {
    var t;
    !this.stickyScrollController && this._options.enableStickyScroll ? (this.stickyScrollController = new XM(this, this.model, this.view, this.renderers, this.treeDelegate, this._options), this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus) : this.stickyScrollController && !this._options.enableStickyScroll && (this.onDidChangeStickyScrollFocused = ee.None, this.stickyScrollController.dispose(), this.stickyScrollController = void 0), (t = this.stickyScrollController) == null || t.updateOptions(e);
  }
  // Widget
  getHTMLElement() {
    return this.view.getHTMLElement();
  }
  get scrollTop() {
    return this.view.scrollTop;
  }
  set scrollTop(e) {
    this.view.scrollTop = e;
  }
  get scrollHeight() {
    return this.view.scrollHeight;
  }
  get renderHeight() {
    return this.view.renderHeight;
  }
  get ariaLabel() {
    return this.view.ariaLabel;
  }
  set ariaLabel(e) {
    this.view.ariaLabel = e;
  }
  domFocus() {
    var e;
    (e = this.stickyScrollController) != null && e.focusedLast() ? this.stickyScrollController.domFocus() : this.view.domFocus();
  }
  layout(e, t) {
    var i;
    this.view.layout(e, t), If(t) && ((i = this.findController) == null || i.layout(t));
  }
  style(e) {
    const t = `.${this.view.domId}`, i = [];
    e.treeIndentGuidesStroke && (i.push(`.monaco-list${t}:hover .monaco-tl-indent > .indent-guide, .monaco-list${t}.always .monaco-tl-indent > .indent-guide  { border-color: ${e.treeInactiveIndentGuidesStroke}; }`), i.push(`.monaco-list${t} .monaco-tl-indent > .indent-guide.active { border-color: ${e.treeIndentGuidesStroke}; }`));
    const n = e.treeStickyScrollBackground ?? e.listBackground;
    n && (i.push(`.monaco-list${t} .monaco-scrollable-element .monaco-tree-sticky-container { background-color: ${n}; }`), i.push(`.monaco-list${t} .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-row { background-color: ${n}; }`)), e.treeStickyScrollBorder && i.push(`.monaco-list${t} .monaco-scrollable-element .monaco-tree-sticky-container { border-bottom: 1px solid ${e.treeStickyScrollBorder}; }`), e.treeStickyScrollShadow && i.push(`.monaco-list${t} .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-container-shadow { box-shadow: ${e.treeStickyScrollShadow} 0 6px 6px -6px inset; height: 3px; }`), e.listFocusForeground && (i.push(`.monaco-list${t}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { color: ${e.listFocusForeground}; }`), i.push(`.monaco-list${t}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { color: inherit; }`));
    const o = Fa(e.listFocusAndSelectionOutline, Fa(e.listSelectionOutline, e.listFocusOutline ?? ""));
    o && (i.push(`.monaco-list${t}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused.selected { outline: 1px solid ${o}; outline-offset: -1px;}`), i.push(`.monaco-list${t}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused.selected { outline: inherit;}`)), e.listFocusOutline && (i.push(`.monaco-list${t}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }`), i.push(`.monaco-list${t}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { outline: inherit; }`), i.push(`.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.passive-focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }`), i.push(`.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused.sticky-scroll-focused .monaco-list-rows .monaco-list-row.focused { outline: inherit; }`), i.push(`.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused:not(.sticky-scroll-focused) .monaco-tree-sticky-container .monaco-list-rows .monaco-list-row.focused { outline: inherit; }`)), this.styleElement.textContent = i.join(`
`), this.view.style(e);
  }
  // Tree navigation
  getParentElement(e) {
    const t = this.model.getParentNodeLocation(e);
    return this.model.getNode(t).element;
  }
  getFirstElementChild(e) {
    return this.model.getFirstElementChild(e);
  }
  // Tree
  getNode(e) {
    return this.model.getNode(e);
  }
  getNodeLocation(e) {
    return this.model.getNodeLocation(e);
  }
  collapse(e, t = !1) {
    return this.model.setCollapsed(e, !0, t);
  }
  expand(e, t = !1) {
    return this.model.setCollapsed(e, !1, t);
  }
  toggleCollapsed(e, t = !1) {
    return this.model.setCollapsed(e, void 0, t);
  }
  isCollapsible(e) {
    return this.model.isCollapsible(e);
  }
  setCollapsible(e, t) {
    return this.model.setCollapsible(e, t);
  }
  isCollapsed(e) {
    return this.model.isCollapsed(e);
  }
  refilter() {
    this._onWillRefilter.fire(void 0), this.model.refilter();
  }
  setSelection(e, t) {
    this.eventBufferer.bufferEvents(() => {
      const i = e.map((o) => this.model.getNode(o));
      this.selection.set(i, t);
      const n = e.map((o) => this.model.getListIndex(o)).filter((o) => o > -1);
      this.view.setSelection(n, t, !0);
    });
  }
  getSelection() {
    return this.selection.get();
  }
  setFocus(e, t) {
    this.eventBufferer.bufferEvents(() => {
      const i = e.map((o) => this.model.getNode(o));
      this.focus.set(i, t);
      const n = e.map((o) => this.model.getListIndex(o)).filter((o) => o > -1);
      this.view.setFocus(n, t, !0);
    });
  }
  focusNext(e = 1, t = !1, i, n = ma(i) && i.altKey ? void 0 : this.focusNavigationFilter) {
    this.view.focusNext(e, t, i, n);
  }
  focusPrevious(e = 1, t = !1, i, n = ma(i) && i.altKey ? void 0 : this.focusNavigationFilter) {
    this.view.focusPrevious(e, t, i, n);
  }
  focusNextPage(e, t = ma(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
    return this.view.focusNextPage(e, t);
  }
  focusPreviousPage(e, t = ma(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
    return this.view.focusPreviousPage(e, t, () => {
      var i;
      return ((i = this.stickyScrollController) == null ? void 0 : i.height) ?? 0;
    });
  }
  focusLast(e, t = ma(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
    this.view.focusLast(e, t);
  }
  focusFirst(e, t = ma(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
    this.view.focusFirst(e, t);
  }
  getFocus() {
    return this.focus.get();
  }
  reveal(e, t) {
    this.model.expandTo(e);
    const i = this.model.getListIndex(e);
    if (i !== -1)
      if (!this.stickyScrollController)
        this.view.reveal(i, t);
      else {
        const n = this.stickyScrollController.nodePositionTopBelowWidget(this.getNode(e));
        this.view.reveal(i, t, n);
      }
  }
  // List
  onLeftArrow(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], n = this.model.getNodeLocation(i);
    if (!this.model.setCollapsed(n, !0)) {
      const r = this.model.getParentNodeLocation(n);
      if (!r)
        return;
      const a = this.model.getListIndex(r);
      this.view.reveal(a), this.view.setFocus([a]);
    }
  }
  onRightArrow(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], n = this.model.getNodeLocation(i);
    if (!this.model.setCollapsed(n, !1)) {
      if (!i.children.some((l) => l.visible))
        return;
      const [r] = this.view.getFocus(), a = r + 1;
      this.view.reveal(a), this.view.setFocus([a]);
    }
  }
  onSpace(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], n = this.model.getNodeLocation(i), o = e.browserEvent.altKey;
    this.model.setCollapsed(n, void 0, o);
  }
  dispose() {
    var e;
    Ft(this.disposables), (e = this.stickyScrollController) == null || e.dispose(), this.view.dispose();
  }
}
class tN {
  constructor(e, t, i = {}) {
    this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.nodesByIdentity = /* @__PURE__ */ new Map(), this.model = new GX(e, t, null, i), this.onDidSplice = this.model.onDidSplice, this.onDidChangeCollapseState = this.model.onDidChangeCollapseState, this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount, i.sorter && (this.sorter = {
      compare(n, o) {
        return i.sorter.compare(n.element, o.element);
      }
    }), this.identityProvider = i.identityProvider;
  }
  setChildren(e, t = nt.empty(), i = {}) {
    const n = this.getElementLocation(e);
    this._setChildren(n, this.preserveCollapseState(t), i);
  }
  _setChildren(e, t = nt.empty(), i) {
    const n = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), r = (l) => {
      var h;
      if (l.element === null)
        return;
      const c = l;
      if (n.add(c.element), this.nodes.set(c.element, c), this.identityProvider) {
        const d = this.identityProvider.getId(c.element).toString();
        o.add(d), this.nodesByIdentity.set(d, c);
      }
      (h = i.onDidCreateNode) == null || h.call(i, c);
    }, a = (l) => {
      var h;
      if (l.element === null)
        return;
      const c = l;
      if (n.has(c.element) || this.nodes.delete(c.element), this.identityProvider) {
        const d = this.identityProvider.getId(c.element).toString();
        o.has(d) || this.nodesByIdentity.delete(d);
      }
      (h = i.onDidDeleteNode) == null || h.call(i, c);
    };
    this.model.splice([...e, 0], Number.MAX_VALUE, t, { ...i, onDidCreateNode: r, onDidDeleteNode: a });
  }
  preserveCollapseState(e = nt.empty()) {
    return this.sorter && (e = [...e].sort(this.sorter.compare.bind(this.sorter))), nt.map(e, (t) => {
      let i = this.nodes.get(t.element);
      if (!i && this.identityProvider) {
        const r = this.identityProvider.getId(t.element).toString();
        i = this.nodesByIdentity.get(r);
      }
      if (!i) {
        let r;
        return typeof t.collapsed > "u" ? r = void 0 : t.collapsed === us.Collapsed || t.collapsed === us.PreserveOrCollapsed ? r = !0 : t.collapsed === us.Expanded || t.collapsed === us.PreserveOrExpanded ? r = !1 : r = !!t.collapsed, {
          ...t,
          children: this.preserveCollapseState(t.children),
          collapsed: r
        };
      }
      const n = typeof t.collapsible == "boolean" ? t.collapsible : i.collapsible;
      let o;
      return typeof t.collapsed > "u" || t.collapsed === us.PreserveOrCollapsed || t.collapsed === us.PreserveOrExpanded ? o = i.collapsed : t.collapsed === us.Collapsed ? o = !0 : t.collapsed === us.Expanded ? o = !1 : o = !!t.collapsed, {
        ...t,
        collapsible: n,
        collapsed: o,
        children: this.preserveCollapseState(t.children)
      };
    });
  }
  rerender(e) {
    const t = this.getElementLocation(e);
    this.model.rerender(t);
  }
  getFirstElementChild(e = null) {
    const t = this.getElementLocation(e);
    return this.model.getFirstElementChild(t);
  }
  has(e) {
    return this.nodes.has(e);
  }
  getListIndex(e) {
    const t = this.getElementLocation(e);
    return this.model.getListIndex(t);
  }
  getListRenderCount(e) {
    const t = this.getElementLocation(e);
    return this.model.getListRenderCount(t);
  }
  isCollapsible(e) {
    const t = this.getElementLocation(e);
    return this.model.isCollapsible(t);
  }
  setCollapsible(e, t) {
    const i = this.getElementLocation(e);
    return this.model.setCollapsible(i, t);
  }
  isCollapsed(e) {
    const t = this.getElementLocation(e);
    return this.model.isCollapsed(t);
  }
  setCollapsed(e, t, i) {
    const n = this.getElementLocation(e);
    return this.model.setCollapsed(n, t, i);
  }
  expandTo(e) {
    const t = this.getElementLocation(e);
    this.model.expandTo(t);
  }
  refilter() {
    this.model.refilter();
  }
  getNode(e = null) {
    if (e === null)
      return this.model.getNode(this.model.rootRef);
    const t = this.nodes.get(e);
    if (!t)
      throw new ps(this.user, `Tree element not found: ${e}`);
    return t;
  }
  getNodeLocation(e) {
    return e.element;
  }
  getParentNodeLocation(e) {
    if (e === null)
      throw new ps(this.user, "Invalid getParentNodeLocation call");
    const t = this.nodes.get(e);
    if (!t)
      throw new ps(this.user, `Tree element not found: ${e}`);
    const i = this.model.getNodeLocation(t), n = this.model.getParentNodeLocation(i);
    return this.model.getNode(n).element;
  }
  getElementLocation(e) {
    if (e === null)
      return [];
    const t = this.nodes.get(e);
    if (!t)
      throw new ps(this.user, `Tree element not found: ${e}`);
    return this.model.getNodeLocation(t);
  }
}
function mb(s) {
  const e = [s.element], t = s.incompressible || !1;
  return {
    element: { elements: e, incompressible: t },
    children: nt.map(nt.from(s.children), mb),
    collapsible: s.collapsible,
    collapsed: s.collapsed
  };
}
function pb(s) {
  const e = [s.element], t = s.incompressible || !1;
  let i, n;
  for (; [n, i] = nt.consume(nt.from(s.children), 2), !(n.length !== 1 || n[0].incompressible); )
    s = n[0], e.push(s.element);
  return {
    element: { elements: e, incompressible: t },
    children: nt.map(nt.concat(n, i), pb),
    collapsible: s.collapsible,
    collapsed: s.collapsed
  };
}
function EL(s, e = 0) {
  let t;
  return e < s.element.elements.length - 1 ? t = [EL(s, e + 1)] : t = nt.map(nt.from(s.children), (i) => EL(i, 0)), e === 0 && s.element.incompressible ? {
    element: s.element.elements[e],
    children: t,
    incompressible: !0,
    collapsible: s.collapsible,
    collapsed: s.collapsed
  } : {
    element: s.element.elements[e],
    children: t,
    collapsible: s.collapsible,
    collapsed: s.collapsed
  };
}
function QM(s) {
  return EL(s, 0);
}
function zF(s, e, t) {
  return s.element === e ? { ...s, children: t } : { ...s, children: nt.map(nt.from(s.children), (i) => zF(i, e, t)) };
}
const cQ = (s) => ({
  getId(e) {
    return e.elements.map((t) => s.getId(t).toString()).join("\0");
  }
});
class hQ {
  get onDidSplice() {
    return this.model.onDidSplice;
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get onDidChangeRenderNodeCount() {
    return this.model.onDidChangeRenderNodeCount;
  }
  constructor(e, t, i = {}) {
    this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.model = new tN(e, t, i), this.enabled = typeof i.compressionEnabled > "u" ? !0 : i.compressionEnabled, this.identityProvider = i.identityProvider;
  }
  setChildren(e, t = nt.empty(), i) {
    const n = i.diffIdentityProvider && cQ(i.diffIdentityProvider);
    if (e === null) {
      const g = nt.map(t, this.enabled ? pb : mb);
      this._setChildren(null, g, { diffIdentityProvider: n, diffDepth: 1 / 0 });
      return;
    }
    const o = this.nodes.get(e);
    if (!o)
      throw new ps(this.user, "Unknown compressed tree node");
    const r = this.model.getNode(o), a = this.model.getParentNodeLocation(o), l = this.model.getNode(a), c = QM(r), h = zF(c, e, t), d = (this.enabled ? pb : mb)(h), u = i.diffIdentityProvider ? (g, p) => i.diffIdentityProvider.getId(g) === i.diffIdentityProvider.getId(p) : void 0;
    if (li(d.element.elements, r.element.elements, u)) {
      this._setChildren(o, d.children || nt.empty(), { diffIdentityProvider: n, diffDepth: 1 });
      return;
    }
    const f = l.children.map((g) => g === r ? d : g);
    this._setChildren(l.element, f, {
      diffIdentityProvider: n,
      diffDepth: r.depth - l.depth
    });
  }
  isCompressionEnabled() {
    return this.enabled;
  }
  setCompressionEnabled(e) {
    if (e === this.enabled)
      return;
    this.enabled = e;
    const i = this.model.getNode().children, n = nt.map(i, QM), o = nt.map(n, e ? pb : mb);
    this._setChildren(null, o, {
      diffIdentityProvider: this.identityProvider,
      diffDepth: 1 / 0
    });
  }
  _setChildren(e, t, i) {
    const n = /* @__PURE__ */ new Set(), o = (a) => {
      for (const l of a.element.elements)
        n.add(l), this.nodes.set(l, a.element);
    }, r = (a) => {
      for (const l of a.element.elements)
        n.has(l) || this.nodes.delete(l);
    };
    this.model.setChildren(e, t, { ...i, onDidCreateNode: o, onDidDeleteNode: r });
  }
  has(e) {
    return this.nodes.has(e);
  }
  getListIndex(e) {
    const t = this.getCompressedNode(e);
    return this.model.getListIndex(t);
  }
  getListRenderCount(e) {
    const t = this.getCompressedNode(e);
    return this.model.getListRenderCount(t);
  }
  getNode(e) {
    if (typeof e > "u")
      return this.model.getNode();
    const t = this.getCompressedNode(e);
    return this.model.getNode(t);
  }
  // TODO: review this
  getNodeLocation(e) {
    const t = this.model.getNodeLocation(e);
    return t === null ? null : t.elements[t.elements.length - 1];
  }
  // TODO: review this
  getParentNodeLocation(e) {
    const t = this.getCompressedNode(e), i = this.model.getParentNodeLocation(t);
    return i === null ? null : i.elements[i.elements.length - 1];
  }
  getFirstElementChild(e) {
    const t = this.getCompressedNode(e);
    return this.model.getFirstElementChild(t);
  }
  isCollapsible(e) {
    const t = this.getCompressedNode(e);
    return this.model.isCollapsible(t);
  }
  setCollapsible(e, t) {
    const i = this.getCompressedNode(e);
    return this.model.setCollapsible(i, t);
  }
  isCollapsed(e) {
    const t = this.getCompressedNode(e);
    return this.model.isCollapsed(t);
  }
  setCollapsed(e, t, i) {
    const n = this.getCompressedNode(e);
    return this.model.setCollapsed(n, t, i);
  }
  expandTo(e) {
    const t = this.getCompressedNode(e);
    this.model.expandTo(t);
  }
  rerender(e) {
    const t = this.getCompressedNode(e);
    this.model.rerender(t);
  }
  refilter() {
    this.model.refilter();
  }
  getCompressedNode(e) {
    if (e === null)
      return null;
    const t = this.nodes.get(e);
    if (!t)
      throw new ps(this.user, `Tree element not found: ${e}`);
    return t;
  }
}
const dQ = (s) => s[s.length - 1];
class iN {
  get element() {
    return this.node.element === null ? null : this.unwrapper(this.node.element);
  }
  get children() {
    return this.node.children.map((e) => new iN(this.unwrapper, e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
  constructor(e, t) {
    this.unwrapper = e, this.node = t;
  }
}
function uQ(s, e) {
  return {
    splice(t, i, n) {
      e.splice(t, i, n.map((o) => s.map(o)));
    },
    updateElementHeight(t, i) {
      e.updateElementHeight(t, i);
    }
  };
}
function fQ(s, e) {
  return {
    ...e,
    identityProvider: e.identityProvider && {
      getId(t) {
        return e.identityProvider.getId(s(t));
      }
    },
    sorter: e.sorter && {
      compare(t, i) {
        return e.sorter.compare(t.elements[0], i.elements[0]);
      }
    },
    filter: e.filter && {
      filter(t, i) {
        return e.filter.filter(s(t), i);
      }
    }
  };
}
class gQ {
  get onDidSplice() {
    return ee.map(this.model.onDidSplice, ({ insertedNodes: e, deletedNodes: t }) => ({
      insertedNodes: e.map((i) => this.nodeMapper.map(i)),
      deletedNodes: t.map((i) => this.nodeMapper.map(i))
    }));
  }
  get onDidChangeCollapseState() {
    return ee.map(this.model.onDidChangeCollapseState, ({ node: e, deep: t }) => ({
      node: this.nodeMapper.map(e),
      deep: t
    }));
  }
  get onDidChangeRenderNodeCount() {
    return ee.map(this.model.onDidChangeRenderNodeCount, (e) => this.nodeMapper.map(e));
  }
  constructor(e, t, i = {}) {
    this.rootRef = null, this.elementMapper = i.elementMapper || dQ;
    const n = (o) => this.elementMapper(o.elements);
    this.nodeMapper = new QI((o) => new iN(n, o)), this.model = new hQ(e, uQ(this.nodeMapper, t), fQ(n, i));
  }
  setChildren(e, t = nt.empty(), i = {}) {
    this.model.setChildren(e, t, i);
  }
  isCompressionEnabled() {
    return this.model.isCompressionEnabled();
  }
  setCompressionEnabled(e) {
    this.model.setCompressionEnabled(e);
  }
  has(e) {
    return this.model.has(e);
  }
  getListIndex(e) {
    return this.model.getListIndex(e);
  }
  getListRenderCount(e) {
    return this.model.getListRenderCount(e);
  }
  getNode(e) {
    return this.nodeMapper.map(this.model.getNode(e));
  }
  getNodeLocation(e) {
    return e.element;
  }
  getParentNodeLocation(e) {
    return this.model.getParentNodeLocation(e);
  }
  getFirstElementChild(e) {
    const t = this.model.getFirstElementChild(e);
    return t === null || typeof t > "u" ? t : this.elementMapper(t.elements);
  }
  isCollapsible(e) {
    return this.model.isCollapsible(e);
  }
  setCollapsible(e, t) {
    return this.model.setCollapsible(e, t);
  }
  isCollapsed(e) {
    return this.model.isCollapsed(e);
  }
  setCollapsed(e, t, i) {
    return this.model.setCollapsed(e, t, i);
  }
  expandTo(e) {
    return this.model.expandTo(e);
  }
  rerender(e) {
    return this.model.rerender(e);
  }
  refilter() {
    return this.model.refilter();
  }
  getCompressedTreeNode(e = null) {
    return this.model.getNode(e);
  }
}
var mQ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
};
class nN extends VF {
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  constructor(e, t, i, n, o = {}) {
    super(e, t, i, n, o), this.user = e;
  }
  setChildren(e, t = nt.empty(), i) {
    this.model.setChildren(e, t, i);
  }
  rerender(e) {
    if (e === void 0) {
      this.view.rerender();
      return;
    }
    this.model.rerender(e);
  }
  hasElement(e) {
    return this.model.has(e);
  }
  createModel(e, t, i) {
    return new tN(e, t, i);
  }
}
class UF {
  get compressedTreeNodeProvider() {
    return this._compressedTreeNodeProvider();
  }
  constructor(e, t, i) {
    this._compressedTreeNodeProvider = e, this.stickyScrollDelegate = t, this.renderer = i, this.templateId = i.templateId, i.onDidChangeTwistieState && (this.onDidChangeTwistieState = i.onDidChangeTwistieState);
  }
  renderTemplate(e) {
    return { compressedTreeNode: void 0, data: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, n) {
    let o = this.stickyScrollDelegate.getCompressedNode(e);
    o || (o = this.compressedTreeNodeProvider.getCompressedTreeNode(e.element)), o.element.elements.length === 1 ? (i.compressedTreeNode = void 0, this.renderer.renderElement(e, t, i.data, n)) : (i.compressedTreeNode = o, this.renderer.renderCompressedElements(o, t, i.data, n));
  }
  disposeElement(e, t, i, n) {
    var o, r, a, l;
    i.compressedTreeNode ? (r = (o = this.renderer).disposeCompressedElements) == null || r.call(o, i.compressedTreeNode, t, i.data, n) : (l = (a = this.renderer).disposeElement) == null || l.call(a, e, t, i.data, n);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.data);
  }
  renderTwistie(e, t) {
    return this.renderer.renderTwistie ? this.renderer.renderTwistie(e, t) : !1;
  }
}
mQ([
  Yt
], UF.prototype, "compressedTreeNodeProvider", null);
class pQ {
  constructor(e) {
    this.modelProvider = e, this.compressedStickyNodes = /* @__PURE__ */ new Map();
  }
  getCompressedNode(e) {
    return this.compressedStickyNodes.get(e);
  }
  constrainStickyScrollNodes(e, t, i) {
    if (this.compressedStickyNodes.clear(), e.length === 0)
      return [];
    for (let n = 0; n < e.length; n++) {
      const o = e[n], r = o.position + o.height;
      if (n + 1 < e.length && r + e[n + 1].height > i || n >= t - 1 && t < e.length) {
        const l = e.slice(0, n), c = e.slice(n), h = this.compressStickyNodes(c);
        return [...l, h];
      }
    }
    return e;
  }
  compressStickyNodes(e) {
    if (e.length === 0)
      throw new Error("Can't compress empty sticky nodes");
    const t = this.modelProvider();
    if (!t.isCompressionEnabled())
      return e[0];
    const i = [];
    for (let c = 0; c < e.length; c++) {
      const h = e[c], d = t.getCompressedTreeNode(h.node.element);
      if (d.element) {
        if (c !== 0 && d.element.incompressible)
          break;
        i.push(...d.element.elements);
      }
    }
    if (i.length < 2)
      return e[0];
    const n = e[e.length - 1], o = { elements: i, incompressible: !1 }, r = { ...n.node, children: [], element: o }, a = new Proxy(e[0].node, {}), l = {
      node: a,
      startIndex: e[0].startIndex,
      endIndex: n.endIndex,
      position: e[0].position,
      height: e[0].height
    };
    return this.compressedStickyNodes.set(a, r), l;
  }
}
function _Q(s, e) {
  return e && {
    ...e,
    keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
      getKeyboardNavigationLabel(t) {
        let i;
        try {
          i = s().getCompressedTreeNode(t);
        } catch {
          return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t);
        }
        return i.element.elements.length === 1 ? e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t) : e.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(i.element.elements);
      }
    }
  };
}
class $F extends nN {
  constructor(e, t, i, n, o = {}) {
    const r = () => this, a = new pQ(() => this.model), l = n.map((c) => new UF(r, a, c));
    super(e, t, i, l, { ..._Q(r, o), stickyScrollDelegate: a });
  }
  setChildren(e, t = nt.empty(), i) {
    this.model.setChildren(e, t, i);
  }
  createModel(e, t, i) {
    return new gQ(e, t, i);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), typeof e.compressionEnabled < "u" && this.model.setCompressionEnabled(e.compressionEnabled);
  }
  getCompressedTreeNode(e = null) {
    return this.model.getCompressedTreeNode(e);
  }
}
function ry(s) {
  return {
    ...s,
    children: [],
    refreshPromise: void 0,
    stale: !0,
    slow: !1,
    forceExpanded: !1
  };
}
function IL(s, e) {
  return e.parent ? e.parent === s ? !0 : IL(s, e.parent) : !1;
}
function bQ(s, e) {
  return s === e || IL(s, e) || IL(e, s);
}
class sN {
  get element() {
    return this.node.element.element;
  }
  get children() {
    return this.node.children.map((e) => new sN(e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
  constructor(e) {
    this.node = e;
  }
}
class CQ {
  constructor(e, t, i) {
    this.renderer = e, this.nodeMapper = t, this.onDidChangeTwistieState = i, this.renderedNodes = /* @__PURE__ */ new Map(), this.templateId = e.templateId;
  }
  renderTemplate(e) {
    return { templateData: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, n) {
    this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, n);
  }
  renderTwistie(e, t) {
    return e.slow ? (t.classList.add(...Te.asClassNameArray(ie.treeItemLoading)), !0) : (t.classList.remove(...Te.asClassNameArray(ie.treeItemLoading)), !1);
  }
  disposeElement(e, t, i, n) {
    var o, r;
    (r = (o = this.renderer).disposeElement) == null || r.call(o, this.nodeMapper.map(e), t, i.templateData, n);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  dispose() {
    this.renderedNodes.clear();
  }
}
function JM(s) {
  return {
    browserEvent: s.browserEvent,
    elements: s.elements.map((e) => e.element)
  };
}
function eR(s) {
  return {
    browserEvent: s.browserEvent,
    element: s.element && s.element.element,
    target: s.target
  };
}
class vQ extends Mp {
  constructor(e) {
    super(e.elements.map((t) => t.element)), this.data = e;
  }
}
function ay(s) {
  return s instanceof Mp ? new vQ(s) : s;
}
class wQ {
  constructor(e) {
    this.dnd = e;
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e.element);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e.map((i) => i.element), t);
  }
  onDragStart(e, t) {
    var i, n;
    (n = (i = this.dnd).onDragStart) == null || n.call(i, ay(e), t);
  }
  onDragOver(e, t, i, n, o, r = !0) {
    return this.dnd.onDragOver(ay(e), t && t.element, i, n, o);
  }
  drop(e, t, i, n, o) {
    this.dnd.drop(ay(e), t && t.element, i, n, o);
  }
  onDragEnd(e) {
    var t, i;
    (i = (t = this.dnd).onDragEnd) == null || i.call(t, e);
  }
  dispose() {
    this.dnd.dispose();
  }
}
function KF(s) {
  return s && {
    ...s,
    collapseByDefault: !0,
    identityProvider: s.identityProvider && {
      getId(e) {
        return s.identityProvider.getId(e.element);
      }
    },
    dnd: s.dnd && new wQ(s.dnd),
    multipleSelectionController: s.multipleSelectionController && {
      isSelectionSingleChangeEvent(e) {
        return s.multipleSelectionController.isSelectionSingleChangeEvent({ ...e, element: e.element });
      },
      isSelectionRangeChangeEvent(e) {
        return s.multipleSelectionController.isSelectionRangeChangeEvent({ ...e, element: e.element });
      }
    },
    accessibilityProvider: s.accessibilityProvider && {
      ...s.accessibilityProvider,
      getPosInSet: void 0,
      getSetSize: void 0,
      getRole: s.accessibilityProvider.getRole ? (e) => s.accessibilityProvider.getRole(e.element) : () => "treeitem",
      isChecked: s.accessibilityProvider.isChecked ? (e) => {
        var t;
        return !!((t = s.accessibilityProvider) != null && t.isChecked(e.element));
      } : void 0,
      getAriaLabel(e) {
        return s.accessibilityProvider.getAriaLabel(e.element);
      },
      getWidgetAriaLabel() {
        return s.accessibilityProvider.getWidgetAriaLabel();
      },
      getWidgetRole: s.accessibilityProvider.getWidgetRole ? () => s.accessibilityProvider.getWidgetRole() : () => "tree",
      getAriaLevel: s.accessibilityProvider.getAriaLevel && ((e) => s.accessibilityProvider.getAriaLevel(e.element)),
      getActiveDescendantId: s.accessibilityProvider.getActiveDescendantId && ((e) => s.accessibilityProvider.getActiveDescendantId(e.element))
    },
    filter: s.filter && {
      filter(e, t) {
        return s.filter.filter(e.element, t);
      }
    },
    keyboardNavigationLabelProvider: s.keyboardNavigationLabelProvider && {
      ...s.keyboardNavigationLabelProvider,
      getKeyboardNavigationLabel(e) {
        return s.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);
      }
    },
    sorter: void 0,
    expandOnlyOnTwistieClick: typeof s.expandOnlyOnTwistieClick > "u" ? void 0 : typeof s.expandOnlyOnTwistieClick != "function" ? s.expandOnlyOnTwistieClick : (e) => s.expandOnlyOnTwistieClick(e.element),
    defaultFindVisibility: (e) => e.hasChildren && e.stale ? 1 : typeof s.defaultFindVisibility == "number" ? s.defaultFindVisibility : typeof s.defaultFindVisibility > "u" ? 2 : s.defaultFindVisibility(e.element)
  };
}
function NL(s, e) {
  e(s), s.children.forEach((t) => NL(t, e));
}
class jF {
  get onDidScroll() {
    return this.tree.onDidScroll;
  }
  get onDidChangeFocus() {
    return ee.map(this.tree.onDidChangeFocus, JM);
  }
  get onDidChangeSelection() {
    return ee.map(this.tree.onDidChangeSelection, JM);
  }
  get onMouseDblClick() {
    return ee.map(this.tree.onMouseDblClick, eR);
  }
  get onPointer() {
    return ee.map(this.tree.onPointer, eR);
  }
  get onDidFocus() {
    return this.tree.onDidFocus;
  }
  /**
   * To be used internally only!
   * @deprecated
   */
  get onDidChangeModel() {
    return this.tree.onDidChangeModel;
  }
  get onDidChangeCollapseState() {
    return this.tree.onDidChangeCollapseState;
  }
  get onDidChangeFindOpenState() {
    return this.tree.onDidChangeFindOpenState;
  }
  get onDidChangeStickyScrollFocused() {
    return this.tree.onDidChangeStickyScrollFocused;
  }
  get onDidDispose() {
    return this.tree.onDidDispose;
  }
  constructor(e, t, i, n, o, r = {}) {
    this.user = e, this.dataSource = o, this.nodes = /* @__PURE__ */ new Map(), this.subTreeRefreshPromises = /* @__PURE__ */ new Map(), this.refreshPromises = /* @__PURE__ */ new Map(), this._onDidRender = new A(), this._onDidChangeNodeSlowState = new A(), this.nodeMapper = new QI((a) => new sN(a)), this.disposables = new ne(), this.identityProvider = r.identityProvider, this.autoExpandSingleChildren = typeof r.autoExpandSingleChildren > "u" ? !1 : r.autoExpandSingleChildren, this.sorter = r.sorter, this.getDefaultCollapseState = (a) => r.collapseByDefault ? r.collapseByDefault(a) ? us.PreserveOrCollapsed : us.PreserveOrExpanded : void 0, this.tree = this.createTree(e, t, i, n, r), this.onDidChangeFindMode = this.tree.onDidChangeFindMode, this.onDidChangeFindMatchType = this.tree.onDidChangeFindMatchType, this.root = ry({
      element: void 0,
      parent: null,
      hasChildren: !0,
      defaultCollapseState: void 0
    }), this.identityProvider && (this.root = {
      ...this.root,
      id: null
    }), this.nodes.set(null, this.root), this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);
  }
  createTree(e, t, i, n, o) {
    const r = new eN(i), a = n.map((c) => new CQ(c, this.nodeMapper, this._onDidChangeNodeSlowState.event)), l = KF(o) || {};
    return new nN(e, t, r, a, l);
  }
  updateOptions(e = {}) {
    this.tree.updateOptions(e);
  }
  // Widget
  getHTMLElement() {
    return this.tree.getHTMLElement();
  }
  get scrollTop() {
    return this.tree.scrollTop;
  }
  set scrollTop(e) {
    this.tree.scrollTop = e;
  }
  get scrollHeight() {
    return this.tree.scrollHeight;
  }
  get renderHeight() {
    return this.tree.renderHeight;
  }
  domFocus() {
    this.tree.domFocus();
  }
  layout(e, t) {
    this.tree.layout(e, t);
  }
  style(e) {
    this.tree.style(e);
  }
  // Model
  getInput() {
    return this.root.element;
  }
  async setInput(e, t) {
    this.refreshPromises.forEach((n) => n.cancel()), this.refreshPromises.clear(), this.root.element = e;
    const i = t && { viewState: t, focus: [], selection: [] };
    await this._updateChildren(e, !0, !1, i), i && (this.tree.setFocus(i.focus), this.tree.setSelection(i.selection)), t && typeof t.scrollTop == "number" && (this.scrollTop = t.scrollTop);
  }
  async _updateChildren(e = this.root.element, t = !0, i = !1, n, o) {
    if (typeof this.root.element > "u")
      throw new ps(this.user, "Tree input not set");
    this.root.refreshPromise && (await this.root.refreshPromise, await ee.toPromise(this._onDidRender.event));
    const r = this.getDataNode(e);
    if (await this.refreshAndRenderNode(r, t, n, o), i)
      try {
        this.tree.rerender(r);
      } catch {
      }
  }
  // View
  rerender(e) {
    if (e === void 0 || e === this.root.element) {
      this.tree.rerender();
      return;
    }
    const t = this.getDataNode(e);
    this.tree.rerender(t);
  }
  // Tree
  getNode(e = this.root.element) {
    const t = this.getDataNode(e), i = this.tree.getNode(t === this.root ? null : t);
    return this.nodeMapper.map(i);
  }
  collapse(e, t = !1) {
    const i = this.getDataNode(e);
    return this.tree.collapse(i === this.root ? null : i, t);
  }
  async expand(e, t = !1) {
    if (typeof this.root.element > "u")
      throw new ps(this.user, "Tree input not set");
    this.root.refreshPromise && (await this.root.refreshPromise, await ee.toPromise(this._onDidRender.event));
    const i = this.getDataNode(e);
    if (this.tree.hasElement(i) && !this.tree.isCollapsible(i) || (i.refreshPromise && (await this.root.refreshPromise, await ee.toPromise(this._onDidRender.event)), i !== this.root && !i.refreshPromise && !this.tree.isCollapsed(i)))
      return !1;
    const n = this.tree.expand(i === this.root ? null : i, t);
    return i.refreshPromise && (await this.root.refreshPromise, await ee.toPromise(this._onDidRender.event)), n;
  }
  setSelection(e, t) {
    const i = e.map((n) => this.getDataNode(n));
    this.tree.setSelection(i, t);
  }
  getSelection() {
    return this.tree.getSelection().map((t) => t.element);
  }
  setFocus(e, t) {
    const i = e.map((n) => this.getDataNode(n));
    this.tree.setFocus(i, t);
  }
  getFocus() {
    return this.tree.getFocus().map((t) => t.element);
  }
  reveal(e, t) {
    this.tree.reveal(this.getDataNode(e), t);
  }
  // Tree navigation
  getParentElement(e) {
    const t = this.tree.getParentElement(this.getDataNode(e));
    return t && t.element;
  }
  getFirstElementChild(e = this.root.element) {
    const t = this.getDataNode(e), i = this.tree.getFirstElementChild(t === this.root ? null : t);
    return i && i.element;
  }
  // Implementation
  getDataNode(e) {
    const t = this.nodes.get(e === this.root.element ? null : e);
    if (!t)
      throw new ps(this.user, `Data tree node not found: ${e}`);
    return t;
  }
  async refreshAndRenderNode(e, t, i, n) {
    await this.refreshNode(e, t, i), !this.disposables.isDisposed && this.render(e, i, n);
  }
  async refreshNode(e, t, i) {
    let n;
    if (this.subTreeRefreshPromises.forEach((o, r) => {
      !n && bQ(r, e) && (n = o.then(() => this.refreshNode(e, t, i)));
    }), n)
      return n;
    if (e !== this.root && this.tree.getNode(e).collapsed) {
      e.hasChildren = !!this.dataSource.hasChildren(e.element), e.stale = !0, this.setChildren(e, [], t, i);
      return;
    }
    return this.doRefreshSubTree(e, t, i);
  }
  async doRefreshSubTree(e, t, i) {
    let n;
    e.refreshPromise = new Promise((o) => n = o), this.subTreeRefreshPromises.set(e, e.refreshPromise), e.refreshPromise.finally(() => {
      e.refreshPromise = void 0, this.subTreeRefreshPromises.delete(e);
    });
    try {
      const o = await this.doRefreshNode(e, t, i);
      e.stale = !1, await jy.settled(o.map((r) => this.doRefreshSubTree(r, t, i)));
    } finally {
      n();
    }
  }
  async doRefreshNode(e, t, i) {
    e.hasChildren = !!this.dataSource.hasChildren(e.element);
    let n;
    if (!e.hasChildren)
      n = Promise.resolve(nt.empty());
    else {
      const o = this.doGetChildren(e);
      if (u2(o))
        n = Promise.resolve(o);
      else {
        const r = Em(800);
        r.then(() => {
          e.slow = !0, this._onDidChangeNodeSlowState.fire(e);
        }, (a) => null), n = o.finally(() => r.cancel());
      }
    }
    try {
      const o = await n;
      return this.setChildren(e, o, t, i);
    } catch (o) {
      if (e !== this.root && this.tree.hasElement(e) && this.tree.collapse(e), Jh(o))
        return [];
      throw o;
    } finally {
      e.slow && (e.slow = !1, this._onDidChangeNodeSlowState.fire(e));
    }
  }
  doGetChildren(e) {
    let t = this.refreshPromises.get(e);
    if (t)
      return t;
    const i = this.dataSource.getChildren(e.element);
    return u2(i) ? this.processChildren(i) : (t = Za(async () => this.processChildren(await i)), this.refreshPromises.set(e, t), t.finally(() => {
      this.refreshPromises.delete(e);
    }));
  }
  _onDidChangeCollapseState({ node: e, deep: t }) {
    e.element !== null && !e.collapsed && e.element.stale && (t ? this.collapse(e.element.element) : this.refreshAndRenderNode(e.element, !1).catch(Je));
  }
  setChildren(e, t, i, n) {
    const o = [...t];
    if (e.children.length === 0 && o.length === 0)
      return [];
    const r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
    for (const h of e.children)
      r.set(h.element, h), this.identityProvider && a.set(h.id, { node: h, collapsed: this.tree.hasElement(h) && this.tree.isCollapsed(h) });
    const l = [], c = o.map((h) => {
      const d = !!this.dataSource.hasChildren(h);
      if (!this.identityProvider) {
        const p = ry({ element: h, parent: e, hasChildren: d, defaultCollapseState: this.getDefaultCollapseState(h) });
        return d && p.defaultCollapseState === us.PreserveOrExpanded && l.push(p), p;
      }
      const u = this.identityProvider.getId(h).toString(), f = a.get(u);
      if (f) {
        const p = f.node;
        return r.delete(p.element), this.nodes.delete(p.element), this.nodes.set(h, p), p.element = h, p.hasChildren = d, i ? f.collapsed ? (p.children.forEach((_) => NL(_, (b) => this.nodes.delete(b.element))), p.children.splice(0, p.children.length), p.stale = !0) : l.push(p) : d && !f.collapsed && l.push(p), p;
      }
      const g = ry({ element: h, parent: e, id: u, hasChildren: d, defaultCollapseState: this.getDefaultCollapseState(h) });
      return n && n.viewState.focus && n.viewState.focus.indexOf(u) > -1 && n.focus.push(g), n && n.viewState.selection && n.viewState.selection.indexOf(u) > -1 && n.selection.push(g), (n && n.viewState.expanded && n.viewState.expanded.indexOf(u) > -1 || d && g.defaultCollapseState === us.PreserveOrExpanded) && l.push(g), g;
    });
    for (const h of r.values())
      NL(h, (d) => this.nodes.delete(d.element));
    for (const h of c)
      this.nodes.set(h.element, h);
    return e.children.splice(0, e.children.length, ...c), e !== this.root && this.autoExpandSingleChildren && c.length === 1 && l.length === 0 && (c[0].forceExpanded = !0, l.push(c[0])), l;
  }
  render(e, t, i) {
    const n = e.children.map((r) => this.asTreeElement(r, t)), o = i && {
      ...i,
      diffIdentityProvider: i.diffIdentityProvider && {
        getId(r) {
          return i.diffIdentityProvider.getId(r.element);
        }
      }
    };
    this.tree.setChildren(e === this.root ? null : e, n, o), e !== this.root && this.tree.setCollapsible(e, e.hasChildren), this._onDidRender.fire();
  }
  asTreeElement(e, t) {
    if (e.stale)
      return {
        element: e,
        collapsible: e.hasChildren,
        collapsed: !0
      };
    let i;
    return t && t.viewState.expanded && e.id && t.viewState.expanded.indexOf(e.id) > -1 ? i = !1 : e.forceExpanded ? (i = !1, e.forceExpanded = !1) : i = e.defaultCollapseState, {
      element: e,
      children: e.hasChildren ? nt.map(e.children, (n) => this.asTreeElement(n, t)) : [],
      collapsible: e.hasChildren,
      collapsed: i
    };
  }
  processChildren(e) {
    return this.sorter && (e = [...e].sort(this.sorter.compare.bind(this.sorter))), e;
  }
  dispose() {
    this.disposables.dispose(), this.tree.dispose();
  }
}
class oN {
  get element() {
    return {
      elements: this.node.element.elements.map((e) => e.element),
      incompressible: this.node.element.incompressible
    };
  }
  get children() {
    return this.node.children.map((e) => new oN(e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
  constructor(e) {
    this.node = e;
  }
}
class yQ {
  constructor(e, t, i, n) {
    this.renderer = e, this.nodeMapper = t, this.compressibleNodeMapperProvider = i, this.onDidChangeTwistieState = n, this.renderedNodes = /* @__PURE__ */ new Map(), this.disposables = [], this.templateId = e.templateId;
  }
  renderTemplate(e) {
    return { templateData: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, n) {
    this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, n);
  }
  renderCompressedElements(e, t, i, n) {
    this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(e), t, i.templateData, n);
  }
  renderTwistie(e, t) {
    return e.slow ? (t.classList.add(...Te.asClassNameArray(ie.treeItemLoading)), !0) : (t.classList.remove(...Te.asClassNameArray(ie.treeItemLoading)), !1);
  }
  disposeElement(e, t, i, n) {
    var o, r;
    (r = (o = this.renderer).disposeElement) == null || r.call(o, this.nodeMapper.map(e), t, i.templateData, n);
  }
  disposeCompressedElements(e, t, i, n) {
    var o, r;
    (r = (o = this.renderer).disposeCompressedElements) == null || r.call(o, this.compressibleNodeMapperProvider().map(e), t, i.templateData, n);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  dispose() {
    this.renderedNodes.clear(), this.disposables = Ft(this.disposables);
  }
}
function SQ(s) {
  const e = s && KF(s);
  return e && {
    ...e,
    keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
      ...e.keyboardNavigationLabelProvider,
      getCompressedNodeKeyboardNavigationLabel(t) {
        return s.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(t.map((i) => i.element));
      }
    }
  };
}
class LQ extends jF {
  constructor(e, t, i, n, o, r, a = {}) {
    super(e, t, i, o, r, a), this.compressionDelegate = n, this.compressibleNodeMapper = new QI((l) => new oN(l)), this.filter = a.filter;
  }
  createTree(e, t, i, n, o) {
    const r = new eN(i), a = n.map((c) => new yQ(c, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event)), l = SQ(o) || {};
    return new $F(e, t, r, a, l);
  }
  asTreeElement(e, t) {
    return {
      incompressible: this.compressionDelegate.isIncompressible(e.element),
      ...super.asTreeElement(e, t)
    };
  }
  updateOptions(e = {}) {
    this.tree.updateOptions(e);
  }
  render(e, t, i) {
    if (!this.identityProvider)
      return super.render(e, t);
    const n = (f) => this.identityProvider.getId(f).toString(), o = (f) => {
      const g = /* @__PURE__ */ new Set();
      for (const p of f) {
        const _ = this.tree.getCompressedTreeNode(p === this.root ? null : p);
        if (_.element)
          for (const b of _.element.elements)
            g.add(n(b.element));
      }
      return g;
    }, r = o(this.tree.getSelection()), a = o(this.tree.getFocus());
    super.render(e, t, i);
    const l = this.getSelection();
    let c = !1;
    const h = this.getFocus();
    let d = !1;
    const u = (f) => {
      const g = f.element;
      if (g)
        for (let p = 0; p < g.elements.length; p++) {
          const _ = n(g.elements[p].element), b = g.elements[g.elements.length - 1].element;
          r.has(_) && l.indexOf(b) === -1 && (l.push(b), c = !0), a.has(_) && h.indexOf(b) === -1 && (h.push(b), d = !0);
        }
      f.children.forEach(u);
    };
    u(this.tree.getCompressedTreeNode(e === this.root ? null : e)), c && this.setSelection(l), d && this.setFocus(h);
  }
  // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work
  // and we have to filter everything beforehand
  // Related to #85193 and #85835
  processChildren(e) {
    return this.filter && (e = nt.filter(e, (t) => {
      const i = this.filter.filter(
        t,
        1
        /* TreeVisibility.Visible */
      ), n = kQ(i);
      if (n === 2)
        throw new Error("Recursive tree visibility not supported in async data compressed trees");
      return n === 1;
    })), super.processChildren(e);
  }
}
function kQ(s) {
  return typeof s == "boolean" ? s ? 1 : 0 : JI(s) ? op(s.visibility) : op(s);
}
class xQ extends VF {
  constructor(e, t, i, n, o, r = {}) {
    super(e, t, i, n, r), this.user = e, this.dataSource = o, this.identityProvider = r.identityProvider;
  }
  createModel(e, t, i) {
    return new tN(e, t, i);
  }
}
new ce("isMac", $e, m("isMac", "Whether the operating system is macOS"));
new ce("isLinux", Rn, m("isLinux", "Whether the operating system is Linux"));
new ce("isWindows", es, m("isWindows", "Whether the operating system is Windows"));
const qF = new ce("isWeb", Ef, m("isWeb", "Whether the platform is a web browser"));
new ce("isMacNative", $e && !Ef, m("isMacNative", "Whether the operating system is macOS on a non-browser platform"));
new ce("isIOS", Kl, m("isIOS", "Whether the operating system is iOS"));
new ce("isMobile", KP, m("isMobile", "Whether the platform is a mobile web browser"));
new ce("isDevelopment", !1, !0);
new ce("productQualityType", "", m("productQualityType", "Quality type of VS Code"));
const GF = "inputFocus", ZF = new ce(GF, !1, m("inputFocus", "Whether keyboard focus is inside an input box"));
var el = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, yt = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const js = Be("listService");
class DQ {
  get lastFocusedList() {
    return this._lastFocusedWidget;
  }
  constructor() {
    this.disposables = new ne(), this.lists = [], this._lastFocusedWidget = void 0, this._hasCreatedStyleController = !1;
  }
  setLastFocusedList(e) {
    var t, i;
    e !== this._lastFocusedWidget && ((t = this._lastFocusedWidget) == null || t.getHTMLElement().classList.remove("last-focused"), this._lastFocusedWidget = e, (i = this._lastFocusedWidget) == null || i.getHTMLElement().classList.add("last-focused"));
  }
  register(e, t) {
    if (this._hasCreatedStyleController || (this._hasCreatedStyleController = !0, new FO(Us(), "").style(gd)), this.lists.some((n) => n.widget === e))
      throw new Error("Cannot register the same widget multiple times");
    const i = { widget: e, extraContextKeys: t };
    return this.lists.push(i), xE(e.getHTMLElement()) && this.setLastFocusedList(e), ao(e.onDidFocus(() => this.setLastFocusedList(e)), _e(() => this.lists.splice(this.lists.indexOf(i), 1)), e.onDidDispose(() => {
      this.lists = this.lists.filter((n) => n !== i), this._lastFocusedWidget === e && this.setLastFocusedList(void 0);
    }));
  }
  dispose() {
    this.disposables.dispose();
  }
}
const rp = new ce("listScrollAtBoundary", "none");
ve.or(rp.isEqualTo("top"), rp.isEqualTo("both"));
ve.or(rp.isEqualTo("bottom"), rp.isEqualTo("both"));
const YF = new ce("listFocus", !0), XF = new ce("treestickyScrollFocused", !1), Rw = new ce("listSupportsMultiselect", !0), QF = ve.and(YF, ve.not(GF), XF.negate()), rN = new ce("listHasSelectionOrFocus", !1), aN = new ce("listDoubleSelection", !1), lN = new ce("listMultiSelection", !1), Aw = new ce("listSelectionNavigation", !1), EQ = new ce("listSupportsFind", !0), cN = new ce("treeElementCanCollapse", !1), IQ = new ce("treeElementHasParent", !1), hN = new ce("treeElementCanExpand", !1), NQ = new ce("treeElementHasChild", !1), TQ = new ce("treeFindOpen", !1), JF = "listTypeNavigationMode", e7 = "listAutomaticKeyboardNavigation";
function Pw(s, e) {
  const t = s.createScoped(e.getHTMLElement());
  return YF.bindTo(t), t;
}
function Ow(s, e) {
  const t = rp.bindTo(s), i = () => {
    const n = e.scrollTop === 0, o = e.scrollHeight - e.renderHeight - e.scrollTop < 1;
    n && o ? t.set("both") : n ? t.set("top") : o ? t.set("bottom") : t.set("none");
  };
  return i(), e.onDidScroll(i);
}
const md = "workbench.list.multiSelectModifier", _b = "workbench.list.openMode", Ws = "workbench.list.horizontalScrolling", dN = "workbench.list.defaultFindMode", uN = "workbench.list.typeNavigationMode", U1 = "workbench.list.keyboardNavigation", Yo = "workbench.list.scrollByPage", fN = "workbench.list.defaultFindMatchType", ap = "workbench.tree.indent", $1 = "workbench.tree.renderIndentGuides", Xo = "workbench.list.smoothScrolling", Vr = "workbench.list.mouseWheelScrollSensitivity", zr = "workbench.list.fastScrollSensitivity", K1 = "workbench.tree.expandMode", j1 = "workbench.tree.enableStickyScroll", q1 = "workbench.tree.stickyScrollMaxItemCount";
function Ur(s) {
  return s.getValue(md) === "alt";
}
class MQ extends U {
  constructor(e) {
    super(), this.configurationService = e, this.useAltAsMultipleSelectionModifier = Ur(e), this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      e.affectsConfiguration(md) && (this.useAltAsMultipleSelectionModifier = Ur(this.configurationService));
    }));
  }
  isSelectionSingleChangeEvent(e) {
    return this.useAltAsMultipleSelectionModifier ? e.browserEvent.altKey : AO(e);
  }
  isSelectionRangeChangeEvent(e) {
    return PO(e);
  }
}
function Fw(s, e) {
  const t = s.get(gt), i = s.get(Lt), n = new ne();
  return [{
    ...e,
    keyboardNavigationDelegate: { mightProducePrintableCharacter(r) {
      return i.mightProducePrintableCharacter(r);
    } },
    smoothScrolling: !!t.getValue(Xo),
    mouseWheelScrollSensitivity: t.getValue(Vr),
    fastScrollSensitivity: t.getValue(zr),
    multipleSelectionController: e.multipleSelectionController ?? n.add(new MQ(t)),
    keyboardNavigationEventFilter: PQ(i),
    scrollByPage: !!t.getValue(Yo)
  }, n];
}
let tR = class extends wo {
  constructor(e, t, i, n, o, r, a, l, c) {
    const h = typeof o.horizontalScrolling < "u" ? o.horizontalScrolling : !!l.getValue(Ws), [d, u] = c.invokeFunction(Fw, o);
    super(e, t, i, n, {
      keyboardSupport: !1,
      ...d,
      horizontalScrolling: h
    }), this.disposables.add(u), this.contextKeyService = Pw(r, this), this.disposables.add(Ow(this.contextKeyService, this)), this.listSupportsMultiSelect = Rw.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(o.multipleSelectionSupport !== !1), Aw.bindTo(this.contextKeyService).set(!!o.selectionNavigation), this.listHasSelectionOrFocus = rN.bindTo(this.contextKeyService), this.listDoubleSelection = aN.bindTo(this.contextKeyService), this.listMultiSelection = lN.bindTo(this.contextKeyService), this.horizontalScrolling = o.horizontalScrolling, this._useAltAsMultipleSelectionModifier = Ur(l), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), this.updateStyles(o.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
      const g = this.getSelection(), p = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(g.length > 0 || p.length > 0), this.listMultiSelection.set(g.length > 1), this.listDoubleSelection.set(g.length === 2);
      });
    })), this.disposables.add(this.onDidChangeFocus(() => {
      const g = this.getSelection(), p = this.getFocus();
      this.listHasSelectionOrFocus.set(g.length > 0 || p.length > 0);
    })), this.disposables.add(l.onDidChangeConfiguration((g) => {
      g.affectsConfiguration(md) && (this._useAltAsMultipleSelectionModifier = Ur(l));
      let p = {};
      if (g.affectsConfiguration(Ws) && this.horizontalScrolling === void 0) {
        const _ = !!l.getValue(Ws);
        p = { ...p, horizontalScrolling: _ };
      }
      if (g.affectsConfiguration(Yo)) {
        const _ = !!l.getValue(Yo);
        p = { ...p, scrollByPage: _ };
      }
      if (g.affectsConfiguration(Xo)) {
        const _ = !!l.getValue(Xo);
        p = { ...p, smoothScrolling: _ };
      }
      if (g.affectsConfiguration(Vr)) {
        const _ = l.getValue(Vr);
        p = { ...p, mouseWheelScrollSensitivity: _ };
      }
      if (g.affectsConfiguration(zr)) {
        const _ = l.getValue(zr);
        p = { ...p, fastScrollSensitivity: _ };
      }
      Object.keys(p).length > 0 && this.updateOptions(p);
    })), this.navigator = new t7(this, { configurationService: l, ...o }), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles !== void 0 && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyles(e) {
    this.style(e ? Up(e) : gd);
  }
};
tR = el([
  yt(5, Fe),
  yt(6, js),
  yt(7, gt),
  yt(8, Pe)
], tR);
let iR = class extends IX {
  constructor(e, t, i, n, o, r, a, l, c) {
    const h = typeof o.horizontalScrolling < "u" ? o.horizontalScrolling : !!l.getValue(Ws), [d, u] = c.invokeFunction(Fw, o);
    super(e, t, i, n, {
      keyboardSupport: !1,
      ...d,
      horizontalScrolling: h
    }), this.disposables = new ne(), this.disposables.add(u), this.contextKeyService = Pw(r, this), this.disposables.add(Ow(this.contextKeyService, this.widget)), this.horizontalScrolling = o.horizontalScrolling, this.listSupportsMultiSelect = Rw.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(o.multipleSelectionSupport !== !1), Aw.bindTo(this.contextKeyService).set(!!o.selectionNavigation), this._useAltAsMultipleSelectionModifier = Ur(l), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), this.updateStyles(o.overrideStyles), this.disposables.add(l.onDidChangeConfiguration((g) => {
      g.affectsConfiguration(md) && (this._useAltAsMultipleSelectionModifier = Ur(l));
      let p = {};
      if (g.affectsConfiguration(Ws) && this.horizontalScrolling === void 0) {
        const _ = !!l.getValue(Ws);
        p = { ...p, horizontalScrolling: _ };
      }
      if (g.affectsConfiguration(Yo)) {
        const _ = !!l.getValue(Yo);
        p = { ...p, scrollByPage: _ };
      }
      if (g.affectsConfiguration(Xo)) {
        const _ = !!l.getValue(Xo);
        p = { ...p, smoothScrolling: _ };
      }
      if (g.affectsConfiguration(Vr)) {
        const _ = l.getValue(Vr);
        p = { ...p, mouseWheelScrollSensitivity: _ };
      }
      if (g.affectsConfiguration(zr)) {
        const _ = l.getValue(zr);
        p = { ...p, fastScrollSensitivity: _ };
      }
      Object.keys(p).length > 0 && this.updateOptions(p);
    })), this.navigator = new t7(this, { configurationService: l, ...o }), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles !== void 0 && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyles(e) {
    this.style(e ? Up(e) : gd);
  }
  dispose() {
    this.disposables.dispose(), super.dispose();
  }
};
iR = el([
  yt(5, Fe),
  yt(6, js),
  yt(7, gt),
  yt(8, Pe)
], iR);
let nR = class extends xL {
  constructor(e, t, i, n, o, r, a, l, c, h) {
    const d = typeof r.horizontalScrolling < "u" ? r.horizontalScrolling : !!c.getValue(Ws), [u, f] = h.invokeFunction(Fw, r);
    super(e, t, i, n, o, {
      keyboardSupport: !1,
      ...u,
      horizontalScrolling: d
    }), this.disposables.add(f), this.contextKeyService = Pw(a, this), this.disposables.add(Ow(this.contextKeyService, this)), this.listSupportsMultiSelect = Rw.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(r.multipleSelectionSupport !== !1), Aw.bindTo(this.contextKeyService).set(!!r.selectionNavigation), this.listHasSelectionOrFocus = rN.bindTo(this.contextKeyService), this.listDoubleSelection = aN.bindTo(this.contextKeyService), this.listMultiSelection = lN.bindTo(this.contextKeyService), this.horizontalScrolling = r.horizontalScrolling, this._useAltAsMultipleSelectionModifier = Ur(c), this.disposables.add(this.contextKeyService), this.disposables.add(l.register(this)), this.updateStyles(r.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
      const p = this.getSelection(), _ = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(p.length > 0 || _.length > 0), this.listMultiSelection.set(p.length > 1), this.listDoubleSelection.set(p.length === 2);
      });
    })), this.disposables.add(this.onDidChangeFocus(() => {
      const p = this.getSelection(), _ = this.getFocus();
      this.listHasSelectionOrFocus.set(p.length > 0 || _.length > 0);
    })), this.disposables.add(c.onDidChangeConfiguration((p) => {
      p.affectsConfiguration(md) && (this._useAltAsMultipleSelectionModifier = Ur(c));
      let _ = {};
      if (p.affectsConfiguration(Ws) && this.horizontalScrolling === void 0) {
        const b = !!c.getValue(Ws);
        _ = { ..._, horizontalScrolling: b };
      }
      if (p.affectsConfiguration(Yo)) {
        const b = !!c.getValue(Yo);
        _ = { ..._, scrollByPage: b };
      }
      if (p.affectsConfiguration(Xo)) {
        const b = !!c.getValue(Xo);
        _ = { ..._, smoothScrolling: b };
      }
      if (p.affectsConfiguration(Vr)) {
        const b = c.getValue(Vr);
        _ = { ..._, mouseWheelScrollSensitivity: b };
      }
      if (p.affectsConfiguration(zr)) {
        const b = c.getValue(zr);
        _ = { ..._, fastScrollSensitivity: b };
      }
      Object.keys(_).length > 0 && this.updateOptions(_);
    })), this.navigator = new RQ(this, { configurationService: c, ...r }), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles !== void 0 && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyles(e) {
    this.style(e ? Up(e) : gd);
  }
  dispose() {
    this.disposables.dispose(), super.dispose();
  }
};
nR = el([
  yt(6, Fe),
  yt(7, js),
  yt(8, gt),
  yt(9, Pe)
], nR);
class gN extends U {
  constructor(e, t) {
    super(), this.widget = e, this._onDidOpen = this._register(new A()), this.onDidOpen = this._onDidOpen.event, this._register(ee.filter(this.widget.onDidChangeSelection, (i) => ma(i.browserEvent))((i) => this.onSelectionFromKeyboard(i))), this._register(this.widget.onPointer((i) => this.onPointer(i.element, i.browserEvent))), this._register(this.widget.onMouseDblClick((i) => this.onMouseDblClick(i.element, i.browserEvent))), typeof (t == null ? void 0 : t.openOnSingleClick) != "boolean" && (t != null && t.configurationService) ? (this.openOnSingleClick = (t == null ? void 0 : t.configurationService.getValue(_b)) !== "doubleClick", this._register(t == null ? void 0 : t.configurationService.onDidChangeConfiguration((i) => {
      i.affectsConfiguration(_b) && (this.openOnSingleClick = (t == null ? void 0 : t.configurationService.getValue(_b)) !== "doubleClick");
    }))) : this.openOnSingleClick = (t == null ? void 0 : t.openOnSingleClick) ?? !0;
  }
  onSelectionFromKeyboard(e) {
    if (e.elements.length !== 1)
      return;
    const t = e.browserEvent, i = typeof t.preserveFocus == "boolean" ? t.preserveFocus : !0, n = typeof t.pinned == "boolean" ? t.pinned : !i;
    this._open(this.getSelectedElement(), i, n, !1, e.browserEvent);
  }
  onPointer(e, t) {
    if (!this.openOnSingleClick || t.detail === 2)
      return;
    const n = t.button === 1, o = !0, r = n, a = t.ctrlKey || t.metaKey || t.altKey;
    this._open(e, o, r, a, t);
  }
  onMouseDblClick(e, t) {
    if (!t)
      return;
    const i = t.target;
    if (i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && t.offsetX < 16)
      return;
    const o = !1, r = !0, a = t.ctrlKey || t.metaKey || t.altKey;
    this._open(e, o, r, a, t);
  }
  _open(e, t, i, n, o) {
    e && this._onDidOpen.fire({
      editorOptions: {
        preserveFocus: t,
        pinned: i,
        revealIfVisible: !0
      },
      sideBySide: n,
      element: e,
      browserEvent: o
    });
  }
}
class t7 extends gN {
  constructor(e, t) {
    super(e, t), this.widget = e;
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
}
class RQ extends gN {
  constructor(e, t) {
    super(e, t);
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
}
class AQ extends gN {
  constructor(e, t) {
    super(e, t);
  }
  getSelectedElement() {
    return this.widget.getSelection()[0] ?? void 0;
  }
}
function PQ(s) {
  let e = !1;
  return (t) => {
    if (t.toKeyCodeChord().isModifierKey())
      return !1;
    if (e)
      return e = !1, !1;
    const i = s.softDispatch(t, t.target);
    return i.kind === 1 ? (e = !0, !1) : (e = !1, i.kind === 0);
  };
}
let TL = class extends nN {
  constructor(e, t, i, n, o, r, a, l, c) {
    const { options: h, getTypeNavigationMode: d, disposable: u } = r.invokeFunction($p, o);
    super(e, t, i, n, h), this.disposables.add(u), this.internals = new Zh(this, o, d, o.overrideStyles, a, l, c), this.disposables.add(this.internals);
  }
  updateOptions(e) {
    super.updateOptions(e), this.internals.updateOptions(e);
  }
};
TL = el([
  yt(5, Pe),
  yt(6, Fe),
  yt(7, js),
  yt(8, gt)
], TL);
let sR = class extends $F {
  constructor(e, t, i, n, o, r, a, l, c) {
    const { options: h, getTypeNavigationMode: d, disposable: u } = r.invokeFunction($p, o);
    super(e, t, i, n, h), this.disposables.add(u), this.internals = new Zh(this, o, d, o.overrideStyles, a, l, c), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
  }
};
sR = el([
  yt(5, Pe),
  yt(6, Fe),
  yt(7, js),
  yt(8, gt)
], sR);
let oR = class extends xQ {
  constructor(e, t, i, n, o, r, a, l, c, h) {
    const { options: d, getTypeNavigationMode: u, disposable: f } = a.invokeFunction($p, r);
    super(e, t, i, n, o, d), this.disposables.add(f), this.internals = new Zh(this, r, u, r.overrideStyles, l, c, h), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles !== void 0 && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
  }
};
oR = el([
  yt(6, Pe),
  yt(7, Fe),
  yt(8, js),
  yt(9, gt)
], oR);
let ML = class extends jF {
  get onDidOpen() {
    return this.internals.onDidOpen;
  }
  constructor(e, t, i, n, o, r, a, l, c, h) {
    const { options: d, getTypeNavigationMode: u, disposable: f } = a.invokeFunction($p, r);
    super(e, t, i, n, o, d), this.disposables.add(f), this.internals = new Zh(this, r, u, r.overrideStyles, l, c, h), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
  }
};
ML = el([
  yt(6, Pe),
  yt(7, Fe),
  yt(8, js),
  yt(9, gt)
], ML);
let rR = class extends LQ {
  constructor(e, t, i, n, o, r, a, l, c, h, d) {
    const { options: u, getTypeNavigationMode: f, disposable: g } = l.invokeFunction($p, a);
    super(e, t, i, n, o, r, u), this.disposables.add(g), this.internals = new Zh(this, a, f, a.overrideStyles, c, h, d), this.disposables.add(this.internals);
  }
  updateOptions(e) {
    super.updateOptions(e), this.internals.updateOptions(e);
  }
};
rR = el([
  yt(7, Pe),
  yt(8, Fe),
  yt(9, js),
  yt(10, gt)
], rR);
function i7(s) {
  const e = s.getValue(dN);
  if (e === "highlight")
    return Na.Highlight;
  if (e === "filter")
    return Na.Filter;
  const t = s.getValue(U1);
  if (t === "simple" || t === "highlight")
    return Na.Highlight;
  if (t === "filter")
    return Na.Filter;
}
function n7(s) {
  const e = s.getValue(fN);
  if (e === "fuzzy")
    return Gh.Fuzzy;
  if (e === "contiguous")
    return Gh.Contiguous;
}
function $p(s, e) {
  const t = s.get(gt), i = s.get(fd), n = s.get(Fe), o = s.get(Pe), r = () => {
    const u = n.getContextKeyValue(JF);
    if (u === "automatic")
      return Dr.Automatic;
    if (u === "trigger" || n.getContextKeyValue(e7) === !1)
      return Dr.Trigger;
    const g = t.getValue(uN);
    if (g === "automatic")
      return Dr.Automatic;
    if (g === "trigger")
      return Dr.Trigger;
  }, a = e.horizontalScrolling !== void 0 ? e.horizontalScrolling : !!t.getValue(Ws), [l, c] = o.invokeFunction(Fw, e), h = e.paddingBottom, d = e.renderIndentGuides !== void 0 ? e.renderIndentGuides : t.getValue($1);
  return {
    getTypeNavigationMode: r,
    disposable: c,
    options: {
      // ...options, // TODO@Joao why is this not splatted here?
      keyboardSupport: !1,
      ...l,
      indent: typeof t.getValue(ap) == "number" ? t.getValue(ap) : void 0,
      renderIndentGuides: d,
      smoothScrolling: !!t.getValue(Xo),
      defaultFindMode: i7(t),
      defaultFindMatchType: n7(t),
      horizontalScrolling: a,
      scrollByPage: !!t.getValue(Yo),
      paddingBottom: h,
      hideTwistiesOfChildlessElements: e.hideTwistiesOfChildlessElements,
      expandOnlyOnTwistieClick: e.expandOnlyOnTwistieClick ?? t.getValue(K1) === "doubleClick",
      contextViewProvider: i,
      findWidgetStyles: _X,
      enableStickyScroll: !!t.getValue(j1),
      stickyScrollMaxItemCount: Number(t.getValue(q1))
    }
  };
}
let Zh = class {
  get onDidOpen() {
    return this.navigator.onDidOpen;
  }
  constructor(e, t, i, n, o, r, a) {
    this.tree = e, this.disposables = [], this.contextKeyService = Pw(o, e), this.disposables.push(Ow(this.contextKeyService, e)), this.listSupportsMultiSelect = Rw.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(t.multipleSelectionSupport !== !1), Aw.bindTo(this.contextKeyService).set(!!t.selectionNavigation), this.listSupportFindWidget = EQ.bindTo(this.contextKeyService), this.listSupportFindWidget.set(t.findWidgetEnabled ?? !0), this.hasSelectionOrFocus = rN.bindTo(this.contextKeyService), this.hasDoubleSelection = aN.bindTo(this.contextKeyService), this.hasMultiSelection = lN.bindTo(this.contextKeyService), this.treeElementCanCollapse = cN.bindTo(this.contextKeyService), this.treeElementHasParent = IQ.bindTo(this.contextKeyService), this.treeElementCanExpand = hN.bindTo(this.contextKeyService), this.treeElementHasChild = NQ.bindTo(this.contextKeyService), this.treeFindOpen = TQ.bindTo(this.contextKeyService), this.treeStickyScrollFocused = XF.bindTo(this.contextKeyService), this._useAltAsMultipleSelectionModifier = Ur(a), this.updateStyleOverrides(n);
    const c = () => {
      const d = e.getFocus()[0];
      if (!d)
        return;
      const u = e.getNode(d);
      this.treeElementCanCollapse.set(u.collapsible && !u.collapsed), this.treeElementHasParent.set(!!e.getParentElement(d)), this.treeElementCanExpand.set(u.collapsible && u.collapsed), this.treeElementHasChild.set(!!e.getFirstElementChild(d));
    }, h = /* @__PURE__ */ new Set();
    h.add(JF), h.add(e7), this.disposables.push(this.contextKeyService, r.register(e), e.onDidChangeSelection(() => {
      const d = e.getSelection(), u = e.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.hasSelectionOrFocus.set(d.length > 0 || u.length > 0), this.hasMultiSelection.set(d.length > 1), this.hasDoubleSelection.set(d.length === 2);
      });
    }), e.onDidChangeFocus(() => {
      const d = e.getSelection(), u = e.getFocus();
      this.hasSelectionOrFocus.set(d.length > 0 || u.length > 0), c();
    }), e.onDidChangeCollapseState(c), e.onDidChangeModel(c), e.onDidChangeFindOpenState((d) => this.treeFindOpen.set(d)), e.onDidChangeStickyScrollFocused((d) => this.treeStickyScrollFocused.set(d)), a.onDidChangeConfiguration((d) => {
      let u = {};
      if (d.affectsConfiguration(md) && (this._useAltAsMultipleSelectionModifier = Ur(a)), d.affectsConfiguration(ap)) {
        const f = a.getValue(ap);
        u = { ...u, indent: f };
      }
      if (d.affectsConfiguration($1) && t.renderIndentGuides === void 0) {
        const f = a.getValue($1);
        u = { ...u, renderIndentGuides: f };
      }
      if (d.affectsConfiguration(Xo)) {
        const f = !!a.getValue(Xo);
        u = { ...u, smoothScrolling: f };
      }
      if (d.affectsConfiguration(dN) || d.affectsConfiguration(U1)) {
        const f = i7(a);
        u = { ...u, defaultFindMode: f };
      }
      if (d.affectsConfiguration(uN) || d.affectsConfiguration(U1)) {
        const f = i();
        u = { ...u, typeNavigationMode: f };
      }
      if (d.affectsConfiguration(fN)) {
        const f = n7(a);
        u = { ...u, defaultFindMatchType: f };
      }
      if (d.affectsConfiguration(Ws) && t.horizontalScrolling === void 0) {
        const f = !!a.getValue(Ws);
        u = { ...u, horizontalScrolling: f };
      }
      if (d.affectsConfiguration(Yo)) {
        const f = !!a.getValue(Yo);
        u = { ...u, scrollByPage: f };
      }
      if (d.affectsConfiguration(K1) && t.expandOnlyOnTwistieClick === void 0 && (u = { ...u, expandOnlyOnTwistieClick: a.getValue(K1) === "doubleClick" }), d.affectsConfiguration(j1)) {
        const f = a.getValue(j1);
        u = { ...u, enableStickyScroll: f };
      }
      if (d.affectsConfiguration(q1)) {
        const f = Math.max(1, a.getValue(q1));
        u = { ...u, stickyScrollMaxItemCount: f };
      }
      if (d.affectsConfiguration(Vr)) {
        const f = a.getValue(Vr);
        u = { ...u, mouseWheelScrollSensitivity: f };
      }
      if (d.affectsConfiguration(zr)) {
        const f = a.getValue(zr);
        u = { ...u, fastScrollSensitivity: f };
      }
      Object.keys(u).length > 0 && e.updateOptions(u);
    }), this.contextKeyService.onDidChangeContext((d) => {
      d.affectsSome(h) && e.updateOptions({ typeNavigationMode: i() });
    })), this.navigator = new AQ(e, { configurationService: a, ...t }), this.disposables.push(this.navigator);
  }
  updateOptions(e) {
    e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyleOverrides(e) {
    this.tree.style(e ? Up(e) : gd);
  }
  dispose() {
    this.disposables = Ft(this.disposables);
  }
};
Zh = el([
  yt(4, Fe),
  yt(5, js),
  yt(6, gt)
], Zh);
const OQ = Mi.as(hd.Configuration);
OQ.registerConfiguration({
  id: "workbench",
  order: 7,
  title: m("workbenchConfigurationTitle", "Workbench"),
  type: "object",
  properties: {
    [md]: {
      type: "string",
      enum: ["ctrlCmd", "alt"],
      markdownEnumDescriptions: [
        m("multiSelectModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
        m("multiSelectModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
      ],
      default: "ctrlCmd",
      description: m({
        key: "multiSelectModifier",
        comment: [
          "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
          "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
        ]
      }, "The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier.")
    },
    [_b]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: m({
        key: "openModeModifier",
        comment: ["`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized."]
      }, "Controls how to open items in trees and lists using the mouse (if supported). Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    },
    [Ws]: {
      type: "boolean",
      default: !1,
      description: m("horizontalScrolling setting", "Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication.")
    },
    [Yo]: {
      type: "boolean",
      default: !1,
      description: m("list.scrollByPage", "Controls whether clicks in the scrollbar scroll page by page.")
    },
    [ap]: {
      type: "number",
      default: 8,
      minimum: 4,
      maximum: 40,
      description: m("tree indent setting", "Controls tree indentation in pixels.")
    },
    [$1]: {
      type: "string",
      enum: ["none", "onHover", "always"],
      default: "onHover",
      description: m("render tree indent guides", "Controls whether the tree should render indent guides.")
    },
    [Xo]: {
      type: "boolean",
      default: !1,
      description: m("list smoothScrolling setting", "Controls whether lists and trees have smooth scrolling.")
    },
    [Vr]: {
      type: "number",
      default: 1,
      markdownDescription: m("Mouse Wheel Scroll Sensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.")
    },
    [zr]: {
      type: "number",
      default: 5,
      markdownDescription: m("Fast Scroll Sensitivity", "Scrolling speed multiplier when pressing `Alt`.")
    },
    [dN]: {
      type: "string",
      enum: ["highlight", "filter"],
      enumDescriptions: [
        m("defaultFindModeSettingKey.highlight", "Highlight elements when searching. Further up and down navigation will traverse only the highlighted elements."),
        m("defaultFindModeSettingKey.filter", "Filter elements when searching.")
      ],
      default: "highlight",
      description: m("defaultFindModeSettingKey", "Controls the default find mode for lists and trees in the workbench.")
    },
    [U1]: {
      type: "string",
      enum: ["simple", "highlight", "filter"],
      enumDescriptions: [
        m("keyboardNavigationSettingKey.simple", "Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes."),
        m("keyboardNavigationSettingKey.highlight", "Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements."),
        m("keyboardNavigationSettingKey.filter", "Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input.")
      ],
      default: "highlight",
      description: m("keyboardNavigationSettingKey", "Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter."),
      deprecated: !0,
      deprecationMessage: m("keyboardNavigationSettingKeyDeprecated", "Please use 'workbench.list.defaultFindMode' and	'workbench.list.typeNavigationMode' instead.")
    },
    [fN]: {
      type: "string",
      enum: ["fuzzy", "contiguous"],
      enumDescriptions: [
        m("defaultFindMatchTypeSettingKey.fuzzy", "Use fuzzy matching when searching."),
        m("defaultFindMatchTypeSettingKey.contiguous", "Use contiguous matching when searching.")
      ],
      default: "fuzzy",
      description: m("defaultFindMatchTypeSettingKey", "Controls the type of matching used when searching lists and trees in the workbench.")
    },
    [K1]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: m("expand mode", "Controls how tree folders are expanded when clicking the folder names. Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    },
    [j1]: {
      type: "boolean",
      default: !0,
      description: m("sticky scroll", "Controls whether sticky scrolling is enabled in trees.")
    },
    [q1]: {
      type: "number",
      minimum: 1,
      default: 7,
      markdownDescription: m("sticky scroll maximum items", "Controls the number of sticky elements displayed in the tree when {0} is enabled.", "`#workbench.tree.enableStickyScroll#`")
    },
    [uN]: {
      type: "string",
      enum: ["automatic", "trigger"],
      default: "automatic",
      markdownDescription: m("typeNavigationMode2", "Controls how type navigation works in lists and trees in the workbench. When set to `trigger`, type navigation begins once the `list.triggerTypeNavigation` command is run.")
    }
  }
});
class ec {
  constructor(e, t, i, n) {
    this.isProviderFirst = e, this.parent = t, this.link = i, this._rangeCallback = n, this.id = cS.nextId();
  }
  get uri() {
    return this.link.uri;
  }
  get range() {
    return this._range ?? this.link.targetSelectionRange ?? this.link.range;
  }
  set range(e) {
    this._range = e, this._rangeCallback(this);
  }
  get ariaMessage() {
    var t;
    const e = (t = this.parent.getPreview(this)) == null ? void 0 : t.preview(this.range);
    return e ? m({ key: "aria.oneReference.preview", comment: ["Placeholders are: 0: filename, 1:line number, 2: column number, 3: preview snippet of source code"] }, "{0} in {1} on line {2} at column {3}", e.value, qo(this.uri), this.range.startLineNumber, this.range.startColumn) : m("aria.oneReference", "in {0} on line {1} at column {2}", qo(this.uri), this.range.startLineNumber, this.range.startColumn);
  }
}
class FQ {
  constructor(e) {
    this._modelReference = e;
  }
  dispose() {
    this._modelReference.dispose();
  }
  preview(e, t = 8) {
    const i = this._modelReference.object.textEditorModel;
    if (!i)
      return;
    const { startLineNumber: n, startColumn: o, endLineNumber: r, endColumn: a } = e, l = i.getWordUntilPosition({ lineNumber: n, column: o - t }), c = new T(n, l.startColumn, n, o), h = new T(
      r,
      a,
      r,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ), d = i.getValueInRange(c).replace(/^\s+/, ""), u = i.getValueInRange(e), f = i.getValueInRange(h).replace(/\s+$/, "");
    return {
      value: d + u + f,
      highlight: { start: d.length, end: d.length + u.length }
    };
  }
}
class lp {
  constructor(e, t) {
    this.parent = e, this.uri = t, this.children = [], this._previews = new Yn();
  }
  dispose() {
    Ft(this._previews.values()), this._previews.clear();
  }
  getPreview(e) {
    return this._previews.get(e.uri);
  }
  get ariaMessage() {
    const e = this.children.length;
    return e === 1 ? m("aria.fileReferences.1", "1 symbol in {0}, full path {1}", qo(this.uri), this.uri.fsPath) : m("aria.fileReferences.N", "{0} symbols in {1}, full path {2}", e, qo(this.uri), this.uri.fsPath);
  }
  async resolve(e) {
    if (this._previews.size !== 0)
      return this;
    for (const t of this.children)
      if (!this._previews.has(t.uri))
        try {
          const i = await e.createModelReference(t.uri);
          this._previews.set(t.uri, new FQ(i));
        } catch (i) {
          Je(i);
        }
    return this;
  }
}
class Jn {
  constructor(e, t) {
    this.groups = [], this.references = [], this._onDidChangeReferenceRange = new A(), this.onDidChangeReferenceRange = this._onDidChangeReferenceRange.event, this._links = e, this._title = t;
    const [i] = e;
    e.sort(Jn._compareReferences);
    let n;
    for (const o of e)
      if ((!n || !Et.isEqual(n.uri, o.uri, !0)) && (n = new lp(this, o.uri), this.groups.push(n)), n.children.length === 0 || Jn._compareReferences(o, n.children[n.children.length - 1]) !== 0) {
        const r = new ec(i === o, n, o, (a) => this._onDidChangeReferenceRange.fire(a));
        this.references.push(r), n.children.push(r);
      }
  }
  dispose() {
    Ft(this.groups), this._onDidChangeReferenceRange.dispose(), this.groups.length = 0;
  }
  clone() {
    return new Jn(this._links, this._title);
  }
  get title() {
    return this._title;
  }
  get isEmpty() {
    return this.groups.length === 0;
  }
  get ariaMessage() {
    return this.isEmpty ? m("aria.result.0", "No results found") : this.references.length === 1 ? m("aria.result.1", "Found 1 symbol in {0}", this.references[0].uri.fsPath) : this.groups.length === 1 ? m("aria.result.n1", "Found {0} symbols in {1}", this.references.length, this.groups[0].uri.fsPath) : m("aria.result.nm", "Found {0} symbols in {1} files", this.references.length, this.groups.length);
  }
  nextOrPreviousReference(e, t) {
    const { parent: i } = e;
    let n = i.children.indexOf(e);
    const o = i.children.length, r = i.parent.groups.length;
    return r === 1 || t && n + 1 < o || !t && n > 0 ? (t ? n = (n + 1) % o : n = (n + o - 1) % o, i.children[n]) : (n = i.parent.groups.indexOf(i), t ? (n = (n + 1) % r, i.parent.groups[n].children[0]) : (n = (n + r - 1) % r, i.parent.groups[n].children[i.parent.groups[n].children.length - 1]));
  }
  nearestReference(e, t) {
    const i = this.references.map((n, o) => ({
      idx: o,
      prefixLen: Vb(n.uri.toString(), e.toString()),
      offsetDist: Math.abs(n.range.startLineNumber - t.lineNumber) * 100 + Math.abs(n.range.startColumn - t.column)
    })).sort((n, o) => n.prefixLen > o.prefixLen ? -1 : n.prefixLen < o.prefixLen ? 1 : n.offsetDist < o.offsetDist ? -1 : n.offsetDist > o.offsetDist ? 1 : 0)[0];
    if (i)
      return this.references[i.idx];
  }
  referenceAt(e, t) {
    for (const i of this.references)
      if (i.uri.toString() === e.toString() && T.containsPosition(i.range, t))
        return i;
  }
  firstReference() {
    for (const e of this.references)
      if (e.isProviderFirst)
        return e;
    return this.references[0];
  }
  static _compareReferences(e, t) {
    return Et.compare(e.uri, t.uri) || T.compareRangesUsingStarts(e.range, t.range);
  }
}
class RL {
  constructor(e, t, i) {
    this.options = t, this.styles = i, this.count = 0, this.element = te(e, he(".monaco-count-badge")), this.countFormat = this.options.countFormat || "{0}", this.titleFormat = this.options.titleFormat || "", this.setCount(this.options.count || 0);
  }
  setCount(e) {
    this.count = e, this.render();
  }
  setTitleFormat(e) {
    this.titleFormat = e, this.render();
  }
  render() {
    this.element.textContent = Hb(this.countFormat, this.count), this.element.title = Hb(this.titleFormat, this.count), this.element.style.backgroundColor = this.styles.badgeBackground ?? "", this.element.style.color = this.styles.badgeForeground ?? "", this.styles.badgeBorder && (this.element.style.border = `1px solid ${this.styles.badgeBorder}`);
  }
}
class Al extends U {
  /**
   * Create a new {@link HighlightedLabel}.
   *
   * @param container The parent container to append to.
   */
  constructor(e, t) {
    super(), this.options = t, this.text = "", this.title = "", this.highlights = [], this.didEverRender = !1, this.supportIcons = (t == null ? void 0 : t.supportIcons) ?? !1, this.domNode = te(e, he("span.monaco-highlighted-label"));
  }
  /**
   * The label's DOM node.
   */
  get element() {
    return this.domNode;
  }
  /**
   * Set the label and highlights.
   *
   * @param text The label to display.
   * @param highlights The ranges to highlight.
   * @param title An optional title for the hover tooltip.
   * @param escapeNewLines Whether to escape new lines.
   * @returns
   */
  set(e, t = [], i = "", n) {
    e || (e = ""), n && (e = Al.escapeNewLines(e, t)), !(this.didEverRender && this.text === e && this.title === i && Xn(this.highlights, t)) && (this.text = e, this.title = i, this.highlights = t, this.render());
  }
  render() {
    var i, n, o;
    const e = [];
    let t = 0;
    for (const r of this.highlights) {
      if (r.end === r.start)
        continue;
      if (t < r.start) {
        const c = this.text.substring(t, r.start);
        this.supportIcons ? e.push(...lh(c)) : e.push(c), t = r.start;
      }
      const a = this.text.substring(t, r.end), l = he("span.highlight", void 0, ...this.supportIcons ? lh(a) : [a]);
      r.extraClasses && l.classList.add(...r.extraClasses), e.push(l), t = r.end;
    }
    if (t < this.text.length) {
      const r = this.text.substring(t);
      this.supportIcons ? e.push(...lh(r)) : e.push(r);
    }
    if (_n(this.domNode, ...e), (n = (i = this.options) == null ? void 0 : i.hoverDelegate) != null && n.showNativeHover)
      this.domNode.title = this.title;
    else if (!this.customHover && this.title !== "") {
      const r = ((o = this.options) == null ? void 0 : o.hoverDelegate) ?? $s("mouse");
      this.customHover = this._register(jr().setupManagedHover(r, this.domNode, this.title));
    } else this.customHover && this.customHover.update(this.title);
    this.didEverRender = !0;
  }
  static escapeNewLines(e, t) {
    let i = 0, n = 0;
    return e.replace(/\r\n|\r|\n/g, (o, r) => {
      n = o === `\r
` ? -1 : 0, r += i;
      for (const a of t)
        a.end <= r || (a.start >= r && (a.start += n), a.end >= r && (a.end += n));
      return i += n, "⏎";
    });
  }
}
class rg {
  constructor(e) {
    this._element = e;
  }
  get element() {
    return this._element;
  }
  set textContent(e) {
    this.disposed || e === this._textContent || (this._textContent = e, this._element.textContent = e);
  }
  set classNames(e) {
    this.disposed || Xn(e, this._classNames) || (this._classNames = e, this._element.classList.value = "", this._element.classList.add(...e));
  }
  set empty(e) {
    this.disposed || e === this._empty || (this._empty = e, this._element.style.marginLeft = e ? "0" : "");
  }
  dispose() {
    this.disposed = !0;
  }
}
class AL extends U {
  constructor(e, t) {
    super(), this.customHovers = /* @__PURE__ */ new Map(), this.creationOptions = t, this.domNode = this._register(new rg(te(e, he(".monaco-icon-label")))), this.labelContainer = te(this.domNode.element, he(".monaco-icon-label-container")), this.nameContainer = te(this.labelContainer, he("span.monaco-icon-name-container")), t != null && t.supportHighlights || t != null && t.supportIcons ? this.nameNode = this._register(new HQ(this.nameContainer, !!t.supportIcons)) : this.nameNode = new BQ(this.nameContainer), this.hoverDelegate = (t == null ? void 0 : t.hoverDelegate) ?? $s("mouse");
  }
  get element() {
    return this.domNode.element;
  }
  setLabel(e, t, i) {
    const n = ["monaco-icon-label"], o = ["monaco-icon-label-container"];
    let r = "";
    i && (i.extraClasses && n.push(...i.extraClasses), i.italic && n.push("italic"), i.strikethrough && n.push("strikethrough"), i.disabledCommand && o.push("disabled"), i.title && (typeof i.title == "string" ? r += i.title : r += e));
    const a = this.domNode.element.querySelector(".monaco-icon-label-iconpath");
    if (i != null && i.iconPath) {
      let l;
      !a || !ki(a) ? (l = he(".monaco-icon-label-iconpath"), this.domNode.element.prepend(l)) : l = a, l.style.backgroundImage = Ua(i == null ? void 0 : i.iconPath);
    } else a && a.remove();
    if (this.domNode.classNames = n, this.domNode.element.setAttribute("aria-label", r), this.labelContainer.classList.value = "", this.labelContainer.classList.add(...o), this.setupHover(i != null && i.descriptionTitle ? this.labelContainer : this.element, i == null ? void 0 : i.title), this.nameNode.setLabel(e, i), t || this.descriptionNode) {
      const l = this.getOrCreateDescriptionNode();
      l instanceof Al ? (l.set(t || "", i ? i.descriptionMatches : void 0, void 0, i == null ? void 0 : i.labelEscapeNewLines), this.setupHover(l.element, i == null ? void 0 : i.descriptionTitle)) : (l.textContent = t && (i != null && i.labelEscapeNewLines) ? Al.escapeNewLines(t, []) : t || "", this.setupHover(l.element, (i == null ? void 0 : i.descriptionTitle) || ""), l.empty = !t);
    }
    if (i != null && i.suffix || this.suffixNode) {
      const l = this.getOrCreateSuffixNode();
      l.textContent = (i == null ? void 0 : i.suffix) ?? "";
    }
  }
  setupHover(e, t) {
    const i = this.customHovers.get(e);
    if (i && (i.dispose(), this.customHovers.delete(e)), !t) {
      e.removeAttribute("title");
      return;
    }
    if (this.hoverDelegate.showNativeHover)
      (function(o, r) {
        Ss(r) ? o.title = sO(r) : r != null && r.markdownNotSupportedFallback ? o.title = r.markdownNotSupportedFallback : o.removeAttribute("title");
      })(e, t);
    else {
      const n = jr().setupManagedHover(this.hoverDelegate, e, t);
      n && this.customHovers.set(e, n);
    }
  }
  dispose() {
    super.dispose();
    for (const e of this.customHovers.values())
      e.dispose();
    this.customHovers.clear();
  }
  getOrCreateSuffixNode() {
    if (!this.suffixNode) {
      const e = this._register(new rg(iB(this.nameContainer, he("span.monaco-icon-suffix-container"))));
      this.suffixNode = this._register(new rg(te(e.element, he("span.label-suffix"))));
    }
    return this.suffixNode;
  }
  getOrCreateDescriptionNode() {
    var e;
    if (!this.descriptionNode) {
      const t = this._register(new rg(te(this.labelContainer, he("span.monaco-icon-description-container"))));
      (e = this.creationOptions) != null && e.supportDescriptionHighlights ? this.descriptionNode = this._register(new Al(te(t.element, he("span.label-description")), { supportIcons: !!this.creationOptions.supportIcons })) : this.descriptionNode = this._register(new rg(te(t.element, he("span.label-description"))));
    }
    return this.descriptionNode;
  }
}
class BQ {
  constructor(e) {
    this.container = e, this.label = void 0, this.singleLabel = void 0;
  }
  setLabel(e, t) {
    if (!(this.label === e && Xn(this.options, t)))
      if (this.label = e, this.options = t, typeof e == "string")
        this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = te(this.container, he("a.label-name", { id: t == null ? void 0 : t.domId }))), this.singleLabel.textContent = e;
      else {
        this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
        for (let i = 0; i < e.length; i++) {
          const n = e[i], o = (t == null ? void 0 : t.domId) && `${t == null ? void 0 : t.domId}_${i}`;
          te(this.container, he("a.label-name", { id: o, "data-icon-label-count": e.length, "data-icon-label-index": i, role: "treeitem" }, n)), i < e.length - 1 && te(this.container, he("span.label-separator", void 0, (t == null ? void 0 : t.separator) || "/"));
        }
      }
  }
}
function WQ(s, e, t) {
  if (!t)
    return;
  let i = 0;
  return s.map((n) => {
    const o = { start: i, end: i + n.length }, r = t.map((a) => Ki.intersect(o, a)).filter((a) => !Ki.isEmpty(a)).map(({ start: a, end: l }) => ({ start: a - i, end: l - i }));
    return i = o.end + e.length, r;
  });
}
class HQ extends U {
  constructor(e, t) {
    super(), this.container = e, this.supportIcons = t, this.label = void 0, this.singleLabel = void 0;
  }
  setLabel(e, t) {
    if (!(this.label === e && Xn(this.options, t)))
      if (this.label = e, this.options = t, typeof e == "string")
        this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = this._register(new Al(te(this.container, he("a.label-name", { id: t == null ? void 0 : t.domId })), { supportIcons: this.supportIcons }))), this.singleLabel.set(e, t == null ? void 0 : t.matches, void 0, t == null ? void 0 : t.labelEscapeNewLines);
      else {
        this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
        const i = (t == null ? void 0 : t.separator) || "/", n = WQ(e, i, t == null ? void 0 : t.matches);
        for (let o = 0; o < e.length; o++) {
          const r = e[o], a = n ? n[o] : void 0, l = (t == null ? void 0 : t.domId) && `${t == null ? void 0 : t.domId}_${o}`, c = he("a.label-name", { id: l, "data-icon-label-count": e.length, "data-icon-label-index": o, role: "treeitem" });
          this._register(new Al(te(this.container, c), { supportIcons: this.supportIcons })).set(r, a, void 0, t == null ? void 0 : t.labelEscapeNewLines), o < e.length - 1 && te(c, he("span.label-separator", void 0, i));
        }
      }
  }
}
const Bw = Be("labelService");
var Ww = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Hw = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, PL;
let OL = class {
  constructor(e) {
    this._resolverService = e;
  }
  hasChildren(e) {
    return e instanceof Jn || e instanceof lp;
  }
  getChildren(e) {
    if (e instanceof Jn)
      return e.groups;
    if (e instanceof lp)
      return e.resolve(this._resolverService).then((t) => t.children);
    throw new Error("bad tree");
  }
};
OL = Ww([
  Hw(0, bo)
], OL);
class VQ {
  getHeight() {
    return 23;
  }
  getTemplateId(e) {
    return e instanceof lp ? G1.id : Z1.id;
  }
}
let FL = class {
  constructor(e) {
    this._keybindingService = e;
  }
  getKeyboardNavigationLabel(e) {
    var t;
    if (e instanceof ec) {
      const i = (t = e.parent.getPreview(e)) == null ? void 0 : t.preview(e.range);
      if (i)
        return i.value;
    }
    return qo(e.uri);
  }
};
FL = Ww([
  Hw(0, Lt)
], FL);
class zQ {
  getId(e) {
    return e instanceof ec ? e.id : e.uri;
  }
}
let BL = class extends U {
  constructor(e, t) {
    super(), this._labelService = t;
    const i = document.createElement("div");
    i.classList.add("reference-file"), this.file = this._register(new AL(i, { supportHighlights: !0 })), this.badge = new RL(te(i, he(".count")), {}, EF), e.appendChild(i);
  }
  set(e, t) {
    const i = BE(e.uri);
    this.file.setLabel(this._labelService.getUriBasenameLabel(e.uri), this._labelService.getUriLabel(i, { relative: !0 }), { title: this._labelService.getUriLabel(e.uri), matches: t });
    const n = e.children.length;
    this.badge.setCount(n), n > 1 ? this.badge.setTitleFormat(m("referencesCount", "{0} references", n)) : this.badge.setTitleFormat(m("referenceCount", "{0} reference", n));
  }
};
BL = Ww([
  Hw(1, Bw)
], BL);
var _h;
let G1 = (_h = class {
  constructor(e) {
    this._instantiationService = e, this.templateId = PL.id;
  }
  renderTemplate(e) {
    return this._instantiationService.createInstance(BL, e);
  }
  renderElement(e, t, i) {
    i.set(e.element, AE(e.filterData));
  }
  disposeTemplate(e) {
    e.dispose();
  }
}, PL = _h, _h.id = "FileReferencesRenderer", _h);
G1 = PL = Ww([
  Hw(0, Pe)
], G1);
class UQ extends U {
  constructor(e) {
    super(), this.label = this._register(new Al(e));
  }
  set(e, t) {
    var n;
    const i = (n = e.parent.getPreview(e)) == null ? void 0 : n.preview(e.range);
    if (!i || !i.value)
      this.label.set(`${qo(e.uri)}:${e.range.startLineNumber + 1}:${e.range.startColumn + 1}`);
    else {
      const { value: o, highlight: r } = i;
      t && !rh.isDefault(t) ? (this.label.element.classList.toggle("referenceMatch", !1), this.label.set(o, AE(t))) : (this.label.element.classList.toggle("referenceMatch", !0), this.label.set(o, [r]));
    }
  }
}
const gv = class gv {
  constructor() {
    this.templateId = gv.id;
  }
  renderTemplate(e) {
    return new UQ(e);
  }
  renderElement(e, t, i) {
    i.set(e.element, e.filterData);
  }
  disposeTemplate(e) {
    e.dispose();
  }
};
gv.id = "OneReferenceRenderer";
let Z1 = gv;
class $Q {
  getWidgetAriaLabel() {
    return m("treeAriaLabel", "References");
  }
  getAriaLabel(e) {
    return e.ariaMessage;
  }
}
var KQ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Od = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const mv = class mv {
  constructor(e, t) {
    this._editor = e, this._model = t, this._decorations = /* @__PURE__ */ new Map(), this._decorationIgnoreSet = /* @__PURE__ */ new Set(), this._callOnDispose = new ne(), this._callOnModelChange = new ne(), this._callOnDispose.add(this._editor.onDidChangeModel(() => this._onModelChanged())), this._onModelChanged();
  }
  dispose() {
    this._callOnModelChange.dispose(), this._callOnDispose.dispose(), this.removeDecorations();
  }
  _onModelChanged() {
    this._callOnModelChange.clear();
    const e = this._editor.getModel();
    if (e) {
      for (const t of this._model.references)
        if (t.uri.toString() === e.uri.toString()) {
          this._addDecorations(t.parent);
          return;
        }
    }
  }
  _addDecorations(e) {
    if (!this._editor.hasModel())
      return;
    this._callOnModelChange.add(this._editor.getModel().onDidChangeDecorations(() => this._onDecorationChanged()));
    const t = [], i = [];
    for (let n = 0, o = e.children.length; n < o; n++) {
      const r = e.children[n];
      this._decorationIgnoreSet.has(r.id) || r.uri.toString() === this._editor.getModel().uri.toString() && (t.push({
        range: r.range,
        options: mv.DecorationOptions
      }), i.push(n));
    }
    this._editor.changeDecorations((n) => {
      const o = n.deltaDecorations([], t);
      for (let r = 0; r < o.length; r++)
        this._decorations.set(o[r], e.children[i[r]]);
    });
  }
  _onDecorationChanged() {
    const e = [], t = this._editor.getModel();
    if (t) {
      for (const [i, n] of this._decorations) {
        const o = t.getDecorationRange(i);
        if (!o)
          continue;
        let r = !1;
        if (!T.equalsRange(o, n.range)) {
          if (T.spansMultipleLines(o))
            r = !0;
          else {
            const a = n.range.endColumn - n.range.startColumn, l = o.endColumn - o.startColumn;
            a !== l && (r = !0);
          }
          r ? (this._decorationIgnoreSet.add(n.id), e.push(i)) : n.range = o;
        }
      }
      for (let i = 0, n = e.length; i < n; i++)
        this._decorations.delete(e[i]);
      this._editor.removeDecorations(e);
    }
  }
  removeDecorations() {
    this._editor.removeDecorations([...this._decorations.keys()]), this._decorations.clear();
  }
};
mv.DecorationOptions = Wt.register({
  description: "reference-decoration",
  stickiness: 1,
  className: "reference-decoration"
});
let WL = mv;
class jQ {
  constructor() {
    this.ratio = 0.7, this.heightInLines = 18;
  }
  static fromJSON(e) {
    let t, i;
    try {
      const n = JSON.parse(e);
      t = n.ratio, i = n.heightInLines;
    } catch {
    }
    return {
      ratio: t || 0.7,
      heightInLines: i || 18
    };
  }
}
class qQ extends ML {
}
let HL = class extends H1 {
  constructor(e, t, i, n, o, r, a, l, c) {
    super(e, { showFrame: !1, showArrow: !0, isResizeable: !0, isAccessible: !0, supportOnTitleClick: !0 }, r), this._defaultTreeKeyboardSupport = t, this.layoutData = i, this._textModelResolverService = o, this._instantiationService = r, this._peekViewService = a, this._uriLabel = l, this._keybindingService = c, this._disposeOnNewModel = new ne(), this._callOnDispose = new ne(), this._onDidSelectReference = new A(), this.onDidSelectReference = this._onDidSelectReference.event, this._dim = new ti(0, 0), this._isClosing = !1, this._applyTheme(n.getColorTheme()), this._callOnDispose.add(n.onDidColorThemeChange(this._applyTheme.bind(this))), this._peekViewService.addExclusiveWidget(e, this), this.create();
  }
  get isClosing() {
    return this._isClosing;
  }
  dispose() {
    this._isClosing = !0, this.setModel(void 0), this._callOnDispose.dispose(), this._disposeOnNewModel.dispose(), Ft(this._preview), Ft(this._previewNotAvailableMessage), Ft(this._tree), Ft(this._previewModelReference), this._splitView.dispose(), super.dispose();
  }
  _applyTheme(e) {
    const t = e.getColor(LX) || j.transparent;
    this.style({
      arrowColor: t,
      frameColor: t,
      headerBackgroundColor: e.getColor(SX) || j.transparent,
      primaryHeadingColor: e.getColor(AF),
      secondaryHeadingColor: e.getColor(PF)
    });
  }
  show(e) {
    super.show(e, this.layoutData.heightInLines || 18);
  }
  focusOnReferenceTree() {
    this._tree.domFocus();
  }
  focusOnPreviewEditor() {
    this._preview.focus();
  }
  isPreviewEditorFocused() {
    return this._preview.hasTextFocus();
  }
  _onTitleClick(e) {
    this._preview && this._preview.getModel() && this._onDidSelectReference.fire({
      element: this._getFocusedReference(),
      kind: e.ctrlKey || e.metaKey || e.altKey ? "side" : "open",
      source: "title"
    });
  }
  _fillBody(e) {
    this.setCssClass("reference-zone-widget"), this._messageContainer = te(e, he("div.messages")), yl(this._messageContainer), this._splitView = new WF(e, {
      orientation: 1
      /* Orientation.HORIZONTAL */
    }), this._previewContainer = te(e, he("div.preview.inline"));
    const t = {
      scrollBeyondLastLine: !1,
      scrollbar: {
        verticalScrollbarSize: 14,
        horizontal: "auto",
        useShadows: !0,
        verticalHasArrows: !1,
        horizontalHasArrows: !1,
        alwaysConsumeMouseWheel: !0
      },
      overviewRulerLanes: 2,
      fixedOverflowWidgets: !0,
      minimap: {
        enabled: !1
      }
    };
    this._preview = this._instantiationService.createInstance(_f, this._previewContainer, t, {}, this.editor), yl(this._previewContainer), this._previewNotAvailableMessage = this._instantiationService.createInstance(ip, m("missingPreviewMessage", "no preview available"), Fs, ip.DEFAULT_CREATION_OPTIONS, null), this._treeContainer = te(e, he("div.ref-tree.inline"));
    const i = {
      keyboardSupport: this._defaultTreeKeyboardSupport,
      accessibilityProvider: new $Q(),
      keyboardNavigationLabelProvider: this._instantiationService.createInstance(FL),
      identityProvider: new zQ(),
      openOnSingleClick: !0,
      selectionNavigation: !0,
      overrideStyles: {
        listBackground: kX
      }
    };
    this._defaultTreeKeyboardSupport && this._callOnDispose.add(Zt(this._treeContainer, "keydown", (o) => {
      o.equals(
        9
        /* KeyCode.Escape */
      ) && (this._keybindingService.dispatchEvent(o, o.target), o.stopPropagation());
    }, !0)), this._tree = this._instantiationService.createInstance(qQ, "ReferencesWidget", this._treeContainer, new VQ(), [
      this._instantiationService.createInstance(G1),
      this._instantiationService.createInstance(Z1)
    ], this._instantiationService.createInstance(OL), i), this._splitView.addView({
      onDidChange: ee.None,
      element: this._previewContainer,
      minimumSize: 200,
      maximumSize: Number.MAX_VALUE,
      layout: (o) => {
        this._preview.layout({ height: this._dim.height, width: o });
      }
    }, V1.Distribute), this._splitView.addView({
      onDidChange: ee.None,
      element: this._treeContainer,
      minimumSize: 100,
      maximumSize: Number.MAX_VALUE,
      layout: (o) => {
        this._treeContainer.style.height = `${this._dim.height}px`, this._treeContainer.style.width = `${o}px`, this._tree.layout(this._dim.height, o);
      }
    }, V1.Distribute), this._disposables.add(this._splitView.onDidSashChange(() => {
      this._dim.width && (this.layoutData.ratio = this._splitView.getViewSize(0) / this._dim.width);
    }, void 0));
    const n = (o, r) => {
      o instanceof ec && (r === "show" && this._revealReference(o, !1), this._onDidSelectReference.fire({ element: o, kind: r, source: "tree" }));
    };
    this._disposables.add(this._tree.onDidOpen((o) => {
      o.sideBySide ? n(o.element, "side") : o.editorOptions.pinned ? n(o.element, "goto") : n(o.element, "show");
    })), yl(this._treeContainer);
  }
  _onWidth(e) {
    this._dim && this._doLayoutBody(this._dim.height, e);
  }
  _doLayoutBody(e, t) {
    super._doLayoutBody(e, t), this._dim = new ti(t, e), this.layoutData.heightInLines = this._viewZone ? this._viewZone.heightInLines : this.layoutData.heightInLines, this._splitView.layout(t), this._splitView.resizeView(0, t * this.layoutData.ratio);
  }
  setSelection(e) {
    return this._revealReference(e, !0).then(() => {
      this._model && (this._tree.setSelection([e]), this._tree.setFocus([e]));
    });
  }
  setModel(e) {
    return this._disposeOnNewModel.clear(), this._model = e, this._model ? this._onNewModel() : Promise.resolve();
  }
  _onNewModel() {
    return this._model ? this._model.isEmpty ? (this.setTitle(""), this._messageContainer.innerText = m("noResults", "No results"), oh(this._messageContainer), Promise.resolve(void 0)) : (yl(this._messageContainer), this._decorationsManager = new WL(this._preview, this._model), this._disposeOnNewModel.add(this._decorationsManager), this._disposeOnNewModel.add(this._model.onDidChangeReferenceRange((e) => this._tree.rerender(e))), this._disposeOnNewModel.add(this._preview.onMouseDown((e) => {
      const { event: t, target: i } = e;
      if (t.detail !== 2)
        return;
      const n = this._getFocusedReference();
      n && this._onDidSelectReference.fire({
        element: { uri: n.uri, range: i.range },
        kind: t.ctrlKey || t.metaKey || t.altKey ? "side" : "open",
        source: "editor"
      });
    })), this.container.classList.add("results-loaded"), oh(this._treeContainer), oh(this._previewContainer), this._splitView.layout(this._dim.width), this.focusOnReferenceTree(), this._tree.setInput(this._model.groups.length === 1 ? this._model.groups[0] : this._model)) : Promise.resolve(void 0);
  }
  _getFocusedReference() {
    const [e] = this._tree.getFocus();
    if (e instanceof ec)
      return e;
    if (e instanceof lp && e.children.length > 0)
      return e.children[0];
  }
  async revealReference(e) {
    await this._revealReference(e, !1), this._onDidSelectReference.fire({ element: e, kind: "goto", source: "tree" });
  }
  async _revealReference(e, t) {
    if (this._revealedReference === e)
      return;
    this._revealedReference = e, e.uri.scheme !== Ie.inMemory ? this.setTitle(zB(e.uri), this._uriLabel.getUriLabel(BE(e.uri))) : this.setTitle(m("peekView.alternateTitle", "References"));
    const i = this._textModelResolverService.createModelReference(e.uri);
    this._tree.getInput() === e.parent ? this._tree.reveal(e) : (t && this._tree.reveal(e.parent), await this._tree.expand(e.parent), this._tree.reveal(e));
    const n = await i;
    if (!this._model) {
      n.dispose();
      return;
    }
    Ft(this._previewModelReference);
    const o = n.object;
    if (o) {
      const r = this._preview.getModel() === o.textEditorModel ? 0 : 1, a = T.lift(e.range).collapseToStart();
      this._previewModelReference = n, this._preview.setModel(o.textEditorModel), this._preview.setSelection(a), this._preview.revealRangeInCenter(a, r);
    } else
      this._preview.setModel(this._previewNotAvailableMessage), n.dispose();
  }
};
HL = KQ([
  Od(3, wn),
  Od(4, bo),
  Od(5, Pe),
  Od(6, RF),
  Od(7, Bw),
  Od(8, Lt)
], HL);
var GQ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Fd = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, bb;
const pd = new ce("referenceSearchVisible", !1, m("referenceSearchVisible", "Whether reference peek is visible, like 'Peek References' or 'Peek Definition'"));
var bh;
let cp = (bh = class {
  static get(e) {
    return e.getContribution(bb.ID);
  }
  constructor(e, t, i, n, o, r, a, l) {
    this._defaultTreeKeyboardSupport = e, this._editor = t, this._editorService = n, this._notificationService = o, this._instantiationService = r, this._storageService = a, this._configurationService = l, this._disposables = new ne(), this._requestIdPool = 0, this._ignoreModelChangeEvent = !1, this._referenceSearchVisible = pd.bindTo(i);
  }
  dispose() {
    var e, t;
    this._referenceSearchVisible.reset(), this._disposables.dispose(), (e = this._widget) == null || e.dispose(), (t = this._model) == null || t.dispose(), this._widget = void 0, this._model = void 0;
  }
  toggleWidget(e, t, i) {
    let n;
    if (this._widget && (n = this._widget.position), this.closeWidget(), n && e.containsPosition(n))
      return;
    this._peekMode = i, this._referenceSearchVisible.set(!0), this._disposables.add(this._editor.onDidChangeModelLanguage(() => {
      this.closeWidget();
    })), this._disposables.add(this._editor.onDidChangeModel(() => {
      this._ignoreModelChangeEvent || this.closeWidget();
    }));
    const o = "peekViewLayout", r = jQ.fromJSON(this._storageService.get(o, 0, "{}"));
    this._widget = this._instantiationService.createInstance(HL, this._editor, this._defaultTreeKeyboardSupport, r), this._widget.setTitle(m("labelLoading", "Loading...")), this._widget.show(e), this._disposables.add(this._widget.onDidClose(() => {
      t.cancel(), this._widget ? (this._storageService.store(
        o,
        JSON.stringify(this._widget.layoutData),
        0,
        1
        /* StorageTarget.MACHINE */
      ), this._widget.isClosing || this.closeWidget(), this._widget = void 0) : this.closeWidget();
    })), this._disposables.add(this._widget.onDidSelectReference((l) => {
      const { element: c, kind: h } = l;
      if (c)
        switch (h) {
          case "open":
            (l.source !== "editor" || !this._configurationService.getValue("editor.stablePeek")) && this.openReference(c, !1, !1);
            break;
          case "side":
            this.openReference(c, !0, !1);
            break;
          case "goto":
            i ? this._gotoReference(c, !0) : this.openReference(c, !1, !0);
            break;
        }
    }));
    const a = ++this._requestIdPool;
    t.then((l) => {
      var c;
      if (a !== this._requestIdPool || !this._widget) {
        l.dispose();
        return;
      }
      return (c = this._model) == null || c.dispose(), this._model = l, this._widget.setModel(this._model).then(() => {
        if (this._widget && this._model && this._editor.hasModel()) {
          this._model.isEmpty ? this._widget.setMetaTitle("") : this._widget.setMetaTitle(m("metaTitle.N", "{0} ({1})", this._model.title, this._model.references.length));
          const h = this._editor.getModel().uri, d = new F(e.startLineNumber, e.startColumn), u = this._model.nearestReference(h, d);
          if (u)
            return this._widget.setSelection(u).then(() => {
              this._widget && this._editor.getOption(
                87
                /* EditorOption.peekWidgetDefaultFocus */
              ) === "editor" && this._widget.focusOnPreviewEditor();
            });
        }
      });
    }, (l) => {
      this._notificationService.error(l);
    });
  }
  changeFocusBetweenPreviewAndReferences() {
    this._widget && (this._widget.isPreviewEditorFocused() ? this._widget.focusOnReferenceTree() : this._widget.focusOnPreviewEditor());
  }
  async goToNextOrPreviousReference(e) {
    if (!this._editor.hasModel() || !this._model || !this._widget)
      return;
    const t = this._widget.position;
    if (!t)
      return;
    const i = this._model.nearestReference(this._editor.getModel().uri, t);
    if (!i)
      return;
    const n = this._model.nextOrPreviousReference(i, e), o = this._editor.hasTextFocus(), r = this._widget.isPreviewEditorFocused();
    await this._widget.setSelection(n), await this._gotoReference(n, !1), o ? this._editor.focus() : this._widget && r && this._widget.focusOnPreviewEditor();
  }
  async revealReference(e) {
    !this._editor.hasModel() || !this._model || !this._widget || await this._widget.revealReference(e);
  }
  closeWidget(e = !0) {
    var t, i;
    (t = this._widget) == null || t.dispose(), (i = this._model) == null || i.dispose(), this._referenceSearchVisible.reset(), this._disposables.clear(), this._widget = void 0, this._model = void 0, e && this._editor.focus(), this._requestIdPool += 1;
  }
  _gotoReference(e, t) {
    var n;
    (n = this._widget) == null || n.hide(), this._ignoreModelChangeEvent = !0;
    const i = T.lift(e.range).collapseToStart();
    return this._editorService.openCodeEditor({
      resource: e.uri,
      options: { selection: i, selectionSource: "code.jump", pinned: t }
    }, this._editor).then((o) => {
      if (this._ignoreModelChangeEvent = !1, !o || !this._widget) {
        this.closeWidget();
        return;
      }
      if (this._editor === o)
        this._widget.show(i), this._widget.focusOnReferenceTree();
      else {
        const r = bb.get(o), a = this._model.clone();
        this.closeWidget(), o.focus(), r == null || r.toggleWidget(i, Za((l) => Promise.resolve(a)), this._peekMode ?? !1);
      }
    }, (o) => {
      this._ignoreModelChangeEvent = !1, Je(o);
    });
  }
  openReference(e, t, i) {
    t || this.closeWidget();
    const { uri: n, range: o } = e;
    this._editorService.openCodeEditor({
      resource: n,
      options: { selection: o, selectionSource: "code.jump", pinned: i }
    }, this._editor, t);
  }
}, bb = bh, bh.ID = "editor.contrib.referencesController", bh);
cp = bb = GQ([
  Fd(2, Fe),
  Fd(3, Tt),
  Fd(4, cn),
  Fd(5, Pe),
  Fd(6, zp),
  Fd(7, gt)
], cp);
function _d(s, e) {
  const t = wX(s);
  if (!t)
    return;
  const i = cp.get(t);
  i && e(i);
}
ts.registerCommandAndKeybindingRule({
  id: "togglePeekWidgetFocus",
  weight: 100,
  primary: ym(
    2089,
    60
    /* KeyCode.F2 */
  ),
  when: ve.or(pd, On.inPeekEditor),
  handler(s) {
    _d(s, (e) => {
      e.changeFocusBetweenPreviewAndReferences();
    });
  }
});
ts.registerCommandAndKeybindingRule({
  id: "goToNextReference",
  weight: 90,
  primary: 62,
  secondary: [
    70
    /* KeyCode.F12 */
  ],
  when: ve.or(pd, On.inPeekEditor),
  handler(s) {
    _d(s, (e) => {
      e.goToNextOrPreviousReference(!0);
    });
  }
});
ts.registerCommandAndKeybindingRule({
  id: "goToPreviousReference",
  weight: 90,
  primary: 1086,
  secondary: [
    1094
    /* KeyCode.F12 */
  ],
  when: ve.or(pd, On.inPeekEditor),
  handler(s) {
    _d(s, (e) => {
      e.goToNextOrPreviousReference(!1);
    });
  }
});
St.registerCommandAlias("goToNextReferenceFromEmbeddedEditor", "goToNextReference");
St.registerCommandAlias("goToPreviousReferenceFromEmbeddedEditor", "goToPreviousReference");
St.registerCommandAlias("closeReferenceSearchEditor", "closeReferenceSearch");
St.registerCommand("closeReferenceSearch", (s) => _d(s, (e) => e.closeWidget()));
ts.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: -1,
  primary: 9,
  secondary: [
    1033
    /* KeyCode.Escape */
  ],
  when: ve.and(On.inPeekEditor, ve.not("config.editor.stablePeek"))
});
ts.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: 250,
  primary: 9,
  secondary: [
    1033
    /* KeyCode.Escape */
  ],
  when: ve.and(pd, ve.not("config.editor.stablePeek"), ve.or(Z.editorTextFocus, ZF.negate()))
});
ts.registerCommandAndKeybindingRule({
  id: "revealReference",
  weight: 200,
  primary: 3,
  mac: {
    primary: 3,
    secondary: [
      2066
      /* KeyCode.DownArrow */
    ]
  },
  when: ve.and(pd, QF, cN.negate(), hN.negate()),
  handler(s) {
    var i;
    const t = (i = s.get(js).lastFocusedList) == null ? void 0 : i.getFocus();
    Array.isArray(t) && t[0] instanceof ec && _d(s, (n) => n.revealReference(t[0]));
  }
});
ts.registerCommandAndKeybindingRule({
  id: "openReferenceToSide",
  weight: 100,
  primary: 2051,
  mac: {
    primary: 259
    /* KeyCode.Enter */
  },
  when: ve.and(pd, QF, cN.negate(), hN.negate()),
  handler(s) {
    var i;
    const t = (i = s.get(js).lastFocusedList) == null ? void 0 : i.getFocus();
    Array.isArray(t) && t[0] instanceof ec && _d(s, (n) => n.openReference(t[0], !0, !0));
  }
});
St.registerCommand("openReference", (s) => {
  var i;
  const t = (i = s.get(js).lastFocusedList) == null ? void 0 : i.getFocus();
  Array.isArray(t) && t[0] instanceof ec && _d(s, (n) => n.openReference(t[0], !1, !0));
});
var s7 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Lg = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const mN = new ce("hasSymbols", !1, m("hasSymbols", "Whether there are symbol locations that can be navigated via keyboard-only.")), Vw = Be("ISymbolNavigationService");
let VL = class {
  constructor(e, t, i, n) {
    this._editorService = t, this._notificationService = i, this._keybindingService = n, this._currentModel = void 0, this._currentIdx = -1, this._ignoreEditorChange = !1, this._ctxHasSymbols = mN.bindTo(e);
  }
  reset() {
    var e, t;
    this._ctxHasSymbols.reset(), (e = this._currentState) == null || e.dispose(), (t = this._currentMessage) == null || t.dispose(), this._currentModel = void 0, this._currentIdx = -1;
  }
  put(e) {
    const t = e.parent.parent;
    if (t.references.length <= 1) {
      this.reset();
      return;
    }
    this._currentModel = t, this._currentIdx = t.references.indexOf(e), this._ctxHasSymbols.set(!0), this._showMessage();
    const i = new zL(this._editorService), n = i.onDidChange((o) => {
      if (this._ignoreEditorChange)
        return;
      const r = this._editorService.getActiveCodeEditor();
      if (!r)
        return;
      const a = r.getModel(), l = r.getPosition();
      if (!a || !l)
        return;
      let c = !1, h = !1;
      for (const d of t.references)
        if (FE(d.uri, a.uri))
          c = !0, h = h || T.containsPosition(d.range, l);
        else if (c)
          break;
      (!c || !h) && this.reset();
    });
    this._currentState = ao(i, n);
  }
  revealNext(e) {
    if (!this._currentModel)
      return Promise.resolve();
    this._currentIdx += 1, this._currentIdx %= this._currentModel.references.length;
    const t = this._currentModel.references[this._currentIdx];
    return this._showMessage(), this._ignoreEditorChange = !0, this._editorService.openCodeEditor({
      resource: t.uri,
      options: {
        selection: T.collapseToStart(t.range),
        selectionRevealType: 3
        /* TextEditorSelectionRevealType.NearTopIfOutsideViewport */
      }
    }, e).finally(() => {
      this._ignoreEditorChange = !1;
    });
  }
  _showMessage() {
    var i;
    (i = this._currentMessage) == null || i.dispose();
    const e = this._keybindingService.lookupKeybinding("editor.gotoNextSymbolFromResult"), t = e ? m("location.kb", "Symbol {0} of {1}, {2} for next", this._currentIdx + 1, this._currentModel.references.length, e.getLabel()) : m("location", "Symbol {0} of {1}", this._currentIdx + 1, this._currentModel.references.length);
    this._currentMessage = this._notificationService.status(t);
  }
};
VL = s7([
  Lg(0, Fe),
  Lg(1, Tt),
  Lg(2, cn),
  Lg(3, Lt)
], VL);
Ze(
  Vw,
  VL,
  1
  /* InstantiationType.Delayed */
);
Le(new class extends jo {
  constructor() {
    super({
      id: "editor.gotoNextSymbolFromResult",
      precondition: mN,
      kbOpts: {
        weight: 100,
        primary: 70
        /* KeyCode.F12 */
      }
    });
  }
  runEditorCommand(s, e) {
    return s.get(Vw).revealNext(e);
  }
}());
ts.registerCommandAndKeybindingRule({
  id: "editor.gotoNextSymbolFromResult.cancel",
  weight: 100,
  when: mN,
  primary: 9,
  handler(s) {
    s.get(Vw).reset();
  }
});
let zL = class {
  constructor(e) {
    this._listener = /* @__PURE__ */ new Map(), this._disposables = new ne(), this._onDidChange = new A(), this.onDidChange = this._onDidChange.event, this._disposables.add(e.onCodeEditorRemove(this._onDidRemoveEditor, this)), this._disposables.add(e.onCodeEditorAdd(this._onDidAddEditor, this)), e.listCodeEditors().forEach(this._onDidAddEditor, this);
  }
  dispose() {
    this._disposables.dispose(), this._onDidChange.dispose(), Ft(this._listener.values());
  }
  _onDidAddEditor(e) {
    this._listener.set(e, ao(e.onDidChangeCursorPosition((t) => this._onDidChange.fire({ editor: e })), e.onDidChangeModelContent((t) => this._onDidChange.fire({ editor: e }))));
  }
  _onDidRemoveEditor(e) {
    var t;
    (t = this._listener.get(e)) == null || t.dispose(), this._listener.delete(e);
  }
};
zL = s7([
  Lg(0, Tt)
], zL);
const sr = Be("openerService");
function ZQ(s) {
  let e;
  const t = /^L?(\d+)(?:,(\d+))?(-L?(\d+)(?:,(\d+))?)?/.exec(s.fragment);
  return t && (e = {
    startLineNumber: parseInt(t[1]),
    startColumn: t[2] ? parseInt(t[2]) : 1,
    endLineNumber: t[4] ? parseInt(t[4]) : void 0,
    endColumn: t[4] ? t[5] ? parseInt(t[5]) : 1 : void 0
  }, s = s.with({ fragment: "" })), { selection: e, uri: s };
}
var YQ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, aR = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, UL, Ch;
let hp = (Ch = class {
  constructor(e, t, i) {
    this._options = e, this._languageService = t, this._openerService = i, this._onDidRenderAsync = new A(), this.onDidRenderAsync = this._onDidRenderAsync.event;
  }
  dispose() {
    this._onDidRenderAsync.dispose();
  }
  render(e, t, i) {
    if (!e)
      return { element: document.createElement("span"), dispose: () => {
      } };
    const n = new ne(), o = n.add(ow(e, { ...this._getRenderOptions(e, n), ...t }, i));
    return o.element.classList.add("rendered-markdown"), {
      element: o.element,
      dispose: () => n.dispose()
    };
  }
  _getRenderOptions(e, t) {
    return {
      codeBlockRenderer: async (i, n) => {
        var l, c;
        let o;
        i ? o = this._languageService.getLanguageIdByLanguageName(i) : this._options.editor && (o = (l = this._options.editor.getModel()) == null ? void 0 : l.getLanguageId()), o || (o = Fs);
        const r = await lY(this._languageService, n, o), a = document.createElement("span");
        if (a.innerHTML = ((c = UL._ttpTokenizer) == null ? void 0 : c.createHTML(r)) ?? r, this._options.editor) {
          const h = this._options.editor.getOption(
            50
            /* EditorOption.fontInfo */
          );
          Zi(a, h);
        } else this._options.codeBlockFontFamily && (a.style.fontFamily = this._options.codeBlockFontFamily);
        return this._options.codeBlockFontSize !== void 0 && (a.style.fontSize = this._options.codeBlockFontSize), a;
      },
      asyncRenderCallback: () => this._onDidRenderAsync.fire(),
      actionHandler: {
        callback: (i) => pN(this._openerService, i, e.isTrusted),
        disposables: t
      }
    };
  }
}, UL = Ch, Ch._ttpTokenizer = ud("tokenizeToString", {
  createHTML(e) {
    return e;
  }
}), Ch);
hp = UL = YQ([
  aR(1, ci),
  aR(2, sr)
], hp);
async function pN(s, e, t) {
  try {
    return await s.open(e, {
      fromUserGesture: !0,
      allowContributedOpeners: !0,
      allowCommands: XQ(t)
    });
  } catch (i) {
    return Je(i), !1;
  }
}
function XQ(s) {
  return s === !0 ? !0 : s && Array.isArray(s.enabledCommands) ? s.enabledCommands : !1;
}
var QQ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, lR = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Cb, Ol;
let Rr = (Ol = class {
  static get(e) {
    return e.getContribution(Cb.ID);
  }
  constructor(e, t, i) {
    this._openerService = i, this._messageWidget = new Hs(), this._messageListeners = new ne(), this._mouseOverMessage = !1, this._editor = e, this._visible = Cb.MESSAGE_VISIBLE.bindTo(t);
  }
  dispose() {
    var e;
    (e = this._message) == null || e.dispose(), this._messageListeners.dispose(), this._messageWidget.dispose(), this._visible.reset();
  }
  showMessage(e, t) {
    Uh(Mr(e) ? e.value : e), this._visible.set(!0), this._messageWidget.clear(), this._messageListeners.clear(), this._message = Mr(e) ? ow(e, {
      actionHandler: {
        callback: (n) => {
          this.closeMessage(), pN(this._openerService, n, Mr(e) ? e.isTrusted : void 0);
        },
        disposables: this._messageListeners
      }
    }) : void 0, this._messageWidget.value = new cR(this._editor, t, typeof e == "string" ? e : this._message.element), this._messageListeners.add(ee.debounce(this._editor.onDidBlurEditorText, (n, o) => o, 0)(() => {
      this._mouseOverMessage || this._messageWidget.value && _i(Gi(), this._messageWidget.value.getDomNode()) || this.closeMessage();
    })), this._messageListeners.add(this._editor.onDidChangeCursorPosition(() => this.closeMessage())), this._messageListeners.add(this._editor.onDidDispose(() => this.closeMessage())), this._messageListeners.add(this._editor.onDidChangeModel(() => this.closeMessage())), this._messageListeners.add(z(this._messageWidget.value.getDomNode(), X.MOUSE_ENTER, () => this._mouseOverMessage = !0, !0)), this._messageListeners.add(z(this._messageWidget.value.getDomNode(), X.MOUSE_LEAVE, () => this._mouseOverMessage = !1, !0));
    let i;
    this._messageListeners.add(this._editor.onMouseMove((n) => {
      n.target.position && (i ? i.containsPosition(n.target.position) || this.closeMessage() : i = new T(t.lineNumber - 3, 1, n.target.position.lineNumber + 3, 1));
    }));
  }
  closeMessage() {
    this._visible.reset(), this._messageListeners.clear(), this._messageWidget.value && this._messageListeners.add(cR.fadeOut(this._messageWidget.value));
  }
}, Cb = Ol, Ol.ID = "editor.contrib.messageController", Ol.MESSAGE_VISIBLE = new ce("messageVisible", !1, m("messageVisible", "Whether the editor is currently showing an inline message")), Ol);
Rr = Cb = QQ([
  lR(1, Fe),
  lR(2, sr)
], Rr);
const JQ = jo.bindToContribution(Rr.get);
Le(new JQ({
  id: "leaveEditorMessage",
  precondition: Rr.MESSAGE_VISIBLE,
  handler: (s) => s.closeMessage(),
  kbOpts: {
    weight: 130,
    primary: 9
    /* KeyCode.Escape */
  }
}));
let cR = class {
  static fadeOut(e) {
    const t = () => {
      e.dispose(), clearTimeout(i), e.getDomNode().removeEventListener("animationend", t);
    }, i = setTimeout(t, 110);
    return e.getDomNode().addEventListener("animationend", t), e.getDomNode().classList.add("fadeOut"), { dispose: t };
  }
  constructor(e, { lineNumber: t, column: i }, n) {
    this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this._editor = e, this._editor.revealLinesInCenterIfOutsideViewport(
      t,
      t,
      0
      /* ScrollType.Smooth */
    ), this._position = { lineNumber: t, column: i }, this._domNode = document.createElement("div"), this._domNode.classList.add("monaco-editor-overlaymessage"), this._domNode.style.marginLeft = "-6px";
    const o = document.createElement("div");
    o.classList.add("anchor", "top"), this._domNode.appendChild(o);
    const r = document.createElement("div");
    typeof n == "string" ? (r.classList.add("message"), r.textContent = n) : (n.classList.add("message"), r.appendChild(n)), this._domNode.appendChild(r);
    const a = document.createElement("div");
    a.classList.add("anchor", "below"), this._domNode.appendChild(a), this._editor.addContentWidget(this), this._domNode.classList.add("fadeIn");
  }
  dispose() {
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "messageoverlay";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      position: this._position,
      preference: [
        1,
        2
      ],
      positionAffinity: 1
    };
  }
  afterRender(e) {
    this._domNode.classList.toggle(
      "below",
      e === 2
      /* ContentWidgetPositionPreference.BELOW */
    );
  }
};
Xa(
  Rr.ID,
  Rr,
  4
  /* EditorContributionInstantiation.Lazy */
);
const eJ = Be("progressService"), i2 = class i2 {
  constructor(e) {
    this.callback = e;
  }
  report(e) {
    this._value = e, this.callback(this._value);
  }
};
i2.None = Object.freeze({ report() {
} });
let Dl = i2;
const Kp = Be("editorProgressService");
function $L(s, e) {
  return e.uri.scheme === s.uri.scheme ? !0 : !Zy(e.uri, Ie.walkThroughSnippet, Ie.vscodeChatCodeBlock, Ie.vscodeChatCodeCompareBlock);
}
async function jp(s, e, t, i, n) {
  const r = t.ordered(s, i).map((l) => Promise.resolve(n(l, s, e)).then(void 0, (c) => {
    Qo(c);
  })), a = await Promise.all(r);
  return Rf(a.flat()).filter((l) => $L(s, l));
}
function zw(s, e, t, i, n) {
  return jp(e, t, s, i, (o, r, a) => o.provideDefinition(r, a, n));
}
function _N(s, e, t, i, n) {
  return jp(e, t, s, i, (o, r, a) => o.provideDeclaration(r, a, n));
}
function bN(s, e, t, i, n) {
  return jp(e, t, s, i, (o, r, a) => o.provideImplementation(r, a, n));
}
function CN(s, e, t, i, n) {
  return jp(e, t, s, i, (o, r, a) => o.provideTypeDefinition(r, a, n));
}
function qp(s, e, t, i, n, o) {
  return jp(e, t, s, n, async (r, a, l) => {
    var d, u;
    const c = (d = await r.provideReferences(a, l, { includeDeclaration: !0 }, o)) == null ? void 0 : d.filter((f) => $L(a, f));
    if (!i || !c || c.length !== 2)
      return c;
    const h = (u = await r.provideReferences(a, l, { includeDeclaration: !1 }, o)) == null ? void 0 : u.filter((f) => $L(a, f));
    return h && h.length === 1 ? h : c;
  });
}
async function Gr(s) {
  const e = await s(), t = new Jn(e, ""), i = t.references.map((n) => n.link);
  return t.dispose(), i;
}
vo("_executeDefinitionProvider", (s, e, t) => {
  const i = s.get(De), n = zw(i.definitionProvider, e, t, !1, _t.None);
  return Gr(() => n);
});
vo("_executeDefinitionProvider_recursive", (s, e, t) => {
  const i = s.get(De), n = zw(i.definitionProvider, e, t, !0, _t.None);
  return Gr(() => n);
});
vo("_executeTypeDefinitionProvider", (s, e, t) => {
  const i = s.get(De), n = CN(i.typeDefinitionProvider, e, t, !1, _t.None);
  return Gr(() => n);
});
vo("_executeTypeDefinitionProvider_recursive", (s, e, t) => {
  const i = s.get(De), n = CN(i.typeDefinitionProvider, e, t, !0, _t.None);
  return Gr(() => n);
});
vo("_executeDeclarationProvider", (s, e, t) => {
  const i = s.get(De), n = _N(i.declarationProvider, e, t, !1, _t.None);
  return Gr(() => n);
});
vo("_executeDeclarationProvider_recursive", (s, e, t) => {
  const i = s.get(De), n = _N(i.declarationProvider, e, t, !0, _t.None);
  return Gr(() => n);
});
vo("_executeReferenceProvider", (s, e, t) => {
  const i = s.get(De), n = qp(i.referenceProvider, e, t, !1, !1, _t.None);
  return Gr(() => n);
});
vo("_executeReferenceProvider_recursive", (s, e, t) => {
  const i = s.get(De), n = qp(i.referenceProvider, e, t, !1, !0, _t.None);
  return Gr(() => n);
});
vo("_executeImplementationProvider", (s, e, t) => {
  const i = s.get(De), n = bN(i.implementationProvider, e, t, !1, _t.None);
  return Gr(() => n);
});
vo("_executeImplementationProvider_recursive", (s, e, t) => {
  const i = s.get(De), n = bN(i.implementationProvider, e, t, !0, _t.None);
  return Gr(() => n);
});
so.appendMenuItem(et.EditorContext, {
  submenu: et.EditorContextPeek,
  title: m("peek.submenu", "Peek"),
  group: "navigation",
  order: 100
});
class vf {
  static is(e) {
    return !e || typeof e != "object" ? !1 : !!(e instanceof vf || F.isIPosition(e.position) && e.model);
  }
  constructor(e, t) {
    this.model = e, this.position = t;
  }
}
const Qs = class Qs extends hB {
  static all() {
    return Qs._allSymbolNavigationCommands.values();
  }
  static _patchConfig(e) {
    const t = { ...e, f1: !0 };
    if (t.menu)
      for (const i of nt.wrap(t.menu))
        (i.id === et.EditorContext || i.id === et.EditorContextPeek) && (i.when = ve.and(e.precondition, i.when));
    return t;
  }
  constructor(e, t) {
    super(Qs._patchConfig(t)), this.configuration = e, Qs._allSymbolNavigationCommands.set(t.id, this);
  }
  runEditorCommand(e, t, i, n) {
    if (!t.hasModel())
      return Promise.resolve(void 0);
    const o = e.get(cn), r = e.get(Tt), a = e.get(Kp), l = e.get(Vw), c = e.get(De), h = e.get(Pe), d = t.getModel(), u = t.getPosition(), f = vf.is(i) ? i : new vf(d, u), g = new YB(
      t,
      5
      /* CodeEditorStateFlag.Position */
    ), p = o6(this._getLocationModel(c, f.model, f.position, g.token), g.token).then(async (_) => {
      var w;
      if (!_ || g.token.isCancellationRequested)
        return;
      Uh(_.ariaMessage);
      let b;
      if (_.referenceAt(d.uri, u)) {
        const v = this._getAlternativeCommand(t);
        !Qs._activeAlternativeCommands.has(v) && Qs._allSymbolNavigationCommands.has(v) && (b = Qs._allSymbolNavigationCommands.get(v));
      }
      const C = _.references.length;
      if (C === 0) {
        if (!this.configuration.muteMessage) {
          const v = d.getWordAtPosition(u);
          (w = Rr.get(t)) == null || w.showMessage(this._getNoResultFoundMessage(v), u);
        }
      } else if (C === 1 && b)
        Qs._activeAlternativeCommands.add(this.desc.id), h.invokeFunction((v) => b.runEditorCommand(v, t, i, n).finally(() => {
          Qs._activeAlternativeCommands.delete(this.desc.id);
        }));
      else
        return this._onResult(r, l, t, _, n);
    }, (_) => {
      o.error(_);
    }).finally(() => {
      g.dispose();
    });
    return a.showWhile(p, 250), p;
  }
  async _onResult(e, t, i, n, o) {
    const r = this._getGoToPreference(i);
    if (!(i instanceof _f) && (this.configuration.openInPeek || r === "peek" && n.references.length > 1))
      this._openInPeek(i, n, o);
    else {
      const a = n.firstReference(), l = n.references.length > 1 && r === "gotoAndPeek", c = await this._openReference(i, e, a, this.configuration.openToSide, !l);
      l && c ? this._openInPeek(c, n, o) : n.dispose(), r === "goto" && t.put(a);
    }
  }
  async _openReference(e, t, i, n, o) {
    let r;
    if (WK(i) && (r = i.targetSelectionRange), r || (r = i.range), !r)
      return;
    const a = await t.openCodeEditor({
      resource: i.uri,
      options: {
        selection: T.collapseToStart(r),
        selectionRevealType: 3,
        selectionSource: "code.jump"
        /* TextEditorSelectionSource.JUMP */
      }
    }, e, n);
    if (a) {
      if (o) {
        const l = a.getModel(), c = a.createDecorationsCollection([{ range: r, options: { description: "symbol-navigate-action-highlight", className: "symbolHighlight" } }]);
        setTimeout(() => {
          a.getModel() === l && c.clear();
        }, 350);
      }
      return a;
    }
  }
  _openInPeek(e, t, i) {
    const n = cp.get(e);
    n && e.hasModel() ? n.toggleWidget(i ?? e.getSelection(), Za((o) => Promise.resolve(t)), this.configuration.openInPeek) : t.dispose();
  }
};
Qs._allSymbolNavigationCommands = /* @__PURE__ */ new Map(), Qs._activeAlternativeCommands = /* @__PURE__ */ new Set();
let ja = Qs;
class Gp extends ja {
  async _getLocationModel(e, t, i, n) {
    return new Jn(await zw(e.definitionProvider, t, i, !1, n), m("def.title", "Definitions"));
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? m("noResultWord", "No definition found for '{0}'", e.word) : m("generic.noResults", "No definition found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeDefinitionCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleDefinitions;
  }
}
var Fl;
Fn((Fl = class extends Gp {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: Fl.id,
      title: {
        ...oi("actions.goToDecl.label", "Go to Definition"),
        mnemonicTitle: m({ key: "miGotoDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Definition")
      },
      precondition: Z.hasDefinitionProvider,
      keybinding: [{
        when: Z.editorTextFocus,
        primary: 70,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        when: ve.and(Z.editorTextFocus, qF),
        primary: 2118,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }],
      menu: [{
        id: et.EditorContext,
        group: "navigation",
        order: 1.1
      }, {
        id: et.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 2
      }]
    }), St.registerCommandAlias("editor.action.goToDeclaration", Fl.id);
  }
}, Fl.id = "editor.action.revealDefinition", Fl));
var Bl;
Fn((Bl = class extends Gp {
  constructor() {
    super({
      openToSide: !0,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: Bl.id,
      title: oi("actions.goToDeclToSide.label", "Open Definition to the Side"),
      precondition: ve.and(Z.hasDefinitionProvider, Z.isInEmbeddedEditor.toNegated()),
      keybinding: [{
        when: Z.editorTextFocus,
        primary: ym(
          2089,
          70
          /* KeyCode.F12 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        when: ve.and(Z.editorTextFocus, qF),
        primary: ym(
          2089,
          2118
          /* KeyCode.F12 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }]
    }), St.registerCommandAlias("editor.action.openDeclarationToTheSide", Bl.id);
  }
}, Bl.id = "editor.action.revealDefinitionAside", Bl));
var Wl;
Fn((Wl = class extends Gp {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: Wl.id,
      title: oi("actions.previewDecl.label", "Peek Definition"),
      precondition: ve.and(Z.hasDefinitionProvider, On.notInPeekEditor, Z.isInEmbeddedEditor.toNegated()),
      keybinding: {
        when: Z.editorTextFocus,
        primary: 582,
        linux: {
          primary: 3140
          /* KeyCode.F10 */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: {
        id: et.EditorContextPeek,
        group: "peek",
        order: 2
      }
    }), St.registerCommandAlias("editor.action.previewDeclaration", Wl.id);
  }
}, Wl.id = "editor.action.peekDefinition", Wl));
class o7 extends ja {
  async _getLocationModel(e, t, i, n) {
    return new Jn(await _N(e.declarationProvider, t, i, !1, n), m("decl.title", "Declarations"));
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? m("decl.noResultWord", "No declaration found for '{0}'", e.word) : m("decl.generic.noResults", "No declaration found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeDeclarationCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleDeclarations;
  }
}
var vh;
Fn((vh = class extends o7 {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: vh.id,
      title: {
        ...oi("actions.goToDeclaration.label", "Go to Declaration"),
        mnemonicTitle: m({ key: "miGotoDeclaration", comment: ["&& denotes a mnemonic"] }, "Go to &&Declaration")
      },
      precondition: ve.and(Z.hasDeclarationProvider, Z.isInEmbeddedEditor.toNegated()),
      menu: [{
        id: et.EditorContext,
        group: "navigation",
        order: 1.3
      }, {
        id: et.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 3
      }]
    });
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? m("decl.noResultWord", "No declaration found for '{0}'", e.word) : m("decl.generic.noResults", "No declaration found");
  }
}, vh.id = "editor.action.revealDeclaration", vh));
Fn(class extends o7 {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: "editor.action.peekDeclaration",
      title: oi("actions.peekDecl.label", "Peek Declaration"),
      precondition: ve.and(Z.hasDeclarationProvider, On.notInPeekEditor, Z.isInEmbeddedEditor.toNegated()),
      menu: {
        id: et.EditorContextPeek,
        group: "peek",
        order: 3
      }
    });
  }
});
class r7 extends ja {
  async _getLocationModel(e, t, i, n) {
    return new Jn(await CN(e.typeDefinitionProvider, t, i, !1, n), m("typedef.title", "Type Definitions"));
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? m("goToTypeDefinition.noResultWord", "No type definition found for '{0}'", e.word) : m("goToTypeDefinition.generic.noResults", "No type definition found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeTypeDefinitionCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleTypeDefinitions;
  }
}
var wh;
Fn((wh = class extends r7 {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: wh.ID,
      title: {
        ...oi("actions.goToTypeDefinition.label", "Go to Type Definition"),
        mnemonicTitle: m({ key: "miGotoTypeDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Type Definition")
      },
      precondition: Z.hasTypeDefinitionProvider,
      keybinding: {
        when: Z.editorTextFocus,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: et.EditorContext,
        group: "navigation",
        order: 1.4
      }, {
        id: et.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 3
      }]
    });
  }
}, wh.ID = "editor.action.goToTypeDefinition", wh));
var yh;
Fn((yh = class extends r7 {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: yh.ID,
      title: oi("actions.peekTypeDefinition.label", "Peek Type Definition"),
      precondition: ve.and(Z.hasTypeDefinitionProvider, On.notInPeekEditor, Z.isInEmbeddedEditor.toNegated()),
      menu: {
        id: et.EditorContextPeek,
        group: "peek",
        order: 4
      }
    });
  }
}, yh.ID = "editor.action.peekTypeDefinition", yh));
class a7 extends ja {
  async _getLocationModel(e, t, i, n) {
    return new Jn(await bN(e.implementationProvider, t, i, !1, n), m("impl.title", "Implementations"));
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? m("goToImplementation.noResultWord", "No implementation found for '{0}'", e.word) : m("goToImplementation.generic.noResults", "No implementation found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeImplementationCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleImplementations;
  }
}
var Sh;
Fn((Sh = class extends a7 {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: Sh.ID,
      title: {
        ...oi("actions.goToImplementation.label", "Go to Implementations"),
        mnemonicTitle: m({ key: "miGotoImplementation", comment: ["&& denotes a mnemonic"] }, "Go to &&Implementations")
      },
      precondition: Z.hasImplementationProvider,
      keybinding: {
        when: Z.editorTextFocus,
        primary: 2118,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: et.EditorContext,
        group: "navigation",
        order: 1.45
      }, {
        id: et.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 4
      }]
    });
  }
}, Sh.ID = "editor.action.goToImplementation", Sh));
var Lh;
Fn((Lh = class extends a7 {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: Lh.ID,
      title: oi("actions.peekImplementation.label", "Peek Implementations"),
      precondition: ve.and(Z.hasImplementationProvider, On.notInPeekEditor, Z.isInEmbeddedEditor.toNegated()),
      keybinding: {
        when: Z.editorTextFocus,
        primary: 3142,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: {
        id: et.EditorContextPeek,
        group: "peek",
        order: 5
      }
    });
  }
}, Lh.ID = "editor.action.peekImplementation", Lh));
class l7 extends ja {
  _getNoResultFoundMessage(e) {
    return e ? m("references.no", "No references found for '{0}'", e.word) : m("references.noGeneric", "No references found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeReferenceCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleReferences;
  }
}
Fn(class extends l7 {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: "editor.action.goToReferences",
      title: {
        ...oi("goToReferences.label", "Go to References"),
        mnemonicTitle: m({ key: "miGotoReference", comment: ["&& denotes a mnemonic"] }, "Go to &&References")
      },
      precondition: ve.and(Z.hasReferenceProvider, On.notInPeekEditor, Z.isInEmbeddedEditor.toNegated()),
      keybinding: {
        when: Z.editorTextFocus,
        primary: 1094,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: et.EditorContext,
        group: "navigation",
        order: 1.45
      }, {
        id: et.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 5
      }]
    });
  }
  async _getLocationModel(e, t, i, n) {
    return new Jn(await qp(e.referenceProvider, t, i, !0, !1, n), m("ref.title", "References"));
  }
});
Fn(class extends l7 {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: "editor.action.referenceSearch.trigger",
      title: oi("references.action.label", "Peek References"),
      precondition: ve.and(Z.hasReferenceProvider, On.notInPeekEditor, Z.isInEmbeddedEditor.toNegated()),
      menu: {
        id: et.EditorContextPeek,
        group: "peek",
        order: 6
      }
    });
  }
  async _getLocationModel(e, t, i, n) {
    return new Jn(await qp(e.referenceProvider, t, i, !1, !1, n), m("ref.title", "References"));
  }
});
class tJ extends ja {
  constructor(e, t, i) {
    super(e, {
      id: "editor.action.goToLocation",
      title: oi("label.generic", "Go to Any Symbol"),
      precondition: ve.and(On.notInPeekEditor, Z.isInEmbeddedEditor.toNegated())
    }), this._references = t, this._gotoMultipleBehaviour = i;
  }
  async _getLocationModel(e, t, i, n) {
    return new Jn(this._references, m("generic.title", "Locations"));
  }
  _getNoResultFoundMessage(e) {
    return e && m("generic.noResult", "No results for '{0}'", e.word) || "";
  }
  _getGoToPreference(e) {
    return this._gotoMultipleBehaviour ?? e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleReferences;
  }
  _getAlternativeCommand() {
    return "";
  }
}
St.registerCommand({
  id: "editor.action.goToLocations",
  metadata: {
    description: "Go to locations from a position in a file",
    args: [
      { name: "uri", description: "The text document in which to start", constraint: we },
      { name: "position", description: "The position at which to start", constraint: F.isIPosition },
      { name: "locations", description: "An array of locations.", constraint: Array },
      { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto`" },
      { name: "noResultsMessage", description: "Human readable message that shows when locations is empty." }
    ]
  },
  handler: async (s, e, t, i, n, o, r) => {
    qi(we.isUri(e)), qi(F.isIPosition(t)), qi(Array.isArray(i)), qi(typeof n > "u" || typeof n == "string"), qi(typeof r > "u" || typeof r == "boolean");
    const a = s.get(Tt), l = await a.openCodeEditor({ resource: e }, a.getFocusedCodeEditor());
    if (FF(l))
      return l.setPosition(t), l.revealPositionInCenterIfOutsideViewport(
        t,
        0
        /* ScrollType.Smooth */
      ), l.invokeWithinContext((c) => {
        const h = new class extends tJ {
          _getNoResultFoundMessage(d) {
            return o || super._getNoResultFoundMessage(d);
          }
        }({
          muteMessage: !o,
          openInPeek: !!r,
          openToSide: !1
        }, i, n);
        c.get(Pe).invokeFunction(h.run.bind(h), l);
      });
  }
});
St.registerCommand({
  id: "editor.action.peekLocations",
  metadata: {
    description: "Peek locations from a position in a file",
    args: [
      { name: "uri", description: "The text document in which to start", constraint: we },
      { name: "position", description: "The position at which to start", constraint: F.isIPosition },
      { name: "locations", description: "An array of locations.", constraint: Array },
      { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto`" }
    ]
  },
  handler: async (s, e, t, i, n) => {
    s.get(fi).executeCommand("editor.action.goToLocations", e, t, i, n, void 0, !0);
  }
});
St.registerCommand({
  id: "editor.action.findReferences",
  handler: (s, e, t) => {
    qi(we.isUri(e)), qi(F.isIPosition(t));
    const i = s.get(De), n = s.get(Tt);
    return n.openCodeEditor({ resource: e }, n.getFocusedCodeEditor()).then((o) => {
      if (!FF(o) || !o.hasModel())
        return;
      const r = cp.get(o);
      if (!r)
        return;
      const a = Za((c) => qp(i.referenceProvider, o.getModel(), F.lift(t), !1, !1, c).then((h) => new Jn(h, m("ref.title", "References")))), l = new T(t.lineNumber, t.column, t.lineNumber, t.column);
      return Promise.resolve(r.toggleWidget(l, a, !1));
    });
  }
});
St.registerCommandAlias("editor.action.showReferences", "editor.action.peekLocations");
var iJ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, ly = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, kg, Hl;
let dp = (Hl = class {
  constructor(e, t, i, n) {
    this.textModelResolverService = t, this.languageService = i, this.languageFeaturesService = n, this.toUnhook = new ne(), this.toUnhookForKeyboard = new ne(), this.currentWordAtPosition = null, this.previousPromise = null, this.editor = e, this.linkDecorations = this.editor.createDecorationsCollection();
    const o = new lO(e);
    this.toUnhook.add(o), this.toUnhook.add(o.onMouseMoveOrRelevantKeyDown(([r, a]) => {
      this.startFindDefinitionFromMouse(r, a ?? void 0);
    })), this.toUnhook.add(o.onExecute((r) => {
      this.isEnabled(r) && this.gotoDefinition(r.target.position, r.hasSideBySideModifier).catch((a) => {
        Je(a);
      }).finally(() => {
        this.removeLinkDecorations();
      });
    })), this.toUnhook.add(o.onCancel(() => {
      this.removeLinkDecorations(), this.currentWordAtPosition = null;
    }));
  }
  static get(e) {
    return e.getContribution(kg.ID);
  }
  async startFindDefinitionFromCursor(e) {
    await this.startFindDefinition(e), this.toUnhookForKeyboard.add(this.editor.onDidChangeCursorPosition(() => {
      this.currentWordAtPosition = null, this.removeLinkDecorations(), this.toUnhookForKeyboard.clear();
    })), this.toUnhookForKeyboard.add(this.editor.onKeyDown((t) => {
      t && (this.currentWordAtPosition = null, this.removeLinkDecorations(), this.toUnhookForKeyboard.clear());
    }));
  }
  startFindDefinitionFromMouse(e, t) {
    if (e.target.type === 9 && this.linkDecorations.length > 0)
      return;
    if (!this.editor.hasModel() || !this.isEnabled(e, t)) {
      this.currentWordAtPosition = null, this.removeLinkDecorations();
      return;
    }
    const i = e.target.position;
    this.startFindDefinition(i);
  }
  async startFindDefinition(e) {
    var r;
    this.toUnhookForKeyboard.clear();
    const t = e ? (r = this.editor.getModel()) == null ? void 0 : r.getWordAtPosition(e) : null;
    if (!t) {
      this.currentWordAtPosition = null, this.removeLinkDecorations();
      return;
    }
    if (this.currentWordAtPosition && this.currentWordAtPosition.startColumn === t.startColumn && this.currentWordAtPosition.endColumn === t.endColumn && this.currentWordAtPosition.word === t.word)
      return;
    this.currentWordAtPosition = t;
    const i = new ZB(
      this.editor,
      15
      /* CodeEditorStateFlag.Scroll */
    );
    this.previousPromise && (this.previousPromise.cancel(), this.previousPromise = null), this.previousPromise = Za((a) => this.findDefinition(e, a));
    let n;
    try {
      n = await this.previousPromise;
    } catch (a) {
      Je(a);
      return;
    }
    if (!n || !n.length || !i.validate(this.editor)) {
      this.removeLinkDecorations();
      return;
    }
    const o = n[0].originSelectionRange ? T.lift(n[0].originSelectionRange) : new T(e.lineNumber, t.startColumn, e.lineNumber, t.endColumn);
    if (n.length > 1) {
      let a = o;
      for (const { originSelectionRange: l } of n)
        l && (a = T.plusRange(a, l));
      this.addDecoration(a, new Oo().appendText(m("multipleResults", "Click to show {0} definitions.", n.length)));
    } else {
      const a = n[0];
      if (!a.uri)
        return;
      this.textModelResolverService.createModelReference(a.uri).then((l) => {
        if (!l.object || !l.object.textEditorModel) {
          l.dispose();
          return;
        }
        const { object: { textEditorModel: c } } = l, { startLineNumber: h } = a.range;
        if (h < 1 || h > c.getLineCount()) {
          l.dispose();
          return;
        }
        const d = this.getPreviewValue(c, h, a), u = this.languageService.guessLanguageIdByFilepathOrFirstLine(c.uri);
        this.addDecoration(o, d ? new Oo().appendCodeblock(u || "", d) : void 0), l.dispose();
      });
    }
  }
  getPreviewValue(e, t, i) {
    let n = i.range;
    return n.endLineNumber - n.startLineNumber >= kg.MAX_SOURCE_PREVIEW_LINES && (n = this.getPreviewRangeBasedOnIndentation(e, t)), this.stripIndentationFromPreviewRange(e, t, n);
  }
  stripIndentationFromPreviewRange(e, t, i) {
    let o = e.getLineFirstNonWhitespaceColumn(t);
    for (let a = t + 1; a < i.endLineNumber; a++) {
      const l = e.getLineFirstNonWhitespaceColumn(a);
      o = Math.min(o, l);
    }
    return e.getValueInRange(i).replace(new RegExp(`^\\s{${o - 1}}`, "gm"), "").trim();
  }
  getPreviewRangeBasedOnIndentation(e, t) {
    const i = e.getLineFirstNonWhitespaceColumn(t), n = Math.min(e.getLineCount(), t + kg.MAX_SOURCE_PREVIEW_LINES);
    let o = t + 1;
    for (; o < n; o++) {
      const r = e.getLineFirstNonWhitespaceColumn(o);
      if (i === r)
        break;
    }
    return new T(t, 1, o + 1, 1);
  }
  addDecoration(e, t) {
    const i = {
      range: e,
      options: {
        description: "goto-definition-link",
        inlineClassName: "goto-definition-link",
        hoverMessage: t
      }
    };
    this.linkDecorations.set([i]);
  }
  removeLinkDecorations() {
    this.linkDecorations.clear();
  }
  isEnabled(e, t) {
    var i;
    return this.editor.hasModel() && e.isLeftClick && e.isNoneOrSingleMouseDown && e.target.type === 6 && !(((i = e.target.detail.injectedText) == null ? void 0 : i.options) instanceof Jl) && (e.hasTriggerModifier || (t ? t.keyCodeIsTriggerKey : !1)) && this.languageFeaturesService.definitionProvider.has(this.editor.getModel());
  }
  findDefinition(e, t) {
    const i = this.editor.getModel();
    return i ? zw(this.languageFeaturesService.definitionProvider, i, e, !1, t) : Promise.resolve(null);
  }
  gotoDefinition(e, t) {
    return this.editor.setPosition(e), this.editor.invokeWithinContext((i) => {
      const n = !t && this.editor.getOption(
        89
        /* EditorOption.definitionLinkOpensInPeek */
      ) && !this.isInPeekEditor(i);
      return new Gp({ openToSide: t, openInPeek: n, muteMessage: !0 }, { title: { value: "", original: "" }, id: "", precondition: void 0 }).run(i);
    });
  }
  isInPeekEditor(e) {
    const t = e.get(Fe);
    return On.inPeekEditor.getValue(t);
  }
  dispose() {
    this.toUnhook.dispose(), this.toUnhookForKeyboard.dispose();
  }
}, kg = Hl, Hl.ID = "editor.contrib.gotodefinitionatposition", Hl.MAX_SOURCE_PREVIEW_LINES = 8, Hl);
dp = kg = iJ([
  ly(1, bo),
  ly(2, ci),
  ly(3, De)
], dp);
Xa(
  dp.ID,
  dp,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
const T_ = he, nJ = {
  keybindingLabelBackground: void 0,
  keybindingLabelForeground: void 0,
  keybindingLabelBorder: void 0,
  keybindingLabelBottomBorder: void 0,
  keybindingLabelShadow: void 0
};
class Zp extends U {
  constructor(e, t, i) {
    super(), this.os = t, this.keyElements = /* @__PURE__ */ new Set(), this.options = i || /* @__PURE__ */ Object.create(null);
    const n = this.options.keybindingLabelForeground;
    this.domNode = te(e, T_(".monaco-keybinding")), n && (this.domNode.style.color = n), this.hover = this._register(jr().setupManagedHover($s("mouse"), this.domNode, "")), this.didEverRender = !1, e.appendChild(this.domNode);
  }
  get element() {
    return this.domNode;
  }
  set(e, t) {
    this.didEverRender && this.keybinding === e && Zp.areSame(this.matches, t) || (this.keybinding = e, this.matches = t, this.render());
  }
  render() {
    if (this.clear(), this.keybinding) {
      const e = this.keybinding.getChords();
      e[0] && this.renderChord(this.domNode, e[0], this.matches ? this.matches.firstPart : null);
      for (let i = 1; i < e.length; i++)
        te(this.domNode, T_("span.monaco-keybinding-key-chord-separator", void 0, " ")), this.renderChord(this.domNode, e[i], this.matches ? this.matches.chordPart : null);
      const t = this.options.disableTitle ?? !1 ? void 0 : this.keybinding.getAriaLabel() || void 0;
      this.hover.update(t), this.domNode.setAttribute("aria-label", t || "");
    } else this.options && this.options.renderUnboundKeybindings && this.renderUnbound(this.domNode);
    this.didEverRender = !0;
  }
  clear() {
    ks(this.domNode), this.keyElements.clear();
  }
  renderChord(e, t, i) {
    const n = YI.modifierLabels[this.os];
    t.ctrlKey && this.renderKey(e, n.ctrlKey, !!(i != null && i.ctrlKey), n.separator), t.shiftKey && this.renderKey(e, n.shiftKey, !!(i != null && i.shiftKey), n.separator), t.altKey && this.renderKey(e, n.altKey, !!(i != null && i.altKey), n.separator), t.metaKey && this.renderKey(e, n.metaKey, !!(i != null && i.metaKey), n.separator);
    const o = t.keyLabel;
    o && this.renderKey(e, o, !!(i != null && i.keyCode), "");
  }
  renderKey(e, t, i, n) {
    te(e, this.createKeyElement(t, i ? ".highlight" : "")), n && te(e, T_("span.monaco-keybinding-key-separator", void 0, n));
  }
  renderUnbound(e) {
    te(e, this.createKeyElement(m("unbound", "Unbound")));
  }
  createKeyElement(e, t = "") {
    const i = T_("span.monaco-keybinding-key" + t, void 0, e);
    return this.keyElements.add(i), this.options.keybindingLabelBackground && (i.style.backgroundColor = this.options.keybindingLabelBackground), this.options.keybindingLabelBorder && (i.style.borderColor = this.options.keybindingLabelBorder), this.options.keybindingLabelBottomBorder && (i.style.borderBottomColor = this.options.keybindingLabelBottomBorder), this.options.keybindingLabelShadow && (i.style.boxShadow = `inset 0 -1px 0 ${this.options.keybindingLabelShadow}`), i;
  }
  static areSame(e, t) {
    return e === t || !e && !t ? !0 : !!e && !!t && Xn(e.firstPart, t.firstPart) && Xn(e.chordPart, t.chordPart);
  }
}
const sJ = "editor.action.inlineSuggest.showPrevious", oJ = "editor.action.inlineSuggest.showNext";
class rJ extends U {
  constructor(e, t, i = {
    orientation: 0
    /* ActionsOrientation.HORIZONTAL */
  }) {
    super(), this.submenuActionViewItems = [], this.hasSecondaryActions = !1, this._onDidChangeDropdownVisibility = this._register(new s8()), this.onDidChangeDropdownVisibility = this._onDidChangeDropdownVisibility.event, this.disposables = this._register(new ne()), i.hoverDelegate = i.hoverDelegate ?? this._register(zE()), this.options = i, this.toggleMenuAction = this._register(new up(() => {
      var n;
      return (n = this.toggleMenuActionViewItem) == null ? void 0 : n.show();
    }, i.toggleMenuTitle)), this.element = document.createElement("div"), this.element.className = "monaco-toolbar", e.appendChild(this.element), this.actionBar = this._register(new $o(this.element, {
      orientation: i.orientation,
      ariaLabel: i.ariaLabel,
      actionRunner: i.actionRunner,
      allowContextMenu: i.allowContextMenu,
      highlightToggledItems: i.highlightToggledItems,
      hoverDelegate: i.hoverDelegate,
      actionViewItemProvider: (n, o) => {
        if (n.id === up.ID)
          return this.toggleMenuActionViewItem = new B1(n, n.menuActions, t, {
            actionViewItemProvider: this.options.actionViewItemProvider,
            actionRunner: this.actionRunner,
            keybindingProvider: this.options.getKeyBinding,
            classNames: Te.asClassNameArray(i.moreIcon ?? ie.toolBarMore),
            anchorAlignmentProvider: this.options.anchorAlignmentProvider,
            menuAsChild: !!this.options.renderDropdownAsChildElement,
            skipTelemetry: this.options.skipTelemetry,
            isMenu: !0,
            hoverDelegate: this.options.hoverDelegate
          }), this.toggleMenuActionViewItem.setActionContext(this.actionBar.context), this.disposables.add(this._onDidChangeDropdownVisibility.add(this.toggleMenuActionViewItem.onDidChangeVisibility)), this.toggleMenuActionViewItem;
        if (i.actionViewItemProvider) {
          const r = i.actionViewItemProvider(n, o);
          if (r)
            return r;
        }
        if (n instanceof Wv) {
          const r = new B1(n, n.actions, t, {
            actionViewItemProvider: this.options.actionViewItemProvider,
            actionRunner: this.actionRunner,
            keybindingProvider: this.options.getKeyBinding,
            classNames: n.class,
            anchorAlignmentProvider: this.options.anchorAlignmentProvider,
            menuAsChild: !!this.options.renderDropdownAsChildElement,
            skipTelemetry: this.options.skipTelemetry,
            hoverDelegate: this.options.hoverDelegate
          });
          return r.setActionContext(this.actionBar.context), this.submenuActionViewItems.push(r), this.disposables.add(this._onDidChangeDropdownVisibility.add(r.onDidChangeVisibility)), r;
        }
      }
    }));
  }
  set actionRunner(e) {
    this.actionBar.actionRunner = e;
  }
  get actionRunner() {
    return this.actionBar.actionRunner;
  }
  getElement() {
    return this.element;
  }
  getItemAction(e) {
    return this.actionBar.getAction(e);
  }
  setActions(e, t) {
    this.clear();
    const i = e ? e.slice(0) : [];
    this.hasSecondaryActions = !!(t && t.length > 0), this.hasSecondaryActions && t && (this.toggleMenuAction.menuActions = t.slice(0), i.push(this.toggleMenuAction)), i.forEach((n) => {
      this.actionBar.push(n, { icon: this.options.icon ?? !0, label: this.options.label ?? !1, keybinding: this.getKeybindingLabel(n) });
    });
  }
  getKeybindingLabel(e) {
    var i, n;
    const t = (n = (i = this.options).getKeyBinding) == null ? void 0 : n.call(i, e);
    return (t == null ? void 0 : t.getLabel()) ?? void 0;
  }
  clear() {
    this.submenuActionViewItems = [], this.disposables.clear(), this.actionBar.clear();
  }
  dispose() {
    this.clear(), this.disposables.dispose(), super.dispose();
  }
}
const pv = class pv extends ys {
  constructor(e, t) {
    t = t || m("moreActions", "More Actions..."), super(pv.ID, t, void 0, !0), this._menuActions = [], this.toggleDropdownMenu = e;
  }
  async run() {
    this.toggleDropdownMenu();
  }
  get menuActions() {
    return this._menuActions;
  }
  set menuActions(e) {
    this._menuActions = e;
  }
};
pv.ID = "toolbar.toggle.more";
let up = pv;
function aJ(s, e) {
  const t = [], i = [];
  for (const n of s)
    e.has(n) || t.push(n);
  for (const n of e)
    s.has(n) || i.push(n);
  return { removed: t, added: i };
}
function lJ(s, e) {
  const t = /* @__PURE__ */ new Set();
  for (const i of e)
    s.has(i) && t.add(i);
  return t;
}
var Uw = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Ar = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, zd, xg;
let KL = class {
  constructor(e, t, i) {
    this._commandService = e, this._keybindingService = t, this._hiddenStates = new jL(i);
  }
  createMenu(e, t, i) {
    return new Y1(e, this._hiddenStates, { emitEventsForSubmenuChanges: !1, eventDebounceDelay: 50, ...i }, this._commandService, this._keybindingService, t);
  }
  getMenuActions(e, t, i) {
    const n = new Y1(e, this._hiddenStates, { emitEventsForSubmenuChanges: !1, eventDebounceDelay: 50, ...i }, this._commandService, this._keybindingService, t), o = n.getActions(i);
    return n.dispose(), o;
  }
  resetHiddenStates(e) {
    this._hiddenStates.reset(e);
  }
};
KL = Uw([
  Ar(0, fi),
  Ar(1, Lt),
  Ar(2, zp)
], KL);
var kh;
let jL = (kh = class {
  constructor(e) {
    this._storageService = e, this._disposables = new ne(), this._onDidChange = new A(), this.onDidChange = this._onDidChange.event, this._ignoreChangeEvent = !1, this._hiddenByDefaultCache = /* @__PURE__ */ new Map();
    try {
      const t = e.get(zd._key, 0, "{}");
      this._data = JSON.parse(t);
    } catch {
      this._data = /* @__PURE__ */ Object.create(null);
    }
    this._disposables.add(e.onDidChangeValue(0, zd._key, this._disposables)(() => {
      if (!this._ignoreChangeEvent)
        try {
          const t = e.get(zd._key, 0, "{}");
          this._data = JSON.parse(t);
        } catch (t) {
          console.log("FAILED to read storage after UPDATE", t);
        }
      this._onDidChange.fire();
    }));
  }
  dispose() {
    this._onDidChange.dispose(), this._disposables.dispose();
  }
  _isHiddenByDefault(e, t) {
    return this._hiddenByDefaultCache.get(`${e.id}/${t}`) ?? !1;
  }
  setDefaultState(e, t, i) {
    this._hiddenByDefaultCache.set(`${e.id}/${t}`, i);
  }
  isHidden(e, t) {
    var o;
    const i = this._isHiddenByDefault(e, t), n = ((o = this._data[e.id]) == null ? void 0 : o.includes(t)) ?? !1;
    return i ? !n : n;
  }
  updateHidden(e, t, i) {
    this._isHiddenByDefault(e, t) && (i = !i);
    const o = this._data[e.id];
    if (i)
      o ? o.indexOf(t) < 0 && o.push(t) : this._data[e.id] = [t];
    else if (o) {
      const r = o.indexOf(t);
      r >= 0 && JB(o, r), o.length === 0 && delete this._data[e.id];
    }
    this._persist();
  }
  reset(e) {
    if (e === void 0)
      this._data = /* @__PURE__ */ Object.create(null), this._persist();
    else {
      for (const { id: t } of e)
        this._data[t] && delete this._data[t];
      this._persist();
    }
  }
  _persist() {
    try {
      this._ignoreChangeEvent = !0;
      const e = JSON.stringify(this._data);
      this._storageService.store(
        zd._key,
        e,
        0,
        0
        /* StorageTarget.USER */
      );
    } finally {
      this._ignoreChangeEvent = !1;
    }
  }
}, zd = kh, kh._key = "menu.hiddenCommands", kh);
jL = zd = Uw([
  Ar(0, zp)
], jL);
class Qg {
  constructor(e, t) {
    this._id = e, this._collectContextKeysForSubmenus = t, this._menuGroups = [], this._allMenuIds = /* @__PURE__ */ new Set(), this._structureContextKeys = /* @__PURE__ */ new Set(), this._preconditionContextKeys = /* @__PURE__ */ new Set(), this._toggledContextKeys = /* @__PURE__ */ new Set(), this.refresh();
  }
  get allMenuIds() {
    return this._allMenuIds;
  }
  get structureContextKeys() {
    return this._structureContextKeys;
  }
  get preconditionContextKeys() {
    return this._preconditionContextKeys;
  }
  get toggledContextKeys() {
    return this._toggledContextKeys;
  }
  refresh() {
    this._menuGroups.length = 0, this._allMenuIds.clear(), this._structureContextKeys.clear(), this._preconditionContextKeys.clear(), this._toggledContextKeys.clear();
    const e = this._sort(so.getMenuItems(this._id));
    let t;
    for (const i of e) {
      const n = i.group || "";
      (!t || t[0] !== n) && (t = [n, []], this._menuGroups.push(t)), t[1].push(i), this._collectContextKeysAndSubmenuIds(i);
    }
    this._allMenuIds.add(this._id);
  }
  _sort(e) {
    return e;
  }
  _collectContextKeysAndSubmenuIds(e) {
    if (Qg._fillInKbExprKeys(e.when, this._structureContextKeys), Nu(e)) {
      if (e.command.precondition && Qg._fillInKbExprKeys(e.command.precondition, this._preconditionContextKeys), e.command.toggled) {
        const t = e.command.toggled.condition || e.command.toggled;
        Qg._fillInKbExprKeys(t, this._toggledContextKeys);
      }
    } else this._collectContextKeysForSubmenus && (so.getMenuItems(e.submenu).forEach(this._collectContextKeysAndSubmenuIds, this), this._allMenuIds.add(e.submenu));
  }
  static _fillInKbExprKeys(e, t) {
    if (e)
      for (const i of e.keys())
        t.add(i);
  }
}
let qL = xg = class extends Qg {
  constructor(e, t, i, n, o, r) {
    super(e, i), this._hiddenStates = t, this._commandService = n, this._keybindingService = o, this._contextKeyService = r, this.refresh();
  }
  createActionGroups(e) {
    const t = [];
    for (const i of this._menuGroups) {
      const [n, o] = i;
      let r;
      for (const a of o)
        if (this._contextKeyService.contextMatchesRules(a.when)) {
          const l = Nu(a);
          l && this._hiddenStates.setDefaultState(this._id, a.command.id, !!a.isHiddenByDefault);
          const c = cJ(this._id, l ? a.command : a, this._hiddenStates);
          if (l) {
            const h = c7(this._commandService, this._keybindingService, a.command.id, a.when);
            (r ?? (r = [])).push(new lo(a.command, a.alt, e, c, h, this._contextKeyService, this._commandService));
          } else {
            const h = new xg(a.submenu, this._hiddenStates, this._collectContextKeysForSubmenus, this._commandService, this._keybindingService, this._contextKeyService).createActionGroups(e), d = Vi.join(...h.map((u) => u[1]));
            d.length > 0 && (r ?? (r = [])).push(new Rg(a, c, d));
          }
        }
      r && r.length > 0 && t.push([n, r]);
    }
    return t;
  }
  _sort(e) {
    return e.sort(xg._compareMenuItems);
  }
  static _compareMenuItems(e, t) {
    const i = e.group, n = t.group;
    if (i !== n) {
      if (i) {
        if (!n)
          return -1;
      } else return 1;
      if (i === "navigation")
        return -1;
      if (n === "navigation")
        return 1;
      const a = i.localeCompare(n);
      if (a !== 0)
        return a;
    }
    const o = e.order || 0, r = t.order || 0;
    return o < r ? -1 : o > r ? 1 : xg._compareTitles(Nu(e) ? e.command.title : e.title, Nu(t) ? t.command.title : t.title);
  }
  static _compareTitles(e, t) {
    const i = typeof e == "string" ? e : e.original, n = typeof t == "string" ? t : t.original;
    return i.localeCompare(n);
  }
};
qL = xg = Uw([
  Ar(3, fi),
  Ar(4, Lt),
  Ar(5, Fe)
], qL);
let Y1 = class {
  constructor(e, t, i, n, o, r) {
    this._disposables = new ne(), this._menuInfo = new qL(e, t, i.emitEventsForSubmenuChanges, n, o, r);
    const a = new ai(() => {
      this._menuInfo.refresh(), this._onDidChange.fire({ menu: this, isStructuralChange: !0, isEnablementChange: !0, isToggleChange: !0 });
    }, i.eventDebounceDelay);
    this._disposables.add(a), this._disposables.add(so.onDidChangeMenu((d) => {
      for (const u of this._menuInfo.allMenuIds)
        if (d.has(u)) {
          a.schedule();
          break;
        }
    }));
    const l = this._disposables.add(new ne()), c = (d) => {
      let u = !1, f = !1, g = !1;
      for (const p of d)
        if (u = u || p.isStructuralChange, f = f || p.isEnablementChange, g = g || p.isToggleChange, u && f && g)
          break;
      return { menu: this, isStructuralChange: u, isEnablementChange: f, isToggleChange: g };
    }, h = () => {
      l.add(r.onDidChangeContext((d) => {
        const u = d.affectsSome(this._menuInfo.structureContextKeys), f = d.affectsSome(this._menuInfo.preconditionContextKeys), g = d.affectsSome(this._menuInfo.toggledContextKeys);
        (u || f || g) && this._onDidChange.fire({ menu: this, isStructuralChange: u, isEnablementChange: f, isToggleChange: g });
      })), l.add(t.onDidChange((d) => {
        this._onDidChange.fire({ menu: this, isStructuralChange: !0, isEnablementChange: !1, isToggleChange: !1 });
      }));
    };
    this._onDidChange = new s4({
      // start/stop context key listener
      onWillAddFirstListener: h,
      onDidRemoveLastListener: l.clear.bind(l),
      delay: i.eventDebounceDelay,
      merge: c
    }), this.onDidChange = this._onDidChange.event;
  }
  getActions(e) {
    return this._menuInfo.createActionGroups(e);
  }
  dispose() {
    this._disposables.dispose(), this._onDidChange.dispose();
  }
};
Y1 = Uw([
  Ar(3, fi),
  Ar(4, Lt),
  Ar(5, Fe)
], Y1);
function cJ(s, e, t) {
  const i = j8(e) ? e.submenu.id : e.id, n = typeof e.title == "string" ? e.title : e.title.value, o = Iu({
    id: `hide/${s.id}/${i}`,
    label: m("hide.label", "Hide '{0}'", n),
    run() {
      t.updateHidden(s, i, !0);
    }
  }), r = Iu({
    id: `toggle/${s.id}/${i}`,
    label: n,
    get checked() {
      return !t.isHidden(s, i);
    },
    run() {
      t.updateHidden(s, i, !!this.checked);
    }
  });
  return {
    hide: o,
    toggle: r,
    get isHidden() {
      return !r.checked;
    }
  };
}
function c7(s, e, t, i = void 0, n = !0) {
  return Iu({
    id: `configureKeybinding/${t}`,
    label: m("configure keybinding", "Configure Keybinding"),
    enabled: n,
    run() {
      const r = !!!e.lookupKeybinding(t) && i ? i.serialize() : void 0;
      s.executeCommand("workbench.action.openGlobalKeybindings", `@command:${t}` + (r ? ` +when:${r}` : ""));
    }
  });
}
var h7 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, io = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let X1 = class extends rJ {
  constructor(e, t, i, n, o, r, a, l) {
    super(e, o, {
      // defaults
      getKeyBinding: (h) => r.lookupKeybinding(h.id) ?? void 0,
      // options (override defaults)
      ...t,
      // mandatory (overide options)
      allowContextMenu: !0,
      skipTelemetry: typeof (t == null ? void 0 : t.telemetrySource) == "string"
    }), this._options = t, this._menuService = i, this._contextKeyService = n, this._contextMenuService = o, this._keybindingService = r, this._commandService = a, this._sessionDisposables = this._store.add(new ne());
    const c = t == null ? void 0 : t.telemetrySource;
    c && this._store.add(this.actionBar.onDidRun((h) => l.publicLog2("workbenchActionExecuted", { id: h.action.id, from: c })));
  }
  setActions(e, t = [], i) {
    var h, d, u;
    this._sessionDisposables.clear();
    const n = e.slice(), o = t.slice(), r = [];
    let a = 0;
    const l = [];
    let c = !1;
    if (((h = this._options) == null ? void 0 : h.hiddenItemStrategy) !== -1)
      for (let f = 0; f < n.length; f++) {
        const g = n[f];
        !(g instanceof lo) && !(g instanceof Rg) || g.hideActions && (r.push(g.hideActions.toggle), g.hideActions.toggle.checked && a++, g.hideActions.isHidden && (c = !0, n[f] = void 0, ((d = this._options) == null ? void 0 : d.hiddenItemStrategy) !== 0 && (l[f] = g)));
      }
    if (((u = this._options) == null ? void 0 : u.overflowBehavior) !== void 0) {
      const f = lJ(new Set(this._options.overflowBehavior.exempted), nt.map(n, (_) => _ == null ? void 0 : _.id)), g = this._options.overflowBehavior.maxItems - f.size;
      let p = 0;
      for (let _ = 0; _ < n.length; _++) {
        const b = n[_];
        b && (p++, !f.has(b.id) && p >= g && (n[_] = void 0, l[_] = b));
      }
    }
    G2(n), G2(l), super.setActions(n, Vi.join(l, o)), (r.length > 0 || n.length > 0) && this._sessionDisposables.add(z(this.getElement(), "contextmenu", (f) => {
      var C, w, v, S, L;
      const g = new Uo(fe(this.getElement()), f), p = this.getItemAction(g.target);
      if (!p)
        return;
      g.preventDefault(), g.stopPropagation();
      const _ = [];
      if (p instanceof lo && p.menuKeybinding)
        _.push(p.menuKeybinding);
      else if (!(p instanceof Rg || p instanceof up)) {
        const k = !!this._keybindingService.lookupKeybinding(p.id);
        _.push(c7(this._commandService, this._keybindingService, p.id, void 0, k));
      }
      if (r.length > 0) {
        let k = !1;
        if (a === 1 && ((C = this._options) == null ? void 0 : C.hiddenItemStrategy) === 0) {
          k = !0;
          for (let x = 0; x < r.length; x++)
            if (r[x].checked) {
              r[x] = Iu({
                id: p.id,
                label: p.label,
                checked: !0,
                enabled: !1,
                run() {
                }
              });
              break;
            }
        }
        if (!k && (p instanceof lo || p instanceof Rg)) {
          if (!p.hideActions)
            return;
          _.push(p.hideActions.hide);
        } else
          _.push(Iu({
            id: "label",
            label: m("hide", "Hide"),
            enabled: !1,
            run() {
            }
          }));
      }
      const b = Vi.join(_, r);
      (w = this._options) != null && w.resetMenu && !i && (i = [this._options.resetMenu]), c && i && (b.push(new Vi()), b.push(Iu({
        id: "resetThisMenu",
        label: m("resetThisMenu", "Reset Menu"),
        run: () => this._menuService.resetHiddenStates(i)
      }))), b.length !== 0 && this._contextMenuService.showContextMenu({
        getAnchor: () => g,
        getActions: () => b,
        // add context menu actions (iff appicable)
        menuId: (v = this._options) == null ? void 0 : v.contextMenu,
        menuActionOptions: { renderShortTitle: !0, ...(S = this._options) == null ? void 0 : S.menuOptions },
        skipTelemetry: typeof ((L = this._options) == null ? void 0 : L.telemetrySource) == "string",
        contextKeyService: this._contextKeyService
      });
    }));
  }
};
X1 = h7([
  io(2, $r),
  io(3, Fe),
  io(4, nr),
  io(5, Lt),
  io(6, fi),
  io(7, Jo)
], X1);
let Q1 = class extends X1 {
  constructor(e, t, i, n, o, r, a, l, c) {
    super(e, { resetMenu: t, ...i }, n, o, r, a, l, c), this._onDidChangeMenuItems = this._store.add(new A()), this.onDidChangeMenuItems = this._onDidChangeMenuItems.event;
    const h = this._store.add(n.createMenu(t, o, { emitEventsForSubmenuChanges: !0 })), d = () => {
      var g, p, _;
      const u = [], f = [];
      XI(h, i == null ? void 0 : i.menuOptions, { primary: u, secondary: f }, (g = i == null ? void 0 : i.toolbarOptions) == null ? void 0 : g.primaryGroup, (p = i == null ? void 0 : i.toolbarOptions) == null ? void 0 : p.shouldInlineSubmenu, (_ = i == null ? void 0 : i.toolbarOptions) == null ? void 0 : _.useSeparatorsInPrimaryActions), e.classList.toggle("has-no-actions", u.length === 0 && f.length === 0), super.setActions(u, f);
    };
    this._store.add(h.onDidChange(() => {
      d(), this._onDidChangeMenuItems.fire(this);
    })), d();
  }
  /**
   * @deprecated The WorkbenchToolBar does not support this method because it works with menus.
   */
  setActions() {
    throw new at("This toolbar is populated from a menu.");
  }
};
Q1 = h7([
  io(3, $r),
  io(4, Fe),
  io(5, nr),
  io(6, Lt),
  io(7, fi),
  io(8, Jo)
], Q1);
const hJ = {
  IconContribution: "base.contributions.icons"
};
var hR;
(function(s) {
  function e(t, i) {
    let n = t.defaults;
    for (; Te.isThemeIcon(n); ) {
      const o = bd.getIcon(n.id);
      if (!o)
        return;
      n = o.defaults;
    }
    return n;
  }
  s.getDefinition = e;
})(hR || (hR = {}));
var dR;
(function(s) {
  function e(i) {
    return {
      weight: i.weight,
      style: i.style,
      src: i.src.map((n) => ({ format: n.format, location: n.location.toString() }))
    };
  }
  s.toJSONObject = e;
  function t(i) {
    const n = (o) => Ss(o) ? o : void 0;
    if (i && Array.isArray(i.src) && i.src.every((o) => Ss(o.format) && Ss(o.location)))
      return {
        weight: n(i.weight),
        style: n(i.style),
        src: i.src.map((o) => ({ format: o.format, location: we.parse(o.location) }))
      };
  }
  s.fromJSONObject = t;
})(dR || (dR = {}));
class dJ {
  constructor() {
    this._onDidChange = new A(), this.onDidChange = this._onDidChange.event, this.iconSchema = {
      definitions: {
        icons: {
          type: "object",
          properties: {
            fontId: { type: "string", description: m("iconDefinition.fontId", "The id of the font to use. If not set, the font that is defined first is used.") },
            fontCharacter: { type: "string", description: m("iconDefinition.fontCharacter", "The font character associated with the icon definition.") }
          },
          additionalProperties: !1,
          defaultSnippets: [{ body: { fontCharacter: "\\\\e030" } }]
        }
      },
      type: "object",
      properties: {}
    }, this.iconReferenceSchema = { type: "string", pattern: `^${Te.iconNameExpression}$`, enum: [], enumDescriptions: [] }, this.iconsById = {}, this.iconFontsById = {};
  }
  registerIcon(e, t, i, n) {
    const o = this.iconsById[e];
    if (o) {
      if (i && !o.description) {
        o.description = i, this.iconSchema.properties[e].markdownDescription = `${i} $(${e})`;
        const l = this.iconReferenceSchema.enum.indexOf(e);
        l !== -1 && (this.iconReferenceSchema.enumDescriptions[l] = i), this._onDidChange.fire();
      }
      return o;
    }
    const r = { id: e, description: i, defaults: t, deprecationMessage: n };
    this.iconsById[e] = r;
    const a = { $ref: "#/definitions/icons" };
    return n && (a.deprecationMessage = n), i && (a.markdownDescription = `${i}: $(${e})`), this.iconSchema.properties[e] = a, this.iconReferenceSchema.enum.push(e), this.iconReferenceSchema.enumDescriptions.push(i || ""), this._onDidChange.fire(), { id: e };
  }
  getIcons() {
    return Object.keys(this.iconsById).map((e) => this.iconsById[e]);
  }
  getIcon(e) {
    return this.iconsById[e];
  }
  getIconSchema() {
    return this.iconSchema;
  }
  toString() {
    const e = (o, r) => o.id.localeCompare(r.id), t = (o) => {
      for (; Te.isThemeIcon(o.defaults); )
        o = this.iconsById[o.defaults.id];
      return `codicon codicon-${o ? o.id : ""}`;
    }, i = [];
    i.push("| preview     | identifier                        | default codicon ID                | description"), i.push("| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |");
    const n = Object.keys(this.iconsById).map((o) => this.iconsById[o]);
    for (const o of n.filter((r) => !!r.description).sort(e))
      i.push(`|<i class="${t(o)}"></i>|${o.id}|${Te.isThemeIcon(o.defaults) ? o.defaults.id : o.id}|${o.description || ""}|`);
    i.push("| preview     | identifier                        "), i.push("| ----------- | --------------------------------- |");
    for (const o of n.filter((r) => !Te.isThemeIcon(r.defaults)).sort(e))
      i.push(`|<i class="${t(o)}"></i>|${o.id}|`);
    return i.join(`
`);
  }
}
const bd = new dJ();
Mi.add(hJ.IconContribution, bd);
function $i(s, e, t, i) {
  return bd.registerIcon(s, e, t, i);
}
function d7() {
  return bd;
}
function uJ() {
  const s = a4();
  for (const e in s) {
    const t = "\\" + s[e].toString(16);
    bd.registerIcon(e, { fontCharacter: t });
  }
}
uJ();
const u7 = "vscode://schemas/icons", f7 = Mi.as(gw.JSONContribution);
f7.registerSchema(u7, bd.getIconSchema());
const uR = new ai(() => f7.notifySchemaChanged(u7), 200);
bd.onDidChange(() => {
  uR.isScheduled() || uR.schedule();
});
$i("widget-close", ie.close, m("widgetClose", "Icon for the close action in widgets."));
$i("goto-previous-location", ie.arrowUp, m("previousChangeIcon", "Icon for goto previous editor location."));
$i("goto-next-location", ie.arrowDown, m("nextChangeIcon", "Icon for goto next editor location."));
Te.modify(ie.sync, "spin");
Te.modify(ie.loading, "spin");
var vN = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, no = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, vb;
let fR = class extends U {
  constructor(e, t, i) {
    super(), this.editor = e, this.model = t, this.instantiationService = i, this.alwaysShowToolbar = zt(this, this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      62
      /* EditorOption.inlineSuggest */
    ).showToolbar === "always"), this.sessionPosition = void 0, this.position = xe(this, (n) => {
      var l, c;
      const o = (l = this.model.read(n)) == null ? void 0 : l.primaryGhostText.read(n);
      if (!this.alwaysShowToolbar.read(n) || !o || o.parts.length === 0)
        return this.sessionPosition = void 0, null;
      const r = o.parts[0].column;
      this.sessionPosition && this.sessionPosition.lineNumber !== o.lineNumber && (this.sessionPosition = void 0);
      const a = new F(o.lineNumber, Math.min(r, ((c = this.sessionPosition) == null ? void 0 : c.column) ?? Number.MAX_SAFE_INTEGER));
      return this.sessionPosition = a, a;
    }), this._register(ho((n, o) => {
      const r = this.model.read(n);
      if (!r || !this.alwaysShowToolbar.read(n))
        return;
      const a = rd((c, h) => {
        const d = h.add(this.instantiationService.createInstance(J1, this.editor, !0, this.position, r.selectedInlineCompletionIndex, r.inlineCompletionsCount, r.activeCommands));
        return e.addContentWidget(d), h.add(_e(() => e.removeContentWidget(d))), h.add(Qe((u) => {
          this.position.read(u) && r.lastTriggerKind.read(u) !== VS.Explicit && r.triggerExplicitly();
        })), d;
      }), l = TO(this, (c, h) => !!this.position.read(c) || !!h);
      o.add(Qe((c) => {
        l.read(c) && a.read(c);
      }));
    }));
  }
};
fR = vN([
  no(2, Pe)
], fR);
const fJ = $i("inline-suggestion-hints-next", ie.chevronRight, m("parameterHintsNextIcon", "Icon for show next parameter hint.")), gJ = $i("inline-suggestion-hints-previous", ie.chevronLeft, m("parameterHintsPreviousIcon", "Icon for show previous parameter hint."));
var Vl;
let J1 = (Vl = class extends U {
  static get dropDownVisible() {
    return this._dropDownVisible;
  }
  createCommandAction(e, t, i) {
    const n = new ys(e, t, i, !0, () => this._commandService.executeCommand(e)), o = this.keybindingService.lookupKeybinding(e, this._contextKeyService);
    let r = t;
    return o && (r = m({ key: "content", comment: ["A label", "A keybinding"] }, "{0} ({1})", t, o.getLabel())), n.tooltip = r, n;
  }
  constructor(e, t, i, n, o, r, a, l, c, h, d) {
    super(), this.editor = e, this.withBorder = t, this._position = i, this._currentSuggestionIdx = n, this._suggestionCount = o, this._extraCommands = r, this._commandService = a, this.keybindingService = c, this._contextKeyService = h, this._menuService = d, this.id = `InlineSuggestionHintsContentWidget${vb.id++}`, this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this.nodes = Xe("div.inlineSuggestionsHints", { className: this.withBorder ? ".withBorder" : "" }, [
      Xe("div@toolBar")
    ]), this.previousAction = this.createCommandAction(sJ, m("previous", "Previous"), Te.asClassName(gJ)), this.availableSuggestionCountAction = new ys("inlineSuggestionHints.availableSuggestionCount", "", void 0, !1), this.nextAction = this.createCommandAction(oJ, m("next", "Next"), Te.asClassName(fJ)), this.inlineCompletionsActionsMenus = this._register(this._menuService.createMenu(et.InlineCompletionsActions, this._contextKeyService)), this.clearAvailableSuggestionCountLabelDebounced = this._register(new ai(() => {
      this.availableSuggestionCountAction.label = "";
    }, 100)), this.disableButtonsDebounced = this._register(new ai(() => {
      this.previousAction.enabled = this.nextAction.enabled = !1;
    }, 100)), this.toolBar = this._register(l.createInstance(GL, this.nodes.toolBar, et.InlineSuggestionToolbar, {
      menuOptions: { renderShortTitle: !0 },
      toolbarOptions: { primaryGroup: (u) => u.startsWith("primary") },
      actionViewItemProvider: (u, f) => {
        if (u instanceof lo)
          return l.createInstance(pJ, u, void 0);
        if (u === this.availableSuggestionCountAction) {
          const g = new mJ(void 0, u, { label: !0, icon: !1 });
          return g.setClass("availableSuggestionCount"), g;
        }
      },
      telemetrySource: "InlineSuggestionToolbar"
    })), this.toolBar.setPrependedPrimaryActions([
      this.previousAction,
      this.availableSuggestionCountAction,
      this.nextAction
    ]), this._register(this.toolBar.onDidChangeDropdownVisibility((u) => {
      vb._dropDownVisible = u;
    })), this._register(Qe((u) => {
      this._position.read(u), this.editor.layoutContentWidget(this);
    })), this._register(Qe((u) => {
      const f = this._suggestionCount.read(u), g = this._currentSuggestionIdx.read(u);
      f !== void 0 ? (this.clearAvailableSuggestionCountLabelDebounced.cancel(), this.availableSuggestionCountAction.label = `${g + 1}/${f}`) : this.clearAvailableSuggestionCountLabelDebounced.schedule(), f !== void 0 && f > 1 ? (this.disableButtonsDebounced.cancel(), this.previousAction.enabled = this.nextAction.enabled = !0) : this.disableButtonsDebounced.schedule();
    })), this._register(Qe((u) => {
      const g = this._extraCommands.read(u).map((p) => ({
        class: void 0,
        id: p.id,
        enabled: !0,
        tooltip: p.tooltip || "",
        label: p.title,
        run: (_) => this._commandService.executeCommand(p.id)
      }));
      for (const [p, _] of this.inlineCompletionsActionsMenus.getActions())
        for (const b of _)
          b instanceof lo && g.push(b);
      g.length > 0 && g.unshift(new Vi()), this.toolBar.setAdditionalSecondaryActions(g);
    }));
  }
  getId() {
    return this.id;
  }
  getDomNode() {
    return this.nodes.root;
  }
  getPosition() {
    return {
      position: this._position.get(),
      preference: [
        1,
        2
        /* ContentWidgetPositionPreference.BELOW */
      ],
      positionAffinity: 3
    };
  }
}, vb = Vl, Vl._dropDownVisible = !1, Vl.id = 0, Vl);
J1 = vb = vN([
  no(6, fi),
  no(7, Pe),
  no(8, Lt),
  no(9, Fe),
  no(10, $r)
], J1);
class mJ extends uw {
  constructor() {
    super(...arguments), this._className = void 0;
  }
  setClass(e) {
    this._className = e;
  }
  render(e) {
    super.render(e), this._className && e.classList.add(this._className);
  }
  updateTooltip() {
  }
}
class pJ extends bf {
  updateLabel() {
    const e = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);
    if (!e)
      return super.updateLabel();
    if (this.label) {
      const t = Xe("div.keybinding").root;
      this._register(new Zp(t, bs, { disableTitle: !0, ...nJ })).set(e), this.label.textContent = this._action.label, this.label.appendChild(t), this.label.classList.add("inlineSuggestionStatusBarItemLabel");
    }
  }
  updateTooltip() {
  }
}
let GL = class extends X1 {
  constructor(e, t, i, n, o, r, a, l, c) {
    super(e, { resetMenu: t, ...i }, n, o, r, a, l, c), this.menuId = t, this.options2 = i, this.menuService = n, this.contextKeyService = o, this.menu = this._store.add(this.menuService.createMenu(this.menuId, this.contextKeyService, { emitEventsForSubmenuChanges: !0 })), this.additionalActions = [], this.prependedPrimaryActions = [], this._store.add(this.menu.onDidChange(() => this.updateToolbar())), this.updateToolbar();
  }
  updateToolbar() {
    var i, n, o, r, a, l, c;
    const e = [], t = [];
    XI(this.menu, (i = this.options2) == null ? void 0 : i.menuOptions, { primary: e, secondary: t }, (o = (n = this.options2) == null ? void 0 : n.toolbarOptions) == null ? void 0 : o.primaryGroup, (a = (r = this.options2) == null ? void 0 : r.toolbarOptions) == null ? void 0 : a.shouldInlineSubmenu, (c = (l = this.options2) == null ? void 0 : l.toolbarOptions) == null ? void 0 : c.useSeparatorsInPrimaryActions), t.push(...this.additionalActions), e.unshift(...this.prependedPrimaryActions), this.setActions(e, t);
  }
  setPrependedPrimaryActions(e) {
    li(this.prependedPrimaryActions, e, (t, i) => t === i) || (this.prependedPrimaryActions = e, this.updateToolbar());
  }
  setAdditionalSecondaryActions(e) {
    li(this.additionalActions, e, (t, i) => t === i) || (this.additionalActions = e, this.updateToolbar());
  }
};
GL = vN([
  no(3, $r),
  no(4, Fe),
  no(5, nr),
  no(6, Lt),
  no(7, fi),
  no(8, Jo)
], GL);
function $w(s, e, t) {
  const i = ui(s);
  return !(e < i.left || e > i.left + i.width || t < i.top || t > i.top + i.height);
}
let _J = class {
  constructor(e, t, i) {
    this.value = e, this.isComplete = t, this.hasLoadingMessage = i;
  }
};
class g7 extends U {
  constructor(e, t) {
    super(), this._editor = e, this._computer = t, this._onResult = this._register(new A()), this.onResult = this._onResult.event, this._firstWaitScheduler = this._register(new ai(() => this._triggerAsyncComputation(), 0)), this._secondWaitScheduler = this._register(new ai(() => this._triggerSyncComputation(), 0)), this._loadingMessageScheduler = this._register(new ai(() => this._triggerLoadingMessage(), 0)), this._state = 0, this._asyncIterable = null, this._asyncIterableDone = !1, this._result = [];
  }
  dispose() {
    this._asyncIterable && (this._asyncIterable.cancel(), this._asyncIterable = null), super.dispose();
  }
  get _hoverTime() {
    return this._editor.getOption(
      60
      /* EditorOption.hover */
    ).delay;
  }
  get _firstWaitTime() {
    return this._hoverTime / 2;
  }
  get _secondWaitTime() {
    return this._hoverTime - this._firstWaitTime;
  }
  get _loadingMessageTime() {
    return 3 * this._hoverTime;
  }
  _setState(e, t = !0) {
    this._state = e, t && this._fireResult();
  }
  _triggerAsyncComputation() {
    this._setState(
      2
      /* HoverOperationState.SecondWait */
    ), this._secondWaitScheduler.schedule(this._secondWaitTime), this._computer.computeAsync ? (this._asyncIterableDone = !1, this._asyncIterable = u6((e) => this._computer.computeAsync(e)), (async () => {
      try {
        for await (const e of this._asyncIterable)
          e && (this._result.push(e), this._fireResult());
        this._asyncIterableDone = !0, (this._state === 3 || this._state === 4) && this._setState(
          0
          /* HoverOperationState.Idle */
        );
      } catch (e) {
        Je(e);
      }
    })()) : this._asyncIterableDone = !0;
  }
  _triggerSyncComputation() {
    this._computer.computeSync && (this._result = this._result.concat(this._computer.computeSync())), this._setState(
      this._asyncIterableDone ? 0 : 3
      /* HoverOperationState.WaitingForAsync */
    );
  }
  _triggerLoadingMessage() {
    this._state === 3 && this._setState(
      4
      /* HoverOperationState.WaitingForAsyncShowingLoading */
    );
  }
  _fireResult() {
    if (this._state === 1 || this._state === 2)
      return;
    const e = this._state === 0, t = this._state === 4;
    this._onResult.fire(new _J(this._result.slice(0), e, t));
  }
  start(e) {
    if (e === 0)
      this._state === 0 && (this._setState(
        1
        /* HoverOperationState.FirstWait */
      ), this._firstWaitScheduler.schedule(this._firstWaitTime), this._loadingMessageScheduler.schedule(this._loadingMessageTime));
    else
      switch (this._state) {
        case 0:
          this._triggerAsyncComputation(), this._secondWaitScheduler.cancel(), this._triggerSyncComputation();
          break;
        case 2:
          this._secondWaitScheduler.cancel(), this._triggerSyncComputation();
          break;
      }
  }
  cancel() {
    this._firstWaitScheduler.cancel(), this._secondWaitScheduler.cancel(), this._loadingMessageScheduler.cancel(), this._asyncIterable && (this._asyncIterable.cancel(), this._asyncIterable = null), this._result = [], this._setState(0, !1);
  }
}
class cy {
  constructor(e, t, i, n) {
    this.priority = e, this.range = t, this.initialMousePosX = i, this.initialMousePosY = n, this.type = 1;
  }
  equals(e) {
    return e.type === 1 && this.range.equalsRange(e.range);
  }
  canAdoptVisibleHover(e, t) {
    return e.type === 1 && t.lineNumber === this.range.startLineNumber;
  }
}
class bJ {
  constructor(e, t, i, n, o, r) {
    this.priority = e, this.owner = t, this.range = i, this.initialMousePosX = n, this.initialMousePosY = o, this.supportsMarkerHover = r, this.type = 2;
  }
  equals(e) {
    return e.type === 2 && this.owner === e.owner;
  }
  canAdoptVisibleHover(e, t) {
    return e.type === 2 && this.owner === e.owner;
  }
}
class fp {
  constructor(e) {
    this.renderedHoverParts = e;
  }
  dispose() {
    for (const e of this.renderedHoverParts)
      e.dispose();
  }
}
const wN = new class {
  constructor() {
    this._participants = [];
  }
  register(e) {
    this._participants.push(e);
  }
  getAll() {
    return this._participants;
  }
}();
class CJ {
  constructor() {
    this._onDidWillResize = new A(), this.onDidWillResize = this._onDidWillResize.event, this._onDidResize = new A(), this.onDidResize = this._onDidResize.event, this._sashListener = new ne(), this._size = new ti(0, 0), this._minSize = new ti(0, 0), this._maxSize = new ti(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER), this.domNode = document.createElement("div"), this._eastSash = new on(this.domNode, { getVerticalSashLeft: () => this._size.width }, {
      orientation: 0
      /* Orientation.VERTICAL */
    }), this._westSash = new on(this.domNode, { getVerticalSashLeft: () => 0 }, {
      orientation: 0
      /* Orientation.VERTICAL */
    }), this._northSash = new on(this.domNode, { getHorizontalSashTop: () => 0 }, { orientation: 1, orthogonalEdge: O1.North }), this._southSash = new on(this.domNode, { getHorizontalSashTop: () => this._size.height }, { orientation: 1, orthogonalEdge: O1.South }), this._northSash.orthogonalStartSash = this._westSash, this._northSash.orthogonalEndSash = this._eastSash, this._southSash.orthogonalStartSash = this._westSash, this._southSash.orthogonalEndSash = this._eastSash;
    let e, t = 0, i = 0;
    this._sashListener.add(ee.any(this._northSash.onDidStart, this._eastSash.onDidStart, this._southSash.onDidStart, this._westSash.onDidStart)(() => {
      e === void 0 && (this._onDidWillResize.fire(), e = this._size, t = 0, i = 0);
    })), this._sashListener.add(ee.any(this._northSash.onDidEnd, this._eastSash.onDidEnd, this._southSash.onDidEnd, this._westSash.onDidEnd)(() => {
      e !== void 0 && (e = void 0, t = 0, i = 0, this._onDidResize.fire({ dimension: this._size, done: !0 }));
    })), this._sashListener.add(this._eastSash.onDidChange((n) => {
      e && (i = n.currentX - n.startX, this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, east: !0 }));
    })), this._sashListener.add(this._westSash.onDidChange((n) => {
      e && (i = -(n.currentX - n.startX), this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, west: !0 }));
    })), this._sashListener.add(this._northSash.onDidChange((n) => {
      e && (t = -(n.currentY - n.startY), this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, north: !0 }));
    })), this._sashListener.add(this._southSash.onDidChange((n) => {
      e && (t = n.currentY - n.startY, this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, south: !0 }));
    })), this._sashListener.add(ee.any(this._eastSash.onDidReset, this._westSash.onDidReset)((n) => {
      this._preferredSize && (this.layout(this._size.height, this._preferredSize.width), this._onDidResize.fire({ dimension: this._size, done: !0 }));
    })), this._sashListener.add(ee.any(this._northSash.onDidReset, this._southSash.onDidReset)((n) => {
      this._preferredSize && (this.layout(this._preferredSize.height, this._size.width), this._onDidResize.fire({ dimension: this._size, done: !0 }));
    }));
  }
  dispose() {
    this._northSash.dispose(), this._southSash.dispose(), this._eastSash.dispose(), this._westSash.dispose(), this._sashListener.dispose(), this._onDidResize.dispose(), this._onDidWillResize.dispose(), this.domNode.remove();
  }
  enableSashes(e, t, i, n) {
    this._northSash.state = e ? 3 : 0, this._eastSash.state = t ? 3 : 0, this._southSash.state = i ? 3 : 0, this._westSash.state = n ? 3 : 0;
  }
  layout(e = this.size.height, t = this.size.width) {
    const { height: i, width: n } = this._minSize, { height: o, width: r } = this._maxSize;
    e = Math.max(i, Math.min(o, e)), t = Math.max(n, Math.min(r, t));
    const a = new ti(t, e);
    ti.equals(a, this._size) || (this.domNode.style.height = e + "px", this.domNode.style.width = t + "px", this._size = a, this._northSash.layout(), this._eastSash.layout(), this._southSash.layout(), this._westSash.layout());
  }
  clearSashHoverState() {
    this._eastSash.clearSashHoverState(), this._westSash.clearSashHoverState(), this._northSash.clearSashHoverState(), this._southSash.clearSashHoverState();
  }
  get size() {
    return this._size;
  }
  set maxSize(e) {
    this._maxSize = e;
  }
  get maxSize() {
    return this._maxSize;
  }
  set minSize(e) {
    this._minSize = e;
  }
  get minSize() {
    return this._minSize;
  }
  set preferredSize(e) {
    this._preferredSize = e;
  }
  get preferredSize() {
    return this._preferredSize;
  }
}
const vJ = 30, wJ = 24;
class yJ extends U {
  constructor(e, t = new ti(10, 10)) {
    super(), this._editor = e, this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this._resizableNode = this._register(new CJ()), this._contentPosition = null, this._isResizing = !1, this._resizableNode.domNode.style.position = "absolute", this._resizableNode.minSize = ti.lift(t), this._resizableNode.layout(t.height, t.width), this._resizableNode.enableSashes(!0, !0, !0, !0), this._register(this._resizableNode.onDidResize((i) => {
      this._resize(new ti(i.dimension.width, i.dimension.height)), i.done && (this._isResizing = !1);
    })), this._register(this._resizableNode.onDidWillResize(() => {
      this._isResizing = !0;
    }));
  }
  get isResizing() {
    return this._isResizing;
  }
  getDomNode() {
    return this._resizableNode.domNode;
  }
  getPosition() {
    return this._contentPosition;
  }
  get position() {
    var e;
    return (e = this._contentPosition) != null && e.position ? F.lift(this._contentPosition.position) : void 0;
  }
  _availableVerticalSpaceAbove(e) {
    const t = this._editor.getDomNode(), i = this._editor.getScrolledVisiblePosition(e);
    return !t || !i ? void 0 : ui(t).top + i.top - vJ;
  }
  _availableVerticalSpaceBelow(e) {
    const t = this._editor.getDomNode(), i = this._editor.getScrolledVisiblePosition(e);
    if (!t || !i)
      return;
    const n = ui(t), o = Im(t.ownerDocument.body), r = n.top + i.top + i.height;
    return o.height - r - wJ;
  }
  _findPositionPreference(e, t) {
    const i = Math.min(this._availableVerticalSpaceBelow(t) ?? 1 / 0, e), n = Math.min(this._availableVerticalSpaceAbove(t) ?? 1 / 0, e), o = Math.min(Math.max(n, i), e), r = Math.min(e, o);
    let a;
    return this._editor.getOption(
      60
      /* EditorOption.hover */
    ).above ? a = r <= n ? 1 : 2 : a = r <= i ? 2 : 1, a === 1 ? this._resizableNode.enableSashes(!0, !0, !1, !1) : this._resizableNode.enableSashes(!1, !0, !0, !1), a;
  }
  _resize(e) {
    this._resizableNode.layout(e.height, e.width);
  }
}
const M_ = he;
let yN = class extends U {
  constructor() {
    super(), this.containerDomNode = document.createElement("div"), this.containerDomNode.className = "monaco-hover", this.containerDomNode.tabIndex = 0, this.containerDomNode.setAttribute("role", "tooltip"), this.contentsDomNode = document.createElement("div"), this.contentsDomNode.className = "monaco-hover-content", this.scrollbar = this._register(new qE(this.contentsDomNode, {
      consumeMouseWheelIfScrollbarIsNeeded: !0
    })), this.containerDomNode.appendChild(this.scrollbar.getDomNode());
  }
  onContentsChanged() {
    this.scrollbar.scanDomNode();
  }
};
class Kw extends U {
  static render(e, t, i) {
    return new Kw(e, t, i);
  }
  constructor(e, t, i) {
    super(), this.actionLabel = t.label, this.actionKeybindingLabel = i, this.actionContainer = te(e, M_("div.action-container")), this.actionContainer.setAttribute("tabindex", "0"), this.action = te(this.actionContainer, M_("a.action")), this.action.setAttribute("role", "button"), t.iconClass && te(this.action, M_(`span.icon.${t.iconClass}`));
    const n = te(this.action, M_("span"));
    n.textContent = i ? `${t.label} (${i})` : t.label, this._store.add(new p7(this.actionContainer, t.run)), this._store.add(new _7(this.actionContainer, t.run, [
      3,
      10
      /* KeyCode.Space */
    ])), this.setEnabled(!0);
  }
  setEnabled(e) {
    e ? (this.actionContainer.classList.remove("disabled"), this.actionContainer.removeAttribute("aria-disabled")) : (this.actionContainer.classList.add("disabled"), this.actionContainer.setAttribute("aria-disabled", "true"));
  }
}
function m7(s, e) {
  return s && e ? m("acessibleViewHint", "Inspect this in the accessible view with {0}.", e) : s ? m("acessibleViewHintNoKbOpen", "Inspect this in the accessible view via the command Open Accessible View which is currently not triggerable via keybinding.") : "";
}
class p7 extends U {
  constructor(e, t) {
    super(), this._register(z(e, X.CLICK, (i) => {
      i.stopPropagation(), i.preventDefault(), t(e);
    }));
  }
}
class _7 extends U {
  constructor(e, t, i) {
    super(), this._register(z(e, X.KEY_DOWN, (n) => {
      const o = new Dt(n);
      i.some((r) => o.equals(r)) && (n.stopPropagation(), n.preventDefault(), t(e));
    }));
  }
}
var SJ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, R_ = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, gr;
const gR = 30, LJ = 6;
var zl;
let ZL = (zl = class extends yJ {
  get isVisibleFromKeyboard() {
    var e;
    return ((e = this._renderedHover) == null ? void 0 : e.source) === 1;
  }
  get isVisible() {
    return this._hoverVisibleKey.get() ?? !1;
  }
  get isFocused() {
    return this._hoverFocusedKey.get() ?? !1;
  }
  constructor(e, t, i, n, o) {
    const r = e.getOption(
      67
      /* EditorOption.lineHeight */
    ) + 8, a = 150, l = new ti(a, r);
    super(e, l), this._configurationService = i, this._accessibilityService = n, this._keybindingService = o, this._hover = this._register(new yN()), this._onDidResize = this._register(new A()), this.onDidResize = this._onDidResize.event, this._minimumSize = l, this._hoverVisibleKey = Z.hoverVisible.bindTo(t), this._hoverFocusedKey = Z.hoverFocused.bindTo(t), te(this._resizableNode.domNode, this._hover.containerDomNode), this._resizableNode.domNode.style.zIndex = "50", this._register(this._editor.onDidLayoutChange(() => {
      this.isVisible && this._updateMaxDimensions();
    })), this._register(this._editor.onDidChangeConfiguration((h) => {
      h.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) && this._updateFont();
    }));
    const c = this._register(Vh(this._resizableNode.domNode));
    this._register(c.onDidFocus(() => {
      this._hoverFocusedKey.set(!0);
    })), this._register(c.onDidBlur(() => {
      this._hoverFocusedKey.set(!1);
    })), this._setRenderedHover(void 0), this._editor.addContentWidget(this);
  }
  dispose() {
    var e;
    super.dispose(), (e = this._renderedHover) == null || e.dispose(), this._editor.removeContentWidget(this);
  }
  getId() {
    return gr.ID;
  }
  static _applyDimensions(e, t, i) {
    const n = typeof t == "number" ? `${t}px` : t, o = typeof i == "number" ? `${i}px` : i;
    e.style.width = n, e.style.height = o;
  }
  _setContentsDomNodeDimensions(e, t) {
    const i = this._hover.contentsDomNode;
    return gr._applyDimensions(i, e, t);
  }
  _setContainerDomNodeDimensions(e, t) {
    const i = this._hover.containerDomNode;
    return gr._applyDimensions(i, e, t);
  }
  _setHoverWidgetDimensions(e, t) {
    this._setContentsDomNodeDimensions(e, t), this._setContainerDomNodeDimensions(e, t), this._layoutContentWidget();
  }
  static _applyMaxDimensions(e, t, i) {
    const n = typeof t == "number" ? `${t}px` : t, o = typeof i == "number" ? `${i}px` : i;
    e.style.maxWidth = n, e.style.maxHeight = o;
  }
  _setHoverWidgetMaxDimensions(e, t) {
    gr._applyMaxDimensions(this._hover.contentsDomNode, e, t), gr._applyMaxDimensions(this._hover.containerDomNode, e, t), this._hover.containerDomNode.style.setProperty("--vscode-hover-maxWidth", typeof e == "number" ? `${e}px` : e), this._layoutContentWidget();
  }
  _setAdjustedHoverWidgetDimensions(e) {
    this._setHoverWidgetMaxDimensions("none", "none");
    const t = e.width, i = e.height;
    this._setHoverWidgetDimensions(t, i);
  }
  _updateResizableNodeMaxDimensions() {
    const e = this._findMaximumRenderingWidth() ?? 1 / 0, t = this._findMaximumRenderingHeight() ?? 1 / 0;
    this._resizableNode.maxSize = new ti(e, t), this._setHoverWidgetMaxDimensions(e, t);
  }
  _resize(e) {
    gr._lastDimensions = new ti(e.width, e.height), this._setAdjustedHoverWidgetDimensions(e), this._resizableNode.layout(e.height, e.width), this._updateResizableNodeMaxDimensions(), this._hover.scrollbar.scanDomNode(), this._editor.layoutContentWidget(this), this._onDidResize.fire();
  }
  _findAvailableSpaceVertically() {
    var t;
    const e = (t = this._renderedHover) == null ? void 0 : t.showAtPosition;
    if (e)
      return this._positionPreference === 1 ? this._availableVerticalSpaceAbove(e) : this._availableVerticalSpaceBelow(e);
  }
  _findMaximumRenderingHeight() {
    const e = this._findAvailableSpaceVertically();
    if (!e)
      return;
    let t = LJ;
    return Array.from(this._hover.contentsDomNode.children).forEach((i) => {
      t += i.clientHeight;
    }), Math.min(e, t);
  }
  _isHoverTextOverflowing() {
    this._hover.containerDomNode.style.setProperty("--vscode-hover-whiteSpace", "nowrap"), this._hover.containerDomNode.style.setProperty("--vscode-hover-sourceWhiteSpace", "nowrap");
    const e = Array.from(this._hover.contentsDomNode.children).some((t) => t.scrollWidth > t.clientWidth);
    return this._hover.containerDomNode.style.removeProperty("--vscode-hover-whiteSpace"), this._hover.containerDomNode.style.removeProperty("--vscode-hover-sourceWhiteSpace"), e;
  }
  _findMaximumRenderingWidth() {
    if (!this._editor || !this._editor.hasModel())
      return;
    const e = this._isHoverTextOverflowing(), t = typeof this._contentWidth > "u" ? 0 : this._contentWidth - 2;
    return e || this._hover.containerDomNode.clientWidth < t ? Im(this._hover.containerDomNode.ownerDocument.body).width - 14 : this._hover.containerDomNode.clientWidth + 2;
  }
  isMouseGettingCloser(e, t) {
    if (!this._renderedHover)
      return !1;
    if (this._renderedHover.initialMousePosX === void 0 || this._renderedHover.initialMousePosY === void 0)
      return this._renderedHover.initialMousePosX = e, this._renderedHover.initialMousePosY = t, !1;
    const i = ui(this.getDomNode());
    this._renderedHover.closestMouseDistance === void 0 && (this._renderedHover.closestMouseDistance = mR(this._renderedHover.initialMousePosX, this._renderedHover.initialMousePosY, i.left, i.top, i.width, i.height));
    const n = mR(e, t, i.left, i.top, i.width, i.height);
    return n > this._renderedHover.closestMouseDistance + 4 ? !1 : (this._renderedHover.closestMouseDistance = Math.min(this._renderedHover.closestMouseDistance, n), !0);
  }
  _setRenderedHover(e) {
    var t;
    (t = this._renderedHover) == null || t.dispose(), this._renderedHover = e, this._hoverVisibleKey.set(!!e), this._hover.containerDomNode.classList.toggle("hidden", !e);
  }
  _updateFont() {
    const { fontSize: e, lineHeight: t } = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    ), i = this._hover.contentsDomNode;
    i.style.fontSize = `${e}px`, i.style.lineHeight = `${t / e}`, Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code")).forEach((o) => this._editor.applyFontInfo(o));
  }
  _updateContent(e) {
    const t = this._hover.contentsDomNode;
    t.style.paddingBottom = "", t.textContent = "", t.appendChild(e);
  }
  _layoutContentWidget() {
    this._editor.layoutContentWidget(this), this._hover.onContentsChanged();
  }
  _updateMaxDimensions() {
    const e = Math.max(this._editor.getLayoutInfo().height / 4, 250, gr._lastDimensions.height), t = Math.max(this._editor.getLayoutInfo().width * 0.66, 500, gr._lastDimensions.width);
    this._setHoverWidgetMaxDimensions(t, e);
  }
  _render(e) {
    this._setRenderedHover(e), this._updateFont(), this._updateContent(e.domNode), this._updateMaxDimensions(), this.onContentsChanged(), this._editor.render();
  }
  getPosition() {
    return this._renderedHover ? {
      position: this._renderedHover.showAtPosition,
      secondaryPosition: this._renderedHover.showAtSecondaryPosition,
      positionAffinity: this._renderedHover.shouldAppearBeforeContent ? 3 : void 0,
      preference: [
        this._positionPreference ?? 1
        /* ContentWidgetPositionPreference.ABOVE */
      ]
    } : null;
  }
  show(e) {
    var r;
    if (!this._editor || !this._editor.hasModel())
      return;
    this._render(e);
    const t = Xc(this._hover.containerDomNode), i = e.showAtPosition;
    this._positionPreference = this._findPositionPreference(t, i) ?? 1, this.onContentsChanged(), e.shouldFocus && this._hover.containerDomNode.focus(), this._onDidResize.fire();
    const o = this._hover.containerDomNode.ownerDocument.activeElement === this._hover.containerDomNode && m7(this._configurationService.getValue("accessibility.verbosity.hover") === !0 && this._accessibilityService.isScreenReaderOptimized(), ((r = this._keybindingService.lookupKeybinding("editor.action.accessibleView")) == null ? void 0 : r.getAriaLabel()) ?? "");
    o && (this._hover.contentsDomNode.ariaLabel = this._hover.contentsDomNode.textContent + ", " + o);
  }
  hide() {
    if (!this._renderedHover)
      return;
    const e = this._renderedHover.shouldFocus || this._hoverFocusedKey.get();
    this._setRenderedHover(void 0), this._resizableNode.maxSize = new ti(1 / 0, 1 / 0), this._resizableNode.clearSashHoverState(), this._hoverFocusedKey.set(!1), this._editor.layoutContentWidget(this), e && this._editor.focus();
  }
  _removeConstraintsRenderNormally() {
    const e = this._editor.getLayoutInfo();
    this._resizableNode.layout(e.height, e.width), this._setHoverWidgetDimensions("auto", "auto");
  }
  setMinimumDimensions(e) {
    this._minimumSize = new ti(Math.max(this._minimumSize.width, e.width), Math.max(this._minimumSize.height, e.height)), this._updateMinimumWidth();
  }
  _updateMinimumWidth() {
    const e = typeof this._contentWidth > "u" ? this._minimumSize.width : Math.min(this._contentWidth, this._minimumSize.width);
    this._resizableNode.minSize = new ti(e, this._minimumSize.height);
  }
  onContentsChanged() {
    var n;
    this._removeConstraintsRenderNormally();
    const e = this._hover.containerDomNode;
    let t = Xc(e), i = Nm(e);
    if (this._resizableNode.layout(t, i), this._setHoverWidgetDimensions(i, t), t = Xc(e), i = Nm(e), this._contentWidth = i, this._updateMinimumWidth(), this._resizableNode.layout(t, i), (n = this._renderedHover) != null && n.showAtPosition) {
      const o = Xc(this._hover.containerDomNode);
      this._positionPreference = this._findPositionPreference(o, this._renderedHover.showAtPosition);
    }
    this._layoutContentWidget();
  }
  focus() {
    this._hover.containerDomNode.focus();
  }
  scrollUp() {
    const e = this._hover.scrollbar.getScrollPosition().scrollTop, t = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    );
    this._hover.scrollbar.setScrollPosition({ scrollTop: e - t.lineHeight });
  }
  scrollDown() {
    const e = this._hover.scrollbar.getScrollPosition().scrollTop, t = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    );
    this._hover.scrollbar.setScrollPosition({ scrollTop: e + t.lineHeight });
  }
  scrollLeft() {
    const e = this._hover.scrollbar.getScrollPosition().scrollLeft;
    this._hover.scrollbar.setScrollPosition({ scrollLeft: e - gR });
  }
  scrollRight() {
    const e = this._hover.scrollbar.getScrollPosition().scrollLeft;
    this._hover.scrollbar.setScrollPosition({ scrollLeft: e + gR });
  }
  pageUp() {
    const e = this._hover.scrollbar.getScrollPosition().scrollTop, t = this._hover.scrollbar.getScrollDimensions().height;
    this._hover.scrollbar.setScrollPosition({ scrollTop: e - t });
  }
  pageDown() {
    const e = this._hover.scrollbar.getScrollPosition().scrollTop, t = this._hover.scrollbar.getScrollDimensions().height;
    this._hover.scrollbar.setScrollPosition({ scrollTop: e + t });
  }
  goToTop() {
    this._hover.scrollbar.setScrollPosition({ scrollTop: 0 });
  }
  goToBottom() {
    this._hover.scrollbar.setScrollPosition({ scrollTop: this._hover.scrollbar.getScrollDimensions().scrollHeight });
  }
}, gr = zl, zl.ID = "editor.contrib.resizableContentHoverWidget", zl._lastDimensions = new ti(0, 0), zl);
ZL = gr = SJ([
  R_(1, Fe),
  R_(2, gt),
  R_(3, Ks),
  R_(4, Lt)
], ZL);
function mR(s, e, t, i, n, o) {
  const r = t + n / 2, a = i + o / 2, l = Math.max(Math.abs(s - r) - n / 2, 0), c = Math.max(Math.abs(e - a) - o / 2, 0);
  return Math.sqrt(l * l + c * c);
}
class eC {
  get anchor() {
    return this._anchor;
  }
  set anchor(e) {
    this._anchor = e;
  }
  get shouldFocus() {
    return this._shouldFocus;
  }
  set shouldFocus(e) {
    this._shouldFocus = e;
  }
  get source() {
    return this._source;
  }
  set source(e) {
    this._source = e;
  }
  get insistOnKeepingHoverVisible() {
    return this._insistOnKeepingHoverVisible;
  }
  set insistOnKeepingHoverVisible(e) {
    this._insistOnKeepingHoverVisible = e;
  }
  constructor(e, t) {
    this._editor = e, this._participants = t, this._anchor = null, this._shouldFocus = !1, this._source = 0, this._insistOnKeepingHoverVisible = !1;
  }
  static _getLineDecorations(e, t) {
    if (t.type !== 1 && !t.supportsMarkerHover)
      return [];
    const i = e.getModel(), n = t.range.startLineNumber;
    if (n > i.getLineCount())
      return [];
    const o = i.getLineMaxColumn(n);
    return e.getLineDecorations(n).filter((r) => {
      if (r.options.isWholeLine)
        return !0;
      const a = r.range.startLineNumber === n ? r.range.startColumn : 1, l = r.range.endLineNumber === n ? r.range.endColumn : o;
      if (r.options.showIfCollapsed) {
        if (a > t.range.startColumn + 1 || t.range.endColumn - 1 > l)
          return !1;
      } else if (a > t.range.startColumn || t.range.endColumn > l)
        return !1;
      return !0;
    });
  }
  computeAsync(e) {
    const t = this._anchor;
    if (!this._editor.hasModel() || !t)
      return Cs.EMPTY;
    const i = eC._getLineDecorations(this._editor, t);
    return Cs.merge(this._participants.map((n) => n.computeAsync ? n.computeAsync(t, i, e) : Cs.EMPTY));
  }
  computeSync() {
    if (!this._editor.hasModel() || !this._anchor)
      return [];
    const e = eC._getLineDecorations(this._editor, this._anchor);
    let t = [];
    for (const i of this._participants)
      t = t.concat(i.computeSync(this._anchor, e));
    return Rf(t);
  }
}
class b7 {
  constructor(e, t, i) {
    this.anchor = e, this.hoverParts = t, this.isComplete = i;
  }
  filter(e) {
    const t = this.hoverParts.filter((i) => i.isValidForHoverAnchor(e));
    return t.length === this.hoverParts.length ? this : new kJ(this, this.anchor, t, this.isComplete);
  }
}
class kJ extends b7 {
  constructor(e, t, i, n) {
    super(t, i, n), this.original = e;
  }
  filter(e) {
    return this.original.filter(e);
  }
}
var xJ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, DJ = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const pR = he;
let YL = class extends U {
  get hasContent() {
    return this._hasContent;
  }
  constructor(e) {
    super(), this._keybindingService = e, this.actions = [], this._hasContent = !1, this.hoverElement = pR("div.hover-row.status-bar"), this.hoverElement.tabIndex = 0, this.actionsElement = te(this.hoverElement, pR("div.actions"));
  }
  addAction(e) {
    const t = this._keybindingService.lookupKeybinding(e.commandId), i = t ? t.getLabel() : null;
    this._hasContent = !0;
    const n = this._register(Kw.render(this.actionsElement, e, i));
    return this.actions.push(n), n;
  }
  append(e) {
    const t = te(this.actionsElement, e);
    return this._hasContent = !0, t;
  }
};
YL = xJ([
  DJ(0, Lt)
], YL);
var EJ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, _R = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const Cd = Be("hoverService");
let wf = class extends U {
  get delay() {
    return this.isInstantlyHovering() ? 0 : this._delay;
  }
  constructor(e, t, i = {}, n, o) {
    super(), this.placement = e, this.instantHover = t, this.overrideOptions = i, this.configurationService = n, this.hoverService = o, this.lastHoverHideTime = 0, this.timeLimit = 200, this.hoverDisposables = this._register(new ne()), this._delay = this.configurationService.getValue("workbench.hover.delay"), this._register(this.configurationService.onDidChangeConfiguration((r) => {
      r.affectsConfiguration("workbench.hover.delay") && (this._delay = this.configurationService.getValue("workbench.hover.delay"));
    }));
  }
  showHover(e, t) {
    const i = typeof this.overrideOptions == "function" ? this.overrideOptions(e, t) : this.overrideOptions;
    this.hoverDisposables.clear();
    const n = ki(e.target) ? [e.target] : e.target.targetElements;
    for (const r of n)
      this.hoverDisposables.add(Zt(r, "keydown", (a) => {
        a.equals(
          9
          /* KeyCode.Escape */
        ) && this.hoverService.hideHover();
      }));
    const o = ki(e.content) ? void 0 : e.content.toString();
    return this.hoverService.showHover({
      ...e,
      ...i,
      persistence: {
        hideOnKeyDown: !0,
        ...i.persistence
      },
      id: o,
      appearance: {
        ...e.appearance,
        compact: !0,
        skipFadeInAnimation: this.isInstantlyHovering(),
        ...i.appearance
      }
    }, t);
  }
  isInstantlyHovering() {
    return this.instantHover && Date.now() - this.lastHoverHideTime < this.timeLimit;
  }
  onDidHideHover() {
    this.hoverDisposables.clear(), this.instantHover && (this.lastHoverHideTime = Date.now());
  }
};
wf = EJ([
  _R(3, gt),
  _R(4, Cd)
], wf);
class IJ {
  constructor(e, t, i) {
    this.provider = e, this.hover = t, this.ordinal = i;
  }
}
async function NJ(s, e, t, i, n) {
  const o = await Promise.resolve(s.provideHover(t, i, n)).catch(Qo);
  if (!(!o || !TJ(o)))
    return new IJ(s, o, e);
}
function SN(s, e, t, i, n = !1) {
  const r = s.ordered(e, n).map((a, l) => NJ(a, l, e, t, i));
  return Cs.fromPromises(r).coalesce();
}
function C7(s, e, t, i, n = !1) {
  return SN(s, e, t, i, n).map((o) => o.hover).toPromise();
}
vo("_executeHoverProvider", (s, e, t) => {
  const i = s.get(De);
  return C7(i.hoverProvider, e, t, _t.None);
});
vo("_executeHoverProvider_recursive", (s, e, t) => {
  const i = s.get(De);
  return C7(i.hoverProvider, e, t, _t.None, !0);
});
function TJ(s) {
  const e = typeof s.range < "u", t = typeof s.contents < "u" && s.contents && s.contents.length > 0;
  return e && t;
}
var MJ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, bc = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const au = he, RJ = $i("hover-increase-verbosity", ie.add, m("increaseHoverVerbosity", "Icon for increaseing hover verbosity.")), AJ = $i("hover-decrease-verbosity", ie.remove, m("decreaseHoverVerbosity", "Icon for decreasing hover verbosity."));
class Vo {
  constructor(e, t, i, n, o, r = void 0) {
    this.owner = e, this.range = t, this.contents = i, this.isBeforeContent = n, this.ordinal = o, this.source = r;
  }
  isValidForHoverAnchor(e) {
    return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
  }
}
class v7 {
  constructor(e, t, i) {
    this.hover = e, this.hoverProvider = t, this.hoverPosition = i;
  }
  supportsVerbosityAction(e) {
    switch (e) {
      case jn.Increase:
        return this.hover.canIncreaseVerbosity ?? !1;
      case jn.Decrease:
        return this.hover.canDecreaseVerbosity ?? !1;
    }
  }
}
let gp = class {
  constructor(e, t, i, n, o, r, a, l) {
    this._editor = e, this._languageService = t, this._openerService = i, this._configurationService = n, this._languageFeaturesService = o, this._keybindingService = r, this._hoverService = a, this._commandService = l, this.hoverOrdinal = 3;
  }
  createLoadingMessage(e) {
    return new Vo(this, e.range, [new Oo().appendText(m("modesContentHover.loading", "Loading..."))], !1, 2e3);
  }
  computeSync(e, t) {
    if (!this._editor.hasModel() || e.type !== 1)
      return [];
    const i = this._editor.getModel(), n = e.range.startLineNumber, o = i.getLineMaxColumn(n), r = [];
    let a = 1e3;
    const l = i.getLineLength(n), c = i.getLanguageIdAtPosition(e.range.startLineNumber, e.range.startColumn), h = this._editor.getOption(
      118
      /* EditorOption.stopRenderingLineAfter */
    ), d = this._configurationService.getValue("editor.maxTokenizationLineLength", {
      overrideIdentifier: c
    });
    let u = !1;
    h >= 0 && l > h && e.range.startColumn >= h && (u = !0, r.push(new Vo(this, e.range, [{
      value: m("stopped rendering", "Rendering paused for long line for performance reasons. This can be configured via `editor.stopRenderingLineAfter`.")
    }], !1, a++))), !u && typeof d == "number" && l >= d && r.push(new Vo(this, e.range, [{
      value: m("too many characters", "Tokenization is skipped for long lines for performance reasons. This can be configured via `editor.maxTokenizationLineLength`.")
    }], !1, a++));
    let f = !1;
    for (const g of t) {
      const p = g.range.startLineNumber === n ? g.range.startColumn : 1, _ = g.range.endLineNumber === n ? g.range.endColumn : o, b = g.options.hoverMessage;
      if (!b || rf(b))
        continue;
      g.options.beforeContentClassName && (f = !0);
      const C = new T(e.range.startLineNumber, p, e.range.startLineNumber, _);
      r.push(new Vo(this, C, uO(b), f, a++));
    }
    return r;
  }
  computeAsync(e, t, i) {
    if (!this._editor.hasModel() || e.type !== 1)
      return Cs.EMPTY;
    const n = this._editor.getModel(), o = this._languageFeaturesService.hoverProvider;
    return o.has(n) ? this._getMarkdownHovers(o, n, e, i) : Cs.EMPTY;
  }
  _getMarkdownHovers(e, t, i, n) {
    const o = i.range.getStartPosition();
    return SN(e, t, o, n).filter((l) => !rf(l.hover.contents)).map((l) => {
      const c = l.hover.range ? T.lift(l.hover.range) : i.range, h = new v7(l.hover, l.provider, o);
      return new Vo(this, c, l.hover.contents, !1, l.ordinal, h);
    });
  }
  renderHoverParts(e, t) {
    return this._renderedHoverParts = new PJ(t, e.fragment, this, this._editor, this._languageService, this._openerService, this._commandService, this._keybindingService, this._hoverService, this._configurationService, e.onContentsChanged), this._renderedHoverParts;
  }
  updateMarkdownHoverVerbosityLevel(e, t, i) {
    var n;
    return Promise.resolve((n = this._renderedHoverParts) == null ? void 0 : n.updateMarkdownHoverPartVerbosityLevel(e, t, i));
  }
};
gp = MJ([
  bc(1, ci),
  bc(2, sr),
  bc(3, gt),
  bc(4, De),
  bc(5, Lt),
  bc(6, Cd),
  bc(7, fi)
], gp);
class A_ {
  constructor(e, t, i) {
    this.hoverPart = e, this.hoverElement = t, this.disposables = i;
  }
  dispose() {
    this.disposables.dispose();
  }
}
class PJ {
  constructor(e, t, i, n, o, r, a, l, c, h, d) {
    this._hoverParticipant = i, this._editor = n, this._languageService = o, this._openerService = r, this._commandService = a, this._keybindingService = l, this._hoverService = c, this._configurationService = h, this._onFinishedRendering = d, this._ongoingHoverOperations = /* @__PURE__ */ new Map(), this._disposables = new ne(), this.renderedHoverParts = this._renderHoverParts(e, t, this._onFinishedRendering), this._disposables.add(_e(() => {
      this.renderedHoverParts.forEach((u) => {
        u.dispose();
      }), this._ongoingHoverOperations.forEach((u) => {
        u.tokenSource.dispose(!0);
      });
    }));
  }
  _renderHoverParts(e, t, i) {
    return e.sort(Os((n) => n.ordinal, Ba)), e.map((n) => {
      const o = this._renderHoverPart(n, i);
      return t.appendChild(o.hoverElement), o;
    });
  }
  _renderHoverPart(e, t) {
    const i = this._renderMarkdownHover(e, t), n = i.hoverElement, o = e.source, r = new ne();
    if (r.add(i), !o)
      return new A_(e, n, r);
    const a = o.supportsVerbosityAction(jn.Increase), l = o.supportsVerbosityAction(jn.Decrease);
    if (!a && !l)
      return new A_(e, n, r);
    const c = au("div.verbosity-actions");
    return n.prepend(c), r.add(this._renderHoverExpansionAction(c, jn.Increase, a)), r.add(this._renderHoverExpansionAction(c, jn.Decrease, l)), new A_(e, n, r);
  }
  _renderMarkdownHover(e, t) {
    return OJ(this._editor, e, this._languageService, this._openerService, t);
  }
  _renderHoverExpansionAction(e, t, i) {
    const n = new ne(), o = t === jn.Increase, r = te(e, au(Te.asCSSSelector(o ? RJ : AJ)));
    r.tabIndex = 0;
    const a = new wf("mouse", !1, { target: e, position: {
      hoverPosition: 0
      /* HoverPosition.LEFT */
    } }, this._configurationService, this._hoverService);
    if (n.add(this._hoverService.setupManagedHover(a, r, FJ(this._keybindingService, t))), !i)
      return r.classList.add("disabled"), n;
    r.classList.add("enabled");
    const l = () => this._commandService.executeCommand(t === jn.Increase ? Fv : Bv);
    return n.add(new p7(r, l)), n.add(new _7(r, l, [
      3,
      10
      /* KeyCode.Space */
    ])), n;
  }
  async updateMarkdownHoverPartVerbosityLevel(e, t, i = !0) {
    const n = this._editor.getModel();
    if (!n)
      return;
    const o = this._getRenderedHoverPartAtIndex(t), r = o == null ? void 0 : o.hoverPart.source;
    if (!o || !(r != null && r.supportsVerbosityAction(e)))
      return;
    const a = await this._fetchHover(r, n, e);
    if (!a)
      return;
    const l = new v7(a, r.hoverProvider, r.hoverPosition), c = o.hoverPart, h = new Vo(this._hoverParticipant, c.range, a.contents, c.isBeforeContent, c.ordinal, l), d = this._renderHoverPart(h, this._onFinishedRendering);
    return this._replaceRenderedHoverPartAtIndex(t, d, h), i && this._focusOnHoverPartWithIndex(t), {
      hoverPart: h,
      hoverElement: d.hoverElement
    };
  }
  async _fetchHover(e, t, i) {
    let n = i === jn.Increase ? 1 : -1;
    const o = e.hoverProvider, r = this._ongoingHoverOperations.get(o);
    r && (r.tokenSource.cancel(), n += r.verbosityDelta);
    const a = new Vs();
    this._ongoingHoverOperations.set(o, { verbosityDelta: n, tokenSource: a });
    const l = { verbosityRequest: { verbosityDelta: n, previousHover: e.hover } };
    let c;
    try {
      c = await Promise.resolve(o.provideHover(t, e.hoverPosition, a.token, l));
    } catch (h) {
      Qo(h);
    }
    return a.dispose(), this._ongoingHoverOperations.delete(o), c;
  }
  _replaceRenderedHoverPartAtIndex(e, t, i) {
    if (e >= this.renderedHoverParts.length || e < 0)
      return;
    const n = this.renderedHoverParts[e], o = n.hoverElement, r = t.hoverElement, a = Array.from(r.children);
    o.replaceChildren(...a);
    const l = new A_(i, o, t.disposables);
    o.focus(), n.dispose(), this.renderedHoverParts[e] = l;
  }
  _focusOnHoverPartWithIndex(e) {
    this.renderedHoverParts[e].hoverElement.focus();
  }
  _getRenderedHoverPartAtIndex(e) {
    return this.renderedHoverParts[e];
  }
  dispose() {
    this._disposables.dispose();
  }
}
function OJ(s, e, t, i, n) {
  const o = new ne(), r = au("div.hover-row"), a = au("div.hover-row-contents");
  r.appendChild(a);
  const l = e.contents;
  for (const h of l) {
    if (rf(h))
      continue;
    const d = au("div.markdown-hover"), u = te(d, au("div.hover-contents")), f = o.add(new hp({ editor: s }, t, i));
    o.add(f.onDidRenderAsync(() => {
      u.className = "hover-contents code-hover-contents", n();
    }));
    const g = o.add(f.render(h));
    u.appendChild(g.element), a.appendChild(d);
  }
  return {
    hoverPart: e,
    hoverElement: r,
    dispose() {
      o.dispose();
    }
  };
}
function FJ(s, e) {
  switch (e) {
    case jn.Increase: {
      const t = s.lookupKeybinding(Fv);
      return t ? m("increaseVerbosityWithKb", "Increase Hover Verbosity ({0})", t.getLabel()) : m("increaseVerbosity", "Increase Hover Verbosity");
    }
    case jn.Decrease: {
      const t = s.lookupKeybinding(Bv);
      return t ? m("decreaseVerbosityWithKb", "Decrease Hover Verbosity ({0})", t.getLabel()) : m("decreaseVerbosity", "Decrease Hover Verbosity");
    }
  }
}
const w7 = [];
function BJ(s) {
  w7.push(s);
}
function WJ() {
  return w7.slice(0);
}
const vd = Be("editorWorkerService");
var y7 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, XL = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let tC = class {
  constructor(e) {
    this._editorWorkerService = e;
  }
  async provideDocumentColors(e, t) {
    return this._editorWorkerService.computeDefaultDocumentColors(e.uri);
  }
  provideColorPresentations(e, t, i) {
    const n = t.range, o = t.color, r = o.alpha, a = new j(new ze(Math.round(255 * o.red), Math.round(255 * o.green), Math.round(255 * o.blue), r)), l = r ? j.Format.CSS.formatRGB(a) : j.Format.CSS.formatRGBA(a), c = r ? j.Format.CSS.formatHSL(a) : j.Format.CSS.formatHSLA(a), h = r ? j.Format.CSS.formatHex(a) : j.Format.CSS.formatHexA(a), d = [];
    return d.push({ label: l, textEdit: { range: n, text: l } }), d.push({ label: c, textEdit: { range: n, text: c } }), d.push({ label: h, textEdit: { range: n, text: h } }), d;
  }
};
tC = y7([
  XL(0, vd)
], tC);
let QL = class extends U {
  constructor(e, t) {
    super(), this._register(e.colorProvider.register("*", new tC(t)));
  }
};
QL = y7([
  XL(0, De),
  XL(1, vd)
], QL);
BJ(QL);
async function S7(s, e, t, i = !0) {
  return LN(new HJ(), s, e, t, i);
}
function L7(s, e, t, i) {
  return Promise.resolve(t.provideColorPresentations(s, e, i));
}
class HJ {
  constructor() {
  }
  async compute(e, t, i, n) {
    const o = await e.provideDocumentColors(t, i);
    if (Array.isArray(o))
      for (const r of o)
        n.push({ colorInfo: r, provider: e });
    return Array.isArray(o);
  }
}
class VJ {
  constructor() {
  }
  async compute(e, t, i, n) {
    const o = await e.provideDocumentColors(t, i);
    if (Array.isArray(o))
      for (const r of o)
        n.push({ range: r.range, color: [r.color.red, r.color.green, r.color.blue, r.color.alpha] });
    return Array.isArray(o);
  }
}
class zJ {
  constructor(e) {
    this.colorInfo = e;
  }
  async compute(e, t, i, n) {
    const o = await e.provideColorPresentations(t, this.colorInfo, _t.None);
    return Array.isArray(o) && n.push(...o), Array.isArray(o);
  }
}
async function LN(s, e, t, i, n) {
  let o = !1, r;
  const a = [], l = e.ordered(t);
  for (let c = l.length - 1; c >= 0; c--) {
    const h = l[c];
    if (h instanceof tC)
      r = h;
    else
      try {
        await s.compute(h, t, i, a) && (o = !0);
      } catch (d) {
        Qo(d);
      }
  }
  return o ? a : r && n ? (await s.compute(r, t, i, a), a) : [];
}
function k7(s, e) {
  const { colorProvider: t } = s.get(De), i = s.get(Ui).getModel(e);
  if (!i)
    throw Tr();
  const n = s.get(gt).getValue("editor.defaultColorDecorators", { resource: e });
  return { model: i, colorProviderRegistry: t, isDefaultColorDecoratorsEnabled: n };
}
St.registerCommand("_executeDocumentColorProvider", function(s, ...e) {
  const [t] = e;
  if (!(t instanceof we))
    throw Tr();
  const { model: i, colorProviderRegistry: n, isDefaultColorDecoratorsEnabled: o } = k7(s, t);
  return LN(new VJ(), n, i, _t.None, o);
});
St.registerCommand("_executeColorPresentationProvider", function(s, ...e) {
  const [t, i] = e, { uri: n, range: o } = i;
  if (!(n instanceof we) || !Array.isArray(t) || t.length !== 4 || !T.isIRange(o))
    throw Tr();
  const { model: r, colorProviderRegistry: a, isDefaultColorDecoratorsEnabled: l } = k7(s, n), [c, h, d, u] = t;
  return LN(new zJ({ range: o, color: { red: c, green: h, blue: d, alpha: u } }), a, r, _t.None, l);
});
const x7 = Be("environmentService");
var UJ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, bR = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const kN = Be("ILanguageFeatureDebounceService");
var iC;
(function(s) {
  const e = /* @__PURE__ */ new WeakMap();
  let t = 0;
  function i(n) {
    let o = e.get(n);
    return o === void 0 && (o = ++t, e.set(n, o)), o;
  }
  s.of = i;
})(iC || (iC = {}));
class $J {
  constructor(e) {
    this._default = e;
  }
  get(e) {
    return this._default;
  }
  update(e, t) {
    return this._default;
  }
  default() {
    return this._default;
  }
}
class KJ {
  constructor(e, t, i, n, o, r) {
    this._logService = e, this._name = t, this._registry = i, this._default = n, this._min = o, this._max = r, this._cache = new Mf(50, 0.7);
  }
  _key(e) {
    return e.id + this._registry.all(e).reduce((t, i) => Xv(iC.of(i), t), 0);
  }
  get(e) {
    const t = this._key(e), i = this._cache.get(t);
    return i ? Dn(i.value, this._min, this._max) : this.default();
  }
  update(e, t) {
    const i = this._key(e);
    let n = this._cache.get(i);
    n || (n = new JW(6), this._cache.set(i, n));
    const o = Dn(n.update(t), this._min, this._max);
    return yE(e.uri, "output") || this._logService.trace(`[DEBOUNCE: ${this._name}] for ${e.uri.toString()} is ${o}ms`), o;
  }
  _overall() {
    const e = new wO();
    for (const [, t] of this._cache)
      e.update(t.value);
    return e.value;
  }
  default() {
    const e = this._overall() | 0 || this._default;
    return Dn(e, this._min, this._max);
  }
}
let JL = class {
  constructor(e, t) {
    this._logService = e, this._data = /* @__PURE__ */ new Map(), this._isDev = t.isExtensionDevelopment || !t.isBuilt;
  }
  for(e, t, i) {
    const n = (i == null ? void 0 : i.min) ?? 50, o = (i == null ? void 0 : i.max) ?? n ** 2, r = (i == null ? void 0 : i.key) ?? void 0, a = `${iC.of(e)},${n}${r ? "," + r : ""}`;
    let l = this._data.get(a);
    return l || (this._isDev ? (this._logService.debug(`[DEBOUNCE: ${t}] is disabled in developed mode`), l = new $J(n * 1.5)) : l = new KJ(
      this._logService,
      t,
      e,
      this._overallAverage() | 0 || n * 1.5,
      // default is overall default or derived from min-value
      n,
      o
    ), this._data.set(a, l)), l;
  }
  _overallAverage() {
    const e = new wO();
    for (const t of this._data.values())
      e.update(t.default());
    return e.value;
  }
};
JL = UJ([
  bR(0, Co),
  bR(1, x7)
], JL);
Ze(
  kN,
  JL,
  1
  /* InstantiationType.Delayed */
);
var jJ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, hy = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, ek;
const qJ = /* @__PURE__ */ Object.create({});
var Ul;
let yf = (Ul = class extends U {
  // ms
  constructor(e, t, i, n) {
    super(), this._editor = e, this._configurationService = t, this._languageFeaturesService = i, this._localToDispose = this._register(new ne()), this._decorationsIds = [], this._colorDatas = /* @__PURE__ */ new Map(), this._colorDecoratorIds = this._editor.createDecorationsCollection(), this._ruleFactory = new c1(this._editor), this._decoratorLimitReporter = new GJ(), this._colorDecorationClassRefs = this._register(new ne()), this._debounceInformation = n.for(i.colorProvider, "Document Colors", { min: ek.RECOMPUTE_TIME }), this._register(e.onDidChangeModel(() => {
      this._isColorDecoratorsEnabled = this.isEnabled(), this.updateColors();
    })), this._register(e.onDidChangeModelLanguage(() => this.updateColors())), this._register(i.colorProvider.onDidChange(() => this.updateColors())), this._register(e.onDidChangeConfiguration((o) => {
      const r = this._isColorDecoratorsEnabled;
      this._isColorDecoratorsEnabled = this.isEnabled(), this._isDefaultColorDecoratorsEnabled = this._editor.getOption(
        148
        /* EditorOption.defaultColorDecorators */
      );
      const a = r !== this._isColorDecoratorsEnabled || o.hasChanged(
        21
        /* EditorOption.colorDecoratorsLimit */
      ), l = o.hasChanged(
        148
        /* EditorOption.defaultColorDecorators */
      );
      (a || l) && (this._isColorDecoratorsEnabled ? this.updateColors() : this.removeAllDecorations());
    })), this._timeoutTimer = null, this._computePromise = null, this._isColorDecoratorsEnabled = this.isEnabled(), this._isDefaultColorDecoratorsEnabled = this._editor.getOption(
      148
      /* EditorOption.defaultColorDecorators */
    ), this.updateColors();
  }
  isEnabled() {
    const e = this._editor.getModel();
    if (!e)
      return !1;
    const t = e.getLanguageId(), i = this._configurationService.getValue(t);
    if (i && typeof i == "object") {
      const n = i.colorDecorators;
      if (n && n.enable !== void 0 && !n.enable)
        return n.enable;
    }
    return this._editor.getOption(
      20
      /* EditorOption.colorDecorators */
    );
  }
  static get(e) {
    return e.getContribution(this.ID);
  }
  dispose() {
    this.stop(), this.removeAllDecorations(), super.dispose();
  }
  updateColors() {
    if (this.stop(), !this._isColorDecoratorsEnabled)
      return;
    const e = this._editor.getModel();
    !e || !this._languageFeaturesService.colorProvider.has(e) || (this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      this._timeoutTimer || (this._timeoutTimer = new Ya(), this._timeoutTimer.cancelAndSet(() => {
        this._timeoutTimer = null, this.beginCompute();
      }, this._debounceInformation.get(e)));
    })), this.beginCompute());
  }
  async beginCompute() {
    this._computePromise = Za(async (e) => {
      const t = this._editor.getModel();
      if (!t)
        return [];
      const i = new Ga(!1), n = await S7(this._languageFeaturesService.colorProvider, t, e, this._isDefaultColorDecoratorsEnabled);
      return this._debounceInformation.update(t, i.elapsed()), n;
    });
    try {
      const e = await this._computePromise;
      this.updateDecorations(e), this.updateColorDecorators(e), this._computePromise = null;
    } catch (e) {
      Je(e);
    }
  }
  stop() {
    this._timeoutTimer && (this._timeoutTimer.cancel(), this._timeoutTimer = null), this._computePromise && (this._computePromise.cancel(), this._computePromise = null), this._localToDispose.clear();
  }
  updateDecorations(e) {
    const t = e.map((i) => ({
      range: {
        startLineNumber: i.colorInfo.range.startLineNumber,
        startColumn: i.colorInfo.range.startColumn,
        endLineNumber: i.colorInfo.range.endLineNumber,
        endColumn: i.colorInfo.range.endColumn
      },
      options: Wt.EMPTY
    }));
    this._editor.changeDecorations((i) => {
      this._decorationsIds = i.deltaDecorations(this._decorationsIds, t), this._colorDatas = /* @__PURE__ */ new Map(), this._decorationsIds.forEach((n, o) => this._colorDatas.set(n, e[o]));
    });
  }
  updateColorDecorators(e) {
    this._colorDecorationClassRefs.clear();
    const t = [], i = this._editor.getOption(
      21
      /* EditorOption.colorDecoratorsLimit */
    );
    for (let o = 0; o < e.length && t.length < i; o++) {
      const { red: r, green: a, blue: l, alpha: c } = e[o].colorInfo.color, h = new ze(Math.round(r * 255), Math.round(a * 255), Math.round(l * 255), c), d = `rgba(${h.r}, ${h.g}, ${h.b}, ${h.a})`, u = this._colorDecorationClassRefs.add(this._ruleFactory.createClassNameRef({
        backgroundColor: d
      }));
      t.push({
        range: {
          startLineNumber: e[o].colorInfo.range.startLineNumber,
          startColumn: e[o].colorInfo.range.startColumn,
          endLineNumber: e[o].colorInfo.range.endLineNumber,
          endColumn: e[o].colorInfo.range.endColumn
        },
        options: {
          description: "colorDetector",
          before: {
            content: x8,
            inlineClassName: `${u.className} colorpicker-color-decoration`,
            inlineClassNameAffectsLetterSpacing: !0,
            attachedData: qJ
          }
        }
      });
    }
    const n = i < e.length ? i : !1;
    this._decoratorLimitReporter.update(e.length, n), this._colorDecoratorIds.set(t);
  }
  removeAllDecorations() {
    this._editor.removeDecorations(this._decorationsIds), this._decorationsIds = [], this._colorDecoratorIds.clear(), this._colorDecorationClassRefs.clear();
  }
  getColorData(e) {
    const t = this._editor.getModel();
    if (!t)
      return null;
    const i = t.getDecorationsInRange(T.fromPositions(e, e)).filter((n) => this._colorDatas.has(n.id));
    return i.length === 0 ? null : this._colorDatas.get(i[0].id);
  }
  isColorDecoration(e) {
    return this._colorDecoratorIds.has(e);
  }
}, ek = Ul, Ul.ID = "editor.contrib.colorDetector", Ul.RECOMPUTE_TIME = 1e3, Ul);
yf = ek = jJ([
  hy(1, gt),
  hy(2, De),
  hy(3, kN)
], yf);
class GJ {
  constructor() {
    this._onDidChange = new A(), this._computed = 0, this._limited = !1;
  }
  update(e, t) {
    (e !== this._computed || t !== this._limited) && (this._computed = e, this._limited = t, this._onDidChange.fire());
  }
}
Xa(
  yf.ID,
  yf,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
class ZJ {
  get color() {
    return this._color;
  }
  set color(e) {
    this._color.equals(e) || (this._color = e, this._onDidChangeColor.fire(e));
  }
  get presentation() {
    return this.colorPresentations[this.presentationIndex];
  }
  get colorPresentations() {
    return this._colorPresentations;
  }
  set colorPresentations(e) {
    this._colorPresentations = e, this.presentationIndex > e.length - 1 && (this.presentationIndex = 0), this._onDidChangePresentation.fire(this.presentation);
  }
  constructor(e, t, i) {
    this.presentationIndex = i, this._onColorFlushed = new A(), this.onColorFlushed = this._onColorFlushed.event, this._onDidChangeColor = new A(), this.onDidChangeColor = this._onDidChangeColor.event, this._onDidChangePresentation = new A(), this.onDidChangePresentation = this._onDidChangePresentation.event, this.originalColor = e, this._color = e, this._colorPresentations = t;
  }
  selectNextColorPresentation() {
    this.presentationIndex = (this.presentationIndex + 1) % this.colorPresentations.length, this.flushColor(), this._onDidChangePresentation.fire(this.presentation);
  }
  guessColorPresentation(e, t) {
    let i = -1;
    for (let n = 0; n < this.colorPresentations.length; n++)
      if (t.toLowerCase() === this.colorPresentations[n].label) {
        i = n;
        break;
      }
    if (i === -1) {
      const n = t.split("(")[0].toLowerCase();
      for (let o = 0; o < this.colorPresentations.length; o++)
        if (this.colorPresentations[o].label.toLowerCase().startsWith(n)) {
          i = o;
          break;
        }
    }
    i !== -1 && i !== this.presentationIndex && (this.presentationIndex = i, this._onDidChangePresentation.fire(this.presentation));
  }
  flushColor() {
    this._onColorFlushed.fire(this._color);
  }
}
const _s = he;
class YJ extends U {
  constructor(e, t, i, n = !1) {
    super(), this.model = t, this.showingStandaloneColorPicker = n, this._closeButton = null, this._domNode = _s(".colorpicker-header"), te(e, this._domNode), this._pickedColorNode = te(this._domNode, _s(".picked-color")), te(this._pickedColorNode, _s("span.codicon.codicon-color-mode")), this._pickedColorPresentation = te(this._pickedColorNode, document.createElement("span")), this._pickedColorPresentation.classList.add("picked-color-presentation");
    const o = m("clickToToggleColorOptions", "Click to toggle color options (rgb/hsl/hex)");
    this._pickedColorNode.setAttribute("title", o), this._originalColorNode = te(this._domNode, _s(".original-color")), this._originalColorNode.style.backgroundColor = j.Format.CSS.format(this.model.originalColor) || "", this.backgroundColor = i.getColorTheme().getColor(l1) || j.white, this._register(i.onDidColorThemeChange((r) => {
      this.backgroundColor = r.getColor(l1) || j.white;
    })), this._register(z(this._pickedColorNode, X.CLICK, () => this.model.selectNextColorPresentation())), this._register(z(this._originalColorNode, X.CLICK, () => {
      this.model.color = this.model.originalColor, this.model.flushColor();
    })), this._register(t.onDidChangeColor(this.onDidChangeColor, this)), this._register(t.onDidChangePresentation(this.onDidChangePresentation, this)), this._pickedColorNode.style.backgroundColor = j.Format.CSS.format(t.color) || "", this._pickedColorNode.classList.toggle("light", t.color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : t.color.isLighter()), this.onDidChangeColor(this.model.color), this.showingStandaloneColorPicker && (this._domNode.classList.add("standalone-colorpicker"), this._closeButton = this._register(new XJ(this._domNode)));
  }
  get closeButton() {
    return this._closeButton;
  }
  get pickedColorNode() {
    return this._pickedColorNode;
  }
  get originalColorNode() {
    return this._originalColorNode;
  }
  onDidChangeColor(e) {
    this._pickedColorNode.style.backgroundColor = j.Format.CSS.format(e) || "", this._pickedColorNode.classList.toggle("light", e.rgba.a < 0.5 ? this.backgroundColor.isLighter() : e.isLighter()), this.onDidChangePresentation();
  }
  onDidChangePresentation() {
    this._pickedColorPresentation.textContent = this.model.presentation ? this.model.presentation.label : "";
  }
}
class XJ extends U {
  constructor(e) {
    super(), this._onClicked = this._register(new A()), this.onClicked = this._onClicked.event, this._button = document.createElement("div"), this._button.classList.add("close-button"), te(e, this._button);
    const t = document.createElement("div");
    t.classList.add("close-button-inner-div"), te(this._button, t), te(t, _s(".button" + Te.asCSSSelector($i("color-picker-close", ie.close, m("closeIcon", "Icon to close the color picker"))))).classList.add("close-icon"), this._register(z(this._button, X.CLICK, () => {
      this._onClicked.fire();
    }));
  }
}
class QJ extends U {
  constructor(e, t, i, n = !1) {
    super(), this.model = t, this.pixelRatio = i, this._insertButton = null, this._domNode = _s(".colorpicker-body"), te(e, this._domNode), this._saturationBox = new JJ(this._domNode, this.model, this.pixelRatio), this._register(this._saturationBox), this._register(this._saturationBox.onDidChange(this.onDidSaturationValueChange, this)), this._register(this._saturationBox.onColorFlushed(this.flushColor, this)), this._opacityStrip = new eee(this._domNode, this.model, n), this._register(this._opacityStrip), this._register(this._opacityStrip.onDidChange(this.onDidOpacityChange, this)), this._register(this._opacityStrip.onColorFlushed(this.flushColor, this)), this._hueStrip = new tee(this._domNode, this.model, n), this._register(this._hueStrip), this._register(this._hueStrip.onDidChange(this.onDidHueChange, this)), this._register(this._hueStrip.onColorFlushed(this.flushColor, this)), n && (this._insertButton = this._register(new iee(this._domNode)), this._domNode.classList.add("standalone-colorpicker"));
  }
  flushColor() {
    this.model.flushColor();
  }
  onDidSaturationValueChange({ s: e, v: t }) {
    const i = this.model.color.hsva;
    this.model.color = new j(new Ir(i.h, e, t, i.a));
  }
  onDidOpacityChange(e) {
    const t = this.model.color.hsva;
    this.model.color = new j(new Ir(t.h, t.s, t.v, e));
  }
  onDidHueChange(e) {
    const t = this.model.color.hsva, i = (1 - e) * 360;
    this.model.color = new j(new Ir(i === 360 ? 0 : i, t.s, t.v, t.a));
  }
  get domNode() {
    return this._domNode;
  }
  get saturationBox() {
    return this._saturationBox;
  }
  get enterButton() {
    return this._insertButton;
  }
  layout() {
    this._saturationBox.layout(), this._opacityStrip.layout(), this._hueStrip.layout();
  }
}
class JJ extends U {
  constructor(e, t, i) {
    super(), this.model = t, this.pixelRatio = i, this._onDidChange = new A(), this.onDidChange = this._onDidChange.event, this._onColorFlushed = new A(), this.onColorFlushed = this._onColorFlushed.event, this._domNode = _s(".saturation-wrap"), te(e, this._domNode), this._canvas = document.createElement("canvas"), this._canvas.className = "saturation-box", te(this._domNode, this._canvas), this.selection = _s(".saturation-selection"), te(this._domNode, this.selection), this.layout(), this._register(z(this._domNode, X.POINTER_DOWN, (n) => this.onPointerDown(n))), this._register(this.model.onDidChangeColor(this.onDidChangeColor, this)), this.monitor = null;
  }
  get domNode() {
    return this._domNode;
  }
  onPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    this.monitor = this._register(new Af());
    const t = ui(this._domNode);
    e.target !== this.selection && this.onDidChangePosition(e.offsetX, e.offsetY), this.monitor.startMonitoring(e.target, e.pointerId, e.buttons, (n) => this.onDidChangePosition(n.pageX - t.left, n.pageY - t.top), () => null);
    const i = z(e.target.ownerDocument, X.POINTER_UP, () => {
      this._onColorFlushed.fire(), i.dispose(), this.monitor && (this.monitor.stopMonitoring(!0), this.monitor = null);
    }, !0);
  }
  onDidChangePosition(e, t) {
    const i = Math.max(0, Math.min(1, e / this.width)), n = Math.max(0, Math.min(1, 1 - t / this.height));
    this.paintSelection(i, n), this._onDidChange.fire({ s: i, v: n });
  }
  layout() {
    this.width = this._domNode.offsetWidth, this.height = this._domNode.offsetHeight, this._canvas.width = this.width * this.pixelRatio, this._canvas.height = this.height * this.pixelRatio, this.paint();
    const e = this.model.color.hsva;
    this.paintSelection(e.s, e.v);
  }
  paint() {
    const e = this.model.color.hsva, t = new j(new Ir(e.h, 1, 1, 1)), i = this._canvas.getContext("2d"), n = i.createLinearGradient(0, 0, this._canvas.width, 0);
    n.addColorStop(0, "rgba(255, 255, 255, 1)"), n.addColorStop(0.5, "rgba(255, 255, 255, 0.5)"), n.addColorStop(1, "rgba(255, 255, 255, 0)");
    const o = i.createLinearGradient(0, 0, 0, this._canvas.height);
    o.addColorStop(0, "rgba(0, 0, 0, 0)"), o.addColorStop(1, "rgba(0, 0, 0, 1)"), i.rect(0, 0, this._canvas.width, this._canvas.height), i.fillStyle = j.Format.CSS.format(t), i.fill(), i.fillStyle = n, i.fill(), i.fillStyle = o, i.fill();
  }
  paintSelection(e, t) {
    this.selection.style.left = `${e * this.width}px`, this.selection.style.top = `${this.height - t * this.height}px`;
  }
  onDidChangeColor(e) {
    if (this.monitor && this.monitor.isMonitoring())
      return;
    this.paint();
    const t = e.hsva;
    this.paintSelection(t.s, t.v);
  }
}
class D7 extends U {
  constructor(e, t, i = !1) {
    super(), this.model = t, this._onDidChange = new A(), this.onDidChange = this._onDidChange.event, this._onColorFlushed = new A(), this.onColorFlushed = this._onColorFlushed.event, i ? (this.domNode = te(e, _s(".standalone-strip")), this.overlay = te(this.domNode, _s(".standalone-overlay"))) : (this.domNode = te(e, _s(".strip")), this.overlay = te(this.domNode, _s(".overlay"))), this.slider = te(this.domNode, _s(".slider")), this.slider.style.top = "0px", this._register(z(this.domNode, X.POINTER_DOWN, (n) => this.onPointerDown(n))), this._register(t.onDidChangeColor(this.onDidChangeColor, this)), this.layout();
  }
  layout() {
    this.height = this.domNode.offsetHeight - this.slider.offsetHeight;
    const e = this.getValue(this.model.color);
    this.updateSliderPosition(e);
  }
  onDidChangeColor(e) {
    const t = this.getValue(e);
    this.updateSliderPosition(t);
  }
  onPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const t = this._register(new Af()), i = ui(this.domNode);
    this.domNode.classList.add("grabbing"), e.target !== this.slider && this.onDidChangeTop(e.offsetY), t.startMonitoring(e.target, e.pointerId, e.buttons, (o) => this.onDidChangeTop(o.pageY - i.top), () => null);
    const n = z(e.target.ownerDocument, X.POINTER_UP, () => {
      this._onColorFlushed.fire(), n.dispose(), t.stopMonitoring(!0), this.domNode.classList.remove("grabbing");
    }, !0);
  }
  onDidChangeTop(e) {
    const t = Math.max(0, Math.min(1, 1 - e / this.height));
    this.updateSliderPosition(t), this._onDidChange.fire(t);
  }
  updateSliderPosition(e) {
    this.slider.style.top = `${(1 - e) * this.height}px`;
  }
}
class eee extends D7 {
  constructor(e, t, i = !1) {
    super(e, t, i), this.domNode.classList.add("opacity-strip"), this.onDidChangeColor(this.model.color);
  }
  onDidChangeColor(e) {
    super.onDidChangeColor(e);
    const { r: t, g: i, b: n } = e.rgba, o = new j(new ze(t, i, n, 1)), r = new j(new ze(t, i, n, 0));
    this.overlay.style.background = `linear-gradient(to bottom, ${o} 0%, ${r} 100%)`;
  }
  getValue(e) {
    return e.hsva.a;
  }
}
class tee extends D7 {
  constructor(e, t, i = !1) {
    super(e, t, i), this.domNode.classList.add("hue-strip");
  }
  getValue(e) {
    return 1 - e.hsva.h / 360;
  }
}
class iee extends U {
  constructor(e) {
    super(), this._onClicked = this._register(new A()), this.onClicked = this._onClicked.event, this._button = te(e, document.createElement("button")), this._button.classList.add("insert-button"), this._button.textContent = "Insert", this._register(z(this._button, X.CLICK, () => {
      this._onClicked.fire();
    }));
  }
  get button() {
    return this._button;
  }
}
class nee extends qr {
  constructor(e, t, i, n, o = !1) {
    super(), this.model = t, this.pixelRatio = i, this._register(Om.getInstance(fe(e)).onDidChange(() => this.layout())), this._domNode = _s(".colorpicker-widget"), e.appendChild(this._domNode), this.header = this._register(new YJ(this._domNode, this.model, n, o)), this.body = this._register(new QJ(this._domNode, this.model, this.pixelRatio, o));
  }
  layout() {
    this.body.layout();
  }
  get domNode() {
    return this._domNode;
  }
}
var E7 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, I7 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class see {
  constructor(e, t, i, n) {
    this.owner = e, this.range = t, this.model = i, this.provider = n, this.forceShowAtRange = !0;
  }
  isValidForHoverAnchor(e) {
    return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
  }
}
let nC = class {
  constructor(e, t) {
    this._editor = e, this._themeService = t, this.hoverOrdinal = 2;
  }
  computeSync(e, t) {
    return [];
  }
  computeAsync(e, t, i) {
    return Cs.fromPromise(this._computeAsync(e, t, i));
  }
  async _computeAsync(e, t, i) {
    if (!this._editor.hasModel())
      return [];
    const n = yf.get(this._editor);
    if (!n)
      return [];
    for (const o of t) {
      if (!n.isColorDecoration(o))
        continue;
      const r = n.getColorData(o.range.getStartPosition());
      if (r)
        return [await N7(this, this._editor.getModel(), r.colorInfo, r.provider)];
    }
    return [];
  }
  renderHoverParts(e, t) {
    const i = T7(this, this._editor, this._themeService, t, e);
    if (!i)
      return new fp([]);
    this._colorPicker = i.colorPicker;
    const n = {
      hoverPart: i.hoverPart,
      hoverElement: this._colorPicker.domNode,
      dispose() {
        i.disposables.dispose();
      }
    };
    return new fp([n]);
  }
  handleResize() {
    var e;
    (e = this._colorPicker) == null || e.layout();
  }
  isColorPickerVisible() {
    return !!this._colorPicker;
  }
};
nC = E7([
  I7(1, wn)
], nC);
class oee {
  constructor(e, t, i, n) {
    this.owner = e, this.range = t, this.model = i, this.provider = n;
  }
}
let sC = class {
  constructor(e, t) {
    this._editor = e, this._themeService = t, this._color = null;
  }
  async createColorHover(e, t, i) {
    if (!this._editor.hasModel() || !yf.get(this._editor))
      return null;
    const o = await S7(i, this._editor.getModel(), _t.None);
    let r = null, a = null;
    for (const d of o) {
      const u = d.colorInfo;
      T.containsRange(u.range, e.range) && (r = u, a = d.provider);
    }
    const l = r ?? e, c = a ?? t, h = !!r;
    return { colorHover: await N7(this, this._editor.getModel(), l, c), foundInEditor: h };
  }
  async updateEditorModel(e) {
    if (!this._editor.hasModel())
      return;
    const t = e.model;
    let i = new T(e.range.startLineNumber, e.range.startColumn, e.range.endLineNumber, e.range.endColumn);
    this._color && (await wb(this._editor.getModel(), t, this._color, i, e), i = M7(this._editor, i, t));
  }
  renderHoverParts(e, t) {
    return T7(this, this._editor, this._themeService, t, e);
  }
  set color(e) {
    this._color = e;
  }
  get color() {
    return this._color;
  }
};
sC = E7([
  I7(1, wn)
], sC);
async function N7(s, e, t, i) {
  const n = e.getValueInRange(t.range), { red: o, green: r, blue: a, alpha: l } = t.color, c = new ze(Math.round(o * 255), Math.round(r * 255), Math.round(a * 255), l), h = new j(c), d = await L7(e, t, i, _t.None), u = new ZJ(h, [], 0);
  return u.colorPresentations = d || [], u.guessColorPresentation(h, n), s instanceof nC ? new see(s, T.lift(t.range), u, i) : new oee(s, T.lift(t.range), u, i);
}
function T7(s, e, t, i, n) {
  if (i.length === 0 || !e.hasModel())
    return;
  if (n.setMinimumDimensions) {
    const u = e.getOption(
      67
      /* EditorOption.lineHeight */
    ) + 8;
    n.setMinimumDimensions(new ti(302, u));
  }
  const o = new ne(), r = i[0], a = e.getModel(), l = r.model, c = o.add(new nee(n.fragment, l, e.getOption(
    144
    /* EditorOption.pixelRatio */
  ), t, s instanceof sC));
  let h = !1, d = new T(r.range.startLineNumber, r.range.startColumn, r.range.endLineNumber, r.range.endColumn);
  if (s instanceof sC) {
    const u = r.model.color;
    s.color = u, wb(a, l, u, d, r), o.add(l.onColorFlushed((f) => {
      s.color = f;
    }));
  } else
    o.add(l.onColorFlushed(async (u) => {
      await wb(a, l, u, d, r), h = !0, d = M7(e, d, l);
    }));
  return o.add(l.onDidChangeColor((u) => {
    wb(a, l, u, d, r);
  })), o.add(e.onDidChangeModelContent((u) => {
    h ? h = !1 : (n.hide(), e.focus());
  })), { hoverPart: r, colorPicker: c, disposables: o };
}
function M7(s, e, t) {
  const i = [], n = t.presentation.textEdit ?? { range: e, text: t.presentation.label, forceMoveMarkers: !1 };
  i.push(n), t.presentation.additionalTextEdits && i.push(...t.presentation.additionalTextEdits);
  const o = T.lift(n.range), r = s.getModel()._setTrackedRange(
    null,
    o,
    3
    /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */
  );
  return s.executeEdits("colorpicker", i), s.pushUndoStop(), s.getModel()._getTrackedRange(r) ?? o;
}
async function wb(s, e, t, i, n) {
  const o = await L7(s, {
    range: i,
    color: {
      red: t.rgba.r / 255,
      green: t.rgba.g / 255,
      blue: t.rgba.b / 255,
      alpha: t.rgba.a
    }
  }, n.provider, _t.None);
  e.colorPresentations = o || [];
}
class mp {
  static capture(e) {
    if (e.getScrollTop() === 0 || e.hasPendingScrollAnimation())
      return new mp(e.getScrollTop(), e.getContentHeight(), null, 0, null);
    let t = null, i = 0;
    const n = e.getVisibleRanges();
    if (n.length > 0) {
      t = n[0].getStartPosition();
      const o = e.getTopForPosition(t.lineNumber, t.column);
      i = e.getScrollTop() - o;
    }
    return new mp(e.getScrollTop(), e.getContentHeight(), t, i, e.getPosition());
  }
  constructor(e, t, i, n, o) {
    this._initialScrollTop = e, this._initialContentHeight = t, this._visiblePosition = i, this._visiblePositionScrollDelta = n, this._cursorPosition = o;
  }
  restore(e) {
    if (!(this._initialContentHeight === e.getContentHeight() && this._initialScrollTop === e.getScrollTop()) && this._visiblePosition) {
      const t = e.getTopForPosition(this._visiblePosition.lineNumber, this._visiblePosition.column);
      e.setScrollTop(t + this._visiblePositionScrollDelta);
    }
  }
  restoreRelativeVerticalPositionOfCursor(e) {
    if (this._initialContentHeight === e.getContentHeight() && this._initialScrollTop === e.getScrollTop())
      return;
    const t = e.getPosition();
    if (!this._cursorPosition || !t)
      return;
    const i = e.getTopForLineNumber(t.lineNumber) - e.getTopForLineNumber(this._cursorPosition.lineNumber);
    e.setScrollTop(
      e.getScrollTop() + i,
      1
      /* ScrollType.Immediate */
    );
  }
}
class R7 {
  static insert(e, t) {
    return {
      range: new T(e.lineNumber, e.column, e.lineNumber, e.column),
      text: t,
      forceMoveMarkers: !0
    };
  }
  static delete(e) {
    return {
      range: e,
      text: null
    };
  }
  static replace(e, t) {
    return {
      range: e,
      text: t
    };
  }
  static replaceMove(e, t) {
    return {
      range: e,
      text: t,
      forceMoveMarkers: !0
    };
  }
}
class A7 {
  constructor(e, t) {
    this.range = e, this.direction = t;
  }
}
class xN {
  constructor(e, t, i) {
    this.hint = e, this.anchor = t, this.provider = i, this._isResolved = !1;
  }
  with(e) {
    const t = new xN(this.hint, e.anchor, this.provider);
    return t._isResolved = this._isResolved, t._currentResolve = this._currentResolve, t;
  }
  async resolve(e) {
    if (typeof this.provider.resolveInlayHint == "function") {
      if (this._currentResolve)
        return await this._currentResolve, e.isCancellationRequested ? void 0 : this.resolve(e);
      this._isResolved || (this._currentResolve = this._doResolve(e).finally(() => this._currentResolve = void 0)), await this._currentResolve;
    }
  }
  async _doResolve(e) {
    try {
      const t = await Promise.resolve(this.provider.resolveInlayHint(this.hint, e));
      this.hint.tooltip = (t == null ? void 0 : t.tooltip) ?? this.hint.tooltip, this.hint.label = (t == null ? void 0 : t.label) ?? this.hint.label, this.hint.textEdits = (t == null ? void 0 : t.textEdits) ?? this.hint.textEdits, this._isResolved = !0;
    } catch (t) {
      Qo(t), this._isResolved = !1;
    }
  }
}
const ku = class ku {
  static async create(e, t, i, n) {
    const o = [], r = e.ordered(t).reverse().map((a) => i.map(async (l) => {
      try {
        const c = await a.provideInlayHints(t, l, n);
        (c != null && c.hints.length || a.onDidChangeInlayHints) && o.push([c ?? ku._emptyInlayHintList, a]);
      } catch (c) {
        Qo(c);
      }
    }));
    if (await Promise.all(r.flat()), n.isCancellationRequested || t.isDisposed())
      throw new ed();
    return new ku(i, o, t);
  }
  constructor(e, t, i) {
    this._disposables = new ne(), this.ranges = e, this.provider = /* @__PURE__ */ new Set();
    const n = [];
    for (const [o, r] of t) {
      this._disposables.add(o), this.provider.add(r);
      for (const a of o.hints) {
        const l = i.validatePosition(a.position);
        let c = "before";
        const h = ku._getRangeAtPosition(i, l);
        let d;
        h.getStartPosition().isBefore(l) ? (d = T.fromPositions(h.getStartPosition(), l), c = "after") : (d = T.fromPositions(l, h.getEndPosition()), c = "before"), n.push(new xN(a, new A7(d, c), r));
      }
    }
    this.items = n.sort((o, r) => F.compare(o.hint.position, r.hint.position));
  }
  dispose() {
    this._disposables.dispose();
  }
  static _getRangeAtPosition(e, t) {
    const i = t.lineNumber, n = e.getWordAtPosition(t);
    if (n)
      return new T(i, n.startColumn, i, n.endColumn);
    e.tokenization.tokenizeIfCheap(i);
    const o = e.tokenization.getLineTokens(i), r = t.column - 1, a = o.findTokenIndexAtOffset(r);
    let l = o.getStartOffset(a), c = o.getEndOffset(a);
    return c - l === 1 && (l === r && a > 1 ? (l = o.getStartOffset(a - 1), c = o.getEndOffset(a - 1)) : c === r && a < o.getCount() - 1 && (l = o.getStartOffset(a + 1), c = o.getEndOffset(a + 1))), new T(i, l + 1, i, c + 1);
  }
};
ku._emptyInlayHintList = Object.freeze({ dispose() {
}, hints: [] });
let oC = ku;
function ree(s) {
  return we.from({
    scheme: Ie.command,
    path: s.id,
    query: s.arguments && encodeURIComponent(JSON.stringify(s.arguments))
  }).toString();
}
const aee = function() {
  if (typeof crypto == "object" && typeof crypto.randomUUID == "function")
    return crypto.randomUUID.bind(crypto);
  let s;
  typeof crypto == "object" && typeof crypto.getRandomValues == "function" ? s = crypto.getRandomValues.bind(crypto) : s = function(i) {
    for (let n = 0; n < i.length; n++)
      i[n] = Math.floor(Math.random() * 256);
    return i;
  };
  const e = new Uint8Array(16), t = [];
  for (let i = 0; i < 256; i++)
    t.push(i.toString(16).padStart(2, "0"));
  return function() {
    s(e), e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128;
    let n = 0, o = "";
    return o += t[e[n++]], o += t[e[n++]], o += t[e[n++]], o += t[e[n++]], o += "-", o += t[e[n++]], o += t[e[n++]], o += "-", o += t[e[n++]], o += t[e[n++]], o += "-", o += t[e[n++]], o += t[e[n++]], o += "-", o += t[e[n++]], o += t[e[n++]], o += t[e[n++]], o += t[e[n++]], o += t[e[n++]], o += t[e[n++]], o;
  };
}();
async function lee(s, e, t, i) {
  const n = s.get(bo), o = s.get(nr), r = s.get(fi), a = s.get(Pe), l = s.get(cn);
  if (await i.item.resolve(_t.None), !i.part.location)
    return;
  const c = i.part.location, h = [], d = new Set(so.getMenuItems(et.EditorContext).map((f) => Nu(f) ? f.command.id : aee()));
  for (const f of ja.all())
    d.has(f.desc.id) && h.push(new ys(f.desc.id, lo.label(f.desc, { renderShortTitle: !0 }), void 0, !0, async () => {
      const g = await n.createModelReference(c.uri);
      try {
        const p = new vf(g.object.textEditorModel, T.getStartPosition(c.range)), _ = i.item.anchor.range;
        await a.invokeFunction(f.runEditorCommand.bind(f), e, p, _);
      } finally {
        g.dispose();
      }
    }));
  if (i.part.command) {
    const { command: f } = i.part;
    h.push(new Vi()), h.push(new ys(f.id, f.title, void 0, !0, async () => {
      try {
        await r.executeCommand(f.id, ...f.arguments ?? []);
      } catch (g) {
        l.notify({
          severity: qI.Error,
          source: i.item.provider.displayName,
          message: g
        });
      }
    }));
  }
  const u = e.getOption(
    128
    /* EditorOption.useShadowDOM */
  );
  o.showContextMenu({
    domForShadowRoot: u ? e.getDomNode() ?? void 0 : void 0,
    getAnchor: () => {
      const f = ui(t);
      return { x: f.left, y: f.top + f.height + 8 };
    },
    getActions: () => h,
    onHide: () => {
      e.focus();
    },
    autoSelectFirstItem: !0
  });
}
async function cee(s, e, t, i) {
  const o = await s.get(bo).createModelReference(i.uri);
  await t.invokeWithinContext(async (r) => {
    const a = e.hasSideBySideModifier, l = r.get(Fe), c = On.inPeekEditor.getValue(l), h = !a && t.getOption(
      89
      /* EditorOption.definitionLinkOpensInPeek */
    ) && !c;
    return new Gp({ openToSide: a, openInPeek: h, muteMessage: !0 }, { title: { value: "", original: "" }, id: "", precondition: void 0 }).run(r, new vf(o.object.textEditorModel, T.getStartPosition(i.range)), T.lift(i.range));
  }), o.dispose();
}
var hee = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Bd = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Ud;
class rC {
  constructor() {
    this._entries = new Mf(50);
  }
  get(e) {
    const t = rC._key(e);
    return this._entries.get(t);
  }
  set(e, t) {
    const i = rC._key(e);
    this._entries.set(i, t);
  }
  static _key(e) {
    return `${e.uri.toString()}/${e.getVersionId()}`;
  }
}
const P7 = Be("IInlayHintsCache");
Ze(
  P7,
  rC,
  1
  /* InstantiationType.Delayed */
);
class tk {
  constructor(e, t) {
    this.item = e, this.index = t;
  }
  get part() {
    const e = this.item.hint.label;
    return typeof e == "string" ? { label: e } : e[this.index];
  }
}
class dee {
  constructor(e, t) {
    this.part = e, this.hasTriggerModifier = t;
  }
}
var Ra;
let ik = (Ra = class {
  static get(e) {
    return e.getContribution(Ud.ID) ?? void 0;
  }
  constructor(e, t, i, n, o, r, a) {
    this._editor = e, this._languageFeaturesService = t, this._inlayHintsCache = n, this._commandService = o, this._notificationService = r, this._instaService = a, this._disposables = new ne(), this._sessionDisposables = new ne(), this._decorationsMetadata = /* @__PURE__ */ new Map(), this._ruleFactory = new c1(this._editor), this._activeRenderMode = 0, this._debounceInfo = i.for(t.inlayHintsProvider, "InlayHint", { min: 25 }), this._disposables.add(t.inlayHintsProvider.onDidChange(() => this._update())), this._disposables.add(e.onDidChangeModel(() => this._update())), this._disposables.add(e.onDidChangeModelLanguage(() => this._update())), this._disposables.add(e.onDidChangeConfiguration((l) => {
      l.hasChanged(
        142
        /* EditorOption.inlayHints */
      ) && this._update();
    })), this._update();
  }
  dispose() {
    this._sessionDisposables.dispose(), this._removeAllDecorations(), this._disposables.dispose();
  }
  _update() {
    this._sessionDisposables.clear(), this._removeAllDecorations();
    const e = this._editor.getOption(
      142
      /* EditorOption.inlayHints */
    );
    if (e.enabled === "off")
      return;
    const t = this._editor.getModel();
    if (!t || !this._languageFeaturesService.inlayHintsProvider.has(t))
      return;
    if (e.enabled === "on")
      this._activeRenderMode = 0;
    else {
      let a, l;
      e.enabled === "onUnlessPressed" ? (a = 0, l = 1) : (a = 1, l = 0), this._activeRenderMode = a, this._sessionDisposables.add(xa.getInstance().event((c) => {
        if (!this._editor.hasModel())
          return;
        const h = c.altKey && c.ctrlKey && !(c.shiftKey || c.metaKey) ? l : a;
        if (h !== this._activeRenderMode) {
          this._activeRenderMode = h;
          const d = this._editor.getModel(), u = this._copyInlayHintsWithCurrentAnchor(d);
          this._updateHintsDecorators([d.getFullModelRange()], u), r.schedule(0);
        }
      }));
    }
    const i = this._inlayHintsCache.get(t);
    i && this._updateHintsDecorators([t.getFullModelRange()], i), this._sessionDisposables.add(_e(() => {
      t.isDisposed() || this._cacheHintsForFastRestore(t);
    }));
    let n;
    const o = /* @__PURE__ */ new Set(), r = new ai(async () => {
      const a = Date.now();
      n == null || n.dispose(!0), n = new Vs();
      const l = t.onWillDispose(() => n == null ? void 0 : n.cancel());
      try {
        const c = n.token, h = await oC.create(this._languageFeaturesService.inlayHintsProvider, t, this._getHintsRanges(), c);
        if (r.delay = this._debounceInfo.update(t, Date.now() - a), c.isCancellationRequested) {
          h.dispose();
          return;
        }
        for (const d of h.provider)
          typeof d.onDidChangeInlayHints == "function" && !o.has(d) && (o.add(d), this._sessionDisposables.add(d.onDidChangeInlayHints(() => {
            r.isScheduled() || r.schedule();
          })));
        this._sessionDisposables.add(h), this._updateHintsDecorators(h.ranges, h.items), this._cacheHintsForFastRestore(t);
      } catch (c) {
        Je(c);
      } finally {
        n.dispose(), l.dispose();
      }
    }, this._debounceInfo.get(t));
    this._sessionDisposables.add(r), this._sessionDisposables.add(_e(() => n == null ? void 0 : n.dispose(!0))), r.schedule(0), this._sessionDisposables.add(this._editor.onDidScrollChange((a) => {
      (a.scrollTopChanged || !r.isScheduled()) && r.schedule();
    })), this._sessionDisposables.add(this._editor.onDidChangeModelContent((a) => {
      n == null || n.cancel();
      const l = Math.max(r.delay, 1250);
      r.schedule(l);
    })), this._sessionDisposables.add(this._installDblClickGesture(() => r.schedule(0))), this._sessionDisposables.add(this._installLinkGesture()), this._sessionDisposables.add(this._installContextMenu());
  }
  _installLinkGesture() {
    const e = new ne(), t = e.add(new lO(this._editor)), i = new ne();
    return e.add(i), e.add(t.onMouseMoveOrRelevantKeyDown((n) => {
      const [o] = n, r = this._getInlayHintLabelPart(o), a = this._editor.getModel();
      if (!r || !a) {
        i.clear();
        return;
      }
      const l = new Vs();
      i.add(_e(() => l.dispose(!0))), r.item.resolve(l.token), this._activeInlayHintPart = r.part.command || r.part.location ? new dee(r, o.hasTriggerModifier) : void 0;
      const c = a.validatePosition(r.item.hint.position).lineNumber, h = new T(c, 1, c, a.getLineMaxColumn(c)), d = this._getInlineHintsForRange(h);
      this._updateHintsDecorators([h], d), i.add(_e(() => {
        this._activeInlayHintPart = void 0, this._updateHintsDecorators([h], d);
      }));
    })), e.add(t.onCancel(() => i.clear())), e.add(t.onExecute(async (n) => {
      const o = this._getInlayHintLabelPart(n);
      if (o) {
        const r = o.part;
        r.location ? this._instaService.invokeFunction(cee, n, this._editor, r.location) : $S.is(r.command) && await this._invokeCommand(r.command, o.item);
      }
    })), e;
  }
  _getInlineHintsForRange(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of this._decorationsMetadata.values())
      e.containsRange(i.item.anchor.range) && t.add(i.item);
    return Array.from(t);
  }
  _installDblClickGesture(e) {
    return this._editor.onMouseUp(async (t) => {
      if (t.event.detail !== 2)
        return;
      const i = this._getInlayHintLabelPart(t);
      if (i && (t.event.preventDefault(), await i.item.resolve(_t.None), co(i.item.hint.textEdits))) {
        const n = i.item.hint.textEdits.map((o) => R7.replace(T.lift(o.range), o.text));
        this._editor.executeEdits("inlayHint.default", n), e();
      }
    });
  }
  _installContextMenu() {
    return this._editor.onContextMenu(async (e) => {
      if (!ki(e.event.target))
        return;
      const t = this._getInlayHintLabelPart(e);
      t && await this._instaService.invokeFunction(lee, this._editor, e.event.target, t);
    });
  }
  _getInlayHintLabelPart(e) {
    var i;
    if (e.target.type !== 6)
      return;
    const t = (i = e.target.detail.injectedText) == null ? void 0 : i.options;
    if (t instanceof Jl && (t == null ? void 0 : t.attachedData) instanceof tk)
      return t.attachedData;
  }
  async _invokeCommand(e, t) {
    try {
      await this._commandService.executeCommand(e.id, ...e.arguments ?? []);
    } catch (i) {
      this._notificationService.notify({
        severity: qI.Error,
        source: t.provider.displayName,
        message: i
      });
    }
  }
  _cacheHintsForFastRestore(e) {
    const t = this._copyInlayHintsWithCurrentAnchor(e);
    this._inlayHintsCache.set(e, t);
  }
  // return inlay hints but with an anchor that reflects "updates"
  // that happened after receiving them, e.g adding new lines before a hint
  _copyInlayHintsWithCurrentAnchor(e) {
    const t = /* @__PURE__ */ new Map();
    for (const [i, n] of this._decorationsMetadata) {
      if (t.has(n.item))
        continue;
      const o = e.getDecorationRange(i);
      if (o) {
        const r = new A7(o, n.item.anchor.direction), a = n.item.with({ anchor: r });
        t.set(n.item, a);
      }
    }
    return Array.from(t.values());
  }
  _getHintsRanges() {
    const t = this._editor.getModel(), i = this._editor.getVisibleRangesPlusViewportAboveBelow(), n = [];
    for (const o of i.sort(T.compareRangesUsingStarts)) {
      const r = t.validateRange(new T(o.startLineNumber - 30, o.startColumn, o.endLineNumber + 30, o.endColumn));
      n.length === 0 || !T.areIntersectingOrTouching(n[n.length - 1], r) ? n.push(r) : n[n.length - 1] = T.plusRange(n[n.length - 1], r);
    }
    return n;
  }
  _updateHintsDecorators(e, t) {
    var g, p;
    const i = [], n = (_, b, C, w, v) => {
      const S = {
        content: C,
        inlineClassNameAffectsLetterSpacing: !0,
        inlineClassName: b.className,
        cursorStops: w,
        attachedData: v
      };
      i.push({
        item: _,
        classNameRef: b,
        decoration: {
          range: _.anchor.range,
          options: {
            // className: "rangeHighlight", // DEBUG highlight to see to what range a hint is attached
            description: "InlayHint",
            showIfCollapsed: _.anchor.range.isEmpty(),
            // "original" range is empty
            collapseOnReplaceEdit: !_.anchor.range.isEmpty(),
            stickiness: 0,
            [_.anchor.direction]: this._activeRenderMode === 0 ? S : void 0
          }
        }
      });
    }, o = (_, b) => {
      const C = this._ruleFactory.createClassNameRef({
        width: `${r / 3 | 0}px`,
        display: "inline-block"
      });
      n(_, C, " ", b ? Nr.Right : Nr.None);
    }, { fontSize: r, fontFamily: a, padding: l, isUniform: c } = this._getLayoutInfo(), h = "--code-editorInlayHintsFontFamily";
    this._editor.getContainerDomNode().style.setProperty(h, a);
    let d = { line: 0, totalLen: 0 };
    for (const _ of t) {
      if (d.line !== _.anchor.range.startLineNumber && (d = { line: _.anchor.range.startLineNumber, totalLen: 0 }), d.totalLen > Ud._MAX_LABEL_LEN)
        continue;
      _.hint.paddingLeft && o(_, !1);
      const b = typeof _.hint.label == "string" ? [{ label: _.hint.label }] : _.hint.label;
      for (let C = 0; C < b.length; C++) {
        const w = b[C], v = C === 0, S = C === b.length - 1, L = {
          fontSize: `${r}px`,
          fontFamily: `var(${h}), ${Qn.fontFamily}`,
          verticalAlign: c ? "baseline" : "middle",
          unicodeBidi: "isolate"
        };
        co(_.hint.textEdits) && (L.cursor = "default"), this._fillInColors(L, _.hint), (w.command || w.location) && ((g = this._activeInlayHintPart) == null ? void 0 : g.part.item) === _ && this._activeInlayHintPart.part.index === C && (L.textDecoration = "underline", this._activeInlayHintPart.hasTriggerModifier && (L.color = Ts(Mz), L.cursor = "pointer")), l && (v && S ? (L.padding = `1px ${Math.max(1, r / 4) | 0}px`, L.borderRadius = `${r / 4 | 0}px`) : v ? (L.padding = `1px 0 1px ${Math.max(1, r / 4) | 0}px`, L.borderRadius = `${r / 4 | 0}px 0 0 ${r / 4 | 0}px`) : S ? (L.padding = `1px ${Math.max(1, r / 4) | 0}px 1px 0`, L.borderRadius = `0 ${r / 4 | 0}px ${r / 4 | 0}px 0`) : L.padding = "1px 0 1px 0");
        let k = w.label;
        d.totalLen += k.length;
        let x = !1;
        const I = d.totalLen - Ud._MAX_LABEL_LEN;
        if (I > 0 && (k = k.slice(0, -I) + "…", x = !0), n(_, this._ruleFactory.createClassNameRef(L), uee(k), S && !_.hint.paddingRight ? Nr.Right : Nr.None, new tk(_, C)), x)
          break;
      }
      if (_.hint.paddingRight && o(_, !0), i.length > Ud._MAX_DECORATORS)
        break;
    }
    const u = [];
    for (const [_, b] of this._decorationsMetadata) {
      const C = (p = this._editor.getModel()) == null ? void 0 : p.getDecorationRange(_);
      C && e.some((w) => w.containsRange(C)) && (u.push(_), b.classNameRef.dispose(), this._decorationsMetadata.delete(_));
    }
    const f = mp.capture(this._editor);
    this._editor.changeDecorations((_) => {
      const b = _.deltaDecorations(u, i.map((C) => C.decoration));
      for (let C = 0; C < b.length; C++) {
        const w = i[C];
        this._decorationsMetadata.set(b[C], w);
      }
    }), f.restore(this._editor);
  }
  _fillInColors(e, t) {
    t.kind === p1.Parameter ? (e.backgroundColor = Ts(Fz), e.color = Ts(Oz)) : t.kind === p1.Type ? (e.backgroundColor = Ts(Pz), e.color = Ts(Az)) : (e.backgroundColor = Ts(rI), e.color = Ts(oI));
  }
  _getLayoutInfo() {
    const e = this._editor.getOption(
      142
      /* EditorOption.inlayHints */
    ), t = e.padding, i = this._editor.getOption(
      52
      /* EditorOption.fontSize */
    ), n = this._editor.getOption(
      49
      /* EditorOption.fontFamily */
    );
    let o = e.fontSize;
    (!o || o < 5 || o > i) && (o = i);
    const r = e.fontFamily || n;
    return { fontSize: o, fontFamily: r, padding: t, isUniform: !t && r === n && o === i };
  }
  _removeAllDecorations() {
    this._editor.removeDecorations(Array.from(this._decorationsMetadata.keys()));
    for (const e of this._decorationsMetadata.values())
      e.classNameRef.dispose();
    this._decorationsMetadata.clear();
  }
}, Ud = Ra, Ra.ID = "editor.contrib.InlayHints", Ra._MAX_DECORATORS = 1500, Ra._MAX_LABEL_LEN = 43, Ra);
ik = Ud = hee([
  Bd(1, De),
  Bd(2, kN),
  Bd(3, P7),
  Bd(4, fi),
  Bd(5, cn),
  Bd(6, Pe)
], ik);
function uee(s) {
  return s.replace(/[ \t]/g, " ");
}
St.registerCommand("_executeInlayHintProvider", async (s, ...e) => {
  const [t, i] = e;
  qi(we.isUri(t)), qi(T.isIRange(i));
  const { inlayHintsProvider: n } = s.get(De), o = await s.get(bo).createModelReference(t);
  try {
    const r = await oC.create(n, o.object.textEditorModel, [T.lift(i)], _t.None), a = r.items.map((l) => l.hint);
    return setTimeout(() => r.dispose(), 0), a;
  } finally {
    o.dispose();
  }
});
var fee = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, al = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class CR extends bJ {
  constructor(e, t, i, n) {
    super(10, t, e.item.anchor.range, i, n, !0), this.part = e;
  }
}
let nk = class extends gp {
  constructor(e, t, i, n, o, r, a, l, c) {
    super(e, t, i, r, l, n, o, c), this._resolverService = a, this.hoverOrdinal = 6;
  }
  suggestHoverAnchor(e) {
    var n;
    if (!ik.get(this._editor) || e.target.type !== 6)
      return null;
    const i = (n = e.target.detail.injectedText) == null ? void 0 : n.options;
    return i instanceof Jl && i.attachedData instanceof tk ? new CR(i.attachedData, this, e.event.posx, e.event.posy) : null;
  }
  computeSync() {
    return [];
  }
  computeAsync(e, t, i) {
    return e instanceof CR ? new Cs(async (n) => {
      const { part: o } = e;
      if (await o.item.resolve(i), i.isCancellationRequested)
        return;
      let r;
      typeof o.item.hint.tooltip == "string" ? r = new Oo().appendText(o.item.hint.tooltip) : o.item.hint.tooltip && (r = o.item.hint.tooltip), r && n.emitOne(new Vo(this, e.range, [r], !1, 0)), co(o.item.hint.textEdits) && n.emitOne(new Vo(this, e.range, [new Oo().appendText(m("hint.dbl", "Double-click to insert"))], !1, 10001));
      let a;
      if (typeof o.part.tooltip == "string" ? a = new Oo().appendText(o.part.tooltip) : o.part.tooltip && (a = o.part.tooltip), a && n.emitOne(new Vo(this, e.range, [a], !1, 1)), o.part.location || o.part.command) {
        let c;
        const d = this._editor.getOption(
          78
          /* EditorOption.multiCursorModifier */
        ) === "altKey" ? $e ? m("links.navigate.kb.meta.mac", "cmd + click") : m("links.navigate.kb.meta", "ctrl + click") : $e ? m("links.navigate.kb.alt.mac", "option + click") : m("links.navigate.kb.alt", "alt + click");
        o.part.location && o.part.command ? c = new Oo().appendText(m("hint.defAndCommand", "Go to Definition ({0}), right click for more", d)) : o.part.location ? c = new Oo().appendText(m("hint.def", "Go to Definition ({0})", d)) : o.part.command && (c = new Oo(`[${m("hint.cmd", "Execute Command")}](${ree(o.part.command)} "${o.part.command.title}") (${d})`, { isTrusted: !0 })), c && n.emitOne(new Vo(this, e.range, [c], !1, 1e4));
      }
      const l = await this._resolveInlayHintLabelPartHover(o, i);
      for await (const c of l)
        n.emitOne(c);
    }) : Cs.EMPTY;
  }
  async _resolveInlayHintLabelPartHover(e, t) {
    if (!e.part.location)
      return Cs.EMPTY;
    const { uri: i, range: n } = e.part.location, o = await this._resolverService.createModelReference(i);
    try {
      const r = o.object.textEditorModel;
      return this._languageFeaturesService.hoverProvider.has(r) ? SN(this._languageFeaturesService.hoverProvider, r, new F(n.startLineNumber, n.startColumn), t).filter((a) => !rf(a.hover.contents)).map((a) => new Vo(this, e.item.anchor.range, a.hover.contents, !1, 2 + a.ordinal)) : Cs.EMPTY;
    } finally {
      o.dispose();
    }
  }
};
nk = fee([
  al(1, ci),
  al(2, sr),
  al(3, Lt),
  al(4, Cd),
  al(5, gt),
  al(6, bo),
  al(7, De),
  al(8, fi)
], nk);
class DN extends U {
  constructor(e, t, i, n, o, r) {
    super();
    const a = t.anchor, l = t.hoverParts;
    this._renderedHoverParts = this._register(new sk(e, i, l, r, o));
    const { showAtPosition: c, showAtSecondaryPosition: h } = DN.computeHoverPositions(e, a.range, l);
    this.shouldAppearBeforeContent = l.some((d) => d.isBeforeContent), this.showAtPosition = c, this.showAtSecondaryPosition = h, this.initialMousePosX = a.initialMousePosX, this.initialMousePosY = a.initialMousePosY, this.shouldFocus = n.shouldFocus, this.source = n.source;
  }
  get domNode() {
    return this._renderedHoverParts.domNode;
  }
  get domNodeHasChildren() {
    return this._renderedHoverParts.domNodeHasChildren;
  }
  get focusedHoverPartIndex() {
    return this._renderedHoverParts.focusedHoverPartIndex;
  }
  async updateHoverVerbosityLevel(e, t, i) {
    this._renderedHoverParts.updateHoverVerbosityLevel(e, t, i);
  }
  isColorPickerVisible() {
    return this._renderedHoverParts.isColorPickerVisible();
  }
  static computeHoverPositions(e, t, i) {
    let n = 1;
    if (e.hasModel()) {
      const h = e._getViewModel(), d = h.coordinatesConverter, u = d.convertModelRangeToViewRange(t), f = h.getLineMinColumn(u.startLineNumber), g = new F(u.startLineNumber, f);
      n = d.convertViewPositionToModelPosition(g).column;
    }
    const o = t.startLineNumber;
    let r = t.startColumn, a;
    for (const h of i) {
      const d = h.range, u = d.startLineNumber === o, f = d.endLineNumber === o;
      if (u && f) {
        const p = d.startColumn, _ = Math.min(r, p);
        r = Math.max(_, n);
      }
      h.forceShowAtRange && (a = d);
    }
    let l, c;
    if (a) {
      const h = a.getStartPosition();
      l = h, c = h;
    } else
      l = t.getStartPosition(), c = new F(o, r);
    return {
      showAtPosition: l,
      showAtSecondaryPosition: c
    };
  }
}
class gee {
  constructor(e, t) {
    this._statusBar = t, e.appendChild(this._statusBar.hoverElement);
  }
  get hoverElement() {
    return this._statusBar.hoverElement;
  }
  get actions() {
    return this._statusBar.actions;
  }
  dispose() {
    this._statusBar.dispose();
  }
}
const _v = class _v extends U {
  constructor(e, t, i, n, o) {
    super(), this._renderedParts = [], this._focusedHoverPartIndex = -1, this._context = o, this._fragment = document.createDocumentFragment(), this._register(this._renderParts(t, i, o, n)), this._register(this._registerListenersOnRenderedParts()), this._register(this._createEditorDecorations(e, i)), this._updateMarkdownAndColorParticipantInfo(t);
  }
  _createEditorDecorations(e, t) {
    if (t.length === 0)
      return U.None;
    let i = t[0].range;
    for (const o of t) {
      const r = o.range;
      i = T.plusRange(i, r);
    }
    const n = e.createDecorationsCollection();
    return n.set([{
      range: i,
      options: _v._DECORATION_OPTIONS
    }]), _e(() => {
      n.clear();
    });
  }
  _renderParts(e, t, i, n) {
    const o = new YL(n), r = {
      fragment: this._fragment,
      statusBar: o,
      ...i
    }, a = new ne();
    for (const c of e) {
      const h = this._renderHoverPartsForParticipant(t, c, r);
      a.add(h);
      for (const d of h.renderedHoverParts)
        this._renderedParts.push({
          type: "hoverPart",
          participant: c,
          hoverPart: d.hoverPart,
          hoverElement: d.hoverElement
        });
    }
    const l = this._renderStatusBar(this._fragment, o);
    return l && (a.add(l), this._renderedParts.push({
      type: "statusBar",
      hoverElement: l.hoverElement,
      actions: l.actions
    })), _e(() => {
      a.dispose();
    });
  }
  _renderHoverPartsForParticipant(e, t, i) {
    const n = e.filter((r) => r.owner === t);
    return n.length > 0 ? t.renderHoverParts(i, n) : new fp([]);
  }
  _renderStatusBar(e, t) {
    if (t.hasContent)
      return new gee(e, t);
  }
  _registerListenersOnRenderedParts() {
    const e = new ne();
    return this._renderedParts.forEach((t, i) => {
      const n = t.hoverElement;
      n.tabIndex = 0, e.add(z(n, X.FOCUS_IN, (o) => {
        o.stopPropagation(), this._focusedHoverPartIndex = i;
      })), e.add(z(n, X.FOCUS_OUT, (o) => {
        o.stopPropagation(), this._focusedHoverPartIndex = -1;
      }));
    }), e;
  }
  _updateMarkdownAndColorParticipantInfo(e) {
    const t = e.find((i) => i instanceof gp && !(i instanceof nk));
    t && (this._markdownHoverParticipant = t), this._colorHoverParticipant = e.find((i) => i instanceof nC);
  }
  async updateHoverVerbosityLevel(e, t, i) {
    if (!this._markdownHoverParticipant)
      return;
    const n = this._normalizedIndexToMarkdownHoverIndexRange(this._markdownHoverParticipant, t);
    if (n === void 0)
      return;
    const o = await this._markdownHoverParticipant.updateMarkdownHoverVerbosityLevel(e, n, i);
    o && (this._renderedParts[t] = {
      type: "hoverPart",
      participant: this._markdownHoverParticipant,
      hoverPart: o.hoverPart,
      hoverElement: o.hoverElement
    }, this._context.onContentsChanged());
  }
  isColorPickerVisible() {
    var e;
    return ((e = this._colorHoverParticipant) == null ? void 0 : e.isColorPickerVisible()) ?? !1;
  }
  _normalizedIndexToMarkdownHoverIndexRange(e, t) {
    const i = this._renderedParts[t];
    if (!i || i.type !== "hoverPart" || !(i.participant === e))
      return;
    const o = this._renderedParts.findIndex((r) => r.type === "hoverPart" && r.participant === e);
    if (o === -1)
      throw new at();
    return t - o;
  }
  get domNode() {
    return this._fragment;
  }
  get domNodeHasChildren() {
    return this._fragment.hasChildNodes();
  }
  get focusedHoverPartIndex() {
    return this._focusedHoverPartIndex;
  }
};
_v._DECORATION_OPTIONS = Wt.register({
  description: "content-hover-highlight",
  className: "hoverHighlight"
});
let sk = _v;
var mee = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, vR = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let ok = class extends U {
  constructor(e, t, i) {
    super(), this._editor = e, this._instantiationService = t, this._keybindingService = i, this._currentResult = null, this._onContentsChanged = this._register(new A()), this.onContentsChanged = this._onContentsChanged.event, this._contentHoverWidget = this._register(this._instantiationService.createInstance(ZL, this._editor)), this._participants = this._initializeHoverParticipants(), this._computer = new eC(this._editor, this._participants), this._hoverOperation = this._register(new g7(this._editor, this._computer)), this._registerListeners();
  }
  _initializeHoverParticipants() {
    const e = [];
    for (const t of wN.getAll()) {
      const i = this._instantiationService.createInstance(t, this._editor);
      e.push(i);
    }
    return e.sort((t, i) => t.hoverOrdinal - i.hoverOrdinal), this._register(this._contentHoverWidget.onDidResize(() => {
      this._participants.forEach((t) => {
        var i;
        return (i = t.handleResize) == null ? void 0 : i.call(t);
      });
    })), e;
  }
  _registerListeners() {
    this._register(this._hoverOperation.onResult((t) => {
      if (!this._computer.anchor)
        return;
      const i = t.hasLoadingMessage ? this._addLoadingMessage(t.value) : t.value;
      this._withResult(new b7(this._computer.anchor, i, t.isComplete));
    }));
    const e = this._contentHoverWidget.getDomNode();
    this._register(Zt(e, "keydown", (t) => {
      t.equals(
        9
        /* KeyCode.Escape */
      ) && this.hide();
    })), this._register(Zt(e, "mouseleave", (t) => {
      this._onMouseLeave(t);
    })), this._register(ii.onDidChange(() => {
      this._contentHoverWidget.position && this._currentResult && this._setCurrentResult(this._currentResult);
    }));
  }
  /**
   * Returns true if the hover shows now or will show.
   */
  _startShowingOrUpdateHover(e, t, i, n, o) {
    if (!(this._contentHoverWidget.position && this._currentResult))
      return e ? (this._startHoverOperationIfNecessary(e, t, i, n, !1), !0) : !1;
    const a = this._editor.getOption(
      60
      /* EditorOption.hover */
    ).sticky, l = o && this._contentHoverWidget.isMouseGettingCloser(o.event.posx, o.event.posy);
    return a && l ? (e && this._startHoverOperationIfNecessary(e, t, i, n, !0), !0) : e ? this._currentResult.anchor.equals(e) ? !0 : e.canAdoptVisibleHover(this._currentResult.anchor, this._contentHoverWidget.position) ? (this._setCurrentResult(this._currentResult.filter(e)), this._startHoverOperationIfNecessary(e, t, i, n, !1), !0) : (this._setCurrentResult(null), this._startHoverOperationIfNecessary(e, t, i, n, !1), !0) : (this._setCurrentResult(null), !1);
  }
  _startHoverOperationIfNecessary(e, t, i, n, o) {
    this._computer.anchor && this._computer.anchor.equals(e) || (this._hoverOperation.cancel(), this._computer.anchor = e, this._computer.shouldFocus = n, this._computer.source = i, this._computer.insistOnKeepingHoverVisible = o, this._hoverOperation.start(t));
  }
  _setCurrentResult(e) {
    let t = e;
    if (this._currentResult === t)
      return;
    t && t.hoverParts.length === 0 && (t = null), this._currentResult = t, this._currentResult ? this._showHover(this._currentResult) : this._hideHover();
  }
  _addLoadingMessage(e) {
    if (!this._computer.anchor)
      return e;
    for (const t of this._participants) {
      if (!t.createLoadingMessage)
        continue;
      const i = t.createLoadingMessage(this._computer.anchor);
      if (i)
        return e.slice(0).concat([i]);
    }
    return e;
  }
  _withResult(e) {
    if (this._contentHoverWidget.position && this._currentResult && this._currentResult.isComplete || this._setCurrentResult(e), !e.isComplete)
      return;
    const n = e.hoverParts.length === 0, o = this._computer.insistOnKeepingHoverVisible;
    n && o || this._setCurrentResult(e);
  }
  _showHover(e) {
    const t = this._getHoverContext();
    this._renderedContentHover = new DN(this._editor, e, this._participants, this._computer, t, this._keybindingService), this._renderedContentHover.domNodeHasChildren ? this._contentHoverWidget.show(this._renderedContentHover) : this._renderedContentHover.dispose();
  }
  _hideHover() {
    this._contentHoverWidget.hide();
  }
  _getHoverContext() {
    return { hide: () => {
      this.hide();
    }, onContentsChanged: () => {
      this._onContentsChanged.fire(), this._contentHoverWidget.onContentsChanged();
    }, setMinimumDimensions: (n) => {
      this._contentHoverWidget.setMinimumDimensions(n);
    } };
  }
  showsOrWillShow(e) {
    if (this._contentHoverWidget.isResizing)
      return !0;
    const i = this._findHoverAnchorCandidates(e);
    if (!(i.length > 0))
      return this._startShowingOrUpdateHover(null, 0, 0, !1, e);
    const o = i[0];
    return this._startShowingOrUpdateHover(o, 0, 0, !1, e);
  }
  _findHoverAnchorCandidates(e) {
    const t = [];
    for (const n of this._participants) {
      if (!n.suggestHoverAnchor)
        continue;
      const o = n.suggestHoverAnchor(e);
      o && t.push(o);
    }
    const i = e.target;
    switch (i.type) {
      case 6: {
        t.push(new cy(0, i.range, e.event.posx, e.event.posy));
        break;
      }
      case 7: {
        const n = this._editor.getOption(
          50
          /* EditorOption.fontInfo */
        ).typicalHalfwidthCharacterWidth / 2;
        if (!(!i.detail.isAfterLines && typeof i.detail.horizontalDistanceToText == "number" && i.detail.horizontalDistanceToText < n))
          break;
        t.push(new cy(0, i.range, e.event.posx, e.event.posy));
        break;
      }
    }
    return t.sort((n, o) => o.priority - n.priority), t;
  }
  _onMouseLeave(e) {
    const t = this._editor.getDomNode();
    (!t || !$w(t, e.x, e.y)) && this.hide();
  }
  startShowingAtRange(e, t, i, n) {
    this._startShowingOrUpdateHover(new cy(0, e, void 0, void 0), t, i, n, null);
  }
  async updateHoverVerbosityLevel(e, t, i) {
    var n;
    (n = this._renderedContentHover) == null || n.updateHoverVerbosityLevel(e, t, i);
  }
  focusedHoverPartIndex() {
    var e;
    return ((e = this._renderedContentHover) == null ? void 0 : e.focusedHoverPartIndex) ?? -1;
  }
  containsNode(e) {
    return e ? this._contentHoverWidget.getDomNode().contains(e) : !1;
  }
  focus() {
    this._contentHoverWidget.focus();
  }
  scrollUp() {
    this._contentHoverWidget.scrollUp();
  }
  scrollDown() {
    this._contentHoverWidget.scrollDown();
  }
  scrollLeft() {
    this._contentHoverWidget.scrollLeft();
  }
  scrollRight() {
    this._contentHoverWidget.scrollRight();
  }
  pageUp() {
    this._contentHoverWidget.pageUp();
  }
  pageDown() {
    this._contentHoverWidget.pageDown();
  }
  goToTop() {
    this._contentHoverWidget.goToTop();
  }
  goToBottom() {
    this._contentHoverWidget.goToBottom();
  }
  hide() {
    this._computer.anchor = null, this._hoverOperation.cancel(), this._setCurrentResult(null);
  }
  getDomNode() {
    return this._contentHoverWidget.getDomNode();
  }
  get isColorPickerVisible() {
    var e;
    return ((e = this._renderedContentHover) == null ? void 0 : e.isColorPickerVisible()) ?? !1;
  }
  get isVisibleFromKeyboard() {
    return this._contentHoverWidget.isVisibleFromKeyboard;
  }
  get isVisible() {
    return this._contentHoverWidget.isVisible;
  }
  get isFocused() {
    return this._contentHoverWidget.isFocused;
  }
  get isResizing() {
    return this._contentHoverWidget.isResizing;
  }
  get widget() {
    return this._contentHoverWidget;
  }
};
ok = mee([
  vR(1, Pe),
  vR(2, Lt)
], ok);
var pee = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, wR = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, rk, xh;
let vn = (xh = class extends U {
  constructor(e, t, i) {
    super(), this._editor = e, this._instantiationService = t, this._keybindingService = i, this._onHoverContentsChanged = this._register(new A()), this.shouldKeepOpenOnEditorMouseMoveOrLeave = !1, this._listenersStore = new ne(), this._hoverState = {
      mouseDown: !1,
      activatedByDecoratorClick: !1
    }, this._reactToEditorMouseMoveRunner = this._register(new ai(() => this._reactToEditorMouseMove(this._mouseMoveEvent), 0)), this._hookListeners(), this._register(this._editor.onDidChangeConfiguration((n) => {
      n.hasChanged(
        60
        /* EditorOption.hover */
      ) && (this._unhookListeners(), this._hookListeners());
    }));
  }
  static get(e) {
    return e.getContribution(rk.ID);
  }
  _hookListeners() {
    const e = this._editor.getOption(
      60
      /* EditorOption.hover */
    );
    this._hoverSettings = {
      enabled: e.enabled,
      sticky: e.sticky,
      hidingDelay: e.hidingDelay
    }, e.enabled ? (this._listenersStore.add(this._editor.onMouseDown((t) => this._onEditorMouseDown(t))), this._listenersStore.add(this._editor.onMouseUp(() => this._onEditorMouseUp())), this._listenersStore.add(this._editor.onMouseMove((t) => this._onEditorMouseMove(t))), this._listenersStore.add(this._editor.onKeyDown((t) => this._onKeyDown(t)))) : (this._listenersStore.add(this._editor.onMouseMove((t) => this._onEditorMouseMove(t))), this._listenersStore.add(this._editor.onKeyDown((t) => this._onKeyDown(t)))), this._listenersStore.add(this._editor.onMouseLeave((t) => this._onEditorMouseLeave(t))), this._listenersStore.add(this._editor.onDidChangeModel(() => {
      this._cancelScheduler(), this._hideWidgets();
    })), this._listenersStore.add(this._editor.onDidChangeModelContent(() => this._cancelScheduler())), this._listenersStore.add(this._editor.onDidScrollChange((t) => this._onEditorScrollChanged(t)));
  }
  _unhookListeners() {
    this._listenersStore.clear();
  }
  _cancelScheduler() {
    this._mouseMoveEvent = void 0, this._reactToEditorMouseMoveRunner.cancel();
  }
  _onEditorScrollChanged(e) {
    (e.scrollTopChanged || e.scrollLeftChanged) && this._hideWidgets();
  }
  _onEditorMouseDown(e) {
    this._hoverState.mouseDown = !0, !this._shouldNotHideCurrentHoverWidget(e) && this._hideWidgets();
  }
  _shouldNotHideCurrentHoverWidget(e) {
    return this._isMouseOnContentHoverWidget(e) || this._isContentWidgetResizing();
  }
  _isMouseOnContentHoverWidget(e) {
    var i;
    const t = (i = this._contentWidget) == null ? void 0 : i.getDomNode();
    return t ? $w(t, e.event.posx, e.event.posy) : !1;
  }
  _onEditorMouseUp() {
    this._hoverState.mouseDown = !1;
  }
  _onEditorMouseLeave(e) {
    this.shouldKeepOpenOnEditorMouseMoveOrLeave || (this._cancelScheduler(), this._shouldNotHideCurrentHoverWidget(e)) || this._hideWidgets();
  }
  _shouldNotRecomputeCurrentHoverWidget(e) {
    const t = this._hoverSettings.sticky, i = (r, a) => {
      const l = this._isMouseOnContentHoverWidget(r);
      return a && l;
    }, n = (r) => {
      var c;
      const a = this._isMouseOnContentHoverWidget(r), l = ((c = this._contentWidget) == null ? void 0 : c.isColorPickerVisible) ?? !1;
      return a && l;
    }, o = (r, a) => {
      var l, c, h, d;
      return (a && ((c = this._contentWidget) == null ? void 0 : c.containsNode((l = r.event.browserEvent.view) == null ? void 0 : l.document.activeElement)) && !((d = (h = r.event.browserEvent.view) == null ? void 0 : h.getSelection()) != null && d.isCollapsed)) ?? !1;
    };
    return i(e, t) || n(e) || o(e, t);
  }
  _onEditorMouseMove(e) {
    var a, l, c, h;
    if (this.shouldKeepOpenOnEditorMouseMoveOrLeave || (this._mouseMoveEvent = e, (a = this._contentWidget) != null && a.isFocused || (l = this._contentWidget) != null && l.isResizing))
      return;
    const t = this._hoverSettings.sticky;
    if (t && ((c = this._contentWidget) != null && c.isVisibleFromKeyboard))
      return;
    if (this._shouldNotRecomputeCurrentHoverWidget(e)) {
      this._reactToEditorMouseMoveRunner.cancel();
      return;
    }
    const n = this._hoverSettings.hidingDelay;
    if (((h = this._contentWidget) == null ? void 0 : h.isVisible) && t && n > 0) {
      this._reactToEditorMouseMoveRunner.isScheduled() || this._reactToEditorMouseMoveRunner.schedule(n);
      return;
    }
    this._reactToEditorMouseMove(e);
  }
  _reactToEditorMouseMove(e) {
    var l;
    if (!e)
      return;
    const i = (l = e.target.element) == null ? void 0 : l.classList.contains("colorpicker-color-decoration"), n = this._editor.getOption(
      149
      /* EditorOption.colorDecoratorsActivatedOn */
    ), o = this._hoverSettings.enabled, r = this._hoverState.activatedByDecoratorClick;
    if (i && (n === "click" && !r || n === "hover" && !o || n === "clickAndHover" && !o && !r) || !i && !o && !r) {
      this._hideWidgets();
      return;
    }
    this._tryShowHoverWidget(e) || this._hideWidgets();
  }
  _tryShowHoverWidget(e) {
    return this._getOrCreateContentWidget().showsOrWillShow(e);
  }
  _onKeyDown(e) {
    var n;
    if (!this._editor.hasModel())
      return;
    const t = this._keybindingService.softDispatch(e, this._editor.getDomNode()), i = t.kind === 1 || t.kind === 2 && (t.commandId === VP || t.commandId === Fv || t.commandId === Bv) && ((n = this._contentWidget) == null ? void 0 : n.isVisible);
    e.keyCode === 5 || e.keyCode === 6 || e.keyCode === 57 || e.keyCode === 4 || i || this._hideWidgets();
  }
  _hideWidgets() {
    var e, t;
    this._hoverState.mouseDown && ((e = this._contentWidget) != null && e.isColorPickerVisible) || J1.dropDownVisible || (this._hoverState.activatedByDecoratorClick = !1, (t = this._contentWidget) == null || t.hide());
  }
  _getOrCreateContentWidget() {
    return this._contentWidget || (this._contentWidget = this._instantiationService.createInstance(ok, this._editor), this._listenersStore.add(this._contentWidget.onContentsChanged(() => this._onHoverContentsChanged.fire()))), this._contentWidget;
  }
  showContentHover(e, t, i, n, o = !1) {
    this._hoverState.activatedByDecoratorClick = o, this._getOrCreateContentWidget().startShowingAtRange(e, t, i, n);
  }
  _isContentWidgetResizing() {
    var e;
    return ((e = this._contentWidget) == null ? void 0 : e.widget.isResizing) || !1;
  }
  focusedHoverPartIndex() {
    return this._getOrCreateContentWidget().focusedHoverPartIndex();
  }
  updateHoverVerbosityLevel(e, t, i) {
    this._getOrCreateContentWidget().updateHoverVerbosityLevel(e, t, i);
  }
  focus() {
    var e;
    (e = this._contentWidget) == null || e.focus();
  }
  scrollUp() {
    var e;
    (e = this._contentWidget) == null || e.scrollUp();
  }
  scrollDown() {
    var e;
    (e = this._contentWidget) == null || e.scrollDown();
  }
  scrollLeft() {
    var e;
    (e = this._contentWidget) == null || e.scrollLeft();
  }
  scrollRight() {
    var e;
    (e = this._contentWidget) == null || e.scrollRight();
  }
  pageUp() {
    var e;
    (e = this._contentWidget) == null || e.pageUp();
  }
  pageDown() {
    var e;
    (e = this._contentWidget) == null || e.pageDown();
  }
  goToTop() {
    var e;
    (e = this._contentWidget) == null || e.goToTop();
  }
  goToBottom() {
    var e;
    (e = this._contentWidget) == null || e.goToBottom();
  }
  get isColorPickerVisible() {
    var e;
    return (e = this._contentWidget) == null ? void 0 : e.isColorPickerVisible;
  }
  get isHoverVisible() {
    var e;
    return (e = this._contentWidget) == null ? void 0 : e.isVisible;
  }
  dispose() {
    var e;
    super.dispose(), this._unhookListeners(), this._listenersStore.dispose(), (e = this._contentWidget) == null || e.dispose();
  }
}, rk = xh, xh.ID = "editor.contrib.contentHover", xh);
vn = rk = pee([
  wR(1, Pe),
  wR(2, Lt)
], vn);
var To;
(function(s) {
  s.NoAutoFocus = "noAutoFocus", s.FocusIfVisible = "focusIfVisible", s.AutoFocusImmediately = "autoFocusImmediately";
})(To || (To = {}));
class _ee extends ss {
  constructor() {
    super({
      id: VP,
      label: m({
        key: "showOrFocusHover",
        comment: [
          "Label for action that will trigger the showing/focusing of a hover in the editor.",
          "If the hover is not visible, it will show the hover.",
          "This allows for users to show the hover without using the mouse."
        ]
      }, "Show or Focus Hover"),
      metadata: {
        description: oi("showOrFocusHoverDescription", "Show or focus the editor hover which shows documentation, references, and other content for a symbol at the current cursor position."),
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              focus: {
                description: "Controls if and when the hover should take focus upon being triggered by this action.",
                enum: [To.NoAutoFocus, To.FocusIfVisible, To.AutoFocusImmediately],
                enumDescriptions: [
                  m("showOrFocusHover.focus.noAutoFocus", "The hover will not automatically take focus."),
                  m("showOrFocusHover.focus.focusIfVisible", "The hover will take focus only if it is already visible."),
                  m("showOrFocusHover.focus.autoFocusImmediately", "The hover will automatically take focus when it appears.")
                ],
                default: To.FocusIfVisible
              }
            }
          }
        }]
      },
      alias: "Show or Focus Hover",
      precondition: void 0,
      kbOpts: {
        kbExpr: Z.editorTextFocus,
        primary: ym(
          2089,
          2087
          /* KeyCode.KeyI */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    const n = vn.get(t);
    if (!n)
      return;
    const o = i == null ? void 0 : i.focus;
    let r = To.FocusIfVisible;
    Object.values(To).includes(o) ? r = o : typeof o == "boolean" && o && (r = To.AutoFocusImmediately);
    const a = (c) => {
      const h = t.getPosition(), d = new T(h.lineNumber, h.column, h.lineNumber, h.column);
      n.showContentHover(d, 1, 1, c);
    }, l = t.getOption(
      2
      /* EditorOption.accessibilitySupport */
    ) === 2;
    n.isHoverVisible ? r !== To.NoAutoFocus ? n.focus() : a(l) : a(l || r === To.AutoFocusImmediately);
  }
}
class bee extends ss {
  constructor() {
    super({
      id: e9,
      label: m({
        key: "showDefinitionPreviewHover",
        comment: [
          "Label for action that will trigger the showing of definition preview hover in the editor.",
          "This allows for users to show the definition preview hover without using the mouse."
        ]
      }, "Show Definition Preview Hover"),
      alias: "Show Definition Preview Hover",
      precondition: void 0,
      metadata: {
        description: oi("showDefinitionPreviewHoverDescription", "Show the definition preview hover in the editor.")
      }
    });
  }
  run(e, t) {
    const i = vn.get(t);
    if (!i)
      return;
    const n = t.getPosition();
    if (!n)
      return;
    const o = new T(n.lineNumber, n.column, n.lineNumber, n.column), r = dp.get(t);
    if (!r)
      return;
    r.startFindDefinitionFromCursor(n).then(() => {
      i.showContentHover(o, 1, 1, !0);
    });
  }
}
class Cee extends ss {
  constructor() {
    super({
      id: t9,
      label: m({
        key: "scrollUpHover",
        comment: [
          "Action that allows to scroll up in the hover widget with the up arrow when the hover widget is focused."
        ]
      }, "Scroll Up Hover"),
      alias: "Scroll Up Hover",
      precondition: Z.hoverFocused,
      kbOpts: {
        kbExpr: Z.hoverFocused,
        primary: 16,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: oi("scrollUpHoverDescription", "Scroll up the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = vn.get(t);
    i && i.scrollUp();
  }
}
class vee extends ss {
  constructor() {
    super({
      id: i9,
      label: m({
        key: "scrollDownHover",
        comment: [
          "Action that allows to scroll down in the hover widget with the up arrow when the hover widget is focused."
        ]
      }, "Scroll Down Hover"),
      alias: "Scroll Down Hover",
      precondition: Z.hoverFocused,
      kbOpts: {
        kbExpr: Z.hoverFocused,
        primary: 18,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: oi("scrollDownHoverDescription", "Scroll down the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = vn.get(t);
    i && i.scrollDown();
  }
}
class wee extends ss {
  constructor() {
    super({
      id: n9,
      label: m({
        key: "scrollLeftHover",
        comment: [
          "Action that allows to scroll left in the hover widget with the left arrow when the hover widget is focused."
        ]
      }, "Scroll Left Hover"),
      alias: "Scroll Left Hover",
      precondition: Z.hoverFocused,
      kbOpts: {
        kbExpr: Z.hoverFocused,
        primary: 15,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: oi("scrollLeftHoverDescription", "Scroll left the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = vn.get(t);
    i && i.scrollLeft();
  }
}
class yee extends ss {
  constructor() {
    super({
      id: s9,
      label: m({
        key: "scrollRightHover",
        comment: [
          "Action that allows to scroll right in the hover widget with the right arrow when the hover widget is focused."
        ]
      }, "Scroll Right Hover"),
      alias: "Scroll Right Hover",
      precondition: Z.hoverFocused,
      kbOpts: {
        kbExpr: Z.hoverFocused,
        primary: 17,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: oi("scrollRightHoverDescription", "Scroll right the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = vn.get(t);
    i && i.scrollRight();
  }
}
class See extends ss {
  constructor() {
    super({
      id: o9,
      label: m({
        key: "pageUpHover",
        comment: [
          "Action that allows to page up in the hover widget with the page up command when the hover widget is focused."
        ]
      }, "Page Up Hover"),
      alias: "Page Up Hover",
      precondition: Z.hoverFocused,
      kbOpts: {
        kbExpr: Z.hoverFocused,
        primary: 11,
        secondary: [
          528
          /* KeyCode.UpArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: oi("pageUpHoverDescription", "Page up the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = vn.get(t);
    i && i.pageUp();
  }
}
class Lee extends ss {
  constructor() {
    super({
      id: r9,
      label: m({
        key: "pageDownHover",
        comment: [
          "Action that allows to page down in the hover widget with the page down command when the hover widget is focused."
        ]
      }, "Page Down Hover"),
      alias: "Page Down Hover",
      precondition: Z.hoverFocused,
      kbOpts: {
        kbExpr: Z.hoverFocused,
        primary: 12,
        secondary: [
          530
          /* KeyCode.DownArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: oi("pageDownHoverDescription", "Page down the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = vn.get(t);
    i && i.pageDown();
  }
}
class kee extends ss {
  constructor() {
    super({
      id: a9,
      label: m({
        key: "goToTopHover",
        comment: [
          "Action that allows to go to the top of the hover widget with the home command when the hover widget is focused."
        ]
      }, "Go To Top Hover"),
      alias: "Go To Bottom Hover",
      precondition: Z.hoverFocused,
      kbOpts: {
        kbExpr: Z.hoverFocused,
        primary: 14,
        secondary: [
          2064
          /* KeyCode.UpArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: oi("goToTopHoverDescription", "Go to the top of the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = vn.get(t);
    i && i.goToTop();
  }
}
class xee extends ss {
  constructor() {
    super({
      id: l9,
      label: m({
        key: "goToBottomHover",
        comment: [
          "Action that allows to go to the bottom in the hover widget with the end command when the hover widget is focused."
        ]
      }, "Go To Bottom Hover"),
      alias: "Go To Bottom Hover",
      precondition: Z.hoverFocused,
      kbOpts: {
        kbExpr: Z.hoverFocused,
        primary: 13,
        secondary: [
          2066
          /* KeyCode.DownArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: oi("goToBottomHoverDescription", "Go to the bottom of the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = vn.get(t);
    i && i.goToBottom();
  }
}
class Dee extends ss {
  constructor() {
    super({
      id: Fv,
      label: c9,
      alias: "Increase Hover Verbosity Level",
      precondition: Z.hoverVisible
    });
  }
  run(e, t, i) {
    const n = vn.get(t);
    if (!n)
      return;
    const o = (i == null ? void 0 : i.index) !== void 0 ? i.index : n.focusedHoverPartIndex();
    n.updateHoverVerbosityLevel(jn.Increase, o, i == null ? void 0 : i.focus);
  }
}
class Eee extends ss {
  constructor() {
    super({
      id: Bv,
      label: h9,
      alias: "Decrease Hover Verbosity Level",
      precondition: Z.hoverVisible
    });
  }
  run(e, t, i) {
    var r;
    const n = vn.get(t);
    if (!n)
      return;
    const o = (i == null ? void 0 : i.index) !== void 0 ? i.index : n.focusedHoverPartIndex();
    (r = vn.get(t)) == null || r.updateHoverVerbosityLevel(jn.Decrease, o, i == null ? void 0 : i.focus);
  }
}
const O7 = Be("IWorkspaceEditService");
class EN {
  constructor(e) {
    this.metadata = e;
  }
  static convert(e) {
    return e.edits.map((t) => {
      if (mh.is(t))
        return mh.lift(t);
      if (Uu.is(t))
        return Uu.lift(t);
      throw new Error("Unsupported edit");
    });
  }
}
class mh extends EN {
  static is(e) {
    return e instanceof mh ? !0 : Wi(e) && we.isUri(e.resource) && Wi(e.textEdit);
  }
  static lift(e) {
    return e instanceof mh ? e : new mh(e.resource, e.textEdit, e.versionId, e.metadata);
  }
  constructor(e, t, i = void 0, n) {
    super(n), this.resource = e, this.textEdit = t, this.versionId = i;
  }
}
class Uu extends EN {
  static is(e) {
    return e instanceof Uu ? !0 : Wi(e) && (!!e.newResource || !!e.oldResource);
  }
  static lift(e) {
    return e instanceof Uu ? e : new Uu(e.oldResource, e.newResource, e.options, e.metadata);
  }
  constructor(e, t, i = {}, n) {
    super(n), this.oldResource = e, this.newResource = t, this.options = i;
  }
}
const vr = class vr {
  constructor(e) {
    this.value = e;
  }
  equals(e) {
    return this.value === e.value;
  }
  contains(e) {
    return this.equals(e) || this.value === "" || e.value.startsWith(this.value + vr.sep);
  }
  intersects(e) {
    return this.contains(e) || e.contains(this);
  }
  append(...e) {
    return new vr((this.value ? [this.value, ...e] : e).join(vr.sep));
  }
};
vr.sep = ".", vr.None = new vr("@@none@@"), vr.Empty = new vr("");
let Hi = vr;
const yi = new class {
  constructor() {
    this.QuickFix = new Hi("quickfix"), this.Refactor = new Hi("refactor"), this.RefactorExtract = this.Refactor.append("extract"), this.RefactorInline = this.Refactor.append("inline"), this.RefactorMove = this.Refactor.append("move"), this.RefactorRewrite = this.Refactor.append("rewrite"), this.Notebook = new Hi("notebook"), this.Source = new Hi("source"), this.SourceOrganizeImports = this.Source.append("organizeImports"), this.SourceFixAll = this.Source.append("fixAll"), this.SurroundWith = this.Refactor.append("surround");
  }
}();
var tc;
(function(s) {
  s.Refactor = "refactor", s.RefactorPreview = "refactor preview", s.Lightbulb = "lightbulb", s.Default = "other (default)", s.SourceAction = "source action", s.QuickFix = "quick fix action", s.FixAll = "fix all", s.OrganizeImports = "organize imports", s.AutoFix = "auto fix", s.QuickFixHover = "quick fix hover window", s.OnSave = "save participants", s.ProblemsView = "problems view";
})(tc || (tc = {}));
function Iee(s, e) {
  return !(s.include && !s.include.intersects(e) || s.excludes && s.excludes.some((t) => F7(e, t, s.include)) || !s.includeSourceActions && yi.Source.contains(e));
}
function Nee(s, e) {
  const t = e.kind ? new Hi(e.kind) : void 0;
  return !(s.include && (!t || !s.include.contains(t)) || s.excludes && t && s.excludes.some((i) => F7(t, i, s.include)) || !s.includeSourceActions && t && yi.Source.contains(t) || s.onlyIncludePreferredActions && !e.isPreferred);
}
function F7(s, e, t) {
  return !(!e.contains(s) || t && e.contains(t));
}
class Fc {
  static fromUser(e, t) {
    return !e || typeof e != "object" ? new Fc(t.kind, t.apply, !1) : new Fc(Fc.getKindFromUser(e, t.kind), Fc.getApplyFromUser(e, t.apply), Fc.getPreferredUser(e));
  }
  static getApplyFromUser(e, t) {
    switch (typeof e.apply == "string" ? e.apply.toLowerCase() : "") {
      case "first":
        return "first";
      case "never":
        return "never";
      case "ifsingle":
        return "ifSingle";
      default:
        return t;
    }
  }
  static getKindFromUser(e, t) {
    return typeof e.kind == "string" ? new Hi(e.kind) : t;
  }
  static getPreferredUser(e) {
    return typeof e.preferred == "boolean" ? e.preferred : !1;
  }
  constructor(e, t, i) {
    this.kind = e, this.apply = t, this.preferred = i;
  }
}
class Tee {
  constructor(e, t, i) {
    this.action = e, this.provider = t, this.highlightRange = i;
  }
  async resolve(e) {
    var t;
    if ((t = this.provider) != null && t.resolveCodeAction && !this.action.edit) {
      let i;
      try {
        i = await this.provider.resolveCodeAction(this.action, e);
      } catch (n) {
        Qo(n);
      }
      i && (this.action.edit = i.edit);
    }
    return this;
  }
}
const Mee = "editor.action.codeAction", B7 = "editor.action.quickFix", Ree = "editor.action.autoFix", Aee = "editor.action.refactor", Pee = "editor.action.sourceAction", yR = "editor.action.organizeImports", SR = "editor.action.fixAll";
class Jg extends U {
  static codeActionsPreferredComparator(e, t) {
    return e.isPreferred && !t.isPreferred ? -1 : !e.isPreferred && t.isPreferred ? 1 : 0;
  }
  static codeActionsComparator({ action: e }, { action: t }) {
    return e.isAI && !t.isAI ? 1 : !e.isAI && t.isAI ? -1 : co(e.diagnostics) ? co(t.diagnostics) ? Jg.codeActionsPreferredComparator(e, t) : -1 : co(t.diagnostics) ? 1 : Jg.codeActionsPreferredComparator(e, t);
  }
  constructor(e, t, i) {
    super(), this.documentation = t, this._register(i), this.allActions = [...e].sort(Jg.codeActionsComparator), this.validActions = this.allActions.filter(({ action: n }) => !n.disabled);
  }
  get hasAutoFix() {
    return this.validActions.some(({ action: e }) => !!e.kind && yi.QuickFix.contains(new Hi(e.kind)) && !!e.isPreferred);
  }
  get hasAIFix() {
    return this.validActions.some(({ action: e }) => !!e.isAI);
  }
  get allAIFixes() {
    return this.validActions.every(({ action: e }) => !!e.isAI);
  }
}
const LR = { actions: [], documentation: void 0 };
async function lu(s, e, t, i, n, o) {
  var p;
  const r = i.filter || {}, a = {
    ...r,
    excludes: [...r.excludes || [], yi.Notebook]
  }, l = {
    only: (p = r.include) == null ? void 0 : p.value,
    trigger: i.type
  }, c = new XB(e, o), h = i.type === 2, d = Oee(s, e, h ? a : r), u = new ne(), f = d.map(async (_) => {
    try {
      n.report(_);
      const b = await _.provideCodeActions(e, t, l, c.token);
      if (b && u.add(b), c.token.isCancellationRequested)
        return LR;
      const C = ((b == null ? void 0 : b.actions) || []).filter((v) => v && Nee(r, v)), w = Bee(_, C, r.include);
      return {
        actions: C.map((v) => new Tee(v, _)),
        documentation: w
      };
    } catch (b) {
      if (Jh(b))
        throw b;
      return Qo(b), LR;
    }
  }), g = s.onDidChange(() => {
    const _ = s.all(e);
    li(_, d) || c.cancel();
  });
  try {
    const _ = await Promise.all(f), b = _.map((w) => w.actions).flat(), C = [
      ...Rf(_.map((w) => w.documentation)),
      ...Fee(s, e, i, b)
    ];
    return new Jg(b, C, u);
  } finally {
    g.dispose(), c.dispose();
  }
}
function Oee(s, e, t) {
  return s.all(e).filter((i) => i.providedCodeActionKinds ? i.providedCodeActionKinds.some((n) => Iee(t, new Hi(n))) : !0);
}
function* Fee(s, e, t, i) {
  var n, o, r;
  if (e && i.length)
    for (const a of s.all(e))
      a._getAdditionalMenuItems && (yield* (r = a._getAdditionalMenuItems) == null ? void 0 : r.call(a, { trigger: t.type, only: (o = (n = t.filter) == null ? void 0 : n.include) == null ? void 0 : o.value }, i.map((l) => l.action)));
}
function Bee(s, e, t) {
  if (!s.documentation)
    return;
  const i = s.documentation.map((n) => ({ kind: new Hi(n.kind), command: n.command }));
  if (t) {
    let n;
    for (const o of i)
      o.kind.contains(t) && (n ? n.kind.contains(o.kind) && (n = o) : n = o);
    if (n)
      return n == null ? void 0 : n.command;
  }
  for (const n of e)
    if (n.kind) {
      for (const o of i)
        if (o.kind.contains(new Hi(n.kind)))
          return o.command;
    }
}
var nh;
(function(s) {
  s.OnSave = "onSave", s.FromProblemsView = "fromProblemsView", s.FromCodeActions = "fromCodeActions", s.FromAILightbulb = "fromAILightbulb";
})(nh || (nh = {}));
async function Wee(s, e, t, i, n = _t.None) {
  var c;
  const o = s.get(O7), r = s.get(fi), a = s.get(Jo), l = s.get(cn);
  if (a.publicLog2("codeAction.applyCodeAction", {
    codeActionTitle: e.action.title,
    codeActionKind: e.action.kind,
    codeActionIsPreferred: !!e.action.isPreferred,
    reason: t
  }), await e.resolve(n), !n.isCancellationRequested && !((c = e.action.edit) != null && c.edits.length && !(await o.apply(e.action.edit, {
    editor: i == null ? void 0 : i.editor,
    label: e.action.title,
    quotableLabel: e.action.title,
    code: "undoredo.codeAction",
    respectAutoSaveConfig: t !== nh.OnSave,
    showPreview: i == null ? void 0 : i.preview
  })).isApplied) && e.action.command)
    try {
      await r.executeCommand(e.action.command.id, ...e.action.command.arguments || []);
    } catch (h) {
      const d = Hee(h);
      l.error(typeof d == "string" ? d : m("applyCodeActionFailed", "An unknown error occurred while applying the code action"));
    }
}
function Hee(s) {
  return typeof s == "string" ? s : s instanceof Error && typeof s.message == "string" ? s.message : void 0;
}
St.registerCommand("_executeCodeActionProvider", async function(s, e, t, i, n) {
  if (!(e instanceof we))
    throw Tr();
  const { codeActionProvider: o } = s.get(De), r = s.get(Ui).getModel(e);
  if (!r)
    throw Tr();
  const a = Ue.isISelection(t) ? Ue.liftSelection(t) : T.isIRange(t) ? r.validateRange(t) : void 0;
  if (!a)
    throw Tr();
  const l = typeof i == "string" ? new Hi(i) : void 0, c = await lu(o, r, a, { type: 1, triggerAction: tc.Default, filter: { includeSourceActions: !0, include: l } }, Dl.None, _t.None), h = [], d = Math.min(c.validActions.length, typeof n == "number" ? n : 0);
  for (let u = 0; u < d; u++)
    h.push(c.validActions[u].resolve(_t.None));
  try {
    return await Promise.all(h), c.validActions.map((u) => u.action);
  } finally {
    setTimeout(() => c.dispose(), 100);
  }
});
var Vee = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, zee = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, ak, Dh;
let lk = (Dh = class {
  constructor(e) {
    this.keybindingService = e;
  }
  getResolver() {
    const e = new Fr(() => this.keybindingService.getKeybindings().filter((t) => ak.codeActionCommands.indexOf(t.command) >= 0).filter((t) => t.resolvedKeybinding).map((t) => {
      let i = t.commandArgs;
      return t.command === yR ? i = { kind: yi.SourceOrganizeImports.value } : t.command === SR && (i = { kind: yi.SourceFixAll.value }), {
        resolvedKeybinding: t.resolvedKeybinding,
        ...Fc.fromUser(i, {
          kind: Hi.None,
          apply: "never"
          /* CodeActionAutoApply.Never */
        })
      };
    }));
    return (t) => {
      if (t.kind) {
        const i = this.bestKeybindingForCodeAction(t, e.value);
        return i == null ? void 0 : i.resolvedKeybinding;
      }
    };
  }
  bestKeybindingForCodeAction(e, t) {
    if (!e.kind)
      return;
    const i = new Hi(e.kind);
    return t.filter((n) => n.kind.contains(i)).filter((n) => n.preferred ? e.isPreferred : !0).reduceRight((n, o) => n ? n.kind.contains(o.kind) ? o : n : o, void 0);
  }
}, ak = Dh, Dh.codeActionCommands = [
  Aee,
  Mee,
  Pee,
  yR,
  SR
], Dh);
lk = ak = Vee([
  zee(0, Lt)
], lk);
E("symbolIcon.arrayForeground", Me, m("symbolIcon.arrayForeground", "The foreground color for array symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.booleanForeground", Me, m("symbolIcon.booleanForeground", "The foreground color for boolean symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.classForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, m("symbolIcon.classForeground", "The foreground color for class symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.colorForeground", Me, m("symbolIcon.colorForeground", "The foreground color for color symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.constantForeground", Me, m("symbolIcon.constantForeground", "The foreground color for constant symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.constructorForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, m("symbolIcon.constructorForeground", "The foreground color for constructor symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.enumeratorForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, m("symbolIcon.enumeratorForeground", "The foreground color for enumerator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.enumeratorMemberForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, m("symbolIcon.enumeratorMemberForeground", "The foreground color for enumerator member symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.eventForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, m("symbolIcon.eventForeground", "The foreground color for event symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.fieldForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, m("symbolIcon.fieldForeground", "The foreground color for field symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.fileForeground", Me, m("symbolIcon.fileForeground", "The foreground color for file symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.folderForeground", Me, m("symbolIcon.folderForeground", "The foreground color for folder symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.functionForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, m("symbolIcon.functionForeground", "The foreground color for function symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.interfaceForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, m("symbolIcon.interfaceForeground", "The foreground color for interface symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.keyForeground", Me, m("symbolIcon.keyForeground", "The foreground color for key symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.keywordForeground", Me, m("symbolIcon.keywordForeground", "The foreground color for keyword symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.methodForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, m("symbolIcon.methodForeground", "The foreground color for method symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.moduleForeground", Me, m("symbolIcon.moduleForeground", "The foreground color for module symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.namespaceForeground", Me, m("symbolIcon.namespaceForeground", "The foreground color for namespace symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.nullForeground", Me, m("symbolIcon.nullForeground", "The foreground color for null symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.numberForeground", Me, m("symbolIcon.numberForeground", "The foreground color for number symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.objectForeground", Me, m("symbolIcon.objectForeground", "The foreground color for object symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.operatorForeground", Me, m("symbolIcon.operatorForeground", "The foreground color for operator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.packageForeground", Me, m("symbolIcon.packageForeground", "The foreground color for package symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.propertyForeground", Me, m("symbolIcon.propertyForeground", "The foreground color for property symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.referenceForeground", Me, m("symbolIcon.referenceForeground", "The foreground color for reference symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.snippetForeground", Me, m("symbolIcon.snippetForeground", "The foreground color for snippet symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.stringForeground", Me, m("symbolIcon.stringForeground", "The foreground color for string symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.structForeground", Me, m("symbolIcon.structForeground", "The foreground color for struct symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.textForeground", Me, m("symbolIcon.textForeground", "The foreground color for text symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.typeParameterForeground", Me, m("symbolIcon.typeParameterForeground", "The foreground color for type parameter symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.unitForeground", Me, m("symbolIcon.unitForeground", "The foreground color for unit symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
E("symbolIcon.variableForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, m("symbolIcon.variableForeground", "The foreground color for variable symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const W7 = Object.freeze({ kind: Hi.Empty, title: m("codeAction.widget.id.more", "More Actions...") }), Uee = Object.freeze([
  { kind: yi.QuickFix, title: m("codeAction.widget.id.quickfix", "Quick Fix") },
  { kind: yi.RefactorExtract, title: m("codeAction.widget.id.extract", "Extract"), icon: ie.wrench },
  { kind: yi.RefactorInline, title: m("codeAction.widget.id.inline", "Inline"), icon: ie.wrench },
  { kind: yi.RefactorRewrite, title: m("codeAction.widget.id.convert", "Rewrite"), icon: ie.wrench },
  { kind: yi.RefactorMove, title: m("codeAction.widget.id.move", "Move"), icon: ie.wrench },
  { kind: yi.SurroundWith, title: m("codeAction.widget.id.surround", "Surround With"), icon: ie.surroundWith },
  { kind: yi.Source, title: m("codeAction.widget.id.source", "Source Action"), icon: ie.symbolFile },
  W7
]);
function $ee(s, e, t) {
  if (!e)
    return s.map((o) => {
      var r;
      return {
        kind: "action",
        item: o,
        group: W7,
        disabled: !!o.action.disabled,
        label: o.action.disabled || o.action.title,
        canPreview: !!((r = o.action.edit) != null && r.edits.length)
      };
    });
  const i = Uee.map((o) => ({ group: o, actions: [] }));
  for (const o of s) {
    const r = o.action.kind ? new Hi(o.action.kind) : Hi.None;
    for (const a of i)
      if (a.group.kind.contains(r)) {
        a.actions.push(o);
        break;
      }
  }
  const n = [];
  for (const o of i)
    if (o.actions.length) {
      n.push({ kind: "header", group: o.group });
      for (const r of o.actions) {
        const a = o.group;
        n.push({
          kind: "action",
          item: r,
          group: r.action.isAI ? { title: a.title, kind: a.kind, icon: ie.sparkle } : a,
          label: r.action.title,
          disabled: !!r.action.disabled,
          keybinding: t(r.action)
        });
      }
    }
  return n;
}
var Kee = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, jee = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, $d;
const kR = $i("gutter-lightbulb", ie.lightBulb, m("gutterLightbulbWidget", "Icon which spawns code actions menu from the gutter when there is no space in the editor.")), xR = $i("gutter-lightbulb-auto-fix", ie.lightbulbAutofix, m("gutterLightbulbAutoFixWidget", "Icon which spawns code actions menu from the gutter when there is no space in the editor and a quick fix is available.")), DR = $i("gutter-lightbulb-sparkle", ie.lightbulbSparkle, m("gutterLightbulbAIFixWidget", "Icon which spawns code actions menu from the gutter when there is no space in the editor and an AI fix is available.")), ER = $i("gutter-lightbulb-aifix-auto-fix", ie.lightbulbSparkleAutofix, m("gutterLightbulbAIFixAutoFixWidget", "Icon which spawns code actions menu from the gutter when there is no space in the editor and an AI fix and a quick fix is available.")), IR = $i("gutter-lightbulb-sparkle-filled", ie.sparkleFilled, m("gutterLightbulbSparkleFilledWidget", "Icon which spawns code actions menu from the gutter when there is no space in the editor and an AI fix and a quick fix is available."));
var Mo;
(function(s) {
  s.Hidden = {
    type: 0
    /* Type.Hidden */
  };
  class e {
    constructor(i, n, o, r) {
      this.actions = i, this.trigger = n, this.editorPosition = o, this.widgetPosition = r, this.type = 1;
    }
  }
  s.Showing = e;
})(Mo || (Mo = {}));
var Aa;
let ck = (Aa = class extends U {
  constructor(e, t) {
    super(), this._editor = e, this._keybindingService = t, this._onClick = this._register(new A()), this.onClick = this._onClick.event, this._state = Mo.Hidden, this._gutterState = Mo.Hidden, this._iconClasses = [], this.lightbulbClasses = [
      "codicon-" + kR.id,
      "codicon-" + ER.id,
      "codicon-" + xR.id,
      "codicon-" + DR.id,
      "codicon-" + IR.id
    ], this.gutterDecoration = $d.GUTTER_DECORATION, this._domNode = he("div.lightBulbWidget"), this._domNode.role = "listbox", this._register(ln.ignoreTarget(this._domNode)), this._editor.addContentWidget(this), this._register(this._editor.onDidChangeModelContent((i) => {
      const n = this._editor.getModel();
      (this.state.type !== 1 || !n || this.state.editorPosition.lineNumber >= n.getLineCount()) && this.hide(), (this.gutterState.type !== 1 || !n || this.gutterState.editorPosition.lineNumber >= n.getLineCount()) && this.gutterHide();
    })), this._register($6(this._domNode, (i) => {
      if (this.state.type !== 1)
        return;
      this._editor.focus(), i.preventDefault();
      const { top: n, height: o } = ui(this._domNode), r = this._editor.getOption(
        67
        /* EditorOption.lineHeight */
      );
      let a = Math.floor(r / 3);
      this.state.widgetPosition.position !== null && this.state.widgetPosition.position.lineNumber < this.state.editorPosition.lineNumber && (a += r), this._onClick.fire({
        x: i.posx,
        y: n + o + a,
        actions: this.state.actions,
        trigger: this.state.trigger
      });
    })), this._register(z(this._domNode, "mouseenter", (i) => {
      (i.buttons & 1) === 1 && this.hide();
    })), this._register(ee.runAndSubscribe(this._keybindingService.onDidUpdateKeybindings, () => {
      var i, n;
      this._preferredKbLabel = ((i = this._keybindingService.lookupKeybinding(Ree)) == null ? void 0 : i.getLabel()) ?? void 0, this._quickFixKbLabel = ((n = this._keybindingService.lookupKeybinding(B7)) == null ? void 0 : n.getLabel()) ?? void 0, this._updateLightBulbTitleAndIcon();
    })), this._register(this._editor.onMouseDown(async (i) => {
      if (!i.target.element || !this.lightbulbClasses.some((l) => i.target.element && i.target.element.classList.contains(l)) || this.gutterState.type !== 1)
        return;
      this._editor.focus();
      const { top: n, height: o } = ui(i.target.element), r = this._editor.getOption(
        67
        /* EditorOption.lineHeight */
      );
      let a = Math.floor(r / 3);
      this.gutterState.widgetPosition.position !== null && this.gutterState.widgetPosition.position.lineNumber < this.gutterState.editorPosition.lineNumber && (a += r), this._onClick.fire({
        x: i.event.posx,
        y: n + o + a,
        actions: this.gutterState.actions,
        trigger: this.gutterState.trigger
      });
    }));
  }
  dispose() {
    super.dispose(), this._editor.removeContentWidget(this), this._gutterDecorationID && this._removeGutterDecoration(this._gutterDecorationID);
  }
  getId() {
    return "LightBulbWidget";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._state.type === 1 ? this._state.widgetPosition : null;
  }
  update(e, t, i) {
    if (e.validActions.length <= 0)
      return this.gutterHide(), this.hide();
    if (!this._editor.hasTextFocus())
      return this.gutterHide(), this.hide();
    if (!this._editor.getOptions().get(
      65
      /* EditorOption.lightbulb */
    ).enabled)
      return this.gutterHide(), this.hide();
    const r = this._editor.getModel();
    if (!r)
      return this.gutterHide(), this.hide();
    const { lineNumber: a, column: l } = r.validatePosition(i), c = r.getOptions().tabSize, h = this._editor.getOptions().get(
      50
      /* EditorOption.fontInfo */
    ), d = r.getLineContent(a), u = Q5(d, c), f = h.spaceWidth * u > 22, g = (S) => S > 2 && this._editor.getTopForLineNumber(S) === this._editor.getTopForLineNumber(S - 1), p = this._editor.getLineDecorations(a);
    let _ = !1;
    if (p)
      for (const S of p) {
        const L = S.options.glyphMarginClassName;
        if (L && !this.lightbulbClasses.some((k) => L.includes(k))) {
          _ = !0;
          break;
        }
      }
    let b = a, C = 1;
    if (!f) {
      const S = (L) => {
        const k = r.getLineContent(L);
        return /^\s*$|^\s+/.test(k) || k.length <= C;
      };
      if (a > 1 && !g(a - 1)) {
        const L = r.getLineCount(), k = a === L, x = a > 1 && S(a - 1), I = !k && S(a + 1), K = S(a), B = !I && !x;
        if (!I && !x && !_)
          return this.gutterState = new Mo.Showing(e, t, i, {
            position: { lineNumber: b, column: C },
            preference: $d._posPref
          }), this.renderGutterLightbub(), this.hide();
        x || k || x && !K ? b -= 1 : (I || B && K) && (b += 1);
      } else if (a === 1 && (a === r.getLineCount() || !S(a + 1) && !S(a)))
        if (this.gutterState = new Mo.Showing(e, t, i, {
          position: { lineNumber: b, column: C },
          preference: $d._posPref
        }), _)
          this.gutterHide();
        else
          return this.renderGutterLightbub(), this.hide();
      else if (a < r.getLineCount() && !g(a + 1))
        b += 1;
      else if (l * h.spaceWidth < 22)
        return this.hide();
      C = /^\S\s*$/.test(r.getLineContent(b)) ? 2 : 1;
    }
    this.state = new Mo.Showing(e, t, i, {
      position: { lineNumber: b, column: C },
      preference: $d._posPref
    }), this._gutterDecorationID && (this._removeGutterDecoration(this._gutterDecorationID), this.gutterHide());
    const w = e.validActions, v = e.validActions[0].action.kind;
    if (w.length !== 1 || !v) {
      this._editor.layoutContentWidget(this);
      return;
    }
    this._editor.layoutContentWidget(this);
  }
  hide() {
    this.state !== Mo.Hidden && (this.state = Mo.Hidden, this._editor.layoutContentWidget(this));
  }
  gutterHide() {
    this.gutterState !== Mo.Hidden && (this._gutterDecorationID && this._removeGutterDecoration(this._gutterDecorationID), this.gutterState = Mo.Hidden);
  }
  get state() {
    return this._state;
  }
  set state(e) {
    this._state = e, this._updateLightBulbTitleAndIcon();
  }
  get gutterState() {
    return this._gutterState;
  }
  set gutterState(e) {
    this._gutterState = e, this._updateGutterLightBulbTitleAndIcon();
  }
  _updateLightBulbTitleAndIcon() {
    if (this._domNode.classList.remove(...this._iconClasses), this._iconClasses = [], this.state.type !== 1)
      return;
    let e, t = !1;
    this.state.actions.allAIFixes ? (e = ie.sparkleFilled, this.state.actions.validActions.length === 1 && (t = !0)) : this.state.actions.hasAutoFix ? this.state.actions.hasAIFix ? e = ie.lightbulbSparkleAutofix : e = ie.lightbulbAutofix : this.state.actions.hasAIFix ? e = ie.lightbulbSparkle : e = ie.lightBulb, this._updateLightbulbTitle(this.state.actions.hasAutoFix, t), this._iconClasses = Te.asClassNameArray(e), this._domNode.classList.add(...this._iconClasses);
  }
  _updateGutterLightBulbTitleAndIcon() {
    if (this.gutterState.type !== 1)
      return;
    let e, t = !1;
    this.gutterState.actions.allAIFixes ? (e = IR, this.gutterState.actions.validActions.length === 1 && (t = !0)) : this.gutterState.actions.hasAutoFix ? this.gutterState.actions.hasAIFix ? e = ER : e = xR : this.gutterState.actions.hasAIFix ? e = DR : e = kR, this._updateLightbulbTitle(this.gutterState.actions.hasAutoFix, t);
    const i = Wt.register({
      description: "codicon-gutter-lightbulb-decoration",
      glyphMarginClassName: Te.asClassName(e),
      glyphMargin: { position: _o.Left },
      stickiness: 1
    });
    this.gutterDecoration = i;
  }
  /* Gutter Helper Functions */
  renderGutterLightbub() {
    const e = this._editor.getSelection();
    e && (this._gutterDecorationID === void 0 ? this._addGutterDecoration(e.startLineNumber) : this._updateGutterDecoration(this._gutterDecorationID, e.startLineNumber));
  }
  _addGutterDecoration(e) {
    this._editor.changeDecorations((t) => {
      this._gutterDecorationID = t.addDecoration(new T(e, 0, e, 0), this.gutterDecoration);
    });
  }
  _removeGutterDecoration(e) {
    this._editor.changeDecorations((t) => {
      t.removeDecoration(e), this._gutterDecorationID = void 0;
    });
  }
  _updateGutterDecoration(e, t) {
    this._editor.changeDecorations((i) => {
      i.changeDecoration(e, new T(t, 0, t, 0)), i.changeDecorationOptions(e, this.gutterDecoration);
    });
  }
  _updateLightbulbTitle(e, t) {
    this.state.type === 1 && (t ? this.title = m("codeActionAutoRun", "Run: {0}", this.state.actions.validActions[0].action.title) : e && this._preferredKbLabel ? this.title = m("preferredcodeActionWithKb", "Show Code Actions. Preferred Quick Fix Available ({0})", this._preferredKbLabel) : !e && this._quickFixKbLabel ? this.title = m("codeActionWithKb", "Show Code Actions ({0})", this._quickFixKbLabel) : e || (this.title = m("codeAction", "Show Code Actions")));
  }
  set title(e) {
    this._domNode.title = e;
  }
}, $d = Aa, Aa.GUTTER_DECORATION = Wt.register({
  description: "codicon-gutter-lightbulb-decoration",
  glyphMarginClassName: Te.asClassName(ie.lightBulb),
  glyphMargin: { position: _o.Left },
  stickiness: 1
}), Aa.ID = "editor.contrib.lightbulbWidget", Aa._posPref = [
  0
  /* ContentWidgetPositionPreference.EXACT */
], Aa);
ck = $d = Kee([
  jee(1, Lt)
], ck);
var H7 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, hk = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const V7 = "acceptSelectedCodeAction", z7 = "previewSelectedCodeAction";
class qee {
  get templateId() {
    return "header";
  }
  renderTemplate(e) {
    e.classList.add("group-header");
    const t = document.createElement("span");
    return e.append(t), { container: e, text: t };
  }
  renderElement(e, t, i) {
    var n;
    i.text.textContent = ((n = e.group) == null ? void 0 : n.title) ?? "";
  }
  disposeTemplate(e) {
  }
}
let dk = class {
  get templateId() {
    return "action";
  }
  constructor(e, t) {
    this._supportsPreview = e, this._keybindingService = t;
  }
  renderTemplate(e) {
    e.classList.add(this.templateId);
    const t = document.createElement("div");
    t.className = "icon", e.append(t);
    const i = document.createElement("span");
    i.className = "title", e.append(i);
    const n = new Zp(e, bs);
    return { container: e, icon: t, text: i, keybinding: n };
  }
  renderElement(e, t, i) {
    var r, a, l;
    if ((r = e.group) != null && r.icon ? (i.icon.className = Te.asClassName(e.group.icon), e.group.icon.color && (i.icon.style.color = se(e.group.icon.color.id))) : (i.icon.className = Te.asClassName(ie.lightBulb), i.icon.style.color = "var(--vscode-editorLightBulb-foreground)"), !e.item || !e.label)
      return;
    i.text.textContent = U7(e.label), i.keybinding.set(e.keybinding), sB(!!e.keybinding, i.keybinding.element);
    const n = (a = this._keybindingService.lookupKeybinding(V7)) == null ? void 0 : a.getLabel(), o = (l = this._keybindingService.lookupKeybinding(z7)) == null ? void 0 : l.getLabel();
    i.container.classList.toggle("option-disabled", e.disabled), e.disabled ? i.container.title = e.label : n && o ? this._supportsPreview && e.canPreview ? i.container.title = m({ key: "label-preview", comment: ['placeholders are keybindings, e.g "F2 to Apply, Shift+F2 to Preview"'] }, "{0} to Apply, {1} to Preview", n, o) : i.container.title = m({ key: "label", comment: ['placeholder is a keybinding, e.g "F2 to Apply"'] }, "{0} to Apply", n) : i.container.title = "";
  }
  disposeTemplate(e) {
    e.keybinding.dispose();
  }
};
dk = H7([
  hk(1, Lt)
], dk);
class Gee extends UIEvent {
  constructor() {
    super("acceptSelectedAction");
  }
}
class NR extends UIEvent {
  constructor() {
    super("previewSelectedAction");
  }
}
function Zee(s) {
  if (s.kind === "action")
    return s.label;
}
let uk = class extends U {
  constructor(e, t, i, n, o, r) {
    super(), this._delegate = n, this._contextViewService = o, this._keybindingService = r, this._actionLineHeight = 24, this._headerLineHeight = 26, this.cts = this._register(new Vs()), this.domNode = document.createElement("div"), this.domNode.classList.add("actionList");
    const a = {
      getHeight: (l) => l.kind === "header" ? this._headerLineHeight : this._actionLineHeight,
      getTemplateId: (l) => l.kind
    };
    this._list = this._register(new wo(e, this.domNode, a, [
      new dk(t, this._keybindingService),
      new qee()
    ], {
      keyboardSupport: !1,
      typeNavigationEnabled: !0,
      keyboardNavigationLabelProvider: { getKeyboardNavigationLabel: Zee },
      accessibilityProvider: {
        getAriaLabel: (l) => {
          if (l.kind === "action") {
            let c = l.label ? U7(l == null ? void 0 : l.label) : "";
            return l.disabled && (c = m({ key: "customQuickFixWidget.labels", comment: ["Action widget labels for accessibility."] }, "{0}, Disabled Reason: {1}", c, l.disabled)), c;
          }
          return null;
        },
        getWidgetAriaLabel: () => m({ key: "customQuickFixWidget", comment: ["An action widget option"] }, "Action Widget"),
        getRole: (l) => l.kind === "action" ? "option" : "separator",
        getWidgetRole: () => "listbox"
      }
    })), this._list.style(gd), this._register(this._list.onMouseClick((l) => this.onListClick(l))), this._register(this._list.onMouseOver((l) => this.onListHover(l))), this._register(this._list.onDidChangeFocus(() => this.onFocus())), this._register(this._list.onDidChangeSelection((l) => this.onListSelection(l))), this._allMenuItems = i, this._list.splice(0, this._list.length, this._allMenuItems), this._list.length && this.focusNext();
  }
  focusCondition(e) {
    return !e.disabled && e.kind === "action";
  }
  hide(e) {
    this._delegate.onHide(e), this.cts.cancel(), this._contextViewService.hideContextView();
  }
  layout(e) {
    const t = this._allMenuItems.filter((l) => l.kind === "header").length, n = this._allMenuItems.length * this._actionLineHeight + t * this._headerLineHeight - t * this._actionLineHeight;
    this._list.layout(n);
    let o = e;
    if (this._allMenuItems.length >= 50)
      o = 380;
    else {
      const l = this._allMenuItems.map((c, h) => {
        const d = this.domNode.ownerDocument.getElementById(this._list.getElementID(h));
        if (d) {
          d.style.width = "auto";
          const u = d.getBoundingClientRect().width;
          return d.style.width = "", u;
        }
        return 0;
      });
      o = Math.max(...l, e);
    }
    const a = Math.min(n, this.domNode.ownerDocument.body.clientHeight * 0.7);
    return this._list.layout(a, o), this.domNode.style.height = `${a}px`, this._list.domFocus(), o;
  }
  focusPrevious() {
    this._list.focusPrevious(1, !0, void 0, this.focusCondition);
  }
  focusNext() {
    this._list.focusNext(1, !0, void 0, this.focusCondition);
  }
  acceptSelected(e) {
    const t = this._list.getFocus();
    if (t.length === 0)
      return;
    const i = t[0], n = this._list.element(i);
    if (!this.focusCondition(n))
      return;
    const o = e ? new NR() : new Gee();
    this._list.setSelection([i], o);
  }
  onListSelection(e) {
    if (!e.elements.length)
      return;
    const t = e.elements[0];
    t.item && this.focusCondition(t) ? this._delegate.onSelect(t.item, e.browserEvent instanceof NR) : this._list.setSelection([]);
  }
  onFocus() {
    var n, o;
    const e = this._list.getFocus();
    if (e.length === 0)
      return;
    const t = e[0], i = this._list.element(t);
    (o = (n = this._delegate).onFocus) == null || o.call(n, i.item);
  }
  async onListHover(e) {
    const t = e.element;
    if (t && t.item && this.focusCondition(t)) {
      if (this._delegate.onHover && !t.disabled && t.kind === "action") {
        const i = await this._delegate.onHover(t.item, this.cts.token);
        t.canPreview = i ? i.canPreview : void 0;
      }
      e.index && this._list.splice(e.index, 1, [t]);
    }
    this._list.setFocus(typeof e.index == "number" ? [e.index] : []);
  }
  onListClick(e) {
    e.element && this.focusCondition(e.element) && this._list.setFocus([]);
  }
};
uk = H7([
  hk(4, fd),
  hk(5, Lt)
], uk);
function U7(s) {
  return s.replace(/\r\n|\r|\n/g, " ");
}
var Yee = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, dy = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
E("actionBar.toggledBackground", lI, m("actionBar.toggledBackground", "Background color for toggled action items in action bar."));
const Yh = {
  Visible: new ce("codeActionMenuVisible", !1, m("codeActionMenuVisible", "Whether the action widget list is visible"))
}, wd = Be("actionWidgetService");
let Xh = class extends U {
  get isVisible() {
    return Yh.Visible.getValue(this._contextKeyService) || !1;
  }
  constructor(e, t, i) {
    super(), this._contextViewService = e, this._contextKeyService = t, this._instantiationService = i, this._list = this._register(new Hs());
  }
  show(e, t, i, n, o, r, a) {
    const l = Yh.Visible.bindTo(this._contextKeyService), c = this._instantiationService.createInstance(uk, e, t, i, n);
    this._contextViewService.showContextView({
      getAnchor: () => o,
      render: (h) => (l.set(!0), this._renderWidget(h, c, a ?? [])),
      onHide: (h) => {
        l.reset(), this._onWidgetClosed(h);
      }
    }, r, !1);
  }
  acceptSelected(e) {
    var t;
    (t = this._list.value) == null || t.acceptSelected(e);
  }
  focusPrevious() {
    var e, t;
    (t = (e = this._list) == null ? void 0 : e.value) == null || t.focusPrevious();
  }
  focusNext() {
    var e, t;
    (t = (e = this._list) == null ? void 0 : e.value) == null || t.focusNext();
  }
  hide(e) {
    var t;
    (t = this._list.value) == null || t.hide(e), this._list.clear();
  }
  _renderWidget(e, t, i) {
    var f;
    const n = document.createElement("div");
    if (n.classList.add("action-widget"), e.appendChild(n), this._list.value = t, this._list.value)
      n.appendChild(this._list.value.domNode);
    else
      throw new Error("List has no value");
    const o = new ne(), r = document.createElement("div"), a = e.appendChild(r);
    a.classList.add("context-view-block"), o.add(z(a, X.MOUSE_DOWN, (g) => g.stopPropagation()));
    const l = document.createElement("div"), c = e.appendChild(l);
    c.classList.add("context-view-pointerBlock"), o.add(z(c, X.POINTER_MOVE, () => c.remove())), o.add(z(c, X.MOUSE_DOWN, () => c.remove()));
    let h = 0;
    if (i.length) {
      const g = this._createActionBar(".action-widget-action-bar", i);
      g && (n.appendChild(g.getContainer().parentElement), o.add(g), h = g.getContainer().offsetWidth);
    }
    const d = (f = this._list.value) == null ? void 0 : f.layout(h);
    n.style.width = `${d}px`;
    const u = o.add(Vh(e));
    return o.add(u.onDidBlur(() => this.hide(!0))), o;
  }
  _createActionBar(e, t) {
    if (!t.length)
      return;
    const i = he(e), n = new $o(i);
    return n.push(t, { icon: !1, label: !0 }), n;
  }
  _onWidgetClosed(e) {
    var t;
    (t = this._list.value) == null || t.hide(e);
  }
};
Xh = Yee([
  dy(0, fd),
  dy(1, Fe),
  dy(2, Pe)
], Xh);
Ze(
  wd,
  Xh,
  1
  /* InstantiationType.Delayed */
);
const Yp = 1100;
Fn(class extends Nf {
  constructor() {
    super({
      id: "hideCodeActionWidget",
      title: oi("hideCodeActionWidget.title", "Hide action widget"),
      precondition: Yh.Visible,
      keybinding: {
        weight: Yp,
        primary: 9,
        secondary: [
          1033
          /* KeyCode.Escape */
        ]
      }
    });
  }
  run(s) {
    s.get(wd).hide(!0);
  }
});
Fn(class extends Nf {
  constructor() {
    super({
      id: "selectPrevCodeAction",
      title: oi("selectPrevCodeAction.title", "Select previous action"),
      precondition: Yh.Visible,
      keybinding: {
        weight: Yp,
        primary: 16,
        secondary: [
          2064
          /* KeyCode.UpArrow */
        ],
        mac: { primary: 16, secondary: [
          2064,
          302
          /* KeyCode.KeyP */
        ] }
      }
    });
  }
  run(s) {
    const e = s.get(wd);
    e instanceof Xh && e.focusPrevious();
  }
});
Fn(class extends Nf {
  constructor() {
    super({
      id: "selectNextCodeAction",
      title: oi("selectNextCodeAction.title", "Select next action"),
      precondition: Yh.Visible,
      keybinding: {
        weight: Yp,
        primary: 18,
        secondary: [
          2066
          /* KeyCode.DownArrow */
        ],
        mac: { primary: 18, secondary: [
          2066,
          300
          /* KeyCode.KeyN */
        ] }
      }
    });
  }
  run(s) {
    const e = s.get(wd);
    e instanceof Xh && e.focusNext();
  }
});
Fn(class extends Nf {
  constructor() {
    super({
      id: V7,
      title: oi("acceptSelected.title", "Accept selected action"),
      precondition: Yh.Visible,
      keybinding: {
        weight: Yp,
        primary: 3,
        secondary: [
          2137
          /* KeyCode.Period */
        ]
      }
    });
  }
  run(s) {
    const e = s.get(wd);
    e instanceof Xh && e.acceptSelected();
  }
});
Fn(class extends Nf {
  constructor() {
    super({
      id: z7,
      title: oi("previewSelected.title", "Preview selected action"),
      precondition: Yh.Visible,
      keybinding: {
        weight: Yp,
        primary: 2051
      }
    });
  }
  run(s) {
    const e = s.get(wd);
    e instanceof Xh && e.acceptSelected(!0);
  }
});
var Bt;
(function(s) {
  s[s.Hint = 1] = "Hint", s[s.Info = 2] = "Info", s[s.Warning = 4] = "Warning", s[s.Error = 8] = "Error";
})(Bt || (Bt = {}));
(function(s) {
  function e(r, a) {
    return a - r;
  }
  s.compare = e;
  const t = /* @__PURE__ */ Object.create(null);
  t[s.Error] = m("sev.error", "Error"), t[s.Warning] = m("sev.warning", "Warning"), t[s.Info] = m("sev.info", "Info");
  function i(r) {
    return t[r] || "";
  }
  s.toString = i;
  function n(r) {
    switch (r) {
      case Gt.Error:
        return s.Error;
      case Gt.Warning:
        return s.Warning;
      case Gt.Info:
        return s.Info;
      case Gt.Ignore:
        return s.Hint;
    }
  }
  s.fromSeverity = n;
  function o(r) {
    switch (r) {
      case s.Error:
        return Gt.Error;
      case s.Warning:
        return Gt.Warning;
      case s.Info:
        return Gt.Info;
      case s.Hint:
        return Gt.Ignore;
    }
  }
  s.toSeverity = o;
})(Bt || (Bt = {}));
var aC;
(function(s) {
  const e = "";
  function t(n) {
    return i(n, !0);
  }
  s.makeKey = t;
  function i(n, o) {
    const r = [e];
    return n.source ? r.push(n.source.replace("¦", "\\¦")) : r.push(e), n.code ? typeof n.code == "string" ? r.push(n.code.replace("¦", "\\¦")) : r.push(n.code.value.replace("¦", "\\¦")) : r.push(e), n.severity !== void 0 && n.severity !== null ? r.push(Bt.toString(n.severity)) : r.push(e), n.message && o ? r.push(n.message.replace("¦", "\\¦")) : r.push(e), n.startLineNumber !== void 0 && n.startLineNumber !== null ? r.push(n.startLineNumber.toString()) : r.push(e), n.startColumn !== void 0 && n.startColumn !== null ? r.push(n.startColumn.toString()) : r.push(e), n.endLineNumber !== void 0 && n.endLineNumber !== null ? r.push(n.endLineNumber.toString()) : r.push(e), n.endColumn !== void 0 && n.endColumn !== null ? r.push(n.endColumn.toString()) : r.push(e), r.push(e), r.join("¦");
  }
  s.makeKeyOptionalMessage = i;
})(aC || (aC = {}));
const Zr = Be("markerService"), Xee = new ce("supportedCodeAction", ""), TR = "_typescript.applyFixAllCodeAction";
class Qee extends U {
  constructor(e, t, i, n = 250) {
    super(), this._editor = e, this._markerService = t, this._signalChange = i, this._delay = n, this._autoTriggerTimer = this._register(new Ya()), this._register(this._markerService.onMarkerChanged((o) => this._onMarkerChanges(o))), this._register(this._editor.onDidChangeCursorPosition(() => this._tryAutoTrigger()));
  }
  trigger(e) {
    const t = this._getRangeOfSelectionUnlessWhitespaceEnclosed(e);
    this._signalChange(t ? { trigger: e, selection: t } : void 0);
  }
  _onMarkerChanges(e) {
    const t = this._editor.getModel();
    t && e.some((i) => FE(i, t.uri)) && this._tryAutoTrigger();
  }
  _tryAutoTrigger() {
    this._autoTriggerTimer.cancelAndSet(() => {
      this.trigger({ type: 2, triggerAction: tc.Default });
    }, this._delay);
  }
  _getRangeOfSelectionUnlessWhitespaceEnclosed(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._editor.getSelection();
    if (e.type === 1)
      return t;
    const i = this._editor.getOption(
      65
      /* EditorOption.lightbulb */
    ).enabled;
    if (i !== eo.Off) {
      {
        if (i === eo.On)
          return t;
        if (i === eo.OnCode) {
          if (!t.isEmpty())
            return t;
          const o = this._editor.getModel(), { lineNumber: r, column: a } = t.getPosition(), l = o.getLineContent(r);
          if (l.length === 0)
            return;
          if (a === 1) {
            if (/\s/.test(l[0]))
              return;
          } else if (a === o.getLineMaxColumn(r)) {
            if (/\s/.test(l[l.length - 1]))
              return;
          } else if (/\s/.test(l[a - 2]) && /\s/.test(l[a - 1]))
            return;
        }
      }
      return t;
    }
  }
}
var Bc;
(function(s) {
  s.Empty = {
    type: 0
    /* Type.Empty */
  };
  class e {
    constructor(i, n, o) {
      this.trigger = i, this.position = n, this._cancellablePromise = o, this.type = 1, this.actions = o.catch((r) => {
        if (Jh(r))
          return $7;
        throw r;
      });
    }
    cancel() {
      this._cancellablePromise.cancel();
    }
  }
  s.Triggered = e;
})(Bc || (Bc = {}));
const $7 = Object.freeze({
  allActions: [],
  validActions: [],
  dispose: () => {
  },
  documentation: [],
  hasAutoFix: !1,
  hasAIFix: !1,
  allAIFixes: !1
});
class Jee extends U {
  constructor(e, t, i, n, o, r, a) {
    super(), this._editor = e, this._registry = t, this._markerService = i, this._progressService = o, this._configurationService = r, this._telemetryService = a, this._codeActionOracle = this._register(new Hs()), this._state = Bc.Empty, this._onDidChangeState = this._register(new A()), this.onDidChangeState = this._onDidChangeState.event, this._disposed = !1, this._supportedCodeActions = Xee.bindTo(n), this._register(this._editor.onDidChangeModel(() => this._update())), this._register(this._editor.onDidChangeModelLanguage(() => this._update())), this._register(this._registry.onDidChange(() => this._update())), this._register(this._editor.onDidChangeConfiguration((l) => {
      l.hasChanged(
        65
        /* EditorOption.lightbulb */
      ) && this._update();
    })), this._update();
  }
  dispose() {
    this._disposed || (this._disposed = !0, super.dispose(), this.setState(Bc.Empty, !0));
  }
  _settingEnabledNearbyQuickfixes() {
    var t;
    const e = (t = this._editor) == null ? void 0 : t.getModel();
    return this._configurationService ? this._configurationService.getValue("editor.codeActionWidget.includeNearbyQuickFixes", { resource: e == null ? void 0 : e.uri }) : !1;
  }
  _update() {
    if (this._disposed)
      return;
    this._codeActionOracle.value = void 0, this.setState(Bc.Empty);
    const e = this._editor.getModel();
    if (e && this._registry.has(e) && !this._editor.getOption(
      92
      /* EditorOption.readOnly */
    )) {
      const t = this._registry.all(e).flatMap((i) => i.providedCodeActionKinds ?? []);
      this._supportedCodeActions.set(t.join(" ")), this._codeActionOracle.value = new Qee(this._editor, this._markerService, (i) => {
        var l;
        if (!i) {
          this.setState(Bc.Empty);
          return;
        }
        const n = i.selection.getStartPosition(), o = Za(async (c) => {
          var h, d, u, f, g, p, _, b, C, w;
          if (this._settingEnabledNearbyQuickfixes() && i.trigger.type === 1 && (i.trigger.triggerAction === tc.QuickFix || (d = (h = i.trigger.filter) == null ? void 0 : h.include) != null && d.contains(yi.QuickFix))) {
            const v = await lu(this._registry, e, i.selection, i.trigger, Dl.None, c), S = [...v.allActions];
            if (c.isCancellationRequested)
              return $7;
            const L = (u = v.validActions) == null ? void 0 : u.some((x) => x.action.kind ? yi.QuickFix.contains(new Hi(x.action.kind)) : !1), k = this._markerService.read({ resource: e.uri });
            if (L) {
              for (const x of v.validActions)
                (g = (f = x.action.command) == null ? void 0 : f.arguments) != null && g.some((I) => typeof I == "string" && I.includes(TR)) && (x.action.diagnostics = [...k.filter((I) => I.relatedInformation)]);
              return { validActions: v.validActions, allActions: S, documentation: v.documentation, hasAutoFix: v.hasAutoFix, hasAIFix: v.hasAIFix, allAIFixes: v.allAIFixes, dispose: () => {
                v.dispose();
              } };
            } else if (!L && k.length > 0) {
              const x = i.selection.getPosition();
              let I = x, K = Number.MAX_VALUE;
              const B = [...v.validActions];
              for (const H of k) {
                const P = H.endColumn, q = H.endLineNumber, J = H.startLineNumber;
                if (q === x.lineNumber || J === x.lineNumber) {
                  I = new F(q, P);
                  const oe = {
                    type: i.trigger.type,
                    triggerAction: i.trigger.triggerAction,
                    filter: { include: (p = i.trigger.filter) != null && p.include ? (_ = i.trigger.filter) == null ? void 0 : _.include : yi.QuickFix },
                    autoApply: i.trigger.autoApply,
                    context: { notAvailableMessage: ((b = i.trigger.context) == null ? void 0 : b.notAvailableMessage) || "", position: I }
                  }, ae = new Ue(I.lineNumber, I.column, I.lineNumber, I.column), re = await lu(this._registry, e, ae, oe, Dl.None, c);
                  if (re.validActions.length !== 0) {
                    for (const be of re.validActions)
                      (w = (C = be.action.command) == null ? void 0 : C.arguments) != null && w.some((Ce) => typeof Ce == "string" && Ce.includes(TR)) && (be.action.diagnostics = [...k.filter((Ce) => Ce.relatedInformation)]);
                    v.allActions.length === 0 && S.push(...re.allActions), Math.abs(x.column - P) < K ? B.unshift(...re.validActions) : B.push(...re.validActions);
                  }
                  K = Math.abs(x.column - P);
                }
              }
              const W = B.filter((H, P, q) => q.findIndex((J) => J.action.title === H.action.title) === P);
              return W.sort((H, P) => H.action.isPreferred && !P.action.isPreferred ? -1 : !H.action.isPreferred && P.action.isPreferred || H.action.isAI && !P.action.isAI ? 1 : !H.action.isAI && P.action.isAI ? -1 : 0), { validActions: W, allActions: S, documentation: v.documentation, hasAutoFix: v.hasAutoFix, hasAIFix: v.hasAIFix, allAIFixes: v.allAIFixes, dispose: () => {
                v.dispose();
              } };
            }
          }
          if (i.trigger.type === 1) {
            const v = new Ga(), S = await lu(this._registry, e, i.selection, i.trigger, Dl.None, c);
            return this._telemetryService && this._telemetryService.publicLog2("codeAction.invokedDurations", {
              codeActions: S.validActions.length,
              duration: v.elapsed()
            }), S;
          }
          return lu(this._registry, e, i.selection, i.trigger, Dl.None, c);
        });
        i.trigger.type === 1 && ((l = this._progressService) == null || l.showWhile(o, 250));
        const r = new Bc.Triggered(i.trigger, n, o);
        let a = !1;
        this._state.type === 1 && (a = this._state.trigger.type === 1 && r.type === 1 && r.trigger.type === 2 && this._state.position !== r.position), a ? setTimeout(() => {
          this.setState(r);
        }, 500) : this.setState(r);
      }, void 0), this._codeActionOracle.value.trigger({ type: 2, triggerAction: tc.Default });
    } else
      this._supportedCodeActions.reset();
  }
  trigger(e) {
    var t;
    (t = this._codeActionOracle.value) == null || t.trigger(e);
  }
  setState(e, t) {
    e !== this._state && (this._state.type === 1 && this._state.cancel(), this._state = e, !t && !this._disposed && this._onDidChangeState.fire(e));
  }
}
var ete = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, hr = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Kd;
const tte = "quickfix-edit-highlight";
var $l;
let fk = ($l = class extends U {
  static get(e) {
    return e.getContribution(Kd.ID);
  }
  constructor(e, t, i, n, o, r, a, l, c, h, d) {
    super(), this._commandService = a, this._configurationService = l, this._actionWidgetService = c, this._instantiationService = h, this._telemetryService = d, this._activeCodeActions = this._register(new Hs()), this._showDisabled = !1, this._disposed = !1, this._editor = e, this._model = this._register(new Jee(this._editor, o.codeActionProvider, t, i, r, l, this._telemetryService)), this._register(this._model.onDidChangeState((u) => this.update(u))), this._lightBulbWidget = new Fr(() => {
      const u = this._editor.getContribution(ck.ID);
      return u && this._register(u.onClick((f) => this.showCodeActionsFromLightbulb(f.actions, f))), u;
    }), this._resolver = n.createInstance(lk), this._register(this._editor.onDidLayoutChange(() => this._actionWidgetService.hide()));
  }
  dispose() {
    this._disposed = !0, super.dispose();
  }
  async showCodeActionsFromLightbulb(e, t) {
    if (e.allAIFixes && e.validActions.length === 1) {
      const i = e.validActions[0], n = i.action.command;
      n && n.id === "inlineChat.start" && n.arguments && n.arguments.length >= 1 && (n.arguments[0] = { ...n.arguments[0], autoSend: !1 }), await this._applyCodeAction(i, !1, !1, nh.FromAILightbulb);
      return;
    }
    await this.showCodeActionList(e, t, { includeDisabledActions: !1, fromLightbulb: !0 });
  }
  showCodeActions(e, t, i) {
    return this.showCodeActionList(t, i, { includeDisabledActions: !1, fromLightbulb: !1 });
  }
  manualTriggerAtCurrentPosition(e, t, i, n) {
    var r;
    if (!this._editor.hasModel())
      return;
    (r = Rr.get(this._editor)) == null || r.closeMessage();
    const o = this._editor.getPosition();
    this._trigger({ type: 1, triggerAction: t, filter: i, autoApply: n, context: { notAvailableMessage: e, position: o } });
  }
  _trigger(e) {
    return this._model.trigger(e);
  }
  async _applyCodeAction(e, t, i, n) {
    try {
      await this._instantiationService.invokeFunction(Wee, e, n, { preview: i, editor: this._editor });
    } finally {
      t && this._trigger({ type: 2, triggerAction: tc.QuickFix, filter: {} });
    }
  }
  hideLightBulbWidget() {
    var e, t;
    (e = this._lightBulbWidget.rawValue) == null || e.hide(), (t = this._lightBulbWidget.rawValue) == null || t.gutterHide();
  }
  async update(e) {
    var n, o, r, a, l;
    if (e.type !== 1) {
      this.hideLightBulbWidget();
      return;
    }
    let t;
    try {
      t = await e.actions;
    } catch (c) {
      Je(c);
      return;
    }
    if (this._disposed)
      return;
    const i = this._editor.getSelection();
    if ((i == null ? void 0 : i.startLineNumber) === e.position.lineNumber)
      if ((n = this._lightBulbWidget.value) == null || n.update(t, e.trigger, e.position), e.trigger.type === 1) {
        if ((o = e.trigger.filter) != null && o.include) {
          const h = this.tryGetValidActionToApply(e.trigger, t);
          if (h) {
            try {
              this.hideLightBulbWidget(), await this._applyCodeAction(h, !1, !1, nh.FromCodeActions);
            } finally {
              t.dispose();
            }
            return;
          }
          if (e.trigger.context) {
            const d = this.getInvalidActionThatWouldHaveBeenApplied(e.trigger, t);
            if (d && d.action.disabled) {
              (r = Rr.get(this._editor)) == null || r.showMessage(d.action.disabled, e.trigger.context.position), t.dispose();
              return;
            }
          }
        }
        const c = !!((a = e.trigger.filter) != null && a.include);
        if (e.trigger.context && (!t.allActions.length || !c && !t.validActions.length)) {
          (l = Rr.get(this._editor)) == null || l.showMessage(e.trigger.context.notAvailableMessage, e.trigger.context.position), this._activeCodeActions.value = t, t.dispose();
          return;
        }
        this._activeCodeActions.value = t, this.showCodeActionList(t, this.toCoords(e.position), { includeDisabledActions: c, fromLightbulb: !1 });
      } else
        this._actionWidgetService.isVisible ? t.dispose() : this._activeCodeActions.value = t;
  }
  getInvalidActionThatWouldHaveBeenApplied(e, t) {
    if (t.allActions.length && (e.autoApply === "first" && t.validActions.length === 0 || e.autoApply === "ifSingle" && t.allActions.length === 1))
      return t.allActions.find(({ action: i }) => i.disabled);
  }
  tryGetValidActionToApply(e, t) {
    if (t.validActions.length && (e.autoApply === "first" && t.validActions.length > 0 || e.autoApply === "ifSingle" && t.validActions.length === 1))
      return t.validActions[0];
  }
  async showCodeActionList(e, t, i) {
    const n = this._editor.createDecorationsCollection(), o = this._editor.getDomNode();
    if (!o)
      return;
    const r = i.includeDisabledActions && (this._showDisabled || e.validActions.length === 0) ? e.allActions : e.validActions;
    if (!r.length)
      return;
    const a = F.isIPosition(t) ? this.toCoords(t) : t, l = {
      onSelect: async (c, h) => {
        this._applyCodeAction(
          c,
          /* retrigger */
          !0,
          !!h,
          i.fromLightbulb ? nh.FromAILightbulb : nh.FromCodeActions
        ), this._actionWidgetService.hide(!1), n.clear();
      },
      onHide: (c) => {
        var h;
        (h = this._editor) == null || h.focus(), n.clear();
      },
      onHover: async (c, h) => {
        var f;
        if (h.isCancellationRequested)
          return;
        let d = !1;
        const u = c.action.kind;
        if (u) {
          const g = new Hi(u);
          d = [
            yi.RefactorExtract,
            yi.RefactorInline,
            yi.RefactorRewrite,
            yi.RefactorMove,
            yi.Source
          ].some((_) => _.contains(g));
        }
        return { canPreview: d || !!((f = c.action.edit) != null && f.edits.length) };
      },
      onFocus: (c) => {
        var h, d;
        if (c && c.action) {
          const u = c.action.ranges, f = c.action.diagnostics;
          if (n.clear(), u && u.length > 0) {
            const g = f && (f == null ? void 0 : f.length) > 1 ? f.map((p) => ({ range: p, options: Kd.DECORATION })) : u.map((p) => ({ range: p, options: Kd.DECORATION }));
            n.set(g);
          } else if (f && f.length > 0) {
            const g = f.map((_) => ({ range: _, options: Kd.DECORATION }));
            n.set(g);
            const p = f[0];
            if (p.startLineNumber && p.startColumn) {
              const _ = (d = (h = this._editor.getModel()) == null ? void 0 : h.getWordAtPosition({ lineNumber: p.startLineNumber, column: p.startColumn })) == null ? void 0 : d.word;
              Rm(m("editingNewSelection", "Context: {0} at line {1} and column {2}.", _, p.startLineNumber, p.startColumn));
            }
          }
        } else
          n.clear();
      }
    };
    this._actionWidgetService.show("codeActionWidget", !0, $ee(r, this._shouldShowHeaders(), this._resolver.getResolver()), l, a, o, this._getActionBarActions(e, t, i));
  }
  toCoords(e) {
    if (!this._editor.hasModel())
      return { x: 0, y: 0 };
    this._editor.revealPosition(
      e,
      1
      /* ScrollType.Immediate */
    ), this._editor.render();
    const t = this._editor.getScrolledVisiblePosition(e), i = ui(this._editor.getDomNode()), n = i.left + t.left, o = i.top + t.top + t.height;
    return { x: n, y: o };
  }
  _shouldShowHeaders() {
    var t;
    const e = (t = this._editor) == null ? void 0 : t.getModel();
    return this._configurationService.getValue("editor.codeActionWidget.showHeaders", { resource: e == null ? void 0 : e.uri });
  }
  _getActionBarActions(e, t, i) {
    if (i.fromLightbulb)
      return [];
    const n = e.documentation.map((o) => ({
      id: o.id,
      label: o.title,
      tooltip: o.tooltip ?? "",
      class: void 0,
      enabled: !0,
      run: () => this._commandService.executeCommand(o.id, ...o.arguments ?? [])
    }));
    return i.includeDisabledActions && e.validActions.length > 0 && e.allActions.length !== e.validActions.length && n.push(this._showDisabled ? {
      id: "hideMoreActions",
      label: m("hideMoreActions", "Hide Disabled"),
      enabled: !0,
      tooltip: "",
      class: void 0,
      run: () => (this._showDisabled = !1, this.showCodeActionList(e, t, i))
    } : {
      id: "showMoreActions",
      label: m("showMoreActions", "Show Disabled"),
      enabled: !0,
      tooltip: "",
      class: void 0,
      run: () => (this._showDisabled = !0, this.showCodeActionList(e, t, i))
    }), n;
  }
}, Kd = $l, $l.ID = "editor.contrib.codeActionController", $l.DECORATION = Wt.register({
  description: "quickfix-highlight",
  className: tte
}), $l);
fk = Kd = ete([
  hr(1, Zr),
  hr(2, Fe),
  hr(3, Pe),
  hr(4, De),
  hr(5, Kp),
  hr(6, fi),
  hr(7, gt),
  hr(8, wd),
  hr(9, Pe),
  hr(10, Jo)
], fk);
tr((s, e) => {
  ((n, o) => {
    o && e.addRule(`.monaco-editor ${n} { background-color: ${o}; }`);
  })(".quickfix-edit-highlight", s.getColor(Da));
  const i = s.getColor(Jc);
  i && e.addRule(`.monaco-editor .quickfix-edit-highlight { border: 1px ${dh(s.type) ? "dotted" : "solid"} ${i}; box-sizing: border-box; }`);
});
var K7 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, lC = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class MR {
  constructor(e, t, i) {
    this.marker = e, this.index = t, this.total = i;
  }
}
let gk = class {
  constructor(e, t, i) {
    this._markerService = t, this._configService = i, this._onDidChange = new A(), this.onDidChange = this._onDidChange.event, this._dispoables = new ne(), this._markers = [], this._nextIdx = -1, we.isUri(e) ? this._resourceFilter = (a) => a.toString() === e.toString() : e && (this._resourceFilter = e);
    const n = this._configService.getValue("problems.sortOrder"), o = (a, l) => {
      let c = Lm(a.resource.toString(), l.resource.toString());
      return c === 0 && (n === "position" ? c = T.compareRangesUsingStarts(a, l) || Bt.compare(a.severity, l.severity) : c = Bt.compare(a.severity, l.severity) || T.compareRangesUsingStarts(a, l)), c;
    }, r = () => {
      this._markers = this._markerService.read({
        resource: we.isUri(e) ? e : void 0,
        severities: Bt.Error | Bt.Warning | Bt.Info
      }), typeof e == "function" && (this._markers = this._markers.filter((a) => this._resourceFilter(a.resource))), this._markers.sort(o);
    };
    r(), this._dispoables.add(t.onMarkerChanged((a) => {
      (!this._resourceFilter || a.some((l) => this._resourceFilter(l))) && (r(), this._nextIdx = -1, this._onDidChange.fire());
    }));
  }
  dispose() {
    this._dispoables.dispose(), this._onDidChange.dispose();
  }
  matches(e) {
    return !this._resourceFilter && !e ? !0 : !this._resourceFilter || !e ? !1 : this._resourceFilter(e);
  }
  get selected() {
    const e = this._markers[this._nextIdx];
    return e && new MR(e, this._nextIdx + 1, this._markers.length);
  }
  _initIdx(e, t, i) {
    let n = !1, o = this._markers.findIndex((r) => r.resource.toString() === e.uri.toString());
    o < 0 && (o = hO(this._markers, { resource: e.uri }, (r, a) => Lm(r.resource.toString(), a.resource.toString())), o < 0 && (o = ~o));
    for (let r = o; r < this._markers.length; r++) {
      let a = T.lift(this._markers[r]);
      if (a.isEmpty()) {
        const l = e.getWordAtPosition(a.getStartPosition());
        l && (a = new T(a.startLineNumber, l.startColumn, a.startLineNumber, l.endColumn));
      }
      if (t && (a.containsPosition(t) || t.isBeforeOrEqual(a.getStartPosition()))) {
        this._nextIdx = r, n = !0;
        break;
      }
      if (this._markers[r].resource.toString() !== e.uri.toString())
        break;
    }
    n || (this._nextIdx = i ? 0 : this._markers.length - 1), this._nextIdx < 0 && (this._nextIdx = this._markers.length - 1);
  }
  resetIndex() {
    this._nextIdx = -1;
  }
  move(e, t, i) {
    if (this._markers.length === 0)
      return !1;
    const n = this._nextIdx;
    return this._nextIdx === -1 ? this._initIdx(t, i, e) : e ? this._nextIdx = (this._nextIdx + 1) % this._markers.length : e || (this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length), n !== this._nextIdx;
  }
  find(e, t) {
    let i = this._markers.findIndex((n) => n.resource.toString() === e.toString());
    if (!(i < 0)) {
      for (; i < this._markers.length; i++)
        if (T.containsPosition(this._markers[i], t))
          return new MR(this._markers[i], i + 1, this._markers.length);
    }
  }
};
gk = K7([
  lC(1, Zr),
  lC(2, gt)
], gk);
const j7 = Be("IMarkerNavigationService");
let mk = class {
  constructor(e, t) {
    this._markerService = e, this._configService = t, this._provider = new Tn();
  }
  getMarkerList(e) {
    for (const t of this._provider) {
      const i = t.getMarkerList(e);
      if (i)
        return i;
    }
    return new gk(e, this._markerService, this._configService);
  }
};
mk = K7([
  lC(0, Zr),
  lC(1, gt)
], mk);
Ze(
  j7,
  mk,
  1
  /* InstantiationType.Delayed */
);
var pk;
(function(s) {
  function e(t) {
    switch (t) {
      case Gt.Ignore:
        return "severity-ignore " + Te.asClassName(ie.info);
      case Gt.Info:
        return Te.asClassName(ie.info);
      case Gt.Warning:
        return Te.asClassName(ie.warning);
      case Gt.Error:
        return Te.asClassName(ie.error);
      default:
        return "";
    }
  }
  s.className = e;
})(pk || (pk = {}));
var ite = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Wd = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, _k;
class nte {
  constructor(e, t, i, n, o) {
    this._openerService = n, this._labelService = o, this._lines = 0, this._longestLineLength = 0, this._relatedDiagnostics = /* @__PURE__ */ new WeakMap(), this._disposables = new ne(), this._editor = t;
    const r = document.createElement("div");
    r.className = "descriptioncontainer", this._messageBlock = document.createElement("div"), this._messageBlock.classList.add("message"), this._messageBlock.setAttribute("aria-live", "assertive"), this._messageBlock.setAttribute("role", "alert"), r.appendChild(this._messageBlock), this._relatedBlock = document.createElement("div"), r.appendChild(this._relatedBlock), this._disposables.add(Zt(this._relatedBlock, "click", (a) => {
      a.preventDefault();
      const l = this._relatedDiagnostics.get(a.target);
      l && i(l);
    })), this._scrollable = new LO(r, {
      horizontal: 1,
      vertical: 1,
      useShadows: !1,
      horizontalScrollbarSize: 6,
      verticalScrollbarSize: 6
    }), e.appendChild(this._scrollable.getDomNode()), this._disposables.add(this._scrollable.onScroll((a) => {
      r.style.left = `-${a.scrollLeft}px`, r.style.top = `-${a.scrollTop}px`;
    })), this._disposables.add(this._scrollable);
  }
  dispose() {
    Ft(this._disposables);
  }
  update(e) {
    const { source: t, message: i, relatedInformation: n, code: o } = e;
    let r = ((t == null ? void 0 : t.length) || 0) + 2;
    o && (typeof o == "string" ? r += o.length : r += o.value.length);
    const a = td(i);
    this._lines = a.length, this._longestLineLength = 0;
    for (const u of a)
      this._longestLineLength = Math.max(u.length + r, this._longestLineLength);
    ks(this._messageBlock), this._messageBlock.setAttribute("aria-label", this.getAriaLabel(e)), this._editor.applyFontInfo(this._messageBlock);
    let l = this._messageBlock;
    for (const u of a)
      l = document.createElement("div"), l.innerText = u, u === "" && (l.style.height = this._messageBlock.style.lineHeight), this._messageBlock.appendChild(l);
    if (t || o) {
      const u = document.createElement("span");
      if (u.classList.add("details"), l.appendChild(u), t) {
        const f = document.createElement("span");
        f.innerText = t, f.classList.add("source"), u.appendChild(f);
      }
      if (o)
        if (typeof o == "string") {
          const f = document.createElement("span");
          f.innerText = `(${o})`, f.classList.add("code"), u.appendChild(f);
        } else {
          this._codeLink = he("a.code-link"), this._codeLink.setAttribute("href", `${o.target.toString()}`), this._codeLink.onclick = (g) => {
            this._openerService.open(o.target, { allowCommands: !0 }), g.preventDefault(), g.stopPropagation();
          };
          const f = te(this._codeLink, he("span"));
          f.innerText = o.value, u.appendChild(this._codeLink);
        }
    }
    if (ks(this._relatedBlock), this._editor.applyFontInfo(this._relatedBlock), co(n)) {
      const u = this._relatedBlock.appendChild(document.createElement("div"));
      u.style.paddingTop = `${Math.floor(this._editor.getOption(
        67
        /* EditorOption.lineHeight */
      ) * 0.66)}px`, this._lines += 1;
      for (const f of n) {
        const g = document.createElement("div"), p = document.createElement("a");
        p.classList.add("filename"), p.innerText = `${this._labelService.getUriBasenameLabel(f.resource)}(${f.startLineNumber}, ${f.startColumn}): `, p.title = this._labelService.getUriLabel(f.resource), this._relatedDiagnostics.set(p, f);
        const _ = document.createElement("span");
        _.innerText = f.message, g.appendChild(p), g.appendChild(_), this._lines += 1, u.appendChild(g);
      }
    }
    const c = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    ), h = Math.ceil(c.typicalFullwidthCharacterWidth * this._longestLineLength * 0.75), d = c.lineHeight * this._lines;
    this._scrollable.setScrollDimensions({ scrollWidth: h, scrollHeight: d });
  }
  layout(e, t) {
    this._scrollable.getDomNode().style.height = `${e}px`, this._scrollable.getDomNode().style.width = `${t}px`, this._scrollable.setScrollDimensions({ width: t, height: e });
  }
  getHeightInLines() {
    return Math.min(17, this._lines);
  }
  getAriaLabel(e) {
    let t = "";
    switch (e.severity) {
      case Bt.Error:
        t = m("Error", "Error");
        break;
      case Bt.Warning:
        t = m("Warning", "Warning");
        break;
      case Bt.Info:
        t = m("Info", "Info");
        break;
      case Bt.Hint:
        t = m("Hint", "Hint");
        break;
    }
    let i = m("marker aria", "{0} at {1}. ", t, e.startLineNumber + ":" + e.startColumn);
    const n = this._editor.getModel();
    return n && e.startLineNumber <= n.getLineCount() && e.startLineNumber >= 1 && (i = `${n.getLineContent(e.startLineNumber)}, ${i}`), i;
  }
}
var Eh;
let pp = (Eh = class extends H1 {
  constructor(e, t, i, n, o, r, a) {
    super(e, { showArrow: !0, showFrame: !0, isAccessible: !0, frameWidth: 1 }, o), this._themeService = t, this._openerService = i, this._menuService = n, this._contextKeyService = r, this._labelService = a, this._callOnDispose = new ne(), this._onDidSelectRelatedInformation = new A(), this.onDidSelectRelatedInformation = this._onDidSelectRelatedInformation.event, this._severity = Bt.Warning, this._backgroundColor = j.white, this._applyTheme(t.getColorTheme()), this._callOnDispose.add(t.onDidColorThemeChange(this._applyTheme.bind(this))), this.create();
  }
  _applyTheme(e) {
    this._backgroundColor = e.getColor(ate);
    let t = bk, i = ste;
    this._severity === Bt.Warning ? (t = yb, i = ote) : this._severity === Bt.Info && (t = Ck, i = rte);
    const n = e.getColor(t), o = e.getColor(i);
    this.style({
      arrowColor: n,
      frameColor: n,
      headerBackgroundColor: o,
      primaryHeadingColor: e.getColor(AF),
      secondaryHeadingColor: e.getColor(PF)
    });
  }
  _applyStyles() {
    this._parentContainer && (this._parentContainer.style.backgroundColor = this._backgroundColor ? this._backgroundColor.toString() : ""), super._applyStyles();
  }
  dispose() {
    this._callOnDispose.dispose(), super.dispose();
  }
  _fillHead(e) {
    super._fillHead(e), this._disposables.add(this._actionbarWidget.actionRunner.onWillRun((n) => this.editor.focus()));
    const t = [], i = this._menuService.getMenuActions(_k.TitleMenu, this._contextKeyService);
    XI(i, t), this._actionbarWidget.push(t, { label: !1, icon: !0, index: 0 });
  }
  _fillTitleIcon(e) {
    this._icon = te(e, he(""));
  }
  _fillBody(e) {
    this._parentContainer = e, e.classList.add("marker-widget"), this._parentContainer.tabIndex = 0, this._parentContainer.setAttribute("role", "tooltip"), this._container = document.createElement("div"), e.appendChild(this._container), this._message = new nte(this._container, this.editor, (t) => this._onDidSelectRelatedInformation.fire(t), this._openerService, this._labelService), this._disposables.add(this._message);
  }
  show() {
    throw new Error("call showAtMarker");
  }
  showAtMarker(e, t, i) {
    this._container.classList.remove("stale"), this._message.update(e), this._severity = e.severity, this._applyTheme(this._themeService.getColorTheme());
    const n = T.lift(e), o = this.editor.getPosition(), r = o && n.containsPosition(o) ? o : n.getStartPosition();
    super.show(r, this.computeRequiredHeight());
    const a = this.editor.getModel();
    if (a) {
      const l = i > 1 ? m("problems", "{0} of {1} problems", t, i) : m("change", "{0} of {1} problem", t, i);
      this.setTitle(qo(a.uri), l);
    }
    this._icon.className = `codicon ${pk.className(Bt.toSeverity(this._severity))}`, this.editor.revealPositionNearTop(
      r,
      0
      /* ScrollType.Smooth */
    ), this.editor.focus();
  }
  updateMarker(e) {
    this._container.classList.remove("stale"), this._message.update(e);
  }
  showStale() {
    this._container.classList.add("stale"), this._relayout();
  }
  _doLayoutBody(e, t) {
    super._doLayoutBody(e, t), this._heightInPixel = e, this._message.layout(e, t), this._container.style.height = `${e}px`;
  }
  _onWidth(e) {
    this._message.layout(this._heightInPixel, e);
  }
  _relayout() {
    super._relayout(this.computeRequiredHeight());
  }
  computeRequiredHeight() {
    return 3 + this._message.getHeightInLines();
  }
}, _k = Eh, Eh.TitleMenu = new et("gotoErrorTitleMenu"), Eh);
pp = _k = ite([
  Wd(1, wn),
  Wd(2, sr),
  Wd(3, $r),
  Wd(4, Pe),
  Wd(5, Fe),
  Wd(6, Bw)
], pp);
const RR = Hm(_w, Iz), AR = Hm(Ka, Vm), PR = Hm(Wr, zm), bk = E("editorMarkerNavigationError.background", { dark: RR, light: RR, hcDark: Ke, hcLight: Ke }, m("editorMarkerNavigationError", "Editor marker navigation widget error color.")), ste = E("editorMarkerNavigationError.headerBackground", { dark: Ae(bk, 0.1), light: Ae(bk, 0.1), hcDark: null, hcLight: null }, m("editorMarkerNavigationErrorHeaderBackground", "Editor marker navigation widget error heading background.")), yb = E("editorMarkerNavigationWarning.background", { dark: AR, light: AR, hcDark: Ke, hcLight: Ke }, m("editorMarkerNavigationWarning", "Editor marker navigation widget warning color.")), ote = E("editorMarkerNavigationWarning.headerBackground", { dark: Ae(yb, 0.1), light: Ae(yb, 0.1), hcDark: "#0C141F", hcLight: Ae(yb, 0.2) }, m("editorMarkerNavigationWarningBackground", "Editor marker navigation widget warning heading background.")), Ck = E("editorMarkerNavigationInfo.background", { dark: PR, light: PR, hcDark: Ke, hcLight: Ke }, m("editorMarkerNavigationInfo", "Editor marker navigation widget info color.")), rte = E("editorMarkerNavigationInfo.headerBackground", { dark: Ae(Ck, 0.1), light: Ae(Ck, 0.1), hcDark: null, hcLight: null }, m("editorMarkerNavigationInfoHeaderBackground", "Editor marker navigation widget info heading background.")), ate = E("editorMarkerNavigation.background", po, m("editorMarkerNavigationBackground", "Editor marker navigation widget background."));
var lte = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, P_ = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Dg, Ih;
let Qh = (Ih = class {
  static get(e) {
    return e.getContribution(Dg.ID);
  }
  constructor(e, t, i, n, o) {
    this._markerNavigationService = t, this._contextKeyService = i, this._editorService = n, this._instantiationService = o, this._sessionDispoables = new ne(), this._editor = e, this._widgetVisible = q7.bindTo(this._contextKeyService);
  }
  dispose() {
    this._cleanUp(), this._sessionDispoables.dispose();
  }
  _cleanUp() {
    this._widgetVisible.reset(), this._sessionDispoables.clear(), this._widget = void 0, this._model = void 0;
  }
  _getOrCreateModel(e) {
    if (this._model && this._model.matches(e))
      return this._model;
    let t = !1;
    return this._model && (t = !0, this._cleanUp()), this._model = this._markerNavigationService.getMarkerList(e), t && this._model.move(!0, this._editor.getModel(), this._editor.getPosition()), this._widget = this._instantiationService.createInstance(pp, this._editor), this._widget.onDidClose(() => this.close(), this, this._sessionDispoables), this._widgetVisible.set(!0), this._sessionDispoables.add(this._model), this._sessionDispoables.add(this._widget), this._sessionDispoables.add(this._editor.onDidChangeCursorPosition((i) => {
      var n, o, r;
      (!((n = this._model) != null && n.selected) || !T.containsPosition((o = this._model) == null ? void 0 : o.selected.marker, i.position)) && ((r = this._model) == null || r.resetIndex());
    })), this._sessionDispoables.add(this._model.onDidChange(() => {
      if (!this._widget || !this._widget.position || !this._model)
        return;
      const i = this._model.find(this._editor.getModel().uri, this._widget.position);
      i ? this._widget.updateMarker(i.marker) : this._widget.showStale();
    })), this._sessionDispoables.add(this._widget.onDidSelectRelatedInformation((i) => {
      this._editorService.openCodeEditor({
        resource: i.resource,
        options: { pinned: !0, revealIfOpened: !0, selection: T.lift(i).collapseToStart() }
      }, this._editor), this.close(!1);
    })), this._sessionDispoables.add(this._editor.onDidChangeModel(() => this._cleanUp())), this._model;
  }
  close(e = !0) {
    this._cleanUp(), e && this._editor.focus();
  }
  showAtMarker(e) {
    if (this._editor.hasModel()) {
      const t = this._getOrCreateModel(this._editor.getModel().uri);
      t.resetIndex(), t.move(!0, this._editor.getModel(), new F(e.startLineNumber, e.startColumn)), t.selected && this._widget.showAtMarker(t.selected.marker, t.selected.index, t.selected.total);
    }
  }
  async nagivate(e, t) {
    var i, n;
    if (this._editor.hasModel()) {
      const o = this._getOrCreateModel(t ? void 0 : this._editor.getModel().uri);
      if (o.move(e, this._editor.getModel(), this._editor.getPosition()), !o.selected)
        return;
      if (o.selected.marker.resource.toString() !== this._editor.getModel().uri.toString()) {
        this._cleanUp();
        const r = await this._editorService.openCodeEditor({
          resource: o.selected.marker.resource,
          options: { pinned: !1, revealIfOpened: !0, selectionRevealType: 2, selection: o.selected.marker }
        }, this._editor);
        r && ((i = Dg.get(r)) == null || i.close(), (n = Dg.get(r)) == null || n.nagivate(e, t));
      } else
        this._widget.showAtMarker(o.selected.marker, o.selected.index, o.selected.total);
    }
  }
}, Dg = Ih, Ih.ID = "editor.contrib.markerController", Ih);
Qh = Dg = lte([
  P_(1, j7),
  P_(2, Fe),
  P_(3, Tt),
  P_(4, Pe)
], Qh);
class jw extends ss {
  constructor(e, t, i) {
    super(i), this._next = e, this._multiFile = t;
  }
  async run(e, t) {
    var i;
    t.hasModel() && ((i = Qh.get(t)) == null || i.nagivate(this._next, this._multiFile));
  }
}
const qc = class qc extends jw {
  constructor() {
    super(!0, !1, {
      id: qc.ID,
      label: qc.LABEL,
      alias: "Go to Next Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: Z.focus,
        primary: 578,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: pp.TitleMenu,
        title: qc.LABEL,
        icon: $i("marker-navigation-next", ie.arrowDown, m("nextMarkerIcon", "Icon for goto next marker.")),
        group: "navigation",
        order: 1
      }
    });
  }
};
qc.ID = "editor.action.marker.next", qc.LABEL = m("markerAction.next.label", "Go to Next Problem (Error, Warning, Info)");
let cC = qc;
const Gc = class Gc extends jw {
  constructor() {
    super(!1, !1, {
      id: Gc.ID,
      label: Gc.LABEL,
      alias: "Go to Previous Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: Z.focus,
        primary: 1602,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: pp.TitleMenu,
        title: Gc.LABEL,
        icon: $i("marker-navigation-previous", ie.arrowUp, m("previousMarkerIcon", "Icon for goto previous marker.")),
        group: "navigation",
        order: 2
      }
    });
  }
};
Gc.ID = "editor.action.marker.prev", Gc.LABEL = m("markerAction.previous.label", "Go to Previous Problem (Error, Warning, Info)");
let vk = Gc;
class cte extends jw {
  constructor() {
    super(!0, !0, {
      id: "editor.action.marker.nextInFiles",
      label: m("markerAction.nextInFiles.label", "Go to Next Problem in Files (Error, Warning, Info)"),
      alias: "Go to Next Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: Z.focus,
        primary: 66,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: et.MenubarGoMenu,
        title: m({ key: "miGotoNextProblem", comment: ["&& denotes a mnemonic"] }, "Next &&Problem"),
        group: "6_problem_nav",
        order: 1
      }
    });
  }
}
class hte extends jw {
  constructor() {
    super(!1, !0, {
      id: "editor.action.marker.prevInFiles",
      label: m("markerAction.previousInFiles.label", "Go to Previous Problem in Files (Error, Warning, Info)"),
      alias: "Go to Previous Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: Z.focus,
        primary: 1090,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: et.MenubarGoMenu,
        title: m({ key: "miGotoPreviousProblem", comment: ["&& denotes a mnemonic"] }, "Previous &&Problem"),
        group: "6_problem_nav",
        order: 2
      }
    });
  }
}
Xa(
  Qh.ID,
  Qh,
  4
  /* EditorContributionInstantiation.Lazy */
);
Bn(cC);
Bn(vk);
Bn(cte);
Bn(hte);
const q7 = new ce("markersNavigationVisible", !1), dte = jo.bindToContribution(Qh.get);
Le(new dte({
  id: "closeMarkersNavigation",
  precondition: q7,
  handler: (s) => s.close(),
  kbOpts: {
    weight: 150,
    kbExpr: Z.focus,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
var ute = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, uy = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const Zs = he;
class fte {
  constructor(e, t, i) {
    this.owner = e, this.range = t, this.marker = i;
  }
  isValidForHoverAnchor(e) {
    return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
  }
}
const OR = {
  type: 1,
  filter: { include: yi.QuickFix },
  triggerAction: tc.QuickFixHover
};
let wk = class {
  constructor(e, t, i, n) {
    this._editor = e, this._markerDecorationsService = t, this._openerService = i, this._languageFeaturesService = n, this.hoverOrdinal = 1, this.recentMarkerCodeActionsInfo = void 0;
  }
  computeSync(e, t) {
    if (!this._editor.hasModel() || e.type !== 1 && !e.supportsMarkerHover)
      return [];
    const i = this._editor.getModel(), n = e.range.startLineNumber, o = i.getLineMaxColumn(n), r = [];
    for (const a of t) {
      const l = a.range.startLineNumber === n ? a.range.startColumn : 1, c = a.range.endLineNumber === n ? a.range.endColumn : o, h = this._markerDecorationsService.getMarker(i.uri, a);
      if (!h)
        continue;
      const d = new T(e.range.startLineNumber, l, e.range.startLineNumber, c);
      r.push(new fte(this, d, h));
    }
    return r;
  }
  renderHoverParts(e, t) {
    if (!t.length)
      return new fp([]);
    const i = new ne(), n = [];
    t.forEach((r) => {
      const a = this._renderMarkerHover(r);
      e.fragment.appendChild(a.hoverElement), n.push(a);
    });
    const o = t.length === 1 ? t[0] : t.sort((r, a) => Bt.compare(r.marker.severity, a.marker.severity))[0];
    return this.renderMarkerStatusbar(e, o, i), new fp(n);
  }
  _renderMarkerHover(e) {
    const t = new ne(), i = Zs("div.hover-row"), n = te(i, Zs("div.marker.hover-contents")), { source: o, message: r, code: a, relatedInformation: l } = e.marker;
    this._editor.applyFontInfo(n);
    const c = te(n, Zs("span"));
    if (c.style.whiteSpace = "pre-wrap", c.innerText = r, o || a)
      if (a && typeof a != "string") {
        const d = Zs("span");
        if (o) {
          const p = te(d, Zs("span"));
          p.innerText = o;
        }
        const u = te(d, Zs("a.code-link"));
        u.setAttribute("href", a.target.toString()), t.add(z(u, "click", (p) => {
          this._openerService.open(a.target, { allowCommands: !0 }), p.preventDefault(), p.stopPropagation();
        }));
        const f = te(u, Zs("span"));
        f.innerText = a.value;
        const g = te(n, d);
        g.style.opacity = "0.6", g.style.paddingLeft = "6px";
      } else {
        const d = te(n, Zs("span"));
        d.style.opacity = "0.6", d.style.paddingLeft = "6px", d.innerText = o && a ? `${o}(${a})` : o || `(${a})`;
      }
    if (co(l))
      for (const { message: d, resource: u, startLineNumber: f, startColumn: g } of l) {
        const p = te(n, Zs("div"));
        p.style.marginTop = "8px";
        const _ = te(p, Zs("a"));
        _.innerText = `${qo(u)}(${f}, ${g}): `, _.style.cursor = "pointer", t.add(z(_, "click", (C) => {
          if (C.stopPropagation(), C.preventDefault(), this._openerService) {
            const w = { selection: { startLineNumber: f, startColumn: g } };
            this._openerService.open(u, {
              fromUserGesture: !0,
              editorOptions: w
            }).catch(Je);
          }
        }));
        const b = te(p, Zs("span"));
        b.innerText = d, this._editor.applyFontInfo(b);
      }
    return {
      hoverPart: e,
      hoverElement: i,
      dispose: () => t.dispose()
    };
  }
  renderMarkerStatusbar(e, t, i) {
    if (t.marker.severity === Bt.Error || t.marker.severity === Bt.Warning || t.marker.severity === Bt.Info) {
      const n = Qh.get(this._editor);
      n && e.statusBar.addAction({
        label: m("view problem", "View Problem"),
        commandId: cC.ID,
        run: () => {
          e.hide(), n.showAtMarker(t.marker), this._editor.focus();
        }
      });
    }
    if (!this._editor.getOption(
      92
      /* EditorOption.readOnly */
    )) {
      const n = e.statusBar.append(Zs("div"));
      this.recentMarkerCodeActionsInfo && (aC.makeKey(this.recentMarkerCodeActionsInfo.marker) === aC.makeKey(t.marker) ? this.recentMarkerCodeActionsInfo.hasCodeActions || (n.textContent = m("noQuickFixes", "No quick fixes available")) : this.recentMarkerCodeActionsInfo = void 0);
      const o = this.recentMarkerCodeActionsInfo && !this.recentMarkerCodeActionsInfo.hasCodeActions ? U.None : Kb(() => n.textContent = m("checkingForQuickFixes", "Checking for quick fixes..."), 200, i);
      n.textContent || (n.textContent = " ");
      const r = this.getCodeActions(t.marker);
      i.add(_e(() => r.cancel())), r.then((a) => {
        if (o.dispose(), this.recentMarkerCodeActionsInfo = { marker: t.marker, hasCodeActions: a.validActions.length > 0 }, !this.recentMarkerCodeActionsInfo.hasCodeActions) {
          a.dispose(), n.textContent = m("noQuickFixes", "No quick fixes available");
          return;
        }
        n.style.display = "none";
        let l = !1;
        i.add(_e(() => {
          l || a.dispose();
        })), e.statusBar.addAction({
          label: m("quick fixes", "Quick Fix..."),
          commandId: B7,
          run: (c) => {
            l = !0;
            const h = fk.get(this._editor), d = ui(c);
            e.hide(), h == null || h.showCodeActions(OR, a, {
              x: d.left,
              y: d.top,
              width: d.width,
              height: d.height
            });
          }
        });
      }, Je);
    }
  }
  getCodeActions(e) {
    return Za((t) => lu(this._languageFeaturesService.codeActionProvider, this._editor.getModel(), new T(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn), OR, Dl.None, t));
  }
};
wk = ute([
  uy(1, JE),
  uy(2, sr),
  uy(3, De)
], wk);
class gte {
  get lineNumber() {
    return this._lineNumber;
  }
  set lineNumber(e) {
    this._lineNumber = e;
  }
  get lane() {
    return this._laneOrLine;
  }
  set lane(e) {
    this._laneOrLine = e;
  }
  constructor(e) {
    this._editor = e, this._lineNumber = -1, this._laneOrLine = _o.Center;
  }
  computeSync() {
    var o;
    const e = (r) => ({
      value: r
    }), t = this._editor.getLineDecorations(this._lineNumber), i = [], n = this._laneOrLine === "lineNo";
    if (!t)
      return i;
    for (const r of t) {
      const a = ((o = r.options.glyphMargin) == null ? void 0 : o.position) ?? _o.Center;
      if (!n && a !== this._laneOrLine)
        continue;
      const l = n ? r.options.lineNumberHoverMessage : r.options.glyphMarginHoverMessage;
      !l || rf(l) || i.push(...uO(l).map(e));
    }
    return i;
  }
}
var mte = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, FR = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, yk;
const BR = he;
var Nh;
let Sk = (Nh = class extends U {
  constructor(e, t, i) {
    super(), this._renderDisposeables = this._register(new ne()), this._editor = e, this._isVisible = !1, this._messages = [], this._hover = this._register(new yN()), this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible), this._markdownRenderer = this._register(new hp({ editor: this._editor }, t, i)), this._computer = new gte(this._editor), this._hoverOperation = this._register(new g7(this._editor, this._computer)), this._register(this._hoverOperation.onResult((n) => {
      this._withResult(n.value);
    })), this._register(this._editor.onDidChangeModelDecorations(() => this._onModelDecorationsChanged())), this._register(this._editor.onDidChangeConfiguration((n) => {
      n.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) && this._updateFont();
    })), this._register(Zt(this._hover.containerDomNode, "mouseleave", (n) => {
      this._onMouseLeave(n);
    })), this._editor.addOverlayWidget(this);
  }
  dispose() {
    this._editor.removeOverlayWidget(this), super.dispose();
  }
  getId() {
    return yk.ID;
  }
  getDomNode() {
    return this._hover.containerDomNode;
  }
  getPosition() {
    return null;
  }
  _updateFont() {
    Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code")).forEach((t) => this._editor.applyFontInfo(t));
  }
  _onModelDecorationsChanged() {
    this._isVisible && (this._hoverOperation.cancel(), this._hoverOperation.start(
      0
      /* HoverStartMode.Delayed */
    ));
  }
  showsOrWillShow(e) {
    const t = e.target;
    return t.type === 2 && t.detail.glyphMarginLane ? (this._startShowingAt(t.position.lineNumber, t.detail.glyphMarginLane), !0) : t.type === 3 ? (this._startShowingAt(t.position.lineNumber, "lineNo"), !0) : !1;
  }
  _startShowingAt(e, t) {
    this._computer.lineNumber === e && this._computer.lane === t || (this._hoverOperation.cancel(), this.hide(), this._computer.lineNumber = e, this._computer.lane = t, this._hoverOperation.start(
      0
      /* HoverStartMode.Delayed */
    ));
  }
  hide() {
    this._computer.lineNumber = -1, this._hoverOperation.cancel(), this._isVisible && (this._isVisible = !1, this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible));
  }
  _withResult(e) {
    this._messages = e, this._messages.length > 0 ? this._renderMessages(this._computer.lineNumber, this._messages) : this.hide();
  }
  _renderMessages(e, t) {
    this._renderDisposeables.clear();
    const i = document.createDocumentFragment();
    for (const n of t) {
      const o = BR("div.hover-row.markdown-hover"), r = te(o, BR("div.hover-contents")), a = this._renderDisposeables.add(this._markdownRenderer.render(n.value));
      r.appendChild(a.element), i.appendChild(o);
    }
    this._updateContents(i), this._showAt(e);
  }
  _updateContents(e) {
    this._hover.contentsDomNode.textContent = "", this._hover.contentsDomNode.appendChild(e), this._updateFont();
  }
  _showAt(e) {
    this._isVisible || (this._isVisible = !0, this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible));
    const t = this._editor.getLayoutInfo(), i = this._editor.getTopForLineNumber(e), n = this._editor.getScrollTop(), o = this._editor.getOption(
      67
      /* EditorOption.lineHeight */
    ), r = this._hover.containerDomNode.clientHeight, a = i - n - (r - o) / 2, l = t.glyphMarginLeft + t.glyphMarginWidth + (this._computer.lane === "lineNo" ? t.lineNumbersWidth : 0);
    this._hover.containerDomNode.style.left = `${l}px`, this._hover.containerDomNode.style.top = `${Math.max(Math.round(a), 0)}px`;
  }
  _onMouseLeave(e) {
    const t = this._editor.getDomNode();
    (!t || !$w(t, e.x, e.y)) && this.hide();
  }
}, yk = Nh, Nh.ID = "editor.contrib.modesGlyphHoverWidget", Nh);
Sk = yk = mte([
  FR(1, ci),
  FR(2, sr)
], Sk);
var pte = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, _te = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Qu;
let hC = (Qu = class extends U {
  constructor(e, t) {
    super(), this._editor = e, this._instantiationService = t, this.shouldKeepOpenOnEditorMouseMoveOrLeave = !1, this._listenersStore = new ne(), this._hoverState = {
      mouseDown: !1
    }, this._reactToEditorMouseMoveRunner = this._register(new ai(() => this._reactToEditorMouseMove(this._mouseMoveEvent), 0)), this._hookListeners(), this._register(this._editor.onDidChangeConfiguration((i) => {
      i.hasChanged(
        60
        /* EditorOption.hover */
      ) && (this._unhookListeners(), this._hookListeners());
    }));
  }
  _hookListeners() {
    const e = this._editor.getOption(
      60
      /* EditorOption.hover */
    );
    this._hoverSettings = {
      enabled: e.enabled,
      sticky: e.sticky,
      hidingDelay: e.hidingDelay
    }, e.enabled ? (this._listenersStore.add(this._editor.onMouseDown((t) => this._onEditorMouseDown(t))), this._listenersStore.add(this._editor.onMouseUp(() => this._onEditorMouseUp())), this._listenersStore.add(this._editor.onMouseMove((t) => this._onEditorMouseMove(t))), this._listenersStore.add(this._editor.onKeyDown((t) => this._onKeyDown(t)))) : (this._listenersStore.add(this._editor.onMouseMove((t) => this._onEditorMouseMove(t))), this._listenersStore.add(this._editor.onKeyDown((t) => this._onKeyDown(t)))), this._listenersStore.add(this._editor.onMouseLeave((t) => this._onEditorMouseLeave(t))), this._listenersStore.add(this._editor.onDidChangeModel(() => {
      this._cancelScheduler(), this._hideWidgets();
    })), this._listenersStore.add(this._editor.onDidChangeModelContent(() => this._cancelScheduler())), this._listenersStore.add(this._editor.onDidScrollChange((t) => this._onEditorScrollChanged(t)));
  }
  _unhookListeners() {
    this._listenersStore.clear();
  }
  _cancelScheduler() {
    this._mouseMoveEvent = void 0, this._reactToEditorMouseMoveRunner.cancel();
  }
  _onEditorScrollChanged(e) {
    (e.scrollTopChanged || e.scrollLeftChanged) && this._hideWidgets();
  }
  _onEditorMouseDown(e) {
    this._hoverState.mouseDown = !0, !this._isMouseOnMarginHoverWidget(e) && this._hideWidgets();
  }
  _isMouseOnMarginHoverWidget(e) {
    var i;
    const t = (i = this._glyphWidget) == null ? void 0 : i.getDomNode();
    return t ? $w(t, e.event.posx, e.event.posy) : !1;
  }
  _onEditorMouseUp() {
    this._hoverState.mouseDown = !1;
  }
  _onEditorMouseLeave(e) {
    this.shouldKeepOpenOnEditorMouseMoveOrLeave || (this._cancelScheduler(), this._isMouseOnMarginHoverWidget(e)) || this._hideWidgets();
  }
  _shouldNotRecomputeCurrentHoverWidget(e) {
    const t = this._hoverSettings.sticky, i = this._isMouseOnMarginHoverWidget(e);
    return t && i;
  }
  _onEditorMouseMove(e) {
    if (this.shouldKeepOpenOnEditorMouseMoveOrLeave)
      return;
    if (this._mouseMoveEvent = e, this._shouldNotRecomputeCurrentHoverWidget(e)) {
      this._reactToEditorMouseMoveRunner.cancel();
      return;
    }
    this._reactToEditorMouseMove(e);
  }
  _reactToEditorMouseMove(e) {
    !e || this._tryShowHoverWidget(e) || this._hideWidgets();
  }
  _tryShowHoverWidget(e) {
    return this._getOrCreateGlyphWidget().showsOrWillShow(e);
  }
  _onKeyDown(e) {
    this._editor.hasModel() && (e.keyCode === 5 || e.keyCode === 6 || e.keyCode === 57 || e.keyCode === 4 || this._hideWidgets());
  }
  _hideWidgets() {
    var e;
    (e = this._glyphWidget) == null || e.hide();
  }
  _getOrCreateGlyphWidget() {
    return this._glyphWidget || (this._glyphWidget = this._instantiationService.createInstance(Sk, this._editor)), this._glyphWidget;
  }
  dispose() {
    var e;
    super.dispose(), this._unhookListeners(), this._listenersStore.dispose(), (e = this._glyphWidget) == null || e.dispose();
  }
}, Qu.ID = "editor.contrib.marginHover", Qu);
hC = pte([
  _te(1, Pe)
], hC);
const IN = new class {
  constructor() {
    this._implementations = [];
  }
  register(e) {
    return this._implementations.push(e), {
      dispose: () => {
        const t = this._implementations.indexOf(e);
        t !== -1 && this._implementations.splice(t, 1);
      }
    };
  }
  getImplementations() {
    return this._implementations;
  }
}();
class bte {
}
class Cte {
}
class vte {
}
Xa(
  vn.ID,
  vn,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
Xa(
  hC.ID,
  hC,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
Bn(_ee);
Bn(bee);
Bn(Cee);
Bn(vee);
Bn(wee);
Bn(yee);
Bn(See);
Bn(Lee);
Bn(kee);
Bn(xee);
Bn(Dee);
Bn(Eee);
wN.register(gp);
wN.register(wk);
tr((s, e) => {
  const t = s.getColor(JO);
  t && (e.addRule(`.monaco-editor .monaco-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${t.transparent(0.5)}; }`), e.addRule(`.monaco-editor .monaco-hover hr { border-top: 1px solid ${t.transparent(0.5)}; }`), e.addRule(`.monaco-editor .monaco-hover hr { border-bottom: 0px solid ${t.transparent(0.5)}; }`));
});
IN.register(new bte());
IN.register(new Cte());
IN.register(new vte());
var Lk;
(function(s) {
  s[s.Unknown = 0] = "Unknown", s[s.Disabled = 1] = "Disabled", s[s.Enabled = 2] = "Enabled";
})(Lk || (Lk = {}));
var kk;
(function(s) {
  s[s.Invoke = 1] = "Invoke", s[s.Auto = 2] = "Auto";
})(kk || (kk = {}));
var xk;
(function(s) {
  s[s.None = 0] = "None", s[s.KeepWhitespace = 1] = "KeepWhitespace", s[s.InsertAsSnippet = 4] = "InsertAsSnippet";
})(xk || (xk = {}));
var Dk;
(function(s) {
  s[s.Method = 0] = "Method", s[s.Function = 1] = "Function", s[s.Constructor = 2] = "Constructor", s[s.Field = 3] = "Field", s[s.Variable = 4] = "Variable", s[s.Class = 5] = "Class", s[s.Struct = 6] = "Struct", s[s.Interface = 7] = "Interface", s[s.Module = 8] = "Module", s[s.Property = 9] = "Property", s[s.Event = 10] = "Event", s[s.Operator = 11] = "Operator", s[s.Unit = 12] = "Unit", s[s.Value = 13] = "Value", s[s.Constant = 14] = "Constant", s[s.Enum = 15] = "Enum", s[s.EnumMember = 16] = "EnumMember", s[s.Keyword = 17] = "Keyword", s[s.Text = 18] = "Text", s[s.Color = 19] = "Color", s[s.File = 20] = "File", s[s.Reference = 21] = "Reference", s[s.Customcolor = 22] = "Customcolor", s[s.Folder = 23] = "Folder", s[s.TypeParameter = 24] = "TypeParameter", s[s.User = 25] = "User", s[s.Issue = 26] = "Issue", s[s.Snippet = 27] = "Snippet";
})(Dk || (Dk = {}));
var Ek;
(function(s) {
  s[s.Deprecated = 1] = "Deprecated";
})(Ek || (Ek = {}));
var Ik;
(function(s) {
  s[s.Invoke = 0] = "Invoke", s[s.TriggerCharacter = 1] = "TriggerCharacter", s[s.TriggerForIncompleteCompletions = 2] = "TriggerForIncompleteCompletions";
})(Ik || (Ik = {}));
var Nk;
(function(s) {
  s[s.EXACT = 0] = "EXACT", s[s.ABOVE = 1] = "ABOVE", s[s.BELOW = 2] = "BELOW";
})(Nk || (Nk = {}));
var Tk;
(function(s) {
  s[s.NotSet = 0] = "NotSet", s[s.ContentFlush = 1] = "ContentFlush", s[s.RecoverFromMarkers = 2] = "RecoverFromMarkers", s[s.Explicit = 3] = "Explicit", s[s.Paste = 4] = "Paste", s[s.Undo = 5] = "Undo", s[s.Redo = 6] = "Redo";
})(Tk || (Tk = {}));
var Mk;
(function(s) {
  s[s.LF = 1] = "LF", s[s.CRLF = 2] = "CRLF";
})(Mk || (Mk = {}));
var Rk;
(function(s) {
  s[s.Text = 0] = "Text", s[s.Read = 1] = "Read", s[s.Write = 2] = "Write";
})(Rk || (Rk = {}));
var Ak;
(function(s) {
  s[s.None = 0] = "None", s[s.Keep = 1] = "Keep", s[s.Brackets = 2] = "Brackets", s[s.Advanced = 3] = "Advanced", s[s.Full = 4] = "Full";
})(Ak || (Ak = {}));
var Pk;
(function(s) {
  s[s.acceptSuggestionOnCommitCharacter = 0] = "acceptSuggestionOnCommitCharacter", s[s.acceptSuggestionOnEnter = 1] = "acceptSuggestionOnEnter", s[s.accessibilitySupport = 2] = "accessibilitySupport", s[s.accessibilityPageSize = 3] = "accessibilityPageSize", s[s.ariaLabel = 4] = "ariaLabel", s[s.ariaRequired = 5] = "ariaRequired", s[s.autoClosingBrackets = 6] = "autoClosingBrackets", s[s.autoClosingComments = 7] = "autoClosingComments", s[s.screenReaderAnnounceInlineSuggestion = 8] = "screenReaderAnnounceInlineSuggestion", s[s.autoClosingDelete = 9] = "autoClosingDelete", s[s.autoClosingOvertype = 10] = "autoClosingOvertype", s[s.autoClosingQuotes = 11] = "autoClosingQuotes", s[s.autoIndent = 12] = "autoIndent", s[s.automaticLayout = 13] = "automaticLayout", s[s.autoSurround = 14] = "autoSurround", s[s.bracketPairColorization = 15] = "bracketPairColorization", s[s.guides = 16] = "guides", s[s.codeLens = 17] = "codeLens", s[s.codeLensFontFamily = 18] = "codeLensFontFamily", s[s.codeLensFontSize = 19] = "codeLensFontSize", s[s.colorDecorators = 20] = "colorDecorators", s[s.colorDecoratorsLimit = 21] = "colorDecoratorsLimit", s[s.columnSelection = 22] = "columnSelection", s[s.comments = 23] = "comments", s[s.contextmenu = 24] = "contextmenu", s[s.copyWithSyntaxHighlighting = 25] = "copyWithSyntaxHighlighting", s[s.cursorBlinking = 26] = "cursorBlinking", s[s.cursorSmoothCaretAnimation = 27] = "cursorSmoothCaretAnimation", s[s.cursorStyle = 28] = "cursorStyle", s[s.cursorSurroundingLines = 29] = "cursorSurroundingLines", s[s.cursorSurroundingLinesStyle = 30] = "cursorSurroundingLinesStyle", s[s.cursorWidth = 31] = "cursorWidth", s[s.disableLayerHinting = 32] = "disableLayerHinting", s[s.disableMonospaceOptimizations = 33] = "disableMonospaceOptimizations", s[s.domReadOnly = 34] = "domReadOnly", s[s.dragAndDrop = 35] = "dragAndDrop", s[s.dropIntoEditor = 36] = "dropIntoEditor", s[s.emptySelectionClipboard = 37] = "emptySelectionClipboard", s[s.experimentalWhitespaceRendering = 38] = "experimentalWhitespaceRendering", s[s.extraEditorClassName = 39] = "extraEditorClassName", s[s.fastScrollSensitivity = 40] = "fastScrollSensitivity", s[s.find = 41] = "find", s[s.fixedOverflowWidgets = 42] = "fixedOverflowWidgets", s[s.folding = 43] = "folding", s[s.foldingStrategy = 44] = "foldingStrategy", s[s.foldingHighlight = 45] = "foldingHighlight", s[s.foldingImportsByDefault = 46] = "foldingImportsByDefault", s[s.foldingMaximumRegions = 47] = "foldingMaximumRegions", s[s.unfoldOnClickAfterEndOfLine = 48] = "unfoldOnClickAfterEndOfLine", s[s.fontFamily = 49] = "fontFamily", s[s.fontInfo = 50] = "fontInfo", s[s.fontLigatures = 51] = "fontLigatures", s[s.fontSize = 52] = "fontSize", s[s.fontWeight = 53] = "fontWeight", s[s.fontVariations = 54] = "fontVariations", s[s.formatOnPaste = 55] = "formatOnPaste", s[s.formatOnType = 56] = "formatOnType", s[s.glyphMargin = 57] = "glyphMargin", s[s.gotoLocation = 58] = "gotoLocation", s[s.hideCursorInOverviewRuler = 59] = "hideCursorInOverviewRuler", s[s.hover = 60] = "hover", s[s.inDiffEditor = 61] = "inDiffEditor", s[s.inlineSuggest = 62] = "inlineSuggest", s[s.inlineEdit = 63] = "inlineEdit", s[s.letterSpacing = 64] = "letterSpacing", s[s.lightbulb = 65] = "lightbulb", s[s.lineDecorationsWidth = 66] = "lineDecorationsWidth", s[s.lineHeight = 67] = "lineHeight", s[s.lineNumbers = 68] = "lineNumbers", s[s.lineNumbersMinChars = 69] = "lineNumbersMinChars", s[s.linkedEditing = 70] = "linkedEditing", s[s.links = 71] = "links", s[s.matchBrackets = 72] = "matchBrackets", s[s.minimap = 73] = "minimap", s[s.mouseStyle = 74] = "mouseStyle", s[s.mouseWheelScrollSensitivity = 75] = "mouseWheelScrollSensitivity", s[s.mouseWheelZoom = 76] = "mouseWheelZoom", s[s.multiCursorMergeOverlapping = 77] = "multiCursorMergeOverlapping", s[s.multiCursorModifier = 78] = "multiCursorModifier", s[s.multiCursorPaste = 79] = "multiCursorPaste", s[s.multiCursorLimit = 80] = "multiCursorLimit", s[s.occurrencesHighlight = 81] = "occurrencesHighlight", s[s.overviewRulerBorder = 82] = "overviewRulerBorder", s[s.overviewRulerLanes = 83] = "overviewRulerLanes", s[s.padding = 84] = "padding", s[s.pasteAs = 85] = "pasteAs", s[s.parameterHints = 86] = "parameterHints", s[s.peekWidgetDefaultFocus = 87] = "peekWidgetDefaultFocus", s[s.placeholder = 88] = "placeholder", s[s.definitionLinkOpensInPeek = 89] = "definitionLinkOpensInPeek", s[s.quickSuggestions = 90] = "quickSuggestions", s[s.quickSuggestionsDelay = 91] = "quickSuggestionsDelay", s[s.readOnly = 92] = "readOnly", s[s.readOnlyMessage = 93] = "readOnlyMessage", s[s.renameOnType = 94] = "renameOnType", s[s.renderControlCharacters = 95] = "renderControlCharacters", s[s.renderFinalNewline = 96] = "renderFinalNewline", s[s.renderLineHighlight = 97] = "renderLineHighlight", s[s.renderLineHighlightOnlyWhenFocus = 98] = "renderLineHighlightOnlyWhenFocus", s[s.renderValidationDecorations = 99] = "renderValidationDecorations", s[s.renderWhitespace = 100] = "renderWhitespace", s[s.revealHorizontalRightPadding = 101] = "revealHorizontalRightPadding", s[s.roundedSelection = 102] = "roundedSelection", s[s.rulers = 103] = "rulers", s[s.scrollbar = 104] = "scrollbar", s[s.scrollBeyondLastColumn = 105] = "scrollBeyondLastColumn", s[s.scrollBeyondLastLine = 106] = "scrollBeyondLastLine", s[s.scrollPredominantAxis = 107] = "scrollPredominantAxis", s[s.selectionClipboard = 108] = "selectionClipboard", s[s.selectionHighlight = 109] = "selectionHighlight", s[s.selectOnLineNumbers = 110] = "selectOnLineNumbers", s[s.showFoldingControls = 111] = "showFoldingControls", s[s.showUnused = 112] = "showUnused", s[s.snippetSuggestions = 113] = "snippetSuggestions", s[s.smartSelect = 114] = "smartSelect", s[s.smoothScrolling = 115] = "smoothScrolling", s[s.stickyScroll = 116] = "stickyScroll", s[s.stickyTabStops = 117] = "stickyTabStops", s[s.stopRenderingLineAfter = 118] = "stopRenderingLineAfter", s[s.suggest = 119] = "suggest", s[s.suggestFontSize = 120] = "suggestFontSize", s[s.suggestLineHeight = 121] = "suggestLineHeight", s[s.suggestOnTriggerCharacters = 122] = "suggestOnTriggerCharacters", s[s.suggestSelection = 123] = "suggestSelection", s[s.tabCompletion = 124] = "tabCompletion", s[s.tabIndex = 125] = "tabIndex", s[s.unicodeHighlighting = 126] = "unicodeHighlighting", s[s.unusualLineTerminators = 127] = "unusualLineTerminators", s[s.useShadowDOM = 128] = "useShadowDOM", s[s.useTabStops = 129] = "useTabStops", s[s.wordBreak = 130] = "wordBreak", s[s.wordSegmenterLocales = 131] = "wordSegmenterLocales", s[s.wordSeparators = 132] = "wordSeparators", s[s.wordWrap = 133] = "wordWrap", s[s.wordWrapBreakAfterCharacters = 134] = "wordWrapBreakAfterCharacters", s[s.wordWrapBreakBeforeCharacters = 135] = "wordWrapBreakBeforeCharacters", s[s.wordWrapColumn = 136] = "wordWrapColumn", s[s.wordWrapOverride1 = 137] = "wordWrapOverride1", s[s.wordWrapOverride2 = 138] = "wordWrapOverride2", s[s.wrappingIndent = 139] = "wrappingIndent", s[s.wrappingStrategy = 140] = "wrappingStrategy", s[s.showDeprecated = 141] = "showDeprecated", s[s.inlayHints = 142] = "inlayHints", s[s.editorClassName = 143] = "editorClassName", s[s.pixelRatio = 144] = "pixelRatio", s[s.tabFocusMode = 145] = "tabFocusMode", s[s.layoutInfo = 146] = "layoutInfo", s[s.wrappingInfo = 147] = "wrappingInfo", s[s.defaultColorDecorators = 148] = "defaultColorDecorators", s[s.colorDecoratorsActivatedOn = 149] = "colorDecoratorsActivatedOn", s[s.inlineCompletionsAccessibilityVerbose = 150] = "inlineCompletionsAccessibilityVerbose";
})(Pk || (Pk = {}));
var Ok;
(function(s) {
  s[s.TextDefined = 0] = "TextDefined", s[s.LF = 1] = "LF", s[s.CRLF = 2] = "CRLF";
})(Ok || (Ok = {}));
var Fk;
(function(s) {
  s[s.LF = 0] = "LF", s[s.CRLF = 1] = "CRLF";
})(Fk || (Fk = {}));
var Bk;
(function(s) {
  s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 3] = "Right";
})(Bk || (Bk = {}));
var Wk;
(function(s) {
  s[s.Increase = 0] = "Increase", s[s.Decrease = 1] = "Decrease";
})(Wk || (Wk = {}));
var Hk;
(function(s) {
  s[s.None = 0] = "None", s[s.Indent = 1] = "Indent", s[s.IndentOutdent = 2] = "IndentOutdent", s[s.Outdent = 3] = "Outdent";
})(Hk || (Hk = {}));
var Vk;
(function(s) {
  s[s.Both = 0] = "Both", s[s.Right = 1] = "Right", s[s.Left = 2] = "Left", s[s.None = 3] = "None";
})(Vk || (Vk = {}));
var zk;
(function(s) {
  s[s.Type = 1] = "Type", s[s.Parameter = 2] = "Parameter";
})(zk || (zk = {}));
var Uk;
(function(s) {
  s[s.Automatic = 0] = "Automatic", s[s.Explicit = 1] = "Explicit";
})(Uk || (Uk = {}));
var $k;
(function(s) {
  s[s.Invoke = 0] = "Invoke", s[s.Automatic = 1] = "Automatic";
})($k || ($k = {}));
var Kk;
(function(s) {
  s[s.DependsOnKbLayout = -1] = "DependsOnKbLayout", s[s.Unknown = 0] = "Unknown", s[s.Backspace = 1] = "Backspace", s[s.Tab = 2] = "Tab", s[s.Enter = 3] = "Enter", s[s.Shift = 4] = "Shift", s[s.Ctrl = 5] = "Ctrl", s[s.Alt = 6] = "Alt", s[s.PauseBreak = 7] = "PauseBreak", s[s.CapsLock = 8] = "CapsLock", s[s.Escape = 9] = "Escape", s[s.Space = 10] = "Space", s[s.PageUp = 11] = "PageUp", s[s.PageDown = 12] = "PageDown", s[s.End = 13] = "End", s[s.Home = 14] = "Home", s[s.LeftArrow = 15] = "LeftArrow", s[s.UpArrow = 16] = "UpArrow", s[s.RightArrow = 17] = "RightArrow", s[s.DownArrow = 18] = "DownArrow", s[s.Insert = 19] = "Insert", s[s.Delete = 20] = "Delete", s[s.Digit0 = 21] = "Digit0", s[s.Digit1 = 22] = "Digit1", s[s.Digit2 = 23] = "Digit2", s[s.Digit3 = 24] = "Digit3", s[s.Digit4 = 25] = "Digit4", s[s.Digit5 = 26] = "Digit5", s[s.Digit6 = 27] = "Digit6", s[s.Digit7 = 28] = "Digit7", s[s.Digit8 = 29] = "Digit8", s[s.Digit9 = 30] = "Digit9", s[s.KeyA = 31] = "KeyA", s[s.KeyB = 32] = "KeyB", s[s.KeyC = 33] = "KeyC", s[s.KeyD = 34] = "KeyD", s[s.KeyE = 35] = "KeyE", s[s.KeyF = 36] = "KeyF", s[s.KeyG = 37] = "KeyG", s[s.KeyH = 38] = "KeyH", s[s.KeyI = 39] = "KeyI", s[s.KeyJ = 40] = "KeyJ", s[s.KeyK = 41] = "KeyK", s[s.KeyL = 42] = "KeyL", s[s.KeyM = 43] = "KeyM", s[s.KeyN = 44] = "KeyN", s[s.KeyO = 45] = "KeyO", s[s.KeyP = 46] = "KeyP", s[s.KeyQ = 47] = "KeyQ", s[s.KeyR = 48] = "KeyR", s[s.KeyS = 49] = "KeyS", s[s.KeyT = 50] = "KeyT", s[s.KeyU = 51] = "KeyU", s[s.KeyV = 52] = "KeyV", s[s.KeyW = 53] = "KeyW", s[s.KeyX = 54] = "KeyX", s[s.KeyY = 55] = "KeyY", s[s.KeyZ = 56] = "KeyZ", s[s.Meta = 57] = "Meta", s[s.ContextMenu = 58] = "ContextMenu", s[s.F1 = 59] = "F1", s[s.F2 = 60] = "F2", s[s.F3 = 61] = "F3", s[s.F4 = 62] = "F4", s[s.F5 = 63] = "F5", s[s.F6 = 64] = "F6", s[s.F7 = 65] = "F7", s[s.F8 = 66] = "F8", s[s.F9 = 67] = "F9", s[s.F10 = 68] = "F10", s[s.F11 = 69] = "F11", s[s.F12 = 70] = "F12", s[s.F13 = 71] = "F13", s[s.F14 = 72] = "F14", s[s.F15 = 73] = "F15", s[s.F16 = 74] = "F16", s[s.F17 = 75] = "F17", s[s.F18 = 76] = "F18", s[s.F19 = 77] = "F19", s[s.F20 = 78] = "F20", s[s.F21 = 79] = "F21", s[s.F22 = 80] = "F22", s[s.F23 = 81] = "F23", s[s.F24 = 82] = "F24", s[s.NumLock = 83] = "NumLock", s[s.ScrollLock = 84] = "ScrollLock", s[s.Semicolon = 85] = "Semicolon", s[s.Equal = 86] = "Equal", s[s.Comma = 87] = "Comma", s[s.Minus = 88] = "Minus", s[s.Period = 89] = "Period", s[s.Slash = 90] = "Slash", s[s.Backquote = 91] = "Backquote", s[s.BracketLeft = 92] = "BracketLeft", s[s.Backslash = 93] = "Backslash", s[s.BracketRight = 94] = "BracketRight", s[s.Quote = 95] = "Quote", s[s.OEM_8 = 96] = "OEM_8", s[s.IntlBackslash = 97] = "IntlBackslash", s[s.Numpad0 = 98] = "Numpad0", s[s.Numpad1 = 99] = "Numpad1", s[s.Numpad2 = 100] = "Numpad2", s[s.Numpad3 = 101] = "Numpad3", s[s.Numpad4 = 102] = "Numpad4", s[s.Numpad5 = 103] = "Numpad5", s[s.Numpad6 = 104] = "Numpad6", s[s.Numpad7 = 105] = "Numpad7", s[s.Numpad8 = 106] = "Numpad8", s[s.Numpad9 = 107] = "Numpad9", s[s.NumpadMultiply = 108] = "NumpadMultiply", s[s.NumpadAdd = 109] = "NumpadAdd", s[s.NUMPAD_SEPARATOR = 110] = "NUMPAD_SEPARATOR", s[s.NumpadSubtract = 111] = "NumpadSubtract", s[s.NumpadDecimal = 112] = "NumpadDecimal", s[s.NumpadDivide = 113] = "NumpadDivide", s[s.KEY_IN_COMPOSITION = 114] = "KEY_IN_COMPOSITION", s[s.ABNT_C1 = 115] = "ABNT_C1", s[s.ABNT_C2 = 116] = "ABNT_C2", s[s.AudioVolumeMute = 117] = "AudioVolumeMute", s[s.AudioVolumeUp = 118] = "AudioVolumeUp", s[s.AudioVolumeDown = 119] = "AudioVolumeDown", s[s.BrowserSearch = 120] = "BrowserSearch", s[s.BrowserHome = 121] = "BrowserHome", s[s.BrowserBack = 122] = "BrowserBack", s[s.BrowserForward = 123] = "BrowserForward", s[s.MediaTrackNext = 124] = "MediaTrackNext", s[s.MediaTrackPrevious = 125] = "MediaTrackPrevious", s[s.MediaStop = 126] = "MediaStop", s[s.MediaPlayPause = 127] = "MediaPlayPause", s[s.LaunchMediaPlayer = 128] = "LaunchMediaPlayer", s[s.LaunchMail = 129] = "LaunchMail", s[s.LaunchApp2 = 130] = "LaunchApp2", s[s.Clear = 131] = "Clear", s[s.MAX_VALUE = 132] = "MAX_VALUE";
})(Kk || (Kk = {}));
var jk;
(function(s) {
  s[s.Hint = 1] = "Hint", s[s.Info = 2] = "Info", s[s.Warning = 4] = "Warning", s[s.Error = 8] = "Error";
})(jk || (jk = {}));
var qk;
(function(s) {
  s[s.Unnecessary = 1] = "Unnecessary", s[s.Deprecated = 2] = "Deprecated";
})(qk || (qk = {}));
var Gk;
(function(s) {
  s[s.Inline = 1] = "Inline", s[s.Gutter = 2] = "Gutter";
})(Gk || (Gk = {}));
var Zk;
(function(s) {
  s[s.Normal = 1] = "Normal", s[s.Underlined = 2] = "Underlined";
})(Zk || (Zk = {}));
var Yk;
(function(s) {
  s[s.UNKNOWN = 0] = "UNKNOWN", s[s.TEXTAREA = 1] = "TEXTAREA", s[s.GUTTER_GLYPH_MARGIN = 2] = "GUTTER_GLYPH_MARGIN", s[s.GUTTER_LINE_NUMBERS = 3] = "GUTTER_LINE_NUMBERS", s[s.GUTTER_LINE_DECORATIONS = 4] = "GUTTER_LINE_DECORATIONS", s[s.GUTTER_VIEW_ZONE = 5] = "GUTTER_VIEW_ZONE", s[s.CONTENT_TEXT = 6] = "CONTENT_TEXT", s[s.CONTENT_EMPTY = 7] = "CONTENT_EMPTY", s[s.CONTENT_VIEW_ZONE = 8] = "CONTENT_VIEW_ZONE", s[s.CONTENT_WIDGET = 9] = "CONTENT_WIDGET", s[s.OVERVIEW_RULER = 10] = "OVERVIEW_RULER", s[s.SCROLLBAR = 11] = "SCROLLBAR", s[s.OVERLAY_WIDGET = 12] = "OVERLAY_WIDGET", s[s.OUTSIDE_EDITOR = 13] = "OUTSIDE_EDITOR";
})(Yk || (Yk = {}));
var Xk;
(function(s) {
  s[s.AIGenerated = 1] = "AIGenerated";
})(Xk || (Xk = {}));
var Qk;
(function(s) {
  s[s.Invoke = 0] = "Invoke", s[s.Automatic = 1] = "Automatic";
})(Qk || (Qk = {}));
var Jk;
(function(s) {
  s[s.TOP_RIGHT_CORNER = 0] = "TOP_RIGHT_CORNER", s[s.BOTTOM_RIGHT_CORNER = 1] = "BOTTOM_RIGHT_CORNER", s[s.TOP_CENTER = 2] = "TOP_CENTER";
})(Jk || (Jk = {}));
var ex;
(function(s) {
  s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 4] = "Right", s[s.Full = 7] = "Full";
})(ex || (ex = {}));
var tx;
(function(s) {
  s[s.Word = 0] = "Word", s[s.Line = 1] = "Line", s[s.Suggest = 2] = "Suggest";
})(tx || (tx = {}));
var ix;
(function(s) {
  s[s.Left = 0] = "Left", s[s.Right = 1] = "Right", s[s.None = 2] = "None", s[s.LeftOfInjectedText = 3] = "LeftOfInjectedText", s[s.RightOfInjectedText = 4] = "RightOfInjectedText";
})(ix || (ix = {}));
var nx;
(function(s) {
  s[s.Off = 0] = "Off", s[s.On = 1] = "On", s[s.Relative = 2] = "Relative", s[s.Interval = 3] = "Interval", s[s.Custom = 4] = "Custom";
})(nx || (nx = {}));
var sx;
(function(s) {
  s[s.None = 0] = "None", s[s.Text = 1] = "Text", s[s.Blocks = 2] = "Blocks";
})(sx || (sx = {}));
var ox;
(function(s) {
  s[s.Smooth = 0] = "Smooth", s[s.Immediate = 1] = "Immediate";
})(ox || (ox = {}));
var rx;
(function(s) {
  s[s.Auto = 1] = "Auto", s[s.Hidden = 2] = "Hidden", s[s.Visible = 3] = "Visible";
})(rx || (rx = {}));
var ax;
(function(s) {
  s[s.LTR = 0] = "LTR", s[s.RTL = 1] = "RTL";
})(ax || (ax = {}));
var lx;
(function(s) {
  s.Off = "off", s.OnCode = "onCode", s.On = "on";
})(lx || (lx = {}));
var cx;
(function(s) {
  s[s.Invoke = 1] = "Invoke", s[s.TriggerCharacter = 2] = "TriggerCharacter", s[s.ContentChange = 3] = "ContentChange";
})(cx || (cx = {}));
var hx;
(function(s) {
  s[s.File = 0] = "File", s[s.Module = 1] = "Module", s[s.Namespace = 2] = "Namespace", s[s.Package = 3] = "Package", s[s.Class = 4] = "Class", s[s.Method = 5] = "Method", s[s.Property = 6] = "Property", s[s.Field = 7] = "Field", s[s.Constructor = 8] = "Constructor", s[s.Enum = 9] = "Enum", s[s.Interface = 10] = "Interface", s[s.Function = 11] = "Function", s[s.Variable = 12] = "Variable", s[s.Constant = 13] = "Constant", s[s.String = 14] = "String", s[s.Number = 15] = "Number", s[s.Boolean = 16] = "Boolean", s[s.Array = 17] = "Array", s[s.Object = 18] = "Object", s[s.Key = 19] = "Key", s[s.Null = 20] = "Null", s[s.EnumMember = 21] = "EnumMember", s[s.Struct = 22] = "Struct", s[s.Event = 23] = "Event", s[s.Operator = 24] = "Operator", s[s.TypeParameter = 25] = "TypeParameter";
})(hx || (hx = {}));
var dx;
(function(s) {
  s[s.Deprecated = 1] = "Deprecated";
})(dx || (dx = {}));
var ux;
(function(s) {
  s[s.Hidden = 0] = "Hidden", s[s.Blink = 1] = "Blink", s[s.Smooth = 2] = "Smooth", s[s.Phase = 3] = "Phase", s[s.Expand = 4] = "Expand", s[s.Solid = 5] = "Solid";
})(ux || (ux = {}));
var fx;
(function(s) {
  s[s.Line = 1] = "Line", s[s.Block = 2] = "Block", s[s.Underline = 3] = "Underline", s[s.LineThin = 4] = "LineThin", s[s.BlockOutline = 5] = "BlockOutline", s[s.UnderlineThin = 6] = "UnderlineThin";
})(fx || (fx = {}));
var gx;
(function(s) {
  s[s.AlwaysGrowsWhenTypingAtEdges = 0] = "AlwaysGrowsWhenTypingAtEdges", s[s.NeverGrowsWhenTypingAtEdges = 1] = "NeverGrowsWhenTypingAtEdges", s[s.GrowsOnlyWhenTypingBefore = 2] = "GrowsOnlyWhenTypingBefore", s[s.GrowsOnlyWhenTypingAfter = 3] = "GrowsOnlyWhenTypingAfter";
})(gx || (gx = {}));
var mx;
(function(s) {
  s[s.None = 0] = "None", s[s.Same = 1] = "Same", s[s.Indent = 2] = "Indent", s[s.DeepIndent = 3] = "DeepIndent";
})(mx || (mx = {}));
const xu = class xu {
  static chord(e, t) {
    return ym(e, t);
  }
};
xu.CtrlCmd = 2048, xu.Shift = 1024, xu.Alt = 512, xu.WinCtrl = 256;
let px = xu;
function G7() {
  return {
    editor: void 0,
    // undefined override expected here
    languages: void 0,
    // undefined override expected here
    CancellationTokenSource: Vs,
    Emitter: A,
    KeyCode: Kk,
    KeyMod: px,
    Position: F,
    Range: T,
    Selection: Ue,
    SelectionDirection: ax,
    MarkerSeverity: jk,
    MarkerTag: qk,
    Uri: we,
    Token: Km
  };
}
const WR = "default", wte = "$initialize";
let HR = !1;
function _x(s) {
  Ef && (HR || (HR = !0, console.warn("Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq")), console.warn(s.message));
}
class yte {
  constructor(e, t, i, n, o) {
    this.vsWorker = e, this.req = t, this.channel = i, this.method = n, this.args = o, this.type = 0;
  }
}
class VR {
  constructor(e, t, i, n) {
    this.vsWorker = e, this.seq = t, this.res = i, this.err = n, this.type = 1;
  }
}
class Ste {
  constructor(e, t, i, n, o) {
    this.vsWorker = e, this.req = t, this.channel = i, this.eventName = n, this.arg = o, this.type = 2;
  }
}
class Lte {
  constructor(e, t, i) {
    this.vsWorker = e, this.req = t, this.event = i, this.type = 3;
  }
}
class kte {
  constructor(e, t) {
    this.vsWorker = e, this.req = t, this.type = 4;
  }
}
class xte {
  constructor(e) {
    this._workerId = -1, this._handler = e, this._lastSentReq = 0, this._pendingReplies = /* @__PURE__ */ Object.create(null), this._pendingEmitters = /* @__PURE__ */ new Map(), this._pendingEvents = /* @__PURE__ */ new Map();
  }
  setWorkerId(e) {
    this._workerId = e;
  }
  sendMessage(e, t, i) {
    const n = String(++this._lastSentReq);
    return new Promise((o, r) => {
      this._pendingReplies[n] = {
        resolve: o,
        reject: r
      }, this._send(new yte(this._workerId, n, e, t, i));
    });
  }
  listen(e, t, i) {
    let n = null;
    const o = new A({
      onWillAddFirstListener: () => {
        n = String(++this._lastSentReq), this._pendingEmitters.set(n, o), this._send(new Ste(this._workerId, n, e, t, i));
      },
      onDidRemoveLastListener: () => {
        this._pendingEmitters.delete(n), this._send(new kte(this._workerId, n)), n = null;
      }
    });
    return o.event;
  }
  handleMessage(e) {
    !e || !e.vsWorker || this._workerId !== -1 && e.vsWorker !== this._workerId || this._handleMessage(e);
  }
  createProxyToRemoteChannel(e, t) {
    const i = {
      get: (n, o) => (typeof o == "string" && !n[o] && (Y7(o) ? n[o] = (r) => this.listen(e, o, r) : Z7(o) ? n[o] = this.listen(e, o, void 0) : o.charCodeAt(0) === 36 && (n[o] = async (...r) => (await (t == null ? void 0 : t()), this.sendMessage(e, o, r)))), n[o])
    };
    return new Proxy(/* @__PURE__ */ Object.create(null), i);
  }
  _handleMessage(e) {
    switch (e.type) {
      case 1:
        return this._handleReplyMessage(e);
      case 0:
        return this._handleRequestMessage(e);
      case 2:
        return this._handleSubscribeEventMessage(e);
      case 3:
        return this._handleEventMessage(e);
      case 4:
        return this._handleUnsubscribeEventMessage(e);
    }
  }
  _handleReplyMessage(e) {
    if (!this._pendingReplies[e.seq]) {
      console.warn("Got reply to unknown seq");
      return;
    }
    const t = this._pendingReplies[e.seq];
    if (delete this._pendingReplies[e.seq], e.err) {
      let i = e.err;
      e.err.$isError && (i = new Error(), i.name = e.err.name, i.message = e.err.message, i.stack = e.err.stack), t.reject(i);
      return;
    }
    t.resolve(e.res);
  }
  _handleRequestMessage(e) {
    const t = e.req;
    this._handler.handleMessage(e.channel, e.method, e.args).then((n) => {
      this._send(new VR(this._workerId, t, n, void 0));
    }, (n) => {
      n.detail instanceof Error && (n.detail = h2(n.detail)), this._send(new VR(this._workerId, t, void 0, h2(n)));
    });
  }
  _handleSubscribeEventMessage(e) {
    const t = e.req, i = this._handler.handleEvent(e.channel, e.eventName, e.arg)((n) => {
      this._send(new Lte(this._workerId, t, n));
    });
    this._pendingEvents.set(t, i);
  }
  _handleEventMessage(e) {
    if (!this._pendingEmitters.has(e.req)) {
      console.warn("Got event for unknown req");
      return;
    }
    this._pendingEmitters.get(e.req).fire(e.event);
  }
  _handleUnsubscribeEventMessage(e) {
    if (!this._pendingEvents.has(e.req)) {
      console.warn("Got unsubscribe for unknown req");
      return;
    }
    this._pendingEvents.get(e.req).dispose(), this._pendingEvents.delete(e.req);
  }
  _send(e) {
    const t = [];
    if (e.type === 0)
      for (let i = 0; i < e.args.length; i++)
        e.args[i] instanceof ArrayBuffer && t.push(e.args[i]);
    else e.type === 1 && e.res instanceof ArrayBuffer && t.push(e.res);
    this._handler.sendMessage(e, t);
  }
}
class Dte extends U {
  constructor(e, t) {
    super(), this._localChannels = /* @__PURE__ */ new Map(), this._worker = this._register(e.create({
      amdModuleId: "vs/base/common/worker/simpleWorker",
      esmModuleLocation: t.esmModuleLocation,
      label: t.label
    }, (o) => {
      this._protocol.handleMessage(o);
    }, (o) => {
      Je(o);
    })), this._protocol = new xte({
      sendMessage: (o, r) => {
        this._worker.postMessage(o, r);
      },
      handleMessage: (o, r, a) => this._handleMessage(o, r, a),
      handleEvent: (o, r, a) => this._handleEvent(o, r, a)
    }), this._protocol.setWorkerId(this._worker.getId());
    let i = null;
    const n = globalThis.require;
    typeof n < "u" && typeof n.getConfig == "function" ? i = n.getConfig() : typeof globalThis.requirejs < "u" && (i = globalThis.requirejs.s.contexts._.config), this._onModuleLoaded = this._protocol.sendMessage(WR, wte, [
      this._worker.getId(),
      JSON.parse(JSON.stringify(i)),
      t.amdModuleId
    ]), this.proxy = this._protocol.createProxyToRemoteChannel(WR, async () => {
      await this._onModuleLoaded;
    }), this._onModuleLoaded.catch((o) => {
      this._onError("Worker failed to load " + t.amdModuleId, o);
    });
  }
  _handleMessage(e, t, i) {
    const n = this._localChannels.get(e);
    if (!n)
      return Promise.reject(new Error(`Missing channel ${e} on main thread`));
    if (typeof n[t] != "function")
      return Promise.reject(new Error(`Missing method ${t} on main thread channel ${e}`));
    try {
      return Promise.resolve(n[t].apply(n, i));
    } catch (o) {
      return Promise.reject(o);
    }
  }
  _handleEvent(e, t, i) {
    const n = this._localChannels.get(e);
    if (!n)
      throw new Error(`Missing channel ${e} on main thread`);
    if (Y7(t)) {
      const o = n[t].call(n, i);
      if (typeof o != "function")
        throw new Error(`Missing dynamic event ${t} on main thread channel ${e}.`);
      return o;
    }
    if (Z7(t)) {
      const o = n[t];
      if (typeof o != "function")
        throw new Error(`Missing event ${t} on main thread channel ${e}.`);
      return o;
    }
    throw new Error(`Malformed event name ${t}`);
  }
  setChannel(e, t) {
    this._localChannels.set(e, t);
  }
  _onError(e, t) {
    console.error(e), console.info(t);
  }
}
function Z7(s) {
  return s[0] === "o" && s[1] === "n" && dl(s.charCodeAt(2));
}
function Y7(s) {
  return /^onDynamic/.test(s) && dl(s.charCodeAt(9));
}
let cu;
typeof self == "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope" && globalThis.workerttPolicy !== void 0 ? cu = globalThis.workerttPolicy : cu = ud("defaultWorkerFactory", { createScriptURL: (s) => s });
function Ete(s, e) {
  const t = globalThis.MonacoEnvironment;
  if (t) {
    if (typeof t.getWorker == "function")
      return t.getWorker("workerMain.js", e);
    if (typeof t.getWorkerUrl == "function") {
      const i = t.getWorkerUrl("workerMain.js", e);
      return new Worker(cu ? cu.createScriptURL(i) : i, { name: e, type: "module" });
    }
  }
  if (s) {
    const i = Ite(e, s.toString(!0)), n = new Worker(cu ? cu.createScriptURL(i) : i, { name: e, type: "module" });
    return Nte(n);
  }
  throw new Error("You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker");
}
function Ite(s, e, t) {
  if (!(/^((http:)|(https:)|(file:)|(vscode-file:))/.test(e) && e.substring(0, globalThis.origin.length) !== globalThis.origin)) {
    const o = e.lastIndexOf("?"), r = e.lastIndexOf("#", o), a = o > 0 ? new URLSearchParams(e.substring(o + 1, ~r ? r : void 0)) : new URLSearchParams();
    Xy.addSearchParam(a, !0, !0), a.toString() ? e = `${e}?${a.toString()}#${s}` : e = `${e}#${s}`;
  }
  const n = new Blob([Rf([
    `/*${s}*/`,
    void 0,
    `globalThis._VSCODE_NLS_MESSAGES = ${JSON.stringify(WP())};`,
    `globalThis._VSCODE_NLS_LANGUAGE = ${JSON.stringify(eE())};`,
    `globalThis._VSCODE_FILE_ROOT = '${globalThis._VSCODE_FILE_ROOT}';`,
    "const ttPolicy = globalThis.trustedTypes?.createPolicy('defaultWorkerFactory', { createScriptURL: value => value });",
    "globalThis.workerttPolicy = ttPolicy;",
    `await import(ttPolicy?.createScriptURL('${e}') ?? '${e}');`,
    "globalThis.postMessage({ type: 'vscode-worker-ready' });",
    // in ESM signal we are ready after the async import
    `/*${s}*/`
  ]).join("")], { type: "application/javascript" });
  return URL.createObjectURL(n);
}
function Nte(s) {
  return new Promise((e, t) => {
    s.onmessage = function(i) {
      i.data.type === "vscode-worker-ready" && (s.onmessage = null, e(s));
    }, s.onerror = t;
  });
}
function Tte(s) {
  return typeof s.then == "function";
}
class Mte extends U {
  constructor(e, t, i, n, o, r) {
    super(), this.id = i, this.label = n;
    const a = Ete(e, n);
    Tte(a) ? this.worker = a : this.worker = Promise.resolve(a), this.postMessage(t, []), this.worker.then((l) => {
      l.onmessage = function(c) {
        o(c.data);
      }, l.onmessageerror = r, typeof l.addEventListener == "function" && l.addEventListener("error", r);
    }), this._register(_e(() => {
      var l;
      (l = this.worker) == null || l.then((c) => {
        c.onmessage = null, c.onmessageerror = null, c.removeEventListener("error", r), c.terminate();
      }), this.worker = null;
    }));
  }
  getId() {
    return this.id;
  }
  postMessage(e, t) {
    var i;
    (i = this.worker) == null || i.then((n) => {
      try {
        n.postMessage(e, t);
      } catch (o) {
        Je(o), Je(new Error(`FAILED to post message to '${this.label}'-worker`, { cause: o }));
      }
    });
  }
}
class Rte {
  constructor(e, t) {
    this.amdModuleId = e, this.label = t, this.esmModuleLocation = Yv.asBrowserUri(`${e}.esm.js`);
  }
}
const bv = class bv {
  constructor() {
    this._webWorkerFailedBeforeError = !1;
  }
  create(e, t, i) {
    const n = ++bv.LAST_WORKER_ID;
    if (this._webWorkerFailedBeforeError)
      throw this._webWorkerFailedBeforeError;
    return new Mte(e.esmModuleLocation, e.amdModuleId, n, e.label || "anonymous" + n, t, (o) => {
      _x(o), this._webWorkerFailedBeforeError = o, i(o);
    });
  }
};
bv.LAST_WORKER_ID = 0;
let bx = bv;
function Ate(s, e) {
  const t = typeof s == "string" ? new Rte(s, e) : s;
  return new Dte(new bx(), t);
}
class Pte {
  constructor(e, t, i) {
    const n = new Uint8Array(e * t);
    for (let o = 0, r = e * t; o < r; o++)
      n[o] = i;
    this._data = n, this.rows = e, this.cols = t;
  }
  get(e, t) {
    return this._data[e * this.cols + t];
  }
  set(e, t, i) {
    this._data[e * this.cols + t] = i;
  }
}
class Ote {
  constructor(e) {
    let t = 0, i = 0;
    for (let o = 0, r = e.length; o < r; o++) {
      const [a, l, c] = e[o];
      l > t && (t = l), a > i && (i = a), c > i && (i = c);
    }
    t++, i++;
    const n = new Pte(
      i,
      t,
      0
      /* State.Invalid */
    );
    for (let o = 0, r = e.length; o < r; o++) {
      const [a, l, c] = e[o];
      n.set(a, l, c);
    }
    this._states = n, this._maxCharCode = t;
  }
  nextState(e, t) {
    return t < 0 || t >= this._maxCharCode ? 0 : this._states.get(e, t);
  }
}
let fy = null;
function Fte() {
  return fy === null && (fy = new Ote([
    [
      1,
      104,
      2
      /* State.H */
    ],
    [
      1,
      72,
      2
      /* State.H */
    ],
    [
      1,
      102,
      6
      /* State.F */
    ],
    [
      1,
      70,
      6
      /* State.F */
    ],
    [
      2,
      116,
      3
      /* State.HT */
    ],
    [
      2,
      84,
      3
      /* State.HT */
    ],
    [
      3,
      116,
      4
      /* State.HTT */
    ],
    [
      3,
      84,
      4
      /* State.HTT */
    ],
    [
      4,
      112,
      5
      /* State.HTTP */
    ],
    [
      4,
      80,
      5
      /* State.HTTP */
    ],
    [
      5,
      115,
      9
      /* State.BeforeColon */
    ],
    [
      5,
      83,
      9
      /* State.BeforeColon */
    ],
    [
      5,
      58,
      10
      /* State.AfterColon */
    ],
    [
      6,
      105,
      7
      /* State.FI */
    ],
    [
      6,
      73,
      7
      /* State.FI */
    ],
    [
      7,
      108,
      8
      /* State.FIL */
    ],
    [
      7,
      76,
      8
      /* State.FIL */
    ],
    [
      8,
      101,
      9
      /* State.BeforeColon */
    ],
    [
      8,
      69,
      9
      /* State.BeforeColon */
    ],
    [
      9,
      58,
      10
      /* State.AfterColon */
    ],
    [
      10,
      47,
      11
      /* State.AlmostThere */
    ],
    [
      11,
      47,
      12
      /* State.End */
    ]
  ])), fy;
}
let ag = null;
function Bte() {
  if (ag === null) {
    ag = new Hp(
      0
      /* CharacterClass.None */
    );
    const s = ` 	<>'"、。｡､，．：；‘〈「『〔（［｛｢｣｝］）〕』」〉’｀～…`;
    for (let t = 0; t < s.length; t++)
      ag.set(
        s.charCodeAt(t),
        1
        /* CharacterClass.ForceTermination */
      );
    const e = ".,;:";
    for (let t = 0; t < e.length; t++)
      ag.set(
        e.charCodeAt(t),
        2
        /* CharacterClass.CannotEndIn */
      );
  }
  return ag;
}
class dC {
  static _createLink(e, t, i, n, o) {
    let r = o - 1;
    do {
      const a = t.charCodeAt(r);
      if (e.get(a) !== 2)
        break;
      r--;
    } while (r > n);
    if (n > 0) {
      const a = t.charCodeAt(n - 1), l = t.charCodeAt(r);
      (a === 40 && l === 41 || a === 91 && l === 93 || a === 123 && l === 125) && r--;
    }
    return {
      range: {
        startLineNumber: i,
        startColumn: n + 1,
        endLineNumber: i,
        endColumn: r + 2
      },
      url: t.substring(n, r + 1)
    };
  }
  static computeLinks(e, t = Fte()) {
    const i = Bte(), n = [];
    for (let o = 1, r = e.getLineCount(); o <= r; o++) {
      const a = e.getLineContent(o), l = a.length;
      let c = 0, h = 0, d = 0, u = 1, f = !1, g = !1, p = !1, _ = !1;
      for (; c < l; ) {
        let b = !1;
        const C = a.charCodeAt(c);
        if (u === 13) {
          let w;
          switch (C) {
            case 40:
              f = !0, w = 0;
              break;
            case 41:
              w = f ? 0 : 1;
              break;
            case 91:
              p = !0, g = !0, w = 0;
              break;
            case 93:
              p = !1, w = g ? 0 : 1;
              break;
            case 123:
              _ = !0, w = 0;
              break;
            case 125:
              w = _ ? 0 : 1;
              break;
            // The following three rules make it that ' or " or ` are allowed inside links
            // only if the link is wrapped by some other quote character
            case 39:
            case 34:
            case 96:
              d === C ? w = 1 : d === 39 || d === 34 || d === 96 ? w = 0 : w = 1;
              break;
            case 42:
              w = d === 42 ? 1 : 0;
              break;
            case 124:
              w = d === 124 ? 1 : 0;
              break;
            case 32:
              w = p ? 0 : 1;
              break;
            default:
              w = i.get(C);
          }
          w === 1 && (n.push(dC._createLink(i, a, o, h, c)), b = !0);
        } else if (u === 12) {
          let w;
          C === 91 ? (g = !0, w = 0) : w = i.get(C), w === 1 ? b = !0 : u = 13;
        } else
          u = t.nextState(u, C), u === 0 && (b = !0);
        b && (u = 1, f = !1, g = !1, _ = !1, h = c + 1, d = C), c++;
      }
      u === 13 && n.push(dC._createLink(i, a, o, h, l));
    }
    return n;
  }
}
function Wte(s) {
  return !s || typeof s.getLineCount != "function" || typeof s.getLineContent != "function" ? [] : dC.computeLinks(s);
}
const Cv = class Cv {
  constructor() {
    this._defaultValueSet = [
      ["true", "false"],
      ["True", "False"],
      ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
      ["public", "protected", "private"]
    ];
  }
  navigateValueSet(e, t, i, n, o) {
    if (e && t) {
      const r = this.doNavigateValueSet(t, o);
      if (r)
        return {
          range: e,
          value: r
        };
    }
    if (i && n) {
      const r = this.doNavigateValueSet(n, o);
      if (r)
        return {
          range: i,
          value: r
        };
    }
    return null;
  }
  doNavigateValueSet(e, t) {
    const i = this.numberReplace(e, t);
    return i !== null ? i : this.textReplace(e, t);
  }
  numberReplace(e, t) {
    const i = Math.pow(10, e.length - (e.lastIndexOf(".") + 1));
    let n = Number(e);
    const o = parseFloat(e);
    return !isNaN(n) && !isNaN(o) && n === o ? n === 0 && !t ? null : (n = Math.floor(n * i), n += t ? i : -i, String(n / i)) : null;
  }
  textReplace(e, t) {
    return this.valueSetsReplace(this._defaultValueSet, e, t);
  }
  valueSetsReplace(e, t, i) {
    let n = null;
    for (let o = 0, r = e.length; n === null && o < r; o++)
      n = this.valueSetReplace(e[o], t, i);
    return n;
  }
  valueSetReplace(e, t, i) {
    let n = e.indexOf(t);
    return n >= 0 ? (n += i ? 1 : -1, n < 0 ? n = e.length - 1 : n %= e.length, e[n]) : null;
  }
};
Cv.INSTANCE = new Cv();
let Cx = Cv;
const fm = class fm {
  static getChannel(e) {
    return e.getChannel(fm.CHANNEL_NAME);
  }
  static setChannel(e, t) {
    e.setChannel(fm.CHANNEL_NAME, t);
  }
};
fm.CHANNEL_NAME = "editorWorkerHost";
let vx = fm;
class Hte {
  static computeUnicodeHighlights(e, t, i) {
    const n = i ? i.startLineNumber : 1, o = i ? i.endLineNumber : e.getLineCount(), r = new zR(t), a = r.getCandidateCodePoints();
    let l;
    a === "allNonBasicAscii" ? l = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g") : l = new RegExp(`${Vte(Array.from(a))}`, "g");
    const c = new ou(null, l), h = [];
    let d = !1, u, f = 0, g = 0, p = 0;
    e: for (let _ = n, b = o; _ <= b; _++) {
      const C = e.getLineContent(_), w = C.length;
      c.reset(0);
      do
        if (u = c.next(C), u) {
          let v = u.index, S = u.index + u[0].length;
          if (v > 0) {
            const I = C.charCodeAt(v - 1);
            Si(I) && v--;
          }
          if (S + 1 < w) {
            const I = C.charCodeAt(S - 1);
            Si(I) && S++;
          }
          const L = C.substring(v, S);
          let k = Fm(v + 1, tI, C, 0);
          k && k.endColumn <= v + 1 && (k = null);
          const x = r.shouldHighlightNonBasicASCII(L, k ? k.word : null);
          if (x !== 0) {
            if (x === 3 ? f++ : x === 2 ? g++ : x === 1 ? p++ : _E(), h.length >= 1e3) {
              d = !0;
              break e;
            }
            h.push(new T(_, v + 1, _, S + 1));
          }
        }
      while (u);
    }
    return {
      ranges: h,
      hasMore: d,
      ambiguousCharacterCount: f,
      invisibleCharacterCount: g,
      nonBasicAsciiCharacterCount: p
    };
  }
  static computeUnicodeHighlightReason(e, t) {
    const i = new zR(t);
    switch (i.shouldHighlightNonBasicASCII(e, null)) {
      case 0:
        return null;
      case 2:
        return {
          kind: 1
          /* UnicodeHighlighterReasonKind.Invisible */
        };
      case 3: {
        const o = e.codePointAt(0), r = i.ambiguousCharacters.getPrimaryConfusable(o), a = xm.getLocales().filter((l) => !xm.getInstance(/* @__PURE__ */ new Set([...t.allowedLocales, l])).isAmbiguous(o));
        return { kind: 0, confusableWith: String.fromCodePoint(r), notAmbiguousInLocales: a };
      }
      case 1:
        return {
          kind: 2
          /* UnicodeHighlighterReasonKind.NonBasicAscii */
        };
    }
  }
}
function Vte(s, e) {
  return `[${za(s.map((i) => String.fromCodePoint(i)).join(""))}]`;
}
class zR {
  constructor(e) {
    this.options = e, this.allowedCodePoints = new Set(e.allowedCodePoints), this.ambiguousCharacters = xm.getInstance(new Set(e.allowedLocales));
  }
  getCandidateCodePoints() {
    if (this.options.nonBasicASCII)
      return "allNonBasicAscii";
    const e = /* @__PURE__ */ new Set();
    if (this.options.invisibleCharacters)
      for (const t of Tg.codePoints)
        UR(String.fromCodePoint(t)) || e.add(t);
    if (this.options.ambiguousCharacters)
      for (const t of this.ambiguousCharacters.getConfusableCodePoints())
        e.add(t);
    for (const t of this.allowedCodePoints)
      e.delete(t);
    return e;
  }
  shouldHighlightNonBasicASCII(e, t) {
    const i = e.codePointAt(0);
    if (this.allowedCodePoints.has(i))
      return 0;
    if (this.options.nonBasicASCII)
      return 1;
    let n = !1, o = !1;
    if (t)
      for (const r of t) {
        const a = r.codePointAt(0), l = fE(r);
        n = n || l, !l && !this.ambiguousCharacters.isAmbiguous(a) && !Tg.isInvisibleCharacter(a) && (o = !0);
      }
    return (
      /* Don't allow mixing weird looking characters with ASCII */
      !n && /* Is there an obviously weird looking character? */
      o ? 0 : this.options.invisibleCharacters && !UR(e) && Tg.isInvisibleCharacter(i) ? 2 : this.options.ambiguousCharacters && this.ambiguousCharacters.isAmbiguous(i) ? 3 : 0
    );
  }
}
function UR(s) {
  return s === " " || s === `
` || s === "	";
}
class Sb {
  constructor(e, t, i) {
    this.changes = e, this.moves = t, this.hitTimeout = i;
  }
}
class X7 {
  constructor(e, t) {
    this.lineRangeMapping = e, this.changes = t;
  }
}
class zte {
  constructor(e) {
    this.text = e, this.lineStartOffsetByLineIdx = [], this.lineStartOffsetByLineIdx.push(0);
    for (let t = 0; t < e.length; t++)
      e.charAt(t) === `
` && this.lineStartOffsetByLineIdx.push(t + 1);
  }
  getOffset(e) {
    return this.lineStartOffsetByLineIdx[e.lineNumber - 1] + e.column - 1;
  }
  getOffsetRange(e) {
    return new Ne(this.getOffset(e.getStartPosition()), this.getOffset(e.getEndPosition()));
  }
  get textLength() {
    const e = this.lineStartOffsetByLineIdx.length - 1;
    return new Xl(e, this.text.length - this.lineStartOffsetByLineIdx[e]);
  }
}
class Ute {
  constructor(e) {
    this.edits = e, Wh(() => bE(e, (t, i) => t.range.getEndPosition().isBeforeOrEqual(i.range.getStartPosition())));
  }
  apply(e) {
    let t = "", i = new F(1, 1);
    for (const o of this.edits) {
      const r = o.range, a = r.getStartPosition(), l = r.getEndPosition(), c = $R(i, a);
      c.isEmpty() || (t += e.getValueOfRange(c)), t += o.text, i = l;
    }
    const n = $R(i, e.endPositionExclusive);
    return n.isEmpty() || (t += e.getValueOfRange(n)), t;
  }
  applyToString(e) {
    const t = new Kte(e);
    return this.apply(t);
  }
  getNewRanges() {
    const e = [];
    let t = 0, i = 0, n = 0;
    for (const o of this.edits) {
      const r = Xl.ofText(o.text), a = F.lift({
        lineNumber: o.range.startLineNumber + i,
        column: o.range.startColumn + (o.range.startLineNumber === t ? n : 0)
      }), l = r.createRange(a);
      e.push(l), i = l.endLineNumber - o.range.endLineNumber, n = l.endColumn - o.range.endColumn, t = o.range.endLineNumber;
    }
    return e;
  }
}
class $te {
  constructor(e, t) {
    this.range = e, this.text = t;
  }
  toSingleEditOperation() {
    return {
      range: this.range,
      text: this.text
    };
  }
}
function $R(s, e) {
  if (s.lineNumber === e.lineNumber && s.column === Number.MAX_SAFE_INTEGER)
    return T.fromPositions(e, e);
  if (!s.isBeforeOrEqual(e))
    throw new at("start must be before end");
  return new T(s.lineNumber, s.column, e.lineNumber, e.column);
}
class Q7 {
  get endPositionExclusive() {
    return this.length.addToPosition(new F(1, 1));
  }
}
class Kte extends Q7 {
  constructor(e) {
    super(), this.value = e, this._t = new zte(this.value);
  }
  getValueOfRange(e) {
    return this._t.getOffsetRange(e).substring(this.value);
  }
  get length() {
    return this._t.textLength;
  }
}
class an {
  static inverse(e, t, i) {
    const n = [];
    let o = 1, r = 1;
    for (const l of e) {
      const c = new an(new pe(o, l.original.startLineNumber), new pe(r, l.modified.startLineNumber));
      c.modified.isEmpty || n.push(c), o = l.original.endLineNumberExclusive, r = l.modified.endLineNumberExclusive;
    }
    const a = new an(new pe(o, t + 1), new pe(r, i + 1));
    return a.modified.isEmpty || n.push(a), n;
  }
  static clip(e, t, i) {
    const n = [];
    for (const o of e) {
      const r = o.original.intersect(t), a = o.modified.intersect(i);
      r && !r.isEmpty && a && !a.isEmpty && n.push(new an(r, a));
    }
    return n;
  }
  constructor(e, t) {
    this.original = e, this.modified = t;
  }
  toString() {
    return `{${this.original.toString()}->${this.modified.toString()}}`;
  }
  flip() {
    return new an(this.modified, this.original);
  }
  join(e) {
    return new an(this.original.join(e.original), this.modified.join(e.modified));
  }
  /**
   * This method assumes that the LineRangeMapping describes a valid diff!
   * I.e. if one range is empty, the other range cannot be the entire document.
   * It avoids various problems when the line range points to non-existing line-numbers.
  */
  toRangeMapping() {
    const e = this.original.toInclusiveRange(), t = this.modified.toInclusiveRange();
    if (e && t)
      return new gs(e, t);
    if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {
      if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1))
        throw new at("not a valid diff");
      return new gs(new T(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new T(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
    } else
      return new gs(new T(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new T(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));
  }
  /**
   * This method assumes that the LineRangeMapping describes a valid diff!
   * I.e. if one range is empty, the other range cannot be the entire document.
   * It avoids various problems when the line range points to non-existing line-numbers.
  */
  toRangeMapping2(e, t) {
    if (KR(this.original.endLineNumberExclusive, e) && KR(this.modified.endLineNumberExclusive, t))
      return new gs(new T(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new T(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
    if (!this.original.isEmpty && !this.modified.isEmpty)
      return new gs(T.fromPositions(new F(this.original.startLineNumber, 1), Hd(new F(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), e)), T.fromPositions(new F(this.modified.startLineNumber, 1), Hd(new F(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), t)));
    if (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1)
      return new gs(T.fromPositions(Hd(new F(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), e), Hd(new F(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), e)), T.fromPositions(Hd(new F(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), t), Hd(new F(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), t)));
    throw new at();
  }
}
function Hd(s, e) {
  if (s.lineNumber < 1)
    return new F(1, 1);
  if (s.lineNumber > e.length)
    return new F(e.length, e[e.length - 1].length + 1);
  const t = e[s.lineNumber - 1];
  return s.column > t.length + 1 ? new F(s.lineNumber, t.length + 1) : s;
}
function KR(s, e) {
  return s >= 1 && s <= e.length;
}
class Ls extends an {
  static fromRangeMappings(e) {
    const t = pe.join(e.map((n) => pe.fromRangeInclusive(n.originalRange))), i = pe.join(e.map((n) => pe.fromRangeInclusive(n.modifiedRange)));
    return new Ls(t, i, e);
  }
  constructor(e, t, i) {
    super(e, t), this.innerChanges = i;
  }
  flip() {
    var e;
    return new Ls(this.modified, this.original, (e = this.innerChanges) == null ? void 0 : e.map((t) => t.flip()));
  }
  withInnerChangesFromLineRanges() {
    return new Ls(this.original, this.modified, [this.toRangeMapping()]);
  }
}
class gs {
  static assertSorted(e) {
    for (let t = 1; t < e.length; t++) {
      const i = e[t - 1], n = e[t];
      if (!(i.originalRange.getEndPosition().isBeforeOrEqual(n.originalRange.getStartPosition()) && i.modifiedRange.getEndPosition().isBeforeOrEqual(n.modifiedRange.getStartPosition())))
        throw new at("Range mappings must be sorted");
    }
  }
  constructor(e, t) {
    this.originalRange = e, this.modifiedRange = t;
  }
  toString() {
    return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
  }
  flip() {
    return new gs(this.modifiedRange, this.originalRange);
  }
  /**
   * Creates a single text edit that describes the change from the original to the modified text.
  */
  toTextEdit(e) {
    const t = e.getValueOfRange(this.modifiedRange);
    return new $te(this.originalRange, t);
  }
}
const jte = 3;
class qte {
  computeDiff(e, t, i) {
    var l;
    const o = new Yte(e, t, {
      maxComputationTime: i.maxComputationTimeMs,
      shouldIgnoreTrimWhitespace: i.ignoreTrimWhitespace,
      shouldComputeCharChanges: !0,
      shouldMakePrettyDiff: !0,
      shouldPostProcessCharChanges: !0
    }).computeDiff(), r = [];
    let a = null;
    for (const c of o.changes) {
      let h;
      c.originalEndLineNumber === 0 ? h = new pe(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1) : h = new pe(c.originalStartLineNumber, c.originalEndLineNumber + 1);
      let d;
      c.modifiedEndLineNumber === 0 ? d = new pe(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1) : d = new pe(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);
      let u = new Ls(h, d, (l = c.charChanges) == null ? void 0 : l.map((f) => new gs(new T(f.originalStartLineNumber, f.originalStartColumn, f.originalEndLineNumber, f.originalEndColumn), new T(f.modifiedStartLineNumber, f.modifiedStartColumn, f.modifiedEndLineNumber, f.modifiedEndColumn))));
      a && (a.modified.endLineNumberExclusive === u.modified.startLineNumber || a.original.endLineNumberExclusive === u.original.startLineNumber) && (u = new Ls(a.original.join(u.original), a.modified.join(u.modified), a.innerChanges && u.innerChanges ? a.innerChanges.concat(u.innerChanges) : void 0), r.pop()), r.push(u), a = u;
    }
    return Wh(() => bE(r, (c, h) => h.original.startLineNumber - c.original.endLineNumberExclusive === h.modified.startLineNumber - c.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
    c.original.endLineNumberExclusive < h.original.startLineNumber && c.modified.endLineNumberExclusive < h.modified.startLineNumber)), new Sb(r, [], o.quitEarly);
  }
}
function J7(s, e, t, i) {
  return new La(s, e, t).ComputeDiff(i);
}
let jR = class {
  constructor(e) {
    const t = [], i = [];
    for (let n = 0, o = e.length; n < o; n++)
      t[n] = wx(e[n], 1), i[n] = yx(e[n], 1);
    this.lines = e, this._startColumns = t, this._endColumns = i;
  }
  getElements() {
    const e = [];
    for (let t = 0, i = this.lines.length; t < i; t++)
      e[t] = this.lines[t].substring(this._startColumns[t] - 1, this._endColumns[t] - 1);
    return e;
  }
  getStrictElement(e) {
    return this.lines[e];
  }
  getStartLineNumber(e) {
    return e + 1;
  }
  getEndLineNumber(e) {
    return e + 1;
  }
  createCharSequence(e, t, i) {
    const n = [], o = [], r = [];
    let a = 0;
    for (let l = t; l <= i; l++) {
      const c = this.lines[l], h = e ? this._startColumns[l] : 1, d = e ? this._endColumns[l] : c.length + 1;
      for (let u = h; u < d; u++)
        n[a] = c.charCodeAt(u - 1), o[a] = l + 1, r[a] = u, a++;
      !e && l < i && (n[a] = 10, o[a] = l + 1, r[a] = c.length + 1, a++);
    }
    return new Gte(n, o, r);
  }
};
class Gte {
  constructor(e, t, i) {
    this._charCodes = e, this._lineNumbers = t, this._columns = i;
  }
  toString() {
    return "[" + this._charCodes.map((e, t) => (e === 10 ? "\\n" : String.fromCharCode(e)) + `-(${this._lineNumbers[t]},${this._columns[t]})`).join(", ") + "]";
  }
  _assertIndex(e, t) {
    if (e < 0 || e >= t.length)
      throw new Error("Illegal index");
  }
  getElements() {
    return this._charCodes;
  }
  getStartLineNumber(e) {
    return e > 0 && e === this._lineNumbers.length ? this.getEndLineNumber(e - 1) : (this._assertIndex(e, this._lineNumbers), this._lineNumbers[e]);
  }
  getEndLineNumber(e) {
    return e === -1 ? this.getStartLineNumber(e + 1) : (this._assertIndex(e, this._lineNumbers), this._charCodes[e] === 10 ? this._lineNumbers[e] + 1 : this._lineNumbers[e]);
  }
  getStartColumn(e) {
    return e > 0 && e === this._columns.length ? this.getEndColumn(e - 1) : (this._assertIndex(e, this._columns), this._columns[e]);
  }
  getEndColumn(e) {
    return e === -1 ? this.getStartColumn(e + 1) : (this._assertIndex(e, this._columns), this._charCodes[e] === 10 ? 1 : this._columns[e] + 1);
  }
}
class $u {
  constructor(e, t, i, n, o, r, a, l) {
    this.originalStartLineNumber = e, this.originalStartColumn = t, this.originalEndLineNumber = i, this.originalEndColumn = n, this.modifiedStartLineNumber = o, this.modifiedStartColumn = r, this.modifiedEndLineNumber = a, this.modifiedEndColumn = l;
  }
  static createFromDiffChange(e, t, i) {
    const n = t.getStartLineNumber(e.originalStart), o = t.getStartColumn(e.originalStart), r = t.getEndLineNumber(e.originalStart + e.originalLength - 1), a = t.getEndColumn(e.originalStart + e.originalLength - 1), l = i.getStartLineNumber(e.modifiedStart), c = i.getStartColumn(e.modifiedStart), h = i.getEndLineNumber(e.modifiedStart + e.modifiedLength - 1), d = i.getEndColumn(e.modifiedStart + e.modifiedLength - 1);
    return new $u(n, o, r, a, l, c, h, d);
  }
}
function Zte(s) {
  if (s.length <= 1)
    return s;
  const e = [s[0]];
  let t = e[0];
  for (let i = 1, n = s.length; i < n; i++) {
    const o = s[i], r = o.originalStart - (t.originalStart + t.originalLength), a = o.modifiedStart - (t.modifiedStart + t.modifiedLength);
    Math.min(r, a) < jte ? (t.originalLength = o.originalStart + o.originalLength - t.originalStart, t.modifiedLength = o.modifiedStart + o.modifiedLength - t.modifiedStart) : (e.push(o), t = o);
  }
  return e;
}
class em {
  constructor(e, t, i, n, o) {
    this.originalStartLineNumber = e, this.originalEndLineNumber = t, this.modifiedStartLineNumber = i, this.modifiedEndLineNumber = n, this.charChanges = o;
  }
  static createFromDiffResult(e, t, i, n, o, r, a) {
    let l, c, h, d, u;
    if (t.originalLength === 0 ? (l = i.getStartLineNumber(t.originalStart) - 1, c = 0) : (l = i.getStartLineNumber(t.originalStart), c = i.getEndLineNumber(t.originalStart + t.originalLength - 1)), t.modifiedLength === 0 ? (h = n.getStartLineNumber(t.modifiedStart) - 1, d = 0) : (h = n.getStartLineNumber(t.modifiedStart), d = n.getEndLineNumber(t.modifiedStart + t.modifiedLength - 1)), r && t.originalLength > 0 && t.originalLength < 20 && t.modifiedLength > 0 && t.modifiedLength < 20 && o()) {
      const f = i.createCharSequence(e, t.originalStart, t.originalStart + t.originalLength - 1), g = n.createCharSequence(e, t.modifiedStart, t.modifiedStart + t.modifiedLength - 1);
      if (f.getElements().length > 0 && g.getElements().length > 0) {
        let p = J7(f, g, o, !0).changes;
        a && (p = Zte(p)), u = [];
        for (let _ = 0, b = p.length; _ < b; _++)
          u.push($u.createFromDiffChange(p[_], f, g));
      }
    }
    return new em(l, c, h, d, u);
  }
}
class Yte {
  constructor(e, t, i) {
    this.shouldComputeCharChanges = i.shouldComputeCharChanges, this.shouldPostProcessCharChanges = i.shouldPostProcessCharChanges, this.shouldIgnoreTrimWhitespace = i.shouldIgnoreTrimWhitespace, this.shouldMakePrettyDiff = i.shouldMakePrettyDiff, this.originalLines = e, this.modifiedLines = t, this.original = new jR(e), this.modified = new jR(t), this.continueLineDiff = qR(i.maxComputationTime), this.continueCharDiff = qR(i.maxComputationTime === 0 ? 0 : Math.min(i.maxComputationTime, 5e3));
  }
  computeDiff() {
    if (this.original.lines.length === 1 && this.original.lines[0].length === 0)
      return this.modified.lines.length === 1 && this.modified.lines[0].length === 0 ? {
        quitEarly: !1,
        changes: []
      } : {
        quitEarly: !1,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: 1,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: this.modified.lines.length,
          charChanges: void 0
        }]
      };
    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0)
      return {
        quitEarly: !1,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: this.original.lines.length,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: 1,
          charChanges: void 0
        }]
      };
    const e = J7(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff), t = e.changes, i = e.quitEarly;
    if (this.shouldIgnoreTrimWhitespace) {
      const a = [];
      for (let l = 0, c = t.length; l < c; l++)
        a.push(em.createFromDiffResult(this.shouldIgnoreTrimWhitespace, t[l], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
      return {
        quitEarly: i,
        changes: a
      };
    }
    const n = [];
    let o = 0, r = 0;
    for (let a = -1, l = t.length; a < l; a++) {
      const c = a + 1 < l ? t[a + 1] : null, h = c ? c.originalStart : this.originalLines.length, d = c ? c.modifiedStart : this.modifiedLines.length;
      for (; o < h && r < d; ) {
        const u = this.originalLines[o], f = this.modifiedLines[r];
        if (u !== f) {
          {
            let g = wx(u, 1), p = wx(f, 1);
            for (; g > 1 && p > 1; ) {
              const _ = u.charCodeAt(g - 2), b = f.charCodeAt(p - 2);
              if (_ !== b)
                break;
              g--, p--;
            }
            (g > 1 || p > 1) && this._pushTrimWhitespaceCharChange(n, o + 1, 1, g, r + 1, 1, p);
          }
          {
            let g = yx(u, 1), p = yx(f, 1);
            const _ = u.length + 1, b = f.length + 1;
            for (; g < _ && p < b; ) {
              const C = u.charCodeAt(g - 1), w = u.charCodeAt(p - 1);
              if (C !== w)
                break;
              g++, p++;
            }
            (g < _ || p < b) && this._pushTrimWhitespaceCharChange(n, o + 1, g, _, r + 1, p, b);
          }
        }
        o++, r++;
      }
      c && (n.push(em.createFromDiffResult(this.shouldIgnoreTrimWhitespace, c, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges)), o += c.originalLength, r += c.modifiedLength);
    }
    return {
      quitEarly: i,
      changes: n
    };
  }
  _pushTrimWhitespaceCharChange(e, t, i, n, o, r, a) {
    if (this._mergeTrimWhitespaceCharChange(e, t, i, n, o, r, a))
      return;
    let l;
    this.shouldComputeCharChanges && (l = [new $u(t, i, t, n, o, r, o, a)]), e.push(new em(t, t, o, o, l));
  }
  _mergeTrimWhitespaceCharChange(e, t, i, n, o, r, a) {
    const l = e.length;
    if (l === 0)
      return !1;
    const c = e[l - 1];
    return c.originalEndLineNumber === 0 || c.modifiedEndLineNumber === 0 ? !1 : c.originalEndLineNumber === t && c.modifiedEndLineNumber === o ? (this.shouldComputeCharChanges && c.charChanges && c.charChanges.push(new $u(t, i, t, n, o, r, o, a)), !0) : c.originalEndLineNumber + 1 === t && c.modifiedEndLineNumber + 1 === o ? (c.originalEndLineNumber = t, c.modifiedEndLineNumber = o, this.shouldComputeCharChanges && c.charChanges && c.charChanges.push(new $u(t, i, t, n, o, r, o, a)), !0) : !1;
  }
}
function wx(s, e) {
  const t = Zn(s);
  return t === -1 ? e : t + 1;
}
function yx(s, e) {
  const t = id(s);
  return t === -1 ? e : t + 2;
}
function qR(s) {
  if (s === 0)
    return () => !0;
  const e = Date.now();
  return () => Date.now() - e < s;
}
class Ha {
  static trivial(e, t) {
    return new Ha([new mi(Ne.ofLength(e.length), Ne.ofLength(t.length))], !1);
  }
  static trivialTimedOut(e, t) {
    return new Ha([new mi(Ne.ofLength(e.length), Ne.ofLength(t.length))], !0);
  }
  constructor(e, t) {
    this.diffs = e, this.hitTimeout = t;
  }
}
class mi {
  static invert(e, t) {
    const i = [];
    return dO(e, (n, o) => {
      i.push(mi.fromOffsetPairs(n ? n.getEndExclusives() : Ta.zero, o ? o.getStarts() : new Ta(t, (n ? n.seq2Range.endExclusive - n.seq1Range.endExclusive : 0) + t)));
    }), i;
  }
  static fromOffsetPairs(e, t) {
    return new mi(new Ne(e.offset1, t.offset1), new Ne(e.offset2, t.offset2));
  }
  static assertSorted(e) {
    let t;
    for (const i of e) {
      if (t && !(t.seq1Range.endExclusive <= i.seq1Range.start && t.seq2Range.endExclusive <= i.seq2Range.start))
        throw new at("Sequence diffs must be sorted");
      t = i;
    }
  }
  constructor(e, t) {
    this.seq1Range = e, this.seq2Range = t;
  }
  swap() {
    return new mi(this.seq2Range, this.seq1Range);
  }
  toString() {
    return `${this.seq1Range} <-> ${this.seq2Range}`;
  }
  join(e) {
    return new mi(this.seq1Range.join(e.seq1Range), this.seq2Range.join(e.seq2Range));
  }
  delta(e) {
    return e === 0 ? this : new mi(this.seq1Range.delta(e), this.seq2Range.delta(e));
  }
  deltaStart(e) {
    return e === 0 ? this : new mi(this.seq1Range.deltaStart(e), this.seq2Range.deltaStart(e));
  }
  deltaEnd(e) {
    return e === 0 ? this : new mi(this.seq1Range.deltaEnd(e), this.seq2Range.deltaEnd(e));
  }
  intersect(e) {
    const t = this.seq1Range.intersect(e.seq1Range), i = this.seq2Range.intersect(e.seq2Range);
    if (!(!t || !i))
      return new mi(t, i);
  }
  getStarts() {
    return new Ta(this.seq1Range.start, this.seq2Range.start);
  }
  getEndExclusives() {
    return new Ta(this.seq1Range.endExclusive, this.seq2Range.endExclusive);
  }
}
const Zc = class Zc {
  constructor(e, t) {
    this.offset1 = e, this.offset2 = t;
  }
  toString() {
    return `${this.offset1} <-> ${this.offset2}`;
  }
  delta(e) {
    return e === 0 ? this : new Zc(this.offset1 + e, this.offset2 + e);
  }
  equals(e) {
    return this.offset1 === e.offset1 && this.offset2 === e.offset2;
  }
};
Zc.zero = new Zc(0, 0), Zc.max = new Zc(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
let Ta = Zc;
const vv = class vv {
  isValid() {
    return !0;
  }
};
vv.instance = new vv();
let _p = vv;
class Xte {
  constructor(e) {
    if (this.timeout = e, this.startTime = Date.now(), this.valid = !0, e <= 0)
      throw new at("timeout must be positive");
  }
  // Recommendation: Set a log-point `{this.disable()}` in the body
  isValid() {
    if (!(Date.now() - this.startTime < this.timeout) && this.valid) {
      this.valid = !1;
      debugger;
    }
    return this.valid;
  }
}
class gy {
  constructor(e, t) {
    this.width = e, this.height = t, this.array = [], this.array = new Array(e * t);
  }
  get(e, t) {
    return this.array[e + t * this.width];
  }
  set(e, t, i) {
    this.array[e + t * this.width] = i;
  }
}
function Sx(s) {
  return s === 32 || s === 9;
}
const gm = class gm {
  static getKey(e) {
    let t = this.chrKeys.get(e);
    return t === void 0 && (t = this.chrKeys.size, this.chrKeys.set(e, t)), t;
  }
  constructor(e, t, i) {
    this.range = e, this.lines = t, this.source = i, this.histogram = [];
    let n = 0;
    for (let o = e.startLineNumber - 1; o < e.endLineNumberExclusive - 1; o++) {
      const r = t[o];
      for (let l = 0; l < r.length; l++) {
        n++;
        const c = r[l], h = gm.getKey(c);
        this.histogram[h] = (this.histogram[h] || 0) + 1;
      }
      n++;
      const a = gm.getKey(`
`);
      this.histogram[a] = (this.histogram[a] || 0) + 1;
    }
    this.totalCount = n;
  }
  computeSimilarity(e) {
    let t = 0;
    const i = Math.max(this.histogram.length, e.histogram.length);
    for (let n = 0; n < i; n++)
      t += Math.abs((this.histogram[n] ?? 0) - (e.histogram[n] ?? 0));
    return 1 - t / (this.totalCount + e.totalCount);
  }
};
gm.chrKeys = /* @__PURE__ */ new Map();
let uC = gm;
class Qte {
  compute(e, t, i = _p.instance, n) {
    if (e.length === 0 || t.length === 0)
      return Ha.trivial(e, t);
    const o = new gy(e.length, t.length), r = new gy(e.length, t.length), a = new gy(e.length, t.length);
    for (let g = 0; g < e.length; g++)
      for (let p = 0; p < t.length; p++) {
        if (!i.isValid())
          return Ha.trivialTimedOut(e, t);
        const _ = g === 0 ? 0 : o.get(g - 1, p), b = p === 0 ? 0 : o.get(g, p - 1);
        let C;
        e.getElement(g) === t.getElement(p) ? (g === 0 || p === 0 ? C = 0 : C = o.get(g - 1, p - 1), g > 0 && p > 0 && r.get(g - 1, p - 1) === 3 && (C += a.get(g - 1, p - 1)), C += n ? n(g, p) : 1) : C = -1;
        const w = Math.max(_, b, C);
        if (w === C) {
          const v = g > 0 && p > 0 ? a.get(g - 1, p - 1) : 0;
          a.set(g, p, v + 1), r.set(g, p, 3);
        } else w === _ ? (a.set(g, p, 0), r.set(g, p, 1)) : w === b && (a.set(g, p, 0), r.set(g, p, 2));
        o.set(g, p, w);
      }
    const l = [];
    let c = e.length, h = t.length;
    function d(g, p) {
      (g + 1 !== c || p + 1 !== h) && l.push(new mi(new Ne(g + 1, c), new Ne(p + 1, h))), c = g, h = p;
    }
    let u = e.length - 1, f = t.length - 1;
    for (; u >= 0 && f >= 0; )
      r.get(u, f) === 3 ? (d(u, f), u--, f--) : r.get(u, f) === 1 ? u-- : f--;
    return d(-1, -1), l.reverse(), new Ha(l, !1);
  }
}
class e3 {
  compute(e, t, i = _p.instance) {
    if (e.length === 0 || t.length === 0)
      return Ha.trivial(e, t);
    const n = e, o = t;
    function r(p, _) {
      for (; p < n.length && _ < o.length && n.getElement(p) === o.getElement(_); )
        p++, _++;
      return p;
    }
    let a = 0;
    const l = new Jte();
    l.set(0, r(0, 0));
    const c = new eie();
    c.set(0, l.get(0) === 0 ? null : new GR(null, 0, 0, l.get(0)));
    let h = 0;
    e: for (; ; ) {
      if (a++, !i.isValid())
        return Ha.trivialTimedOut(n, o);
      const p = -Math.min(a, o.length + a % 2), _ = Math.min(a, n.length + a % 2);
      for (h = p; h <= _; h += 2) {
        const b = h === _ ? -1 : l.get(h + 1), C = h === p ? -1 : l.get(h - 1) + 1, w = Math.min(Math.max(b, C), n.length), v = w - h;
        if (w > n.length || v > o.length)
          continue;
        const S = r(w, v);
        l.set(h, S);
        const L = w === b ? c.get(h + 1) : c.get(h - 1);
        if (c.set(h, S !== w ? new GR(L, w, v, S - w) : L), l.get(h) === n.length && l.get(h) - h === o.length)
          break e;
      }
    }
    let d = c.get(h);
    const u = [];
    let f = n.length, g = o.length;
    for (; ; ) {
      const p = d ? d.x + d.length : 0, _ = d ? d.y + d.length : 0;
      if ((p !== f || _ !== g) && u.push(new mi(new Ne(p, f), new Ne(_, g))), !d)
        break;
      f = d.x, g = d.y, d = d.prev;
    }
    return u.reverse(), new Ha(u, !1);
  }
}
class GR {
  constructor(e, t, i, n) {
    this.prev = e, this.x = t, this.y = i, this.length = n;
  }
}
class Jte {
  constructor() {
    this.positiveArr = new Int32Array(10), this.negativeArr = new Int32Array(10);
  }
  get(e) {
    return e < 0 ? (e = -e - 1, this.negativeArr[e]) : this.positiveArr[e];
  }
  set(e, t) {
    if (e < 0) {
      if (e = -e - 1, e >= this.negativeArr.length) {
        const i = this.negativeArr;
        this.negativeArr = new Int32Array(i.length * 2), this.negativeArr.set(i);
      }
      this.negativeArr[e] = t;
    } else {
      if (e >= this.positiveArr.length) {
        const i = this.positiveArr;
        this.positiveArr = new Int32Array(i.length * 2), this.positiveArr.set(i);
      }
      this.positiveArr[e] = t;
    }
  }
}
class eie {
  constructor() {
    this.positiveArr = [], this.negativeArr = [];
  }
  get(e) {
    return e < 0 ? (e = -e - 1, this.negativeArr[e]) : this.positiveArr[e];
  }
  set(e, t) {
    e < 0 ? (e = -e - 1, this.negativeArr[e] = t) : this.positiveArr[e] = t;
  }
}
class fC {
  constructor(e, t, i) {
    this.lines = e, this.range = t, this.considerWhitespaceChanges = i, this.elements = [], this.firstElementOffsetByLineIdx = [], this.lineStartOffsets = [], this.trimmedWsLengthsByLineIdx = [], this.firstElementOffsetByLineIdx.push(0);
    for (let n = this.range.startLineNumber; n <= this.range.endLineNumber; n++) {
      let o = e[n - 1], r = 0;
      n === this.range.startLineNumber && this.range.startColumn > 1 && (r = this.range.startColumn - 1, o = o.substring(r)), this.lineStartOffsets.push(r);
      let a = 0;
      if (!i) {
        const c = o.trimStart();
        a = o.length - c.length, o = c.trimEnd();
      }
      this.trimmedWsLengthsByLineIdx.push(a);
      const l = n === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - r - a, o.length) : o.length;
      for (let c = 0; c < l; c++)
        this.elements.push(o.charCodeAt(c));
      n < this.range.endLineNumber && (this.elements.push(10), this.firstElementOffsetByLineIdx.push(this.elements.length));
    }
  }
  toString() {
    return `Slice: "${this.text}"`;
  }
  get text() {
    return this.getText(new Ne(0, this.length));
  }
  getText(e) {
    return this.elements.slice(e.start, e.endExclusive).map((t) => String.fromCharCode(t)).join("");
  }
  getElement(e) {
    return this.elements[e];
  }
  get length() {
    return this.elements.length;
  }
  getBoundaryScore(e) {
    const t = YR(e > 0 ? this.elements[e - 1] : -1), i = YR(e < this.elements.length ? this.elements[e] : -1);
    if (t === 7 && i === 8)
      return 0;
    if (t === 8)
      return 150;
    let n = 0;
    return t !== i && (n += 10, t === 0 && i === 1 && (n += 1)), n += ZR(t), n += ZR(i), n;
  }
  translateOffset(e, t = "right") {
    const i = qm(this.firstElementOffsetByLineIdx, (o) => o <= e), n = e - this.firstElementOffsetByLineIdx[i];
    return new F(this.range.startLineNumber + i, 1 + this.lineStartOffsets[i] + n + (n === 0 && t === "left" ? 0 : this.trimmedWsLengthsByLineIdx[i]));
  }
  translateRange(e) {
    const t = this.translateOffset(e.start, "right"), i = this.translateOffset(e.endExclusive, "left");
    return i.isBefore(t) ? T.fromPositions(i, i) : T.fromPositions(t, i);
  }
  /**
   * Finds the word that contains the character at the given offset
   */
  findWordContaining(e) {
    if (e < 0 || e >= this.elements.length || !my(this.elements[e]))
      return;
    let t = e;
    for (; t > 0 && my(this.elements[t - 1]); )
      t--;
    let i = e;
    for (; i < this.elements.length && my(this.elements[i]); )
      i++;
    return new Ne(t, i);
  }
  countLinesIn(e) {
    return this.translateOffset(e.endExclusive).lineNumber - this.translateOffset(e.start).lineNumber;
  }
  isStronglyEqual(e, t) {
    return this.elements[e] === this.elements[t];
  }
  extendToFullLines(e) {
    const t = mf(this.firstElementOffsetByLineIdx, (n) => n <= e.start) ?? 0, i = _q(this.firstElementOffsetByLineIdx, (n) => e.endExclusive <= n) ?? this.elements.length;
    return new Ne(t, i);
  }
}
function my(s) {
  return s >= 97 && s <= 122 || s >= 65 && s <= 90 || s >= 48 && s <= 57;
}
const tie = {
  0: 0,
  1: 0,
  2: 0,
  3: 10,
  4: 2,
  5: 30,
  6: 3,
  7: 10,
  8: 10
};
function ZR(s) {
  return tie[s];
}
function YR(s) {
  return s === 10 ? 8 : s === 13 ? 7 : Sx(s) ? 6 : s >= 97 && s <= 122 ? 0 : s >= 65 && s <= 90 ? 1 : s >= 48 && s <= 57 ? 2 : s === -1 ? 3 : s === 44 || s === 59 ? 5 : 4;
}
function iie(s, e, t, i, n, o) {
  let { moves: r, excludedChanges: a } = sie(s, e, t, o);
  if (!o.isValid())
    return [];
  const l = s.filter((h) => !a.has(h)), c = oie(l, i, n, e, t, o);
  return aS(r, c), r = rie(r), r = r.filter((h) => {
    const d = h.original.toOffsetRange().slice(e).map((f) => f.trim());
    return d.join(`
`).length >= 15 && nie(d, (f) => f.length >= 2) >= 2;
  }), r = aie(s, r), r;
}
function nie(s, e) {
  let t = 0;
  for (const i of s)
    e(i) && t++;
  return t;
}
function sie(s, e, t, i) {
  const n = [], o = s.filter((l) => l.modified.isEmpty && l.original.length >= 3).map((l) => new uC(l.original, e, l)), r = new Set(s.filter((l) => l.original.isEmpty && l.modified.length >= 3).map((l) => new uC(l.modified, t, l))), a = /* @__PURE__ */ new Set();
  for (const l of o) {
    let c = -1, h;
    for (const d of r) {
      const u = l.computeSimilarity(d);
      u > c && (c = u, h = d);
    }
    if (c > 0.9 && h && (r.delete(h), n.push(new an(l.range, h.range)), a.add(l.source), a.add(h.source)), !i.isValid())
      return { moves: n, excludedChanges: a };
  }
  return { moves: n, excludedChanges: a };
}
function oie(s, e, t, i, n, o) {
  const r = [], a = new G4();
  for (const u of s)
    for (let f = u.original.startLineNumber; f < u.original.endLineNumberExclusive - 2; f++) {
      const g = `${e[f - 1]}:${e[f + 1 - 1]}:${e[f + 2 - 1]}`;
      a.add(g, { range: new pe(f, f + 3) });
    }
  const l = [];
  s.sort(Os((u) => u.modified.startLineNumber, Ba));
  for (const u of s) {
    let f = [];
    for (let g = u.modified.startLineNumber; g < u.modified.endLineNumberExclusive - 2; g++) {
      const p = `${t[g - 1]}:${t[g + 1 - 1]}:${t[g + 2 - 1]}`, _ = new pe(g, g + 3), b = [];
      a.forEach(p, ({ range: C }) => {
        for (const v of f)
          if (v.originalLineRange.endLineNumberExclusive + 1 === C.endLineNumberExclusive && v.modifiedLineRange.endLineNumberExclusive + 1 === _.endLineNumberExclusive) {
            v.originalLineRange = new pe(v.originalLineRange.startLineNumber, C.endLineNumberExclusive), v.modifiedLineRange = new pe(v.modifiedLineRange.startLineNumber, _.endLineNumberExclusive), b.push(v);
            return;
          }
        const w = {
          modifiedLineRange: _,
          originalLineRange: C
        };
        l.push(w), b.push(w);
      }), f = b;
    }
    if (!o.isValid())
      return [];
  }
  l.sort(rW(Os((u) => u.modifiedLineRange.length, Ba)));
  const c = new Rs(), h = new Rs();
  for (const u of l) {
    const f = u.modifiedLineRange.startLineNumber - u.originalLineRange.startLineNumber, g = c.subtractFrom(u.modifiedLineRange), p = h.subtractFrom(u.originalLineRange).getWithDelta(f), _ = g.getIntersection(p);
    for (const b of _.ranges) {
      if (b.length < 3)
        continue;
      const C = b, w = b.delta(-f);
      r.push(new an(w, C)), c.addRange(C), h.addRange(w);
    }
  }
  r.sort(Os((u) => u.original.startLineNumber, Ba));
  const d = new k1(s);
  for (let u = 0; u < r.length; u++) {
    const f = r[u], g = d.findLastMonotonous((L) => L.original.startLineNumber <= f.original.startLineNumber), p = mf(s, (L) => L.modified.startLineNumber <= f.modified.startLineNumber), _ = Math.max(f.original.startLineNumber - g.original.startLineNumber, f.modified.startLineNumber - p.modified.startLineNumber), b = d.findLastMonotonous((L) => L.original.startLineNumber < f.original.endLineNumberExclusive), C = mf(s, (L) => L.modified.startLineNumber < f.modified.endLineNumberExclusive), w = Math.max(b.original.endLineNumberExclusive - f.original.endLineNumberExclusive, C.modified.endLineNumberExclusive - f.modified.endLineNumberExclusive);
    let v;
    for (v = 0; v < _; v++) {
      const L = f.original.startLineNumber - v - 1, k = f.modified.startLineNumber - v - 1;
      if (L > i.length || k > n.length || c.contains(k) || h.contains(L) || !XR(i[L - 1], n[k - 1], o))
        break;
    }
    v > 0 && (h.addRange(new pe(f.original.startLineNumber - v, f.original.startLineNumber)), c.addRange(new pe(f.modified.startLineNumber - v, f.modified.startLineNumber)));
    let S;
    for (S = 0; S < w; S++) {
      const L = f.original.endLineNumberExclusive + S, k = f.modified.endLineNumberExclusive + S;
      if (L > i.length || k > n.length || c.contains(k) || h.contains(L) || !XR(i[L - 1], n[k - 1], o))
        break;
    }
    S > 0 && (h.addRange(new pe(f.original.endLineNumberExclusive, f.original.endLineNumberExclusive + S)), c.addRange(new pe(f.modified.endLineNumberExclusive, f.modified.endLineNumberExclusive + S))), (v > 0 || S > 0) && (r[u] = new an(new pe(f.original.startLineNumber - v, f.original.endLineNumberExclusive + S), new pe(f.modified.startLineNumber - v, f.modified.endLineNumberExclusive + S)));
  }
  return r;
}
function XR(s, e, t) {
  if (s.trim() === e.trim())
    return !0;
  if (s.length > 300 && e.length > 300)
    return !1;
  const n = new e3().compute(new fC([s], new T(1, 1, 1, s.length), !1), new fC([e], new T(1, 1, 1, e.length), !1), t);
  let o = 0;
  const r = mi.invert(n.diffs, s.length);
  for (const h of r)
    h.seq1Range.forEach((d) => {
      Sx(s.charCodeAt(d)) || o++;
    });
  function a(h) {
    let d = 0;
    for (let u = 0; u < s.length; u++)
      Sx(h.charCodeAt(u)) || d++;
    return d;
  }
  const l = a(s.length > e.length ? s : e);
  return o / l > 0.6 && l > 10;
}
function rie(s) {
  if (s.length === 0)
    return s;
  s.sort(Os((t) => t.original.startLineNumber, Ba));
  const e = [s[0]];
  for (let t = 1; t < s.length; t++) {
    const i = e[e.length - 1], n = s[t], o = n.original.startLineNumber - i.original.endLineNumberExclusive, r = n.modified.startLineNumber - i.modified.endLineNumberExclusive;
    if (o >= 0 && r >= 0 && o + r <= 2) {
      e[e.length - 1] = i.join(n);
      continue;
    }
    e.push(n);
  }
  return e;
}
function aie(s, e) {
  const t = new k1(s);
  return e = e.filter((i) => {
    const n = t.findLastMonotonous((a) => a.original.startLineNumber < i.original.endLineNumberExclusive) || new an(new pe(1, 1), new pe(1, 1)), o = mf(s, (a) => a.modified.startLineNumber < i.modified.endLineNumberExclusive);
    return n !== o;
  }), e;
}
function Lx(s, e, t) {
  let i = t;
  return i = QR(s, e, i), i = QR(s, e, i), i = lie(s, e, i), i;
}
function QR(s, e, t) {
  if (t.length === 0)
    return t;
  const i = [];
  i.push(t[0]);
  for (let o = 1; o < t.length; o++) {
    const r = i[i.length - 1];
    let a = t[o];
    if (a.seq1Range.isEmpty || a.seq2Range.isEmpty) {
      const l = a.seq1Range.start - r.seq1Range.endExclusive;
      let c;
      for (c = 1; c <= l && !(s.getElement(a.seq1Range.start - c) !== s.getElement(a.seq1Range.endExclusive - c) || e.getElement(a.seq2Range.start - c) !== e.getElement(a.seq2Range.endExclusive - c)); c++)
        ;
      if (c--, c === l) {
        i[i.length - 1] = new mi(new Ne(r.seq1Range.start, a.seq1Range.endExclusive - l), new Ne(r.seq2Range.start, a.seq2Range.endExclusive - l));
        continue;
      }
      a = a.delta(-c);
    }
    i.push(a);
  }
  const n = [];
  for (let o = 0; o < i.length - 1; o++) {
    const r = i[o + 1];
    let a = i[o];
    if (a.seq1Range.isEmpty || a.seq2Range.isEmpty) {
      const l = r.seq1Range.start - a.seq1Range.endExclusive;
      let c;
      for (c = 0; c < l && !(!s.isStronglyEqual(a.seq1Range.start + c, a.seq1Range.endExclusive + c) || !e.isStronglyEqual(a.seq2Range.start + c, a.seq2Range.endExclusive + c)); c++)
        ;
      if (c === l) {
        i[o + 1] = new mi(new Ne(a.seq1Range.start + l, r.seq1Range.endExclusive), new Ne(a.seq2Range.start + l, r.seq2Range.endExclusive));
        continue;
      }
      c > 0 && (a = a.delta(c));
    }
    n.push(a);
  }
  return i.length > 0 && n.push(i[i.length - 1]), n;
}
function lie(s, e, t) {
  if (!s.getBoundaryScore || !e.getBoundaryScore)
    return t;
  for (let i = 0; i < t.length; i++) {
    const n = i > 0 ? t[i - 1] : void 0, o = t[i], r = i + 1 < t.length ? t[i + 1] : void 0, a = new Ne(n ? n.seq1Range.endExclusive + 1 : 0, r ? r.seq1Range.start - 1 : s.length), l = new Ne(n ? n.seq2Range.endExclusive + 1 : 0, r ? r.seq2Range.start - 1 : e.length);
    o.seq1Range.isEmpty ? t[i] = JR(o, s, e, a, l) : o.seq2Range.isEmpty && (t[i] = JR(o.swap(), e, s, l, a).swap());
  }
  return t;
}
function JR(s, e, t, i, n) {
  let r = 1;
  for (; s.seq1Range.start - r >= i.start && s.seq2Range.start - r >= n.start && t.isStronglyEqual(s.seq2Range.start - r, s.seq2Range.endExclusive - r) && r < 100; )
    r++;
  r--;
  let a = 0;
  for (; s.seq1Range.start + a < i.endExclusive && s.seq2Range.endExclusive + a < n.endExclusive && t.isStronglyEqual(s.seq2Range.start + a, s.seq2Range.endExclusive + a) && a < 100; )
    a++;
  if (r === 0 && a === 0)
    return s;
  let l = 0, c = -1;
  for (let h = -r; h <= a; h++) {
    const d = s.seq2Range.start + h, u = s.seq2Range.endExclusive + h, f = s.seq1Range.start + h, g = e.getBoundaryScore(f) + t.getBoundaryScore(d) + t.getBoundaryScore(u);
    g > c && (c = g, l = h);
  }
  return s.delta(l);
}
function cie(s, e, t) {
  const i = [];
  for (const n of t) {
    const o = i[i.length - 1];
    if (!o) {
      i.push(n);
      continue;
    }
    n.seq1Range.start - o.seq1Range.endExclusive <= 2 || n.seq2Range.start - o.seq2Range.endExclusive <= 2 ? i[i.length - 1] = new mi(o.seq1Range.join(n.seq1Range), o.seq2Range.join(n.seq2Range)) : i.push(n);
  }
  return i;
}
function hie(s, e, t) {
  const i = mi.invert(t, s.length), n = [];
  let o = new Ta(0, 0);
  function r(l, c) {
    if (l.offset1 < o.offset1 || l.offset2 < o.offset2)
      return;
    const h = s.findWordContaining(l.offset1), d = e.findWordContaining(l.offset2);
    if (!h || !d)
      return;
    let u = new mi(h, d);
    const f = u.intersect(c);
    let g = f.seq1Range.length, p = f.seq2Range.length;
    for (; i.length > 0; ) {
      const _ = i[0];
      if (!(_.seq1Range.intersects(u.seq1Range) || _.seq2Range.intersects(u.seq2Range)))
        break;
      const C = s.findWordContaining(_.seq1Range.start), w = e.findWordContaining(_.seq2Range.start), v = new mi(C, w), S = v.intersect(_);
      if (g += S.seq1Range.length, p += S.seq2Range.length, u = u.join(v), u.seq1Range.endExclusive >= _.seq1Range.endExclusive)
        i.shift();
      else
        break;
    }
    g + p < (u.seq1Range.length + u.seq2Range.length) * 2 / 3 && n.push(u), o = u.getEndExclusives();
  }
  for (; i.length > 0; ) {
    const l = i.shift();
    l.seq1Range.isEmpty || (r(l.getStarts(), l), r(l.getEndExclusives().delta(-1), l));
  }
  return die(t, n);
}
function die(s, e) {
  const t = [];
  for (; s.length > 0 || e.length > 0; ) {
    const i = s[0], n = e[0];
    let o;
    i && (!n || i.seq1Range.start < n.seq1Range.start) ? o = s.shift() : o = e.shift(), t.length > 0 && t[t.length - 1].seq1Range.endExclusive >= o.seq1Range.start ? t[t.length - 1] = t[t.length - 1].join(o) : t.push(o);
  }
  return t;
}
function uie(s, e, t) {
  let i = t;
  if (i.length === 0)
    return i;
  let n = 0, o;
  do {
    o = !1;
    const r = [
      i[0]
    ];
    for (let a = 1; a < i.length; a++) {
      let h = function(u, f) {
        const g = new Ne(c.seq1Range.endExclusive, l.seq1Range.start);
        return s.getText(g).replace(/\s/g, "").length <= 4 && (u.seq1Range.length + u.seq2Range.length > 5 || f.seq1Range.length + f.seq2Range.length > 5);
      };
      const l = i[a], c = r[r.length - 1];
      h(c, l) ? (o = !0, r[r.length - 1] = r[r.length - 1].join(l)) : r.push(l);
    }
    i = r;
  } while (n++ < 10 && o);
  return i;
}
function fie(s, e, t) {
  let i = t;
  if (i.length === 0)
    return i;
  let n = 0, o;
  do {
    o = !1;
    const a = [
      i[0]
    ];
    for (let l = 1; l < i.length; l++) {
      let d = function(f, g) {
        const p = new Ne(h.seq1Range.endExclusive, c.seq1Range.start);
        if (s.countLinesIn(p) > 5 || p.length > 500)
          return !1;
        const b = s.getText(p).trim();
        if (b.length > 20 || b.split(/\r\n|\r|\n/).length > 1)
          return !1;
        const C = s.countLinesIn(f.seq1Range), w = f.seq1Range.length, v = e.countLinesIn(f.seq2Range), S = f.seq2Range.length, L = s.countLinesIn(g.seq1Range), k = g.seq1Range.length, x = e.countLinesIn(g.seq2Range), I = g.seq2Range.length, K = 2 * 40 + 50;
        function B(W) {
          return Math.min(W, K);
        }
        return Math.pow(Math.pow(B(C * 40 + w), 1.5) + Math.pow(B(v * 40 + S), 1.5), 1.5) + Math.pow(Math.pow(B(L * 40 + k), 1.5) + Math.pow(B(x * 40 + I), 1.5), 1.5) > (K ** 1.5) ** 1.5 * 1.3;
      };
      const c = i[l], h = a[a.length - 1];
      d(h, c) ? (o = !0, a[a.length - 1] = a[a.length - 1].join(c)) : a.push(c);
    }
    i = a;
  } while (n++ < 10 && o);
  const r = [];
  return tW(i, (a, l, c) => {
    let h = l;
    function d(b) {
      return b.length > 0 && b.trim().length <= 3 && l.seq1Range.length + l.seq2Range.length > 100;
    }
    const u = s.extendToFullLines(l.seq1Range), f = s.getText(new Ne(u.start, l.seq1Range.start));
    d(f) && (h = h.deltaStart(-f.length));
    const g = s.getText(new Ne(l.seq1Range.endExclusive, u.endExclusive));
    d(g) && (h = h.deltaEnd(g.length));
    const p = mi.fromOffsetPairs(a ? a.getEndExclusives() : Ta.zero, c ? c.getStarts() : Ta.max), _ = h.intersect(p);
    r.length > 0 && _.getStarts().equals(r[r.length - 1].getEndExclusives()) ? r[r.length - 1] = r[r.length - 1].join(_) : r.push(_);
  }), r;
}
class eA {
  constructor(e, t) {
    this.trimmedHash = e, this.lines = t;
  }
  getElement(e) {
    return this.trimmedHash[e];
  }
  get length() {
    return this.trimmedHash.length;
  }
  getBoundaryScore(e) {
    const t = e === 0 ? 0 : tA(this.lines[e - 1]), i = e === this.lines.length ? 0 : tA(this.lines[e]);
    return 1e3 - (t + i);
  }
  getText(e) {
    return this.lines.slice(e.start, e.endExclusive).join(`
`);
  }
  isStronglyEqual(e, t) {
    return this.lines[e] === this.lines[t];
  }
}
function tA(s) {
  let e = 0;
  for (; e < s.length && (s.charCodeAt(e) === 32 || s.charCodeAt(e) === 9); )
    e++;
  return e;
}
class t3 {
  constructor() {
    this.dynamicProgrammingDiffing = new Qte(), this.myersDiffingAlgorithm = new e3();
  }
  computeDiff(e, t, i) {
    if (e.length <= 1 && li(e, t, (S, L) => S === L))
      return new Sb([], [], !1);
    if (e.length === 1 && e[0].length === 0 || t.length === 1 && t[0].length === 0)
      return new Sb([
        new Ls(new pe(1, e.length + 1), new pe(1, t.length + 1), [
          new gs(new T(1, 1, e.length, e[e.length - 1].length + 1), new T(1, 1, t.length, t[t.length - 1].length + 1))
        ])
      ], [], !1);
    const n = i.maxComputationTimeMs === 0 ? _p.instance : new Xte(i.maxComputationTimeMs), o = !i.ignoreTrimWhitespace, r = /* @__PURE__ */ new Map();
    function a(S) {
      let L = r.get(S);
      return L === void 0 && (L = r.size, r.set(S, L)), L;
    }
    const l = e.map((S) => a(S.trim())), c = t.map((S) => a(S.trim())), h = new eA(l, e), d = new eA(c, t), u = h.length + d.length < 1700 ? this.dynamicProgrammingDiffing.compute(h, d, n, (S, L) => e[S] === t[L] ? t[L].length === 0 ? 0.1 : 1 + Math.log(1 + t[L].length) : 0.99) : this.myersDiffingAlgorithm.compute(h, d, n);
    let f = u.diffs, g = u.hitTimeout;
    f = Lx(h, d, f), f = uie(h, d, f);
    const p = [], _ = (S) => {
      if (o)
        for (let L = 0; L < S; L++) {
          const k = b + L, x = C + L;
          if (e[k] !== t[x]) {
            const I = this.refineDiff(e, t, new mi(new Ne(k, k + 1), new Ne(x, x + 1)), n, o);
            for (const K of I.mappings)
              p.push(K);
            I.hitTimeout && (g = !0);
          }
        }
    };
    let b = 0, C = 0;
    for (const S of f) {
      Wh(() => S.seq1Range.start - b === S.seq2Range.start - C);
      const L = S.seq1Range.start - b;
      _(L), b = S.seq1Range.endExclusive, C = S.seq2Range.endExclusive;
      const k = this.refineDiff(e, t, S, n, o);
      k.hitTimeout && (g = !0);
      for (const x of k.mappings)
        p.push(x);
    }
    _(e.length - b);
    const w = iA(p, e, t);
    let v = [];
    return i.computeMoves && (v = this.computeMoves(w, e, t, l, c, n, o)), Wh(() => {
      function S(k, x) {
        if (k.lineNumber < 1 || k.lineNumber > x.length)
          return !1;
        const I = x[k.lineNumber - 1];
        return !(k.column < 1 || k.column > I.length + 1);
      }
      function L(k, x) {
        return !(k.startLineNumber < 1 || k.startLineNumber > x.length + 1 || k.endLineNumberExclusive < 1 || k.endLineNumberExclusive > x.length + 1);
      }
      for (const k of w) {
        if (!k.innerChanges)
          return !1;
        for (const x of k.innerChanges)
          if (!(S(x.modifiedRange.getStartPosition(), t) && S(x.modifiedRange.getEndPosition(), t) && S(x.originalRange.getStartPosition(), e) && S(x.originalRange.getEndPosition(), e)))
            return !1;
        if (!L(k.modified, t) || !L(k.original, e))
          return !1;
      }
      return !0;
    }), new Sb(w, v, g);
  }
  computeMoves(e, t, i, n, o, r, a) {
    return iie(e, t, i, n, o, r).map((h) => {
      const d = this.refineDiff(t, i, new mi(h.original.toOffsetRange(), h.modified.toOffsetRange()), r, a), u = iA(d.mappings, t, i, !0);
      return new X7(h, u);
    });
  }
  refineDiff(e, t, i, n, o) {
    const a = mie(i).toRangeMapping2(e, t), l = new fC(e, a.originalRange, o), c = new fC(t, a.modifiedRange, o), h = l.length + c.length < 500 ? this.dynamicProgrammingDiffing.compute(l, c, n) : this.myersDiffingAlgorithm.compute(l, c, n);
    let d = h.diffs;
    return d = Lx(l, c, d), d = hie(l, c, d), d = cie(l, c, d), d = fie(l, c, d), {
      mappings: d.map((f) => new gs(l.translateRange(f.seq1Range), c.translateRange(f.seq2Range))),
      hitTimeout: h.hitTimeout
    };
  }
}
function iA(s, e, t, i = !1) {
  const n = [];
  for (const o of HE(s.map((r) => gie(r, e, t)), (r, a) => r.original.overlapOrTouch(a.original) || r.modified.overlapOrTouch(a.modified))) {
    const r = o[0], a = o[o.length - 1];
    n.push(new Ls(r.original.join(a.original), r.modified.join(a.modified), o.map((l) => l.innerChanges[0])));
  }
  return Wh(() => !i && n.length > 0 && (n[0].modified.startLineNumber !== n[0].original.startLineNumber || t.length - n[n.length - 1].modified.endLineNumberExclusive !== e.length - n[n.length - 1].original.endLineNumberExclusive) ? !1 : bE(n, (o, r) => r.original.startLineNumber - o.original.endLineNumberExclusive === r.modified.startLineNumber - o.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
  o.original.endLineNumberExclusive < r.original.startLineNumber && o.modified.endLineNumberExclusive < r.modified.startLineNumber)), n;
}
function gie(s, e, t) {
  let i = 0, n = 0;
  s.modifiedRange.endColumn === 1 && s.originalRange.endColumn === 1 && s.originalRange.startLineNumber + i <= s.originalRange.endLineNumber && s.modifiedRange.startLineNumber + i <= s.modifiedRange.endLineNumber && (n = -1), s.modifiedRange.startColumn - 1 >= t[s.modifiedRange.startLineNumber - 1].length && s.originalRange.startColumn - 1 >= e[s.originalRange.startLineNumber - 1].length && s.originalRange.startLineNumber <= s.originalRange.endLineNumber + n && s.modifiedRange.startLineNumber <= s.modifiedRange.endLineNumber + n && (i = 1);
  const o = new pe(s.originalRange.startLineNumber + i, s.originalRange.endLineNumber + 1 + n), r = new pe(s.modifiedRange.startLineNumber + i, s.modifiedRange.endLineNumber + 1 + n);
  return new Ls(o, r, [s]);
}
function mie(s) {
  return new an(new pe(s.seq1Range.start + 1, s.seq1Range.endExclusive + 1), new pe(s.seq2Range.start + 1, s.seq2Range.endExclusive + 1));
}
const nA = {
  getLegacy: () => new qte(),
  getDefault: () => new t3()
};
function i3(s) {
  const e = [];
  for (const t of s) {
    const i = Number(t);
    (i || i === 0 && t.replace(/\s/g, "") !== "") && e.push(i);
  }
  return e;
}
function NN(s, e, t, i) {
  return {
    red: s / 255,
    blue: t / 255,
    green: e / 255,
    alpha: i
  };
}
function lg(s, e) {
  const t = e.index, i = e[0].length;
  if (!t)
    return;
  const n = s.positionAt(t);
  return {
    startLineNumber: n.lineNumber,
    startColumn: n.column,
    endLineNumber: n.lineNumber,
    endColumn: n.column + i
  };
}
function pie(s, e) {
  if (!s)
    return;
  const t = j.Format.CSS.parseHex(e);
  if (t)
    return {
      range: s,
      color: NN(t.rgba.r, t.rgba.g, t.rgba.b, t.rgba.a)
    };
}
function sA(s, e, t) {
  if (!s || e.length !== 1)
    return;
  const n = e[0].values(), o = i3(n);
  return {
    range: s,
    color: NN(o[0], o[1], o[2], t ? o[3] : 1)
  };
}
function oA(s, e, t) {
  if (!s || e.length !== 1)
    return;
  const n = e[0].values(), o = i3(n), r = new j(new to(o[0], o[1] / 100, o[2] / 100, t ? o[3] : 1));
  return {
    range: s,
    color: NN(r.rgba.r, r.rgba.g, r.rgba.b, r.rgba.a)
  };
}
function cg(s, e) {
  return typeof s == "string" ? [...s.matchAll(e)] : s.findMatches(e);
}
function _ie(s) {
  const e = [], i = cg(s, /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm);
  if (i.length > 0)
    for (const n of i) {
      const o = n.filter((c) => c !== void 0), r = o[1], a = o[2];
      if (!a)
        continue;
      let l;
      if (r === "rgb") {
        const c = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm;
        l = sA(lg(s, n), cg(a, c), !1);
      } else if (r === "rgba") {
        const c = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
        l = sA(lg(s, n), cg(a, c), !0);
      } else if (r === "hsl") {
        const c = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm;
        l = oA(lg(s, n), cg(a, c), !1);
      } else if (r === "hsla") {
        const c = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
        l = oA(lg(s, n), cg(a, c), !0);
      } else r === "#" && (l = pie(lg(s, n), r + a));
      l && e.push(l);
    }
  return e;
}
function bie(s) {
  return !s || typeof s.getValue != "function" || typeof s.positionAt != "function" ? [] : _ie(s);
}
const rA = new RegExp("\\bMARK:\\s*(.*)$", "d"), Cie = /^-+|-+$/g;
function vie(s, e) {
  var i;
  let t = [];
  if (e.findRegionSectionHeaders && ((i = e.foldingRules) != null && i.markers)) {
    const n = wie(s, e);
    t = t.concat(n);
  }
  if (e.findMarkSectionHeaders) {
    const n = yie(s);
    t = t.concat(n);
  }
  return t;
}
function wie(s, e) {
  const t = [], i = s.getLineCount();
  for (let n = 1; n <= i; n++) {
    const o = s.getLineContent(n), r = o.match(e.foldingRules.markers.start);
    if (r) {
      const a = { startLineNumber: n, startColumn: r[0].length + 1, endLineNumber: n, endColumn: o.length + 1 };
      if (a.endColumn > a.startColumn) {
        const l = {
          range: a,
          ...n3(o.substring(r[0].length)),
          shouldBeInComments: !1
        };
        (l.text || l.hasSeparatorLine) && t.push(l);
      }
    }
  }
  return t;
}
function yie(s) {
  const e = [], t = s.getLineCount();
  for (let i = 1; i <= t; i++) {
    const n = s.getLineContent(i);
    Sie(n, i, e);
  }
  return e;
}
function Sie(s, e, t) {
  rA.lastIndex = 0;
  const i = rA.exec(s);
  if (i) {
    const n = i.indices[1][0] + 1, o = i.indices[1][1] + 1, r = { startLineNumber: e, startColumn: n, endLineNumber: e, endColumn: o };
    if (r.endColumn > r.startColumn) {
      const a = {
        range: r,
        ...n3(i[1]),
        shouldBeInComments: !0
      };
      (a.text || a.hasSeparatorLine) && t.push(a);
    }
  }
}
function n3(s) {
  s = s.trim();
  const e = s.startsWith("-");
  return s = s.replace(Cie, ""), { text: s, hasSeparatorLine: e };
}
class Lie {
  constructor(e, t, i, n) {
    this._uri = e, this._lines = t, this._eol = i, this._versionId = n, this._lineStarts = null, this._cachedTextValue = null;
  }
  dispose() {
    this._lines.length = 0;
  }
  get version() {
    return this._versionId;
  }
  getText() {
    return this._cachedTextValue === null && (this._cachedTextValue = this._lines.join(this._eol)), this._cachedTextValue;
  }
  onEvents(e) {
    e.eol && e.eol !== this._eol && (this._eol = e.eol, this._lineStarts = null);
    const t = e.changes;
    for (const i of t)
      this._acceptDeleteRange(i.range), this._acceptInsertText(new F(i.range.startLineNumber, i.range.startColumn), i.text);
    this._versionId = e.versionId, this._cachedTextValue = null;
  }
  _ensureLineStarts() {
    if (!this._lineStarts) {
      const e = this._eol.length, t = this._lines.length, i = new Uint32Array(t);
      for (let n = 0; n < t; n++)
        i[n] = this._lines[n].length + e;
      this._lineStarts = new yY(i);
    }
  }
  /**
   * All changes to a line's text go through this method
   */
  _setLineText(e, t) {
    this._lines[e] = t, this._lineStarts && this._lineStarts.setValue(e, this._lines[e].length + this._eol.length);
  }
  _acceptDeleteRange(e) {
    if (e.startLineNumber === e.endLineNumber) {
      if (e.startColumn === e.endColumn)
        return;
      this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.startLineNumber - 1].substring(e.endColumn - 1));
      return;
    }
    this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.endLineNumber - 1].substring(e.endColumn - 1)), this._lines.splice(e.startLineNumber, e.endLineNumber - e.startLineNumber), this._lineStarts && this._lineStarts.removeValues(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, t) {
    if (t.length === 0)
      return;
    const i = td(t);
    if (i.length === 1) {
      this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0] + this._lines[e.lineNumber - 1].substring(e.column - 1));
      return;
    }
    i[i.length - 1] += this._lines[e.lineNumber - 1].substring(e.column - 1), this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0]);
    const n = new Uint32Array(i.length - 1);
    for (let o = 1; o < i.length; o++)
      this._lines.splice(e.lineNumber + o - 1, 0, i[o]), n[o - 1] = i[o].length + this._eol.length;
    this._lineStarts && this._lineStarts.insertValues(e.lineNumber, n);
  }
}
const aA = 60 * 1e3;
class kie extends U {
  constructor(e, t, i = !1) {
    if (super(), this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), this._proxy = e, this._modelService = t, !i) {
      const n = new wE();
      n.cancelAndSet(() => this._checkStopModelSync(), Math.round(aA / 2)), this._register(n);
    }
  }
  dispose() {
    for (const e in this._syncedModels)
      Ft(this._syncedModels[e]);
    this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), super.dispose();
  }
  ensureSyncedResources(e, t = !1) {
    for (const i of e) {
      const n = i.toString();
      this._syncedModels[n] || this._beginModelSync(i, t), this._syncedModels[n] && (this._syncedModelsLastUsedTime[n] = (/* @__PURE__ */ new Date()).getTime());
    }
  }
  _checkStopModelSync() {
    const e = (/* @__PURE__ */ new Date()).getTime(), t = [];
    for (const i in this._syncedModelsLastUsedTime)
      e - this._syncedModelsLastUsedTime[i] > aA && t.push(i);
    for (const i of t)
      this._stopModelSync(i);
  }
  _beginModelSync(e, t) {
    const i = this._modelService.getModel(e);
    if (!i || !t && i.isTooLargeForSyncing())
      return;
    const n = e.toString();
    this._proxy.$acceptNewModel({
      url: i.uri.toString(),
      lines: i.getLinesContent(),
      EOL: i.getEOL(),
      versionId: i.getVersionId()
    });
    const o = new ne();
    o.add(i.onDidChangeContent((r) => {
      this._proxy.$acceptModelChanged(n.toString(), r);
    })), o.add(i.onWillDispose(() => {
      this._stopModelSync(n);
    })), o.add(_e(() => {
      this._proxy.$acceptRemovedModel(n);
    })), this._syncedModels[n] = o;
  }
  _stopModelSync(e) {
    const t = this._syncedModels[e];
    delete this._syncedModels[e], delete this._syncedModelsLastUsedTime[e], Ft(t);
  }
}
class xie {
  constructor() {
    this._models = /* @__PURE__ */ Object.create(null);
  }
  getModel(e) {
    return this._models[e];
  }
  getModels() {
    const e = [];
    return Object.keys(this._models).forEach((t) => e.push(this._models[t])), e;
  }
  $acceptNewModel(e) {
    this._models[e.url] = new Die(we.parse(e.url), e.lines, e.EOL, e.versionId);
  }
  $acceptModelChanged(e, t) {
    if (!this._models[e])
      return;
    this._models[e].onEvents(t);
  }
  $acceptRemovedModel(e) {
    this._models[e] && delete this._models[e];
  }
}
class Die extends Lie {
  get uri() {
    return this._uri;
  }
  get eol() {
    return this._eol;
  }
  getValue() {
    return this.getText();
  }
  findMatches(e) {
    const t = [];
    for (let i = 0; i < this._lines.length; i++) {
      const n = this._lines[i], o = this.offsetAt(new F(i + 1, 1)), r = n.matchAll(e);
      for (const a of r)
        (a.index || a.index === 0) && (a.index = a.index + o), t.push(a);
    }
    return t;
  }
  getLinesContent() {
    return this._lines.slice(0);
  }
  getLineCount() {
    return this._lines.length;
  }
  getLineContent(e) {
    return this._lines[e - 1];
  }
  getWordAtPosition(e, t) {
    const i = Fm(e.column, iI(t), this._lines[e.lineNumber - 1], 0);
    return i ? new T(e.lineNumber, i.startColumn, e.lineNumber, i.endColumn) : null;
  }
  words(e) {
    const t = this._lines, i = this._wordenize.bind(this);
    let n = 0, o = "", r = 0, a = [];
    return {
      *[Symbol.iterator]() {
        for (; ; )
          if (r < a.length) {
            const l = o.substring(a[r].start, a[r].end);
            r += 1, yield l;
          } else if (n < t.length)
            o = t[n], a = i(o, e), r = 0, n += 1;
          else
            break;
      }
    };
  }
  getLineWords(e, t) {
    const i = this._lines[e - 1], n = this._wordenize(i, t), o = [];
    for (const r of n)
      o.push({
        word: i.substring(r.start, r.end),
        startColumn: r.start + 1,
        endColumn: r.end + 1
      });
    return o;
  }
  _wordenize(e, t) {
    const i = [];
    let n;
    for (t.lastIndex = 0; (n = t.exec(e)) && n[0].length !== 0; )
      i.push({ start: n.index, end: n.index + n[0].length });
    return i;
  }
  getValueInRange(e) {
    if (e = this._validateRange(e), e.startLineNumber === e.endLineNumber)
      return this._lines[e.startLineNumber - 1].substring(e.startColumn - 1, e.endColumn - 1);
    const t = this._eol, i = e.startLineNumber - 1, n = e.endLineNumber - 1, o = [];
    o.push(this._lines[i].substring(e.startColumn - 1));
    for (let r = i + 1; r < n; r++)
      o.push(this._lines[r]);
    return o.push(this._lines[n].substring(0, e.endColumn - 1)), o.join(t);
  }
  offsetAt(e) {
    return e = this._validatePosition(e), this._ensureLineStarts(), this._lineStarts.getPrefixSum(e.lineNumber - 2) + (e.column - 1);
  }
  positionAt(e) {
    e = Math.floor(e), e = Math.max(0, e), this._ensureLineStarts();
    const t = this._lineStarts.getIndexOf(e), i = this._lines[t.index].length;
    return {
      lineNumber: 1 + t.index,
      column: 1 + Math.min(t.remainder, i)
    };
  }
  _validateRange(e) {
    const t = this._validatePosition({ lineNumber: e.startLineNumber, column: e.startColumn }), i = this._validatePosition({ lineNumber: e.endLineNumber, column: e.endColumn });
    return t.lineNumber !== e.startLineNumber || t.column !== e.startColumn || i.lineNumber !== e.endLineNumber || i.column !== e.endColumn ? {
      startLineNumber: t.lineNumber,
      startColumn: t.column,
      endLineNumber: i.lineNumber,
      endColumn: i.column
    } : e;
  }
  _validatePosition(e) {
    if (!F.isIPosition(e))
      throw new Error("bad position");
    let { lineNumber: t, column: i } = e, n = !1;
    if (t < 1)
      t = 1, i = 1, n = !0;
    else if (t > this._lines.length)
      t = this._lines.length, i = this._lines[t - 1].length + 1, n = !0;
    else {
      const o = this._lines[t - 1].length + 1;
      i < 1 ? (i = 1, n = !0) : i > o && (i = o, n = !0);
    }
    return n ? { lineNumber: t, column: i } : e;
  }
}
const wv = class wv {
  constructor() {
    this._workerTextModelSyncServer = new xie();
  }
  dispose() {
  }
  _getModel(e) {
    return this._workerTextModelSyncServer.getModel(e);
  }
  _getModels() {
    return this._workerTextModelSyncServer.getModels();
  }
  $acceptNewModel(e) {
    this._workerTextModelSyncServer.$acceptNewModel(e);
  }
  $acceptModelChanged(e, t) {
    this._workerTextModelSyncServer.$acceptModelChanged(e, t);
  }
  $acceptRemovedModel(e) {
    this._workerTextModelSyncServer.$acceptRemovedModel(e);
  }
  async $computeUnicodeHighlights(e, t, i) {
    const n = this._getModel(e);
    return n ? Hte.computeUnicodeHighlights(n, t, i) : { ranges: [], hasMore: !1, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
  }
  async $findSectionHeaders(e, t) {
    const i = this._getModel(e);
    return i ? vie(i, t) : [];
  }
  // ---- BEGIN diff --------------------------------------------------------------------------
  async $computeDiff(e, t, i, n) {
    const o = this._getModel(e), r = this._getModel(t);
    return !o || !r ? null : Lb.computeDiff(o, r, i, n);
  }
  static computeDiff(e, t, i, n) {
    const o = n === "advanced" ? nA.getDefault() : nA.getLegacy(), r = e.getLinesContent(), a = t.getLinesContent(), l = o.computeDiff(r, a, i), c = l.changes.length > 0 ? !1 : this._modelsAreIdentical(e, t);
    function h(d) {
      return d.map((u) => {
        var f;
        return [u.original.startLineNumber, u.original.endLineNumberExclusive, u.modified.startLineNumber, u.modified.endLineNumberExclusive, (f = u.innerChanges) == null ? void 0 : f.map((g) => [
          g.originalRange.startLineNumber,
          g.originalRange.startColumn,
          g.originalRange.endLineNumber,
          g.originalRange.endColumn,
          g.modifiedRange.startLineNumber,
          g.modifiedRange.startColumn,
          g.modifiedRange.endLineNumber,
          g.modifiedRange.endColumn
        ])];
      });
    }
    return {
      identical: c,
      quitEarly: l.hitTimeout,
      changes: h(l.changes),
      moves: l.moves.map((d) => [
        d.lineRangeMapping.original.startLineNumber,
        d.lineRangeMapping.original.endLineNumberExclusive,
        d.lineRangeMapping.modified.startLineNumber,
        d.lineRangeMapping.modified.endLineNumberExclusive,
        h(d.changes)
      ])
    };
  }
  static _modelsAreIdentical(e, t) {
    const i = e.getLineCount(), n = t.getLineCount();
    if (i !== n)
      return !1;
    for (let o = 1; o <= i; o++) {
      const r = e.getLineContent(o), a = t.getLineContent(o);
      if (r !== a)
        return !1;
    }
    return !0;
  }
  async $computeMoreMinimalEdits(e, t, i) {
    const n = this._getModel(e);
    if (!n)
      return t;
    const o = [];
    let r;
    t = t.slice(0).sort((l, c) => {
      if (l.range && c.range)
        return T.compareRangesUsingStarts(l.range, c.range);
      const h = l.range ? 0 : 1, d = c.range ? 0 : 1;
      return h - d;
    });
    let a = 0;
    for (let l = 1; l < t.length; l++)
      T.getEndPosition(t[a].range).equals(T.getStartPosition(t[l].range)) ? (t[a].range = T.fromPositions(T.getStartPosition(t[a].range), T.getEndPosition(t[l].range)), t[a].text += t[l].text) : (a++, t[a] = t[l]);
    t.length = a + 1;
    for (let { range: l, text: c, eol: h } of t) {
      if (typeof h == "number" && (r = h), T.isEmpty(l) && !c)
        continue;
      const d = n.getValueInRange(l);
      if (c = c.replace(/\r\n|\n|\r/g, n.eol), d === c)
        continue;
      if (Math.max(c.length, d.length) > Lb._diffLimit) {
        o.push({ range: l, text: c });
        continue;
      }
      const u = qX(d, c, i), f = n.offsetAt(T.lift(l).getStartPosition());
      for (const g of u) {
        const p = n.positionAt(f + g.originalStart), _ = n.positionAt(f + g.originalStart + g.originalLength), b = {
          text: c.substr(g.modifiedStart, g.modifiedLength),
          range: { startLineNumber: p.lineNumber, startColumn: p.column, endLineNumber: _.lineNumber, endColumn: _.column }
        };
        n.getValueInRange(b.range) !== b.text && o.push(b);
      }
    }
    return typeof r == "number" && o.push({ eol: r, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } }), o;
  }
  // ---- END minimal edits ---------------------------------------------------------------
  async $computeLinks(e) {
    const t = this._getModel(e);
    return t ? Wte(t) : null;
  }
  // --- BEGIN default document colors -----------------------------------------------------------
  async $computeDefaultDocumentColors(e) {
    const t = this._getModel(e);
    return t ? bie(t) : null;
  }
  async $textualSuggest(e, t, i, n) {
    const o = new Ga(), r = new RegExp(i, n), a = /* @__PURE__ */ new Set();
    e: for (const l of e) {
      const c = this._getModel(l);
      if (c) {
        for (const h of c.words(r))
          if (!(h === t || !isNaN(Number(h))) && (a.add(h), a.size > Lb._suggestionsLimit))
            break e;
      }
    }
    return { words: Array.from(a), duration: o.elapsed() };
  }
  // ---- END suggest --------------------------------------------------------------------------
  //#region -- word ranges --
  async $computeWordRanges(e, t, i, n) {
    const o = this._getModel(e);
    if (!o)
      return /* @__PURE__ */ Object.create(null);
    const r = new RegExp(i, n), a = /* @__PURE__ */ Object.create(null);
    for (let l = t.startLineNumber; l < t.endLineNumber; l++) {
      const c = o.getLineWords(l, r);
      for (const h of c) {
        if (!isNaN(Number(h.word)))
          continue;
        let d = a[h.word];
        d || (d = [], a[h.word] = d), d.push({
          startLineNumber: l,
          startColumn: h.startColumn,
          endLineNumber: l,
          endColumn: h.endColumn
        });
      }
    }
    return a;
  }
  //#endregion
  async $navigateValueSet(e, t, i, n, o) {
    const r = this._getModel(e);
    if (!r)
      return null;
    const a = new RegExp(n, o);
    t.startColumn === t.endColumn && (t = {
      startLineNumber: t.startLineNumber,
      startColumn: t.startColumn,
      endLineNumber: t.endLineNumber,
      endColumn: t.endColumn + 1
    });
    const l = r.getValueInRange(t), c = r.getWordAtPosition({ lineNumber: t.startLineNumber, column: t.startColumn }, a);
    if (!c)
      return null;
    const h = r.getValueInRange(c);
    return Cx.INSTANCE.navigateValueSet(t, l, c, h, i);
  }
};
wv._diffLimit = 1e5, wv._suggestionsLimit = 1e4;
let kx = wv;
class Lb extends kx {
  constructor(e, t) {
    super(), this._host = e, this._foreignModuleFactory = t, this._foreignModule = null;
  }
  async $ping() {
    return "pong";
  }
  // ---- BEGIN foreign module support --------------------------------------------------------------------------
  $loadForeignModule(e, t, i) {
    const r = {
      host: xW(i, (a, l) => this._host.$fhr(a, l)),
      getMirrorModels: () => this._getModels()
    };
    return this._foreignModuleFactory ? (this._foreignModule = this._foreignModuleFactory(r, t), Promise.resolve(fS(this._foreignModule))) : new Promise((a, l) => {
      const c = (h) => {
        this._foreignModule = h.create(r, t), a(fS(this._foreignModule));
      };
      import(`${Yv.asBrowserUri(`${e}.js`).toString(!0)}`).then(c).catch(l);
    });
  }
  // foreign method request
  $fmr(e, t) {
    if (!this._foreignModule || typeof this._foreignModule[e] != "function")
      return Promise.reject(new Error("Missing requestHandler or method: " + e));
    try {
      return Promise.resolve(this._foreignModule[e].apply(this._foreignModule, t));
    } catch (i) {
      return Promise.reject(i);
    }
  }
}
typeof importScripts == "function" && (globalThis.monaco = G7());
const TN = Be("textResourceConfigurationService"), s3 = Be("textResourcePropertiesService");
var MN = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Wc = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const lA = 5 * 60 * 1e3;
function Hc(s, e) {
  const t = s.getModel(e);
  return !(!t || t.isTooLargeForSyncing());
}
let xx = class extends U {
  constructor(e, t, i, n, o, r) {
    super(), this._languageConfigurationService = o, this._modelService = t, this._workerManager = this._register(new Dx(e, this._modelService)), this._logService = n, this._register(r.linkProvider.register({ language: "*", hasAccessToAllModels: !0 }, {
      provideLinks: async (a, l) => {
        if (!Hc(this._modelService, a.uri))
          return Promise.resolve({ links: [] });
        const h = await (await this._workerWithResources([a.uri])).$computeLinks(a.uri.toString());
        return h && { links: h };
      }
    })), this._register(r.completionProvider.register("*", new Eie(this._workerManager, i, this._modelService, this._languageConfigurationService)));
  }
  dispose() {
    super.dispose();
  }
  canComputeUnicodeHighlights(e) {
    return Hc(this._modelService, e);
  }
  async computedUnicodeHighlights(e, t, i) {
    return (await this._workerWithResources([e])).$computeUnicodeHighlights(e.toString(), t, i);
  }
  async computeDiff(e, t, i, n) {
    const r = await (await this._workerWithResources(
      [e, t],
      /* forceLargeModels */
      !0
    )).$computeDiff(e.toString(), t.toString(), i, n);
    if (!r)
      return null;
    return {
      identical: r.identical,
      quitEarly: r.quitEarly,
      changes: l(r.changes),
      moves: r.moves.map((c) => new X7(new an(new pe(c[0], c[1]), new pe(c[2], c[3])), l(c[4])))
    };
    function l(c) {
      return c.map((h) => {
        var d;
        return new Ls(new pe(h[0], h[1]), new pe(h[2], h[3]), (d = h[4]) == null ? void 0 : d.map((u) => new gs(new T(u[0], u[1], u[2], u[3]), new T(u[4], u[5], u[6], u[7]))));
      });
    }
  }
  async computeMoreMinimalEdits(e, t, i = !1) {
    if (co(t)) {
      if (!Hc(this._modelService, e))
        return Promise.resolve(t);
      const n = Ga.create(), o = this._workerWithResources([e]).then((r) => r.$computeMoreMinimalEdits(e.toString(), t, i));
      return o.finally(() => this._logService.trace("FORMAT#computeMoreMinimalEdits", e.toString(!0), n.elapsed())), Promise.race([o, Em(1e3).then(() => t)]);
    } else
      return Promise.resolve(void 0);
  }
  canNavigateValueSet(e) {
    return Hc(this._modelService, e);
  }
  async navigateValueSet(e, t, i) {
    const n = this._modelService.getModel(e);
    if (!n)
      return null;
    const o = this._languageConfigurationService.getLanguageConfiguration(n.getLanguageId()).getWordDefinition(), r = o.source, a = o.flags;
    return (await this._workerWithResources([e])).$navigateValueSet(e.toString(), t, i, r, a);
  }
  canComputeWordRanges(e) {
    return Hc(this._modelService, e);
  }
  async computeWordRanges(e, t) {
    const i = this._modelService.getModel(e);
    if (!i)
      return Promise.resolve(null);
    const n = this._languageConfigurationService.getLanguageConfiguration(i.getLanguageId()).getWordDefinition(), o = n.source, r = n.flags;
    return (await this._workerWithResources([e])).$computeWordRanges(e.toString(), t, o, r);
  }
  async findSectionHeaders(e, t) {
    return (await this._workerWithResources([e])).$findSectionHeaders(e.toString(), t);
  }
  async computeDefaultDocumentColors(e) {
    return (await this._workerWithResources([e])).$computeDefaultDocumentColors(e.toString());
  }
  async _workerWithResources(e, t = !1) {
    return await (await this._workerManager.withWorker()).workerWithSyncedResources(e, t);
  }
};
xx = MN([
  Wc(1, Ui),
  Wc(2, TN),
  Wc(3, Co),
  Wc(4, ir),
  Wc(5, De)
], xx);
class Eie {
  constructor(e, t, i, n) {
    this.languageConfigurationService = n, this._debugDisplayName = "wordbasedCompletions", this._workerManager = e, this._configurationService = t, this._modelService = i;
  }
  async provideCompletionItems(e, t) {
    const i = this._configurationService.getValue(e.uri, t, "editor");
    if (i.wordBasedSuggestions === "off")
      return;
    const n = [];
    if (i.wordBasedSuggestions === "currentDocument")
      Hc(this._modelService, e.uri) && n.push(e.uri);
    else
      for (const d of this._modelService.getModels())
        Hc(this._modelService, d.uri) && (d === e ? n.unshift(d.uri) : (i.wordBasedSuggestions === "allDocuments" || d.getLanguageId() === e.getLanguageId()) && n.push(d.uri));
    if (n.length === 0)
      return;
    const o = this.languageConfigurationService.getLanguageConfiguration(e.getLanguageId()).getWordDefinition(), r = e.getWordAtPosition(t), a = r ? new T(t.lineNumber, r.startColumn, t.lineNumber, r.endColumn) : T.fromPositions(t), l = a.setEndPosition(t.lineNumber, t.column), h = await (await this._workerManager.withWorker()).textualSuggest(n, r == null ? void 0 : r.word, o);
    if (h)
      return {
        duration: h.duration,
        suggestions: h.words.map((d) => ({
          kind: 18,
          label: d,
          insertText: d,
          range: { insert: l, replace: a }
        }))
      };
  }
}
let Dx = class extends U {
  constructor(e, t) {
    super(), this._workerDescriptor = e, this._modelService = t, this._editorWorkerClient = null, this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime(), this._register(new LE()).cancelAndSet(() => this._checkStopIdleWorker(), Math.round(lA / 2), pt), this._register(this._modelService.onModelRemoved((n) => this._checkStopEmptyWorker()));
  }
  dispose() {
    this._editorWorkerClient && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null), super.dispose();
  }
  /**
   * Check if the model service has no more models and stop the worker if that is the case.
   */
  _checkStopEmptyWorker() {
    if (!this._editorWorkerClient)
      return;
    this._modelService.getModels().length === 0 && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
  }
  /**
   * Check if the worker has been idle for a while and then stop it.
   */
  _checkStopIdleWorker() {
    if (!this._editorWorkerClient)
      return;
    (/* @__PURE__ */ new Date()).getTime() - this._lastWorkerUsedTime > lA && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
  }
  withWorker() {
    return this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime(), this._editorWorkerClient || (this._editorWorkerClient = new gC(this._workerDescriptor, !1, this._modelService)), Promise.resolve(this._editorWorkerClient);
  }
};
Dx = MN([
  Wc(1, Ui)
], Dx);
class Iie {
  constructor(e) {
    this._instance = e, this.proxy = this._instance;
  }
  dispose() {
    this._instance.dispose();
  }
  setChannel(e, t) {
    throw new Error("Not supported");
  }
}
let gC = class extends U {
  constructor(e, t, i) {
    super(), this._workerDescriptor = e, this._disposed = !1, this._modelService = i, this._keepIdleModels = t, this._worker = null, this._modelManager = null;
  }
  // foreign host request
  fhr(e, t) {
    throw new Error("Not implemented!");
  }
  _getOrCreateWorker() {
    if (!this._worker)
      try {
        this._worker = this._register(Ate(this._workerDescriptor)), vx.setChannel(this._worker, this._createEditorWorkerHost());
      } catch (e) {
        _x(e), this._worker = this._createFallbackLocalWorker();
      }
    return this._worker;
  }
  async _getProxy() {
    try {
      const e = this._getOrCreateWorker().proxy;
      return await e.$ping(), e;
    } catch (e) {
      return _x(e), this._worker = this._createFallbackLocalWorker(), this._worker.proxy;
    }
  }
  _createFallbackLocalWorker() {
    return new Iie(new Lb(this._createEditorWorkerHost(), null));
  }
  _createEditorWorkerHost() {
    return {
      $fhr: (e, t) => this.fhr(e, t)
    };
  }
  _getOrCreateModelManager(e) {
    return this._modelManager || (this._modelManager = this._register(new kie(e, this._modelService, this._keepIdleModels))), this._modelManager;
  }
  async workerWithSyncedResources(e, t = !1) {
    if (this._disposed)
      return Promise.reject(G9());
    const i = await this._getProxy();
    return this._getOrCreateModelManager(i).ensureSyncedResources(e, t), i;
  }
  async textualSuggest(e, t, i) {
    const n = await this.workerWithSyncedResources(e), o = i.source, r = i.flags;
    return n.$textualSuggest(e.map((a) => a.toString()), t, o, r);
  }
  dispose() {
    super.dispose(), this._disposed = !0;
  }
};
gC = MN([
  Wc(2, Ui)
], gC);
var Nie = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Tie = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Ex = class extends U {
  constructor(e) {
    super(), this._themeService = e, this._onWillCreateCodeEditor = this._register(new A()), this._onCodeEditorAdd = this._register(new A()), this.onCodeEditorAdd = this._onCodeEditorAdd.event, this._onCodeEditorRemove = this._register(new A()), this.onCodeEditorRemove = this._onCodeEditorRemove.event, this._onWillCreateDiffEditor = this._register(new A()), this._onDiffEditorAdd = this._register(new A()), this.onDiffEditorAdd = this._onDiffEditorAdd.event, this._onDiffEditorRemove = this._register(new A()), this.onDiffEditorRemove = this._onDiffEditorRemove.event, this._decorationOptionProviders = /* @__PURE__ */ new Map(), this._codeEditorOpenHandlers = new Tn(), this._modelProperties = /* @__PURE__ */ new Map(), this._codeEditors = /* @__PURE__ */ Object.create(null), this._diffEditors = /* @__PURE__ */ Object.create(null), this._globalStyleSheet = null;
  }
  willCreateCodeEditor() {
    this._onWillCreateCodeEditor.fire();
  }
  addCodeEditor(e) {
    this._codeEditors[e.getId()] = e, this._onCodeEditorAdd.fire(e);
  }
  removeCodeEditor(e) {
    delete this._codeEditors[e.getId()] && this._onCodeEditorRemove.fire(e);
  }
  listCodeEditors() {
    return Object.keys(this._codeEditors).map((e) => this._codeEditors[e]);
  }
  willCreateDiffEditor() {
    this._onWillCreateDiffEditor.fire();
  }
  addDiffEditor(e) {
    this._diffEditors[e.getId()] = e, this._onDiffEditorAdd.fire(e);
  }
  listDiffEditors() {
    return Object.keys(this._diffEditors).map((e) => this._diffEditors[e]);
  }
  getFocusedCodeEditor() {
    let e = null;
    const t = this.listCodeEditors();
    for (const i of t) {
      if (i.hasTextFocus())
        return i;
      i.hasWidgetFocus() && (e = i);
    }
    return e;
  }
  removeDecorationType(e) {
    const t = this._decorationOptionProviders.get(e);
    t && (t.refCount--, t.refCount <= 0 && (this._decorationOptionProviders.delete(e), t.dispose(), this.listCodeEditors().forEach((i) => i.removeDecorationsByType(e))));
  }
  setModelProperty(e, t, i) {
    const n = e.toString();
    let o;
    this._modelProperties.has(n) ? o = this._modelProperties.get(n) : (o = /* @__PURE__ */ new Map(), this._modelProperties.set(n, o)), o.set(t, i);
  }
  getModelProperty(e, t) {
    const i = e.toString();
    if (this._modelProperties.has(i))
      return this._modelProperties.get(i).get(t);
  }
  async openCodeEditor(e, t, i) {
    for (const n of this._codeEditorOpenHandlers) {
      const o = await n(e, t, i);
      if (o !== null)
        return o;
    }
    return null;
  }
  registerCodeEditorOpenHandler(e) {
    const t = this._codeEditorOpenHandlers.unshift(e);
    return _e(t);
  }
};
Ex = Nie([
  Tie(0, wn)
], Ex);
var Mie = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, cA = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let mC = class extends Ex {
  constructor(e, t) {
    super(t), this._register(this.onCodeEditorAdd(() => this._checkContextKey())), this._register(this.onCodeEditorRemove(() => this._checkContextKey())), this._editorIsOpen = e.createKey("editorIsOpen", !1), this._activeCodeEditor = null, this._register(this.registerCodeEditorOpenHandler(async (i, n, o) => n ? this.doOpenEditor(n, i) : null));
  }
  _checkContextKey() {
    let e = !1;
    for (const t of this.listCodeEditors())
      if (!t.isSimpleWidget) {
        e = !0;
        break;
      }
    this._editorIsOpen.set(e);
  }
  setActiveCodeEditor(e) {
    this._activeCodeEditor = e;
  }
  getActiveCodeEditor() {
    return this._activeCodeEditor;
  }
  doOpenEditor(e, t) {
    if (!this.findModel(e, t.resource)) {
      if (t.resource) {
        const o = t.resource.scheme;
        if (o === Ie.http || o === Ie.https)
          return $4(t.resource.toString()), e;
      }
      return null;
    }
    const n = t.options ? t.options.selection : null;
    if (n)
      if (typeof n.endLineNumber == "number" && typeof n.endColumn == "number")
        e.setSelection(n), e.revealRangeInCenter(
          n,
          1
          /* ScrollType.Immediate */
        );
      else {
        const o = {
          lineNumber: n.startLineNumber,
          column: n.startColumn
        };
        e.setPosition(o), e.revealPositionInCenter(
          o,
          1
          /* ScrollType.Immediate */
        );
      }
    return e;
  }
  findModel(e, t) {
    const i = e.getModel();
    return i && i.uri.toString() !== t.toString() ? null : i;
  }
};
mC = Mie([
  cA(0, Fe),
  cA(1, wn)
], mC);
Ze(
  Tt,
  mC,
  0
  /* InstantiationType.Eager */
);
const oc = Be("layoutService");
var o3 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, r3 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let pC = class {
  get mainContainer() {
    var e;
    return ((e = VE(this._codeEditorService.listCodeEditors())) == null ? void 0 : e.getContainerDomNode()) ?? pt.document.body;
  }
  get activeContainer() {
    const e = this._codeEditorService.getFocusedCodeEditor() ?? this._codeEditorService.getActiveCodeEditor();
    return (e == null ? void 0 : e.getContainerDomNode()) ?? this.mainContainer;
  }
  get mainContainerDimension() {
    return Im(this.mainContainer);
  }
  get activeContainerDimension() {
    return Im(this.activeContainer);
  }
  get containers() {
    return Rf(this._codeEditorService.listCodeEditors().map((e) => e.getContainerDomNode()));
  }
  getContainer() {
    return this.activeContainer;
  }
  whenContainerStylesLoaded() {
  }
  focus() {
    var e;
    (e = this._codeEditorService.getFocusedCodeEditor()) == null || e.focus();
  }
  constructor(e) {
    this._codeEditorService = e, this.onDidLayoutMainContainer = ee.None, this.onDidLayoutActiveContainer = ee.None, this.onDidLayoutContainer = ee.None, this.onDidChangeActiveContainer = ee.None, this.onDidAddContainer = ee.None, this.mainContainerOffset = { top: 0, quickPickTop: 0 }, this.activeContainerOffset = { top: 0, quickPickTop: 0 };
  }
};
pC = o3([
  r3(0, Tt)
], pC);
let Ix = class extends pC {
  get mainContainer() {
    return this._container;
  }
  constructor(e, t) {
    super(t), this._container = e;
  }
};
Ix = o3([
  r3(1, Tt)
], Ix);
Ze(
  oc,
  pC,
  1
  /* InstantiationType.Delayed */
);
const a3 = Be("dialogService");
var Rie = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, hA = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
function O_(s) {
  return s.scheme === Ie.file ? s.fsPath : s.path;
}
let l3 = 0;
class F_ {
  constructor(e, t, i, n, o, r, a) {
    this.id = ++l3, this.type = 0, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || !1, this.resourceLabel = t, this.strResource = i, this.resourceLabels = [this.resourceLabel], this.strResources = [this.strResource], this.groupId = n, this.groupOrder = o, this.sourceId = r, this.sourceOrder = a, this.isValid = !0;
  }
  setValid(e) {
    this.isValid = e;
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? "  VALID" : "INVALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
}
class dA {
  constructor(e, t) {
    this.resourceLabel = e, this.reason = t;
  }
}
class uA {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  createMessage() {
    const e = [], t = [];
    for (const [, n] of this.elements)
      (n.reason === 0 ? e : t).push(n.resourceLabel);
    const i = [];
    return e.length > 0 && i.push(m({ key: "externalRemoval", comment: ["{0} is a list of filenames"] }, "The following files have been closed and modified on disk: {0}.", e.join(", "))), t.length > 0 && i.push(m({ key: "noParallelUniverses", comment: ["{0} is a list of filenames"] }, "The following files have been modified in an incompatible way: {0}.", t.join(", "))), i.join(`
`);
  }
  get size() {
    return this.elements.size;
  }
  has(e) {
    return this.elements.has(e);
  }
  set(e, t) {
    this.elements.set(e, t);
  }
  delete(e) {
    return this.elements.delete(e);
  }
}
class Aie {
  constructor(e, t, i, n, o, r, a) {
    this.id = ++l3, this.type = 1, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || !1, this.resourceLabels = t, this.strResources = i, this.groupId = n, this.groupOrder = o, this.sourceId = r, this.sourceOrder = a, this.removedResources = null, this.invalidatedResources = null;
  }
  canSplit() {
    return typeof this.actual.split == "function";
  }
  removeResource(e, t, i) {
    this.removedResources || (this.removedResources = new uA()), this.removedResources.has(t) || this.removedResources.set(t, new dA(e, i));
  }
  setValid(e, t, i) {
    i ? this.invalidatedResources && (this.invalidatedResources.delete(t), this.invalidatedResources.size === 0 && (this.invalidatedResources = null)) : (this.invalidatedResources || (this.invalidatedResources = new uA()), this.invalidatedResources.has(t) || this.invalidatedResources.set(t, new dA(
      e,
      0
      /* RemovedResourceReason.ExternalRemoval */
    )));
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? "INVALID" : "  VALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
}
class c3 {
  constructor(e, t) {
    this.resourceLabel = e, this.strResource = t, this._past = [], this._future = [], this.locked = !1, this.versionId = 1;
  }
  dispose() {
    for (const e of this._past)
      e.type === 1 && e.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* RemovedResourceReason.ExternalRemoval */
      );
    for (const e of this._future)
      e.type === 1 && e.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* RemovedResourceReason.ExternalRemoval */
      );
    this.versionId++;
  }
  toString() {
    const e = [];
    e.push(`* ${this.strResource}:`);
    for (let t = 0; t < this._past.length; t++)
      e.push(`   * [UNDO] ${this._past[t]}`);
    for (let t = this._future.length - 1; t >= 0; t--)
      e.push(`   * [REDO] ${this._future[t]}`);
    return e.join(`
`);
  }
  flushAllElements() {
    this._past = [], this._future = [], this.versionId++;
  }
  _setElementValidFlag(e, t) {
    e.type === 1 ? e.setValid(this.resourceLabel, this.strResource, t) : e.setValid(t);
  }
  setElementsValidFlag(e, t) {
    for (const i of this._past)
      t(i.actual) && this._setElementValidFlag(i, e);
    for (const i of this._future)
      t(i.actual) && this._setElementValidFlag(i, e);
  }
  pushElement(e) {
    for (const t of this._future)
      t.type === 1 && t.removeResource(
        this.resourceLabel,
        this.strResource,
        1
        /* RemovedResourceReason.NoParallelUniverses */
      );
    this._future = [], this._past.push(e), this.versionId++;
  }
  createSnapshot(e) {
    const t = [];
    for (let i = 0, n = this._past.length; i < n; i++)
      t.push(this._past[i].id);
    for (let i = this._future.length - 1; i >= 0; i--)
      t.push(this._future[i].id);
    return new vF(e, t);
  }
  restoreSnapshot(e) {
    const t = e.elements.length;
    let i = !0, n = 0, o = -1;
    for (let a = 0, l = this._past.length; a < l; a++, n++) {
      const c = this._past[a];
      i && (n >= t || c.id !== e.elements[n]) && (i = !1, o = 0), !i && c.type === 1 && c.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* RemovedResourceReason.ExternalRemoval */
      );
    }
    let r = -1;
    for (let a = this._future.length - 1; a >= 0; a--, n++) {
      const l = this._future[a];
      i && (n >= t || l.id !== e.elements[n]) && (i = !1, r = a), !i && l.type === 1 && l.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* RemovedResourceReason.ExternalRemoval */
      );
    }
    o !== -1 && (this._past = this._past.slice(0, o)), r !== -1 && (this._future = this._future.slice(r + 1)), this.versionId++;
  }
  getElements() {
    const e = [], t = [];
    for (const i of this._past)
      e.push(i.actual);
    for (const i of this._future)
      t.push(i.actual);
    return { past: e, future: t };
  }
  getClosestPastElement() {
    return this._past.length === 0 ? null : this._past[this._past.length - 1];
  }
  getSecondClosestPastElement() {
    return this._past.length < 2 ? null : this._past[this._past.length - 2];
  }
  getClosestFutureElement() {
    return this._future.length === 0 ? null : this._future[this._future.length - 1];
  }
  hasPastElements() {
    return this._past.length > 0;
  }
  hasFutureElements() {
    return this._future.length > 0;
  }
  splitPastWorkspaceElement(e, t) {
    for (let i = this._past.length - 1; i >= 0; i--)
      if (this._past[i] === e) {
        t.has(this.strResource) ? this._past[i] = t.get(this.strResource) : this._past.splice(i, 1);
        break;
      }
    this.versionId++;
  }
  splitFutureWorkspaceElement(e, t) {
    for (let i = this._future.length - 1; i >= 0; i--)
      if (this._future[i] === e) {
        t.has(this.strResource) ? this._future[i] = t.get(this.strResource) : this._future.splice(i, 1);
        break;
      }
    this.versionId++;
  }
  moveBackward(e) {
    this._past.pop(), this._future.push(e), this.versionId++;
  }
  moveForward(e) {
    this._future.pop(), this._past.push(e), this.versionId++;
  }
}
class py {
  constructor(e) {
    this.editStacks = e, this._versionIds = [];
    for (let t = 0, i = this.editStacks.length; t < i; t++)
      this._versionIds[t] = this.editStacks[t].versionId;
  }
  isValid() {
    for (let e = 0, t = this.editStacks.length; e < t; e++)
      if (this._versionIds[e] !== this.editStacks[e].versionId)
        return !1;
    return !0;
  }
}
const h3 = new c3("", "");
h3.locked = !0;
let Nx = class {
  constructor(e, t) {
    this._dialogService = e, this._notificationService = t, this._editStacks = /* @__PURE__ */ new Map(), this._uriComparisonKeyComputers = [];
  }
  getUriComparisonKey(e) {
    for (const t of this._uriComparisonKeyComputers)
      if (t[0] === e.scheme)
        return t[1].getComparisonKey(e);
    return e.toString();
  }
  _print(e) {
    console.log("------------------------------------"), console.log(`AFTER ${e}: `);
    const t = [];
    for (const i of this._editStacks)
      t.push(i[1].toString());
    console.log(t.join(`
`));
  }
  pushElement(e, t = mL.None, i = Oc.None) {
    if (e.type === 0) {
      const n = O_(e.resource), o = this.getUriComparisonKey(e.resource);
      this._pushElement(new F_(e, n, o, t.id, t.nextOrder(), i.id, i.nextOrder()));
    } else {
      const n = /* @__PURE__ */ new Set(), o = [], r = [];
      for (const a of e.resources) {
        const l = O_(a), c = this.getUriComparisonKey(a);
        n.has(c) || (n.add(c), o.push(l), r.push(c));
      }
      o.length === 1 ? this._pushElement(new F_(e, o[0], r[0], t.id, t.nextOrder(), i.id, i.nextOrder())) : this._pushElement(new Aie(e, o, r, t.id, t.nextOrder(), i.id, i.nextOrder()));
    }
  }
  _pushElement(e) {
    for (let t = 0, i = e.strResources.length; t < i; t++) {
      const n = e.resourceLabels[t], o = e.strResources[t];
      let r;
      this._editStacks.has(o) ? r = this._editStacks.get(o) : (r = new c3(n, o), this._editStacks.set(o, r)), r.pushElement(e);
    }
  }
  getLastElement(e) {
    const t = this.getUriComparisonKey(e);
    if (this._editStacks.has(t)) {
      const i = this._editStacks.get(t);
      if (i.hasFutureElements())
        return null;
      const n = i.getClosestPastElement();
      return n ? n.actual : null;
    }
    return null;
  }
  _splitPastWorkspaceElement(e, t) {
    const i = e.actual.split(), n = /* @__PURE__ */ new Map();
    for (const o of i) {
      const r = O_(o.resource), a = this.getUriComparisonKey(o.resource), l = new F_(o, r, a, 0, 0, 0, 0);
      n.set(l.strResource, l);
    }
    for (const o of e.strResources) {
      if (t && t.has(o))
        continue;
      this._editStacks.get(o).splitPastWorkspaceElement(e, n);
    }
  }
  _splitFutureWorkspaceElement(e, t) {
    const i = e.actual.split(), n = /* @__PURE__ */ new Map();
    for (const o of i) {
      const r = O_(o.resource), a = this.getUriComparisonKey(o.resource), l = new F_(o, r, a, 0, 0, 0, 0);
      n.set(l.strResource, l);
    }
    for (const o of e.strResources) {
      if (t && t.has(o))
        continue;
      this._editStacks.get(o).splitFutureWorkspaceElement(e, n);
    }
  }
  removeElements(e) {
    const t = typeof e == "string" ? e : this.getUriComparisonKey(e);
    this._editStacks.has(t) && (this._editStacks.get(t).dispose(), this._editStacks.delete(t));
  }
  setElementsValidFlag(e, t, i) {
    const n = this.getUriComparisonKey(e);
    this._editStacks.has(n) && this._editStacks.get(n).setElementsValidFlag(t, i);
  }
  createSnapshot(e) {
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).createSnapshot(e) : new vF(e, []);
  }
  restoreSnapshot(e) {
    const t = this.getUriComparisonKey(e.resource);
    if (this._editStacks.has(t)) {
      const i = this._editStacks.get(t);
      i.restoreSnapshot(e), !i.hasPastElements() && !i.hasFutureElements() && (i.dispose(), this._editStacks.delete(t));
    }
  }
  getElements(e) {
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).getElements() : { past: [], future: [] };
  }
  _findClosestUndoElementWithSource(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, o] of this._editStacks) {
      const r = o.getClosestPastElement();
      r && r.sourceId === e && (!t || r.sourceOrder > t.sourceOrder) && (t = r, i = n);
    }
    return [t, i];
  }
  canUndo(e) {
    if (e instanceof Oc) {
      const [, i] = this._findClosestUndoElementWithSource(e.id);
      return !!i;
    }
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).hasPastElements() : !1;
  }
  _onError(e, t) {
    Je(e);
    for (const i of t.strResources)
      this.removeElements(i);
    this._notificationService.error(e);
  }
  _acquireLocks(e) {
    for (const t of e.editStacks)
      if (t.locked)
        throw new Error("Cannot acquire edit stack lock");
    for (const t of e.editStacks)
      t.locked = !0;
    return () => {
      for (const t of e.editStacks)
        t.locked = !1;
    };
  }
  _safeInvokeWithLocks(e, t, i, n, o) {
    const r = this._acquireLocks(i);
    let a;
    try {
      a = t();
    } catch (l) {
      return r(), n.dispose(), this._onError(l, e);
    }
    return a ? a.then(() => (r(), n.dispose(), o()), (l) => (r(), n.dispose(), this._onError(l, e))) : (r(), n.dispose(), o());
  }
  async _invokeWorkspacePrepare(e) {
    if (typeof e.actual.prepareUndoRedo > "u")
      return U.None;
    const t = e.actual.prepareUndoRedo();
    return typeof t > "u" ? U.None : t;
  }
  _invokeResourcePrepare(e, t) {
    if (e.actual.type !== 1 || typeof e.actual.prepareUndoRedo > "u")
      return t(U.None);
    const i = e.actual.prepareUndoRedo();
    return i ? i4(i) ? t(i) : i.then((n) => t(n)) : t(U.None);
  }
  _getAffectedEditStacks(e) {
    const t = [];
    for (const i of e.strResources)
      t.push(this._editStacks.get(i) || h3);
    return new py(t);
  }
  _tryToSplitAndUndo(e, t, i, n) {
    if (t.canSplit())
      return this._splitPastWorkspaceElement(t, i), this._notificationService.warn(n), new B_(this._undo(e, 0, !0));
    for (const o of t.strResources)
      this.removeElements(o);
    return this._notificationService.warn(n), new B_();
  }
  _checkWorkspaceUndo(e, t, i, n) {
    if (t.removedResources)
      return this._tryToSplitAndUndo(e, t, t.removedResources, m({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
    if (n && t.invalidatedResources)
      return this._tryToSplitAndUndo(e, t, t.invalidatedResources, m({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
    const o = [];
    for (const a of i.editStacks)
      a.getClosestPastElement() !== t && o.push(a.resourceLabel);
    if (o.length > 0)
      return this._tryToSplitAndUndo(e, t, null, m({ key: "cannotWorkspaceUndoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because changes were made to {1}", t.label, o.join(", ")));
    const r = [];
    for (const a of i.editStacks)
      a.locked && r.push(a.resourceLabel);
    return r.length > 0 ? this._tryToSplitAndUndo(e, t, null, m({ key: "cannotWorkspaceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, r.join(", "))) : i.isValid() ? null : this._tryToSplitAndUndo(e, t, null, m({ key: "cannotWorkspaceUndoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
  }
  _workspaceUndo(e, t, i) {
    const n = this._getAffectedEditStacks(t), o = this._checkWorkspaceUndo(
      e,
      t,
      n,
      /*invalidated resources will be checked after the prepare call*/
      !1
    );
    return o ? o.returnValue : this._confirmAndExecuteWorkspaceUndo(e, t, n, i);
  }
  _isPartOfUndoGroup(e) {
    if (!e.groupId)
      return !1;
    for (const [, t] of this._editStacks) {
      const i = t.getClosestPastElement();
      if (i) {
        if (i === e) {
          const n = t.getSecondClosestPastElement();
          if (n && n.groupId === e.groupId)
            return !0;
        }
        if (i.groupId === e.groupId)
          return !0;
      }
    }
    return !1;
  }
  async _confirmAndExecuteWorkspaceUndo(e, t, i, n) {
    if (t.canSplit() && !this._isPartOfUndoGroup(t)) {
      let a;
      (function(h) {
        h[h.All = 0] = "All", h[h.This = 1] = "This", h[h.Cancel = 2] = "Cancel";
      })(a || (a = {}));
      const { result: l } = await this._dialogService.prompt({
        type: Gt.Info,
        message: m("confirmWorkspace", "Would you like to undo '{0}' across all files?", t.label),
        buttons: [
          {
            label: m({ key: "ok", comment: ["{0} denotes a number that is > 1, && denotes a mnemonic"] }, "&&Undo in {0} Files", i.editStacks.length),
            run: () => a.All
          },
          {
            label: m({ key: "nok", comment: ["&& denotes a mnemonic"] }, "Undo this &&File"),
            run: () => a.This
          }
        ],
        cancelButton: {
          run: () => a.Cancel
        }
      });
      if (l === a.Cancel)
        return;
      if (l === a.This)
        return this._splitPastWorkspaceElement(t, null), this._undo(e, 0, !0);
      const c = this._checkWorkspaceUndo(
        e,
        t,
        i,
        /*invalidated resources will be checked after the prepare call*/
        !1
      );
      if (c)
        return c.returnValue;
      n = !0;
    }
    let o;
    try {
      o = await this._invokeWorkspacePrepare(t);
    } catch (a) {
      return this._onError(a, t);
    }
    const r = this._checkWorkspaceUndo(
      e,
      t,
      i,
      /*now also check that there are no more invalidated resources*/
      !0
    );
    if (r)
      return o.dispose(), r.returnValue;
    for (const a of i.editStacks)
      a.moveBackward(t);
    return this._safeInvokeWithLocks(t, () => t.actual.undo(), i, o, () => this._continueUndoInGroup(t.groupId, n));
  }
  _resourceUndo(e, t, i) {
    if (!t.isValid) {
      e.flushAllElements();
      return;
    }
    if (e.locked) {
      const n = m({ key: "cannotResourceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not undo '{0}' because there is already an undo or redo operation running.", t.label);
      this._notificationService.warn(n);
      return;
    }
    return this._invokeResourcePrepare(t, (n) => (e.moveBackward(t), this._safeInvokeWithLocks(t, () => t.actual.undo(), new py([e]), n, () => this._continueUndoInGroup(t.groupId, i))));
  }
  _findClosestUndoElementInGroup(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, o] of this._editStacks) {
      const r = o.getClosestPastElement();
      r && r.groupId === e && (!t || r.groupOrder > t.groupOrder) && (t = r, i = n);
    }
    return [t, i];
  }
  _continueUndoInGroup(e, t) {
    if (!e)
      return;
    const [, i] = this._findClosestUndoElementInGroup(e);
    if (i)
      return this._undo(i, 0, t);
  }
  undo(e) {
    if (e instanceof Oc) {
      const [, t] = this._findClosestUndoElementWithSource(e.id);
      return t ? this._undo(t, e.id, !1) : void 0;
    }
    return typeof e == "string" ? this._undo(e, 0, !1) : this._undo(this.getUriComparisonKey(e), 0, !1);
  }
  _undo(e, t = 0, i) {
    if (!this._editStacks.has(e))
      return;
    const n = this._editStacks.get(e), o = n.getClosestPastElement();
    if (!o)
      return;
    if (o.groupId) {
      const [a, l] = this._findClosestUndoElementInGroup(o.groupId);
      if (o !== a && l)
        return this._undo(l, t, i);
    }
    if ((o.sourceId !== t || o.confirmBeforeUndo) && !i)
      return this._confirmAndContinueUndo(e, t, o);
    try {
      return o.type === 1 ? this._workspaceUndo(e, o, i) : this._resourceUndo(n, o, i);
    } finally {
    }
  }
  async _confirmAndContinueUndo(e, t, i) {
    if ((await this._dialogService.confirm({
      message: m("confirmDifferentSource", "Would you like to undo '{0}'?", i.label),
      primaryButton: m({ key: "confirmDifferentSource.yes", comment: ["&& denotes a mnemonic"] }, "&&Yes"),
      cancelButton: m("confirmDifferentSource.no", "No")
    })).confirmed)
      return this._undo(e, t, !0);
  }
  _findClosestRedoElementWithSource(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, o] of this._editStacks) {
      const r = o.getClosestFutureElement();
      r && r.sourceId === e && (!t || r.sourceOrder < t.sourceOrder) && (t = r, i = n);
    }
    return [t, i];
  }
  canRedo(e) {
    if (e instanceof Oc) {
      const [, i] = this._findClosestRedoElementWithSource(e.id);
      return !!i;
    }
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).hasFutureElements() : !1;
  }
  _tryToSplitAndRedo(e, t, i, n) {
    if (t.canSplit())
      return this._splitFutureWorkspaceElement(t, i), this._notificationService.warn(n), new B_(this._redo(e));
    for (const o of t.strResources)
      this.removeElements(o);
    return this._notificationService.warn(n), new B_();
  }
  _checkWorkspaceRedo(e, t, i, n) {
    if (t.removedResources)
      return this._tryToSplitAndRedo(e, t, t.removedResources, m({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
    if (n && t.invalidatedResources)
      return this._tryToSplitAndRedo(e, t, t.invalidatedResources, m({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
    const o = [];
    for (const a of i.editStacks)
      a.getClosestFutureElement() !== t && o.push(a.resourceLabel);
    if (o.length > 0)
      return this._tryToSplitAndRedo(e, t, null, m({ key: "cannotWorkspaceRedoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because changes were made to {1}", t.label, o.join(", ")));
    const r = [];
    for (const a of i.editStacks)
      a.locked && r.push(a.resourceLabel);
    return r.length > 0 ? this._tryToSplitAndRedo(e, t, null, m({ key: "cannotWorkspaceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, r.join(", "))) : i.isValid() ? null : this._tryToSplitAndRedo(e, t, null, m({ key: "cannotWorkspaceRedoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
  }
  _workspaceRedo(e, t) {
    const i = this._getAffectedEditStacks(t), n = this._checkWorkspaceRedo(
      e,
      t,
      i,
      /*invalidated resources will be checked after the prepare call*/
      !1
    );
    return n ? n.returnValue : this._executeWorkspaceRedo(e, t, i);
  }
  async _executeWorkspaceRedo(e, t, i) {
    let n;
    try {
      n = await this._invokeWorkspacePrepare(t);
    } catch (r) {
      return this._onError(r, t);
    }
    const o = this._checkWorkspaceRedo(
      e,
      t,
      i,
      /*now also check that there are no more invalidated resources*/
      !0
    );
    if (o)
      return n.dispose(), o.returnValue;
    for (const r of i.editStacks)
      r.moveForward(t);
    return this._safeInvokeWithLocks(t, () => t.actual.redo(), i, n, () => this._continueRedoInGroup(t.groupId));
  }
  _resourceRedo(e, t) {
    if (!t.isValid) {
      e.flushAllElements();
      return;
    }
    if (e.locked) {
      const i = m({ key: "cannotResourceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not redo '{0}' because there is already an undo or redo operation running.", t.label);
      this._notificationService.warn(i);
      return;
    }
    return this._invokeResourcePrepare(t, (i) => (e.moveForward(t), this._safeInvokeWithLocks(t, () => t.actual.redo(), new py([e]), i, () => this._continueRedoInGroup(t.groupId))));
  }
  _findClosestRedoElementInGroup(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, o] of this._editStacks) {
      const r = o.getClosestFutureElement();
      r && r.groupId === e && (!t || r.groupOrder < t.groupOrder) && (t = r, i = n);
    }
    return [t, i];
  }
  _continueRedoInGroup(e) {
    if (!e)
      return;
    const [, t] = this._findClosestRedoElementInGroup(e);
    if (t)
      return this._redo(t);
  }
  redo(e) {
    if (e instanceof Oc) {
      const [, t] = this._findClosestRedoElementWithSource(e.id);
      return t ? this._redo(t) : void 0;
    }
    return typeof e == "string" ? this._redo(e) : this._redo(this.getUriComparisonKey(e));
  }
  _redo(e) {
    if (!this._editStacks.has(e))
      return;
    const t = this._editStacks.get(e), i = t.getClosestFutureElement();
    if (i) {
      if (i.groupId) {
        const [n, o] = this._findClosestRedoElementInGroup(i.groupId);
        if (i !== n && o)
          return this._redo(o);
      }
      try {
        return i.type === 1 ? this._workspaceRedo(e, i) : this._resourceRedo(t, i);
      } finally {
      }
    }
  }
};
Nx = Rie([
  hA(0, a3),
  hA(1, cn)
], Nx);
class B_ {
  constructor(e) {
    this.returnValue = e;
  }
}
Ze(
  VI,
  Nx,
  1
  /* InstantiationType.Delayed */
);
var Pie = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, _y = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Tx = class {
  constructor(e, t, i, n) {
    this._legend = e, this._themeService = t, this._languageService = i, this._logService = n, this._hasWarnedOverlappingTokens = !1, this._hasWarnedInvalidLengthTokens = !1, this._hasWarnedInvalidEditStart = !1, this._hashTable = new Mx();
  }
  getMetadata(e, t, i) {
    const n = this._languageService.languageIdCodec.encodeLanguageId(i), o = this._hashTable.get(e, t, n);
    let r;
    if (o)
      r = o.metadata;
    else {
      let a = this._legend.tokenTypes[e];
      const l = [];
      if (a) {
        let c = t;
        for (let d = 0; c > 0 && d < this._legend.tokenModifiers.length; d++)
          c & 1 && l.push(this._legend.tokenModifiers[d]), c = c >> 1;
        const h = this._themeService.getColorTheme().getTokenStyleMetadata(a, l, i);
        if (typeof h > "u")
          r = 2147483647;
        else {
          if (r = 0, typeof h.italic < "u") {
            const d = (h.italic ? 1 : 0) << 11;
            r |= d | 1;
          }
          if (typeof h.bold < "u") {
            const d = (h.bold ? 2 : 0) << 11;
            r |= d | 2;
          }
          if (typeof h.underline < "u") {
            const d = (h.underline ? 4 : 0) << 11;
            r |= d | 4;
          }
          if (typeof h.strikethrough < "u") {
            const d = (h.strikethrough ? 8 : 0) << 11;
            r |= d | 8;
          }
          if (h.foreground) {
            const d = h.foreground << 15;
            r |= d | 16;
          }
          r === 0 && (r = 2147483647);
        }
      } else
        r = 2147483647, a = "not-in-legend";
      this._hashTable.add(e, t, n, r);
    }
    return r;
  }
  warnOverlappingSemanticTokens(e, t) {
    this._hasWarnedOverlappingTokens || (this._hasWarnedOverlappingTokens = !0, this._logService.warn(`Overlapping semantic tokens detected at lineNumber ${e}, column ${t}`));
  }
  warnInvalidLengthSemanticTokens(e, t) {
    this._hasWarnedInvalidLengthTokens || (this._hasWarnedInvalidLengthTokens = !0, this._logService.warn(`Semantic token with invalid length detected at lineNumber ${e}, column ${t}`));
  }
  warnInvalidEditStart(e, t, i, n, o) {
    this._hasWarnedInvalidEditStart || (this._hasWarnedInvalidEditStart = !0, this._logService.warn(`Invalid semantic tokens edit detected (previousResultId: ${e}, resultId: ${t}) at edit #${i}: The provided start offset ${n} is outside the previous data (length ${o}).`));
  }
};
Tx = Pie([
  _y(1, wn),
  _y(2, ci),
  _y(3, Co)
], Tx);
class Oie {
  constructor(e, t, i, n) {
    this.tokenTypeIndex = e, this.tokenModifierSet = t, this.languageId = i, this.metadata = n, this.next = null;
  }
}
const ga = class ga {
  constructor() {
    this._elementsCount = 0, this._currentLengthIndex = 0, this._currentLength = ga._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < ga._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], ga._nullOutEntries(this._elements, this._currentLength);
  }
  static _nullOutEntries(e, t) {
    for (let i = 0; i < t; i++)
      e[i] = null;
  }
  _hash2(e, t) {
    return (e << 5) - e + t | 0;
  }
  _hashFunc(e, t, i) {
    return this._hash2(this._hash2(e, t), i) % this._currentLength;
  }
  get(e, t, i) {
    const n = this._hashFunc(e, t, i);
    let o = this._elements[n];
    for (; o; ) {
      if (o.tokenTypeIndex === e && o.tokenModifierSet === t && o.languageId === i)
        return o;
      o = o.next;
    }
    return null;
  }
  add(e, t, i, n) {
    if (this._elementsCount++, this._growCount !== 0 && this._elementsCount >= this._growCount) {
      const o = this._elements;
      this._currentLengthIndex++, this._currentLength = ga._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < ga._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], ga._nullOutEntries(this._elements, this._currentLength);
      for (const r of o) {
        let a = r;
        for (; a; ) {
          const l = a.next;
          a.next = null, this._add(a), a = l;
        }
      }
    }
    this._add(new Oie(e, t, i, n));
  }
  _add(e) {
    const t = this._hashFunc(e.tokenTypeIndex, e.tokenModifierSet, e.languageId);
    e.next = this._elements[t], this._elements[t] = e;
  }
};
ga._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];
let Mx = ga;
const Fie = Be("semanticTokensStylingService");
var Bie = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, by = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Rx = class extends U {
  constructor(e, t, i) {
    super(), this._themeService = e, this._logService = t, this._languageService = i, this._caches = /* @__PURE__ */ new WeakMap(), this._register(this._themeService.onDidColorThemeChange(() => {
      this._caches = /* @__PURE__ */ new WeakMap();
    }));
  }
  getStyling(e) {
    return this._caches.has(e) || this._caches.set(e, new Tx(e.getLegend(), this._themeService, this._languageService, this._logService)), this._caches.get(e);
  }
};
Rx = Bie([
  by(0, wn),
  by(1, Co),
  by(2, ci)
], Rx);
Ze(
  Fie,
  Rx,
  1
  /* InstantiationType.Delayed */
);
const W_ = "**", fA = "/", kb = "[/\\\\]", xb = "[^/\\\\]", Wie = /\//g;
function gA(s, e) {
  switch (s) {
    case 0:
      return "";
    case 1:
      return `${xb}*?`;
    // 1 star matches any number of characters except path separator (/ and \) - non greedy (?)
    default:
      return `(?:${kb}|${xb}+${kb}${e ? `|${kb}${xb}+` : ""})*?`;
  }
}
function mA(s, e) {
  if (!s)
    return [];
  const t = [];
  let i = !1, n = !1, o = "";
  for (const r of s) {
    switch (r) {
      case e:
        if (!i && !n) {
          t.push(o), o = "";
          continue;
        }
        break;
      case "{":
        i = !0;
        break;
      case "}":
        i = !1;
        break;
      case "[":
        n = !0;
        break;
      case "]":
        n = !1;
        break;
    }
    o += r;
  }
  return o && t.push(o), t;
}
function d3(s) {
  if (!s)
    return "";
  let e = "";
  const t = mA(s, fA);
  if (t.every((i) => i === W_))
    e = ".*";
  else {
    let i = !1;
    t.forEach((n, o) => {
      if (n === W_) {
        if (i)
          return;
        e += gA(2, o === t.length - 1);
      } else {
        let r = !1, a = "", l = !1, c = "";
        for (const h of n) {
          if (h !== "}" && r) {
            a += h;
            continue;
          }
          if (l && (h !== "]" || !c)) {
            let d;
            h === "-" ? d = h : (h === "^" || h === "!") && !c ? d = "^" : h === fA ? d = "" : d = za(h), c += d;
            continue;
          }
          switch (h) {
            case "{":
              r = !0;
              continue;
            case "[":
              l = !0;
              continue;
            case "}": {
              const u = `(?:${mA(a, ",").map((f) => d3(f)).join("|")})`;
              e += u, r = !1, a = "";
              break;
            }
            case "]": {
              e += "[" + c + "]", l = !1, c = "";
              break;
            }
            case "?":
              e += xb;
              continue;
            case "*":
              e += gA(1);
              continue;
            default:
              e += za(h);
          }
        }
        o < t.length - 1 && // more segments to come after this
        (t[o + 1] !== W_ || // next segment is not **, or...
        o + 2 < t.length) && (e += kb);
      }
      i = n === W_;
    });
  }
  return e;
}
const Hie = /^\*\*\/\*\.[\w\.-]+$/, Vie = /^\*\*\/([\w\.-]+)\/?$/, zie = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/, Uie = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/, $ie = /^\*\*((\/[\w\.-]+)+)\/?$/, Kie = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/, pA = new Mf(1e4), _A = function() {
  return !1;
}, Pr = function() {
  return null;
};
function RN(s, e) {
  if (!s)
    return Pr;
  let t;
  typeof s != "string" ? t = s.pattern : t = s, t = t.trim();
  const i = `${t}_${!!e.trimForExclusions}`;
  let n = pA.get(i);
  if (n)
    return bA(n, s);
  let o;
  return Hie.test(t) ? n = jie(t.substr(4), t) : (o = Vie.exec(Cy(t, e))) ? n = qie(o[1], t) : (e.trimForExclusions ? Uie : zie).test(t) ? n = Gie(t, e) : (o = $ie.exec(Cy(t, e))) ? n = CA(o[1].substr(1), t, !0) : (o = Kie.exec(Cy(t, e))) ? n = CA(o[1], t, !1) : n = Zie(t), pA.set(i, n), bA(n, s);
}
function bA(s, e) {
  if (typeof e == "string")
    return s;
  const t = function(i, n) {
    return sS(i, e.base, !Rn) ? s(Hv(i.substr(e.base.length), Tl), n) : null;
  };
  return t.allBasenames = s.allBasenames, t.allPaths = s.allPaths, t.basenames = s.basenames, t.patterns = s.patterns, t;
}
function Cy(s, e) {
  return e.trimForExclusions && s.endsWith("/**") ? s.substr(0, s.length - 2) : s;
}
function jie(s, e) {
  return function(t, i) {
    return typeof t == "string" && t.endsWith(s) ? e : null;
  };
}
function qie(s, e) {
  const t = `/${s}`, i = `\\${s}`, n = function(r, a) {
    return typeof r != "string" ? null : a ? a === s ? e : null : r === s || r.endsWith(t) || r.endsWith(i) ? e : null;
  }, o = [s];
  return n.basenames = o, n.patterns = [e], n.allBasenames = o, n;
}
function Gie(s, e) {
  const t = f3(s.slice(1, -1).split(",").map((a) => RN(a, e)).filter((a) => a !== Pr), s), i = t.length;
  if (!i)
    return Pr;
  if (i === 1)
    return t[0];
  const n = function(a, l) {
    for (let c = 0, h = t.length; c < h; c++)
      if (t[c](a, l))
        return s;
    return null;
  }, o = t.find((a) => !!a.allBasenames);
  o && (n.allBasenames = o.allBasenames);
  const r = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
  return r.length && (n.allPaths = r), n;
}
function CA(s, e, t) {
  const i = Tl === ni.sep, n = i ? s : s.replace(Wie, Tl), o = Tl + n, r = ni.sep + s;
  let a;
  return t ? a = function(l, c) {
    return typeof l == "string" && (l === n || l.endsWith(o) || !i && (l === s || l.endsWith(r))) ? e : null;
  } : a = function(l, c) {
    return typeof l == "string" && (l === n || !i && l === s) ? e : null;
  }, a.allPaths = [(t ? "*/" : "./") + s], a;
}
function Zie(s) {
  try {
    const e = new RegExp(`^${d3(s)}$`);
    return function(t) {
      return e.lastIndex = 0, typeof t == "string" && e.test(t) ? s : null;
    };
  } catch {
    return Pr;
  }
}
function Yie(s, e, t) {
  return !s || typeof e != "string" ? !1 : u3(s)(e, void 0, t);
}
function u3(s, e = {}) {
  if (!s)
    return _A;
  if (typeof s == "string" || Xie(s)) {
    const t = RN(s, e);
    if (t === Pr)
      return _A;
    const i = function(n, o) {
      return !!t(n, o);
    };
    return t.allBasenames && (i.allBasenames = t.allBasenames), t.allPaths && (i.allPaths = t.allPaths), i;
  }
  return Qie(s, e);
}
function Xie(s) {
  const e = s;
  return e ? typeof e.base == "string" && typeof e.pattern == "string" : !1;
}
function Qie(s, e) {
  const t = f3(Object.getOwnPropertyNames(s).map((a) => Jie(a, s[a], e)).filter((a) => a !== Pr)), i = t.length;
  if (!i)
    return Pr;
  if (!t.some((a) => !!a.requiresSiblings)) {
    if (i === 1)
      return t[0];
    const a = function(h, d) {
      let u;
      for (let f = 0, g = t.length; f < g; f++) {
        const p = t[f](h, d);
        if (typeof p == "string")
          return p;
        Ky(p) && (u || (u = []), u.push(p));
      }
      return u ? (async () => {
        for (const f of u) {
          const g = await f;
          if (typeof g == "string")
            return g;
        }
        return null;
      })() : null;
    }, l = t.find((h) => !!h.allBasenames);
    l && (a.allBasenames = l.allBasenames);
    const c = t.reduce((h, d) => d.allPaths ? h.concat(d.allPaths) : h, []);
    return c.length && (a.allPaths = c), a;
  }
  const n = function(a, l, c) {
    let h, d;
    for (let u = 0, f = t.length; u < f; u++) {
      const g = t[u];
      g.requiresSiblings && c && (l || (l = XP(a)), h || (h = l.substr(0, l.length - F9(a).length)));
      const p = g(a, l, h, c);
      if (typeof p == "string")
        return p;
      Ky(p) && (d || (d = []), d.push(p));
    }
    return d ? (async () => {
      for (const u of d) {
        const f = await u;
        if (typeof f == "string")
          return f;
      }
      return null;
    })() : null;
  }, o = t.find((a) => !!a.allBasenames);
  o && (n.allBasenames = o.allBasenames);
  const r = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
  return r.length && (n.allPaths = r), n;
}
function Jie(s, e, t) {
  if (e === !1)
    return Pr;
  const i = RN(s, t);
  if (i === Pr)
    return Pr;
  if (typeof e == "boolean")
    return i;
  if (e) {
    const n = e.when;
    if (typeof n == "string") {
      const o = (r, a, l, c) => {
        if (!c || !i(r, a))
          return null;
        const h = n.replace("$(basename)", () => l), d = c(h);
        return Ky(d) ? d.then((u) => u ? s : null) : d ? s : null;
      };
      return o.requiresSiblings = !0, o;
    }
  }
  return i;
}
function f3(s, e) {
  const t = s.filter((a) => !!a.basenames);
  if (t.length < 2)
    return s;
  const i = t.reduce((a, l) => {
    const c = l.basenames;
    return c ? a.concat(c) : a;
  }, []);
  let n;
  if (e) {
    n = [];
    for (let a = 0, l = i.length; a < l; a++)
      n.push(e);
  } else
    n = t.reduce((a, l) => {
      const c = l.patterns;
      return c ? a.concat(c) : a;
    }, []);
  const o = function(a, l) {
    if (typeof a != "string")
      return null;
    if (!l) {
      let h;
      for (h = a.length; h > 0; h--) {
        const d = a.charCodeAt(h - 1);
        if (d === 47 || d === 92)
          break;
      }
      l = a.substr(h);
    }
    const c = i.indexOf(l);
    return c !== -1 ? n[c] : null;
  };
  o.basenames = i, o.patterns = n, o.allBasenames = i;
  const r = s.filter((a) => !a.basenames);
  return r.push(o), r;
}
function g3(s, e, t, i, n, o) {
  if (Array.isArray(s)) {
    let r = 0;
    for (const a of s) {
      const l = g3(a, e, t, i, n, o);
      if (l === 10)
        return l;
      l > r && (r = l);
    }
    return r;
  } else {
    if (typeof s == "string")
      return i ? s === "*" ? 5 : s === t ? 10 : 0 : 0;
    if (s) {
      const { language: r, pattern: a, scheme: l, hasAccessToAllModels: c, notebookType: h } = s;
      if (!i && !c)
        return 0;
      h && n && (e = n);
      let d = 0;
      if (l)
        if (l === e.scheme)
          d = 10;
        else if (l === "*")
          d = 5;
        else
          return 0;
      if (r)
        if (r === t)
          d = 10;
        else if (r === "*")
          d = Math.max(d, 5);
        else
          return 0;
      if (h)
        if (h === o)
          d = 10;
        else if (h === "*" && o !== void 0)
          d = Math.max(d, 5);
        else
          return 0;
      if (a) {
        let u;
        if (typeof a == "string" ? u = a : u = { ...a, base: YP(a.base) }, u === e.fsPath || Yie(u, e.fsPath))
          d = 10;
        else
          return 0;
      }
      return d;
    } else
      return 0;
  }
}
function m3(s) {
  return typeof s == "string" ? !1 : Array.isArray(s) ? s.every(m3) : !!s.exclusive;
}
class vA {
  constructor(e, t, i, n, o) {
    this.uri = e, this.languageId = t, this.notebookUri = i, this.notebookType = n, this.recursive = o;
  }
  equals(e) {
    var t, i;
    return this.notebookType === e.notebookType && this.languageId === e.languageId && this.uri.toString() === e.uri.toString() && ((t = this.notebookUri) == null ? void 0 : t.toString()) === ((i = e.notebookUri) == null ? void 0 : i.toString()) && this.recursive === e.recursive;
  }
}
class Rt {
  constructor(e) {
    this._notebookInfoResolver = e, this._clock = 0, this._entries = [], this._onDidChange = new A(), this.onDidChange = this._onDidChange.event;
  }
  register(e, t) {
    let i = {
      selector: e,
      provider: t,
      _score: -1,
      _time: this._clock++
    };
    return this._entries.push(i), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), _e(() => {
      if (i) {
        const n = this._entries.indexOf(i);
        n >= 0 && (this._entries.splice(n, 1), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), i = void 0);
      }
    });
  }
  has(e) {
    return this.all(e).length > 0;
  }
  all(e) {
    if (!e)
      return [];
    this._updateScores(e, !1);
    const t = [];
    for (const i of this._entries)
      i._score > 0 && t.push(i.provider);
    return t;
  }
  ordered(e, t = !1) {
    const i = [];
    return this._orderedForEach(e, t, (n) => i.push(n.provider)), i;
  }
  orderedGroups(e) {
    const t = [];
    let i, n;
    return this._orderedForEach(e, !1, (o) => {
      i && n === o._score ? i.push(o.provider) : (n = o._score, i = [o.provider], t.push(i));
    }), t;
  }
  _orderedForEach(e, t, i) {
    this._updateScores(e, t);
    for (const n of this._entries)
      n._score > 0 && i(n);
  }
  _updateScores(e, t) {
    var o, r;
    const i = (o = this._notebookInfoResolver) == null ? void 0 : o.call(this, e.uri), n = i ? new vA(e.uri, e.getLanguageId(), i.uri, i.type, t) : new vA(e.uri, e.getLanguageId(), void 0, void 0, t);
    if (!((r = this._lastCandidate) != null && r.equals(n))) {
      this._lastCandidate = n;
      for (const a of this._entries)
        if (a._score = g3(a.selector, n.uri, n.languageId, cq(e), n.notebookUri, n.notebookType), m3(a.selector) && a._score > 0)
          if (t)
            a._score = 0;
          else {
            for (const l of this._entries)
              l._score = 0;
            a._score = 1e3;
            break;
          }
      this._entries.sort(Rt._compareByScoreAndTime);
    }
  }
  static _compareByScoreAndTime(e, t) {
    return e._score < t._score ? 1 : e._score > t._score ? -1 : Eg(e.selector) && !Eg(t.selector) ? 1 : !Eg(e.selector) && Eg(t.selector) ? -1 : e._time < t._time ? 1 : e._time > t._time ? -1 : 0;
  }
}
function Eg(s) {
  return typeof s == "string" ? !1 : Array.isArray(s) ? s.some(Eg) : !!s.isBuiltin;
}
class ene {
  constructor() {
    this.referenceProvider = new Rt(this._score.bind(this)), this.renameProvider = new Rt(this._score.bind(this)), this.newSymbolNamesProvider = new Rt(this._score.bind(this)), this.codeActionProvider = new Rt(this._score.bind(this)), this.definitionProvider = new Rt(this._score.bind(this)), this.typeDefinitionProvider = new Rt(this._score.bind(this)), this.declarationProvider = new Rt(this._score.bind(this)), this.implementationProvider = new Rt(this._score.bind(this)), this.documentSymbolProvider = new Rt(this._score.bind(this)), this.inlayHintsProvider = new Rt(this._score.bind(this)), this.colorProvider = new Rt(this._score.bind(this)), this.codeLensProvider = new Rt(this._score.bind(this)), this.documentFormattingEditProvider = new Rt(this._score.bind(this)), this.documentRangeFormattingEditProvider = new Rt(this._score.bind(this)), this.onTypeFormattingEditProvider = new Rt(this._score.bind(this)), this.signatureHelpProvider = new Rt(this._score.bind(this)), this.hoverProvider = new Rt(this._score.bind(this)), this.documentHighlightProvider = new Rt(this._score.bind(this)), this.multiDocumentHighlightProvider = new Rt(this._score.bind(this)), this.selectionRangeProvider = new Rt(this._score.bind(this)), this.foldingRangeProvider = new Rt(this._score.bind(this)), this.linkProvider = new Rt(this._score.bind(this)), this.inlineCompletionsProvider = new Rt(this._score.bind(this)), this.inlineEditProvider = new Rt(this._score.bind(this)), this.completionProvider = new Rt(this._score.bind(this)), this.linkedEditingRangeProvider = new Rt(this._score.bind(this)), this.documentRangeSemanticTokensProvider = new Rt(this._score.bind(this)), this.documentSemanticTokensProvider = new Rt(this._score.bind(this)), this.documentDropEditProvider = new Rt(this._score.bind(this)), this.documentPasteEditProvider = new Rt(this._score.bind(this));
  }
  _score(e) {
    var t;
    return (t = this._notebookTypeResolver) == null ? void 0 : t.call(this, e);
  }
}
Ze(
  De,
  ene,
  1
  /* InstantiationType.Delayed */
);
var tne = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, hg = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const dr = he;
let Ax = class extends qr {
  get _targetWindow() {
    return fe(this._target.targetElements[0]);
  }
  get _targetDocumentElement() {
    return fe(this._target.targetElements[0]).document.documentElement;
  }
  get isDisposed() {
    return this._isDisposed;
  }
  get isMouseIn() {
    return this._lockMouseTracker.isMouseIn;
  }
  get domNode() {
    return this._hover.containerDomNode;
  }
  get onDispose() {
    return this._onDispose.event;
  }
  get onRequestLayout() {
    return this._onRequestLayout.event;
  }
  get anchor() {
    return this._hoverPosition === 2 ? 0 : 1;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  /**
   * Whether the hover is "locked" by holding the alt/option key. When locked, the hover will not
   * hide and can be hovered regardless of whether the `hideOnHover` hover option is set.
   */
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(e) {
    this._isLocked !== e && (this._isLocked = e, this._hoverContainer.classList.toggle("locked", this._isLocked));
  }
  constructor(e, t, i, n, o, r) {
    var u, f, g, p, _, b, C;
    super(), this._keybindingService = t, this._configurationService = i, this._openerService = n, this._instantiationService = o, this._accessibilityService = r, this._messageListeners = new ne(), this._isDisposed = !1, this._forcePosition = !1, this._x = 0, this._y = 0, this._isLocked = !1, this._enableFocusTraps = !1, this._addedFocusTrap = !1, this._onDispose = this._register(new A()), this._onRequestLayout = this._register(new A()), this._linkHandler = e.linkHandler || ((w) => pN(this._openerService, w, Mr(e.content) ? e.content.isTrusted : void 0)), this._target = "targetElements" in e.target ? e.target : new ine(e.target), this._hoverPointer = (u = e.appearance) != null && u.showPointer ? dr("div.workbench-hover-pointer") : void 0, this._hover = this._register(new yN()), this._hover.containerDomNode.classList.add("workbench-hover", "fadeIn"), (f = e.appearance) != null && f.compact && this._hover.containerDomNode.classList.add("workbench-hover", "compact"), (g = e.appearance) != null && g.skipFadeInAnimation && this._hover.containerDomNode.classList.add("skip-fade-in"), e.additionalClasses && this._hover.containerDomNode.classList.add(...e.additionalClasses), (p = e.position) != null && p.forcePosition && (this._forcePosition = !0), e.trapFocus && (this._enableFocusTraps = !0), this._hoverPosition = ((_ = e.position) == null ? void 0 : _.hoverPosition) ?? 3, this.onmousedown(this._hover.containerDomNode, (w) => w.stopPropagation()), this.onkeydown(this._hover.containerDomNode, (w) => {
      w.equals(
        9
        /* KeyCode.Escape */
      ) && this.dispose();
    }), this._register(z(this._targetWindow, "blur", () => this.dispose()));
    const a = dr("div.hover-row.markdown-hover"), l = dr("div.hover-contents");
    if (typeof e.content == "string")
      l.textContent = e.content, l.style.whiteSpace = "pre-wrap";
    else if (ki(e.content))
      l.appendChild(e.content), l.classList.add("html-hover-contents");
    else {
      const w = e.content, v = this._instantiationService.createInstance(hp, { codeBlockFontFamily: this._configurationService.getValue("editor").fontFamily || Qn.fontFamily }), { element: S } = v.render(w, {
        actionHandler: {
          callback: (L) => this._linkHandler(L),
          disposables: this._messageListeners
        },
        asyncRenderCallback: () => {
          l.classList.add("code-hover-contents"), this.layout(), this._onRequestLayout.fire();
        }
      });
      l.appendChild(S);
    }
    if (a.appendChild(l), this._hover.contentsDomNode.appendChild(a), e.actions && e.actions.length > 0) {
      const w = dr("div.hover-row.status-bar"), v = dr("div.actions");
      e.actions.forEach((S) => {
        const L = this._keybindingService.lookupKeybinding(S.commandId), k = L ? L.getLabel() : null;
        Kw.render(v, {
          label: S.label,
          commandId: S.commandId,
          run: (x) => {
            S.run(x), this.dispose();
          },
          iconClass: S.iconClass
        }, k);
      }), w.appendChild(v), this._hover.containerDomNode.appendChild(w);
    }
    this._hoverContainer = dr("div.workbench-hover-container"), this._hoverPointer && this._hoverContainer.appendChild(this._hoverPointer), this._hoverContainer.appendChild(this._hover.containerDomNode);
    let c;
    if (e.actions && e.actions.length > 0 ? c = !1 : ((b = e.persistence) == null ? void 0 : b.hideOnHover) === void 0 ? c = typeof e.content == "string" || Mr(e.content) && !e.content.value.includes("](") && !e.content.value.includes("</a>") : c = e.persistence.hideOnHover, (C = e.appearance) != null && C.showHoverHint) {
      const w = dr("div.hover-row.status-bar"), v = dr("div.info");
      v.textContent = m("hoverhint", "Hold {0} key to mouse over", $e ? "Option" : "Alt"), w.appendChild(v), this._hover.containerDomNode.appendChild(w);
    }
    const h = [...this._target.targetElements];
    c || h.push(this._hoverContainer);
    const d = this._register(new wA(h));
    if (this._register(d.onMouseOut(() => {
      this._isLocked || this.dispose();
    })), c) {
      const w = [...this._target.targetElements, this._hoverContainer];
      this._lockMouseTracker = this._register(new wA(w)), this._register(this._lockMouseTracker.onMouseOut(() => {
        this._isLocked || this.dispose();
      }));
    } else
      this._lockMouseTracker = d;
  }
  addFocusTrap() {
    if (!this._enableFocusTraps || this._addedFocusTrap)
      return;
    this._addedFocusTrap = !0;
    const e = this._hover.containerDomNode, t = this.findLastFocusableChild(this._hover.containerDomNode);
    if (t) {
      const i = NE(this._hoverContainer, dr("div")), n = te(this._hoverContainer, dr("div"));
      i.tabIndex = 0, n.tabIndex = 0, this._register(z(n, "focus", (o) => {
        e.focus(), o.preventDefault();
      })), this._register(z(i, "focus", (o) => {
        t.focus(), o.preventDefault();
      }));
    }
  }
  findLastFocusableChild(e) {
    if (e.hasChildNodes())
      for (let t = 0; t < e.childNodes.length; t++) {
        const i = e.childNodes.item(e.childNodes.length - t - 1);
        if (i.nodeType === i.ELEMENT_NODE) {
          const o = i;
          if (typeof o.tabIndex == "number" && o.tabIndex >= 0)
            return o;
        }
        const n = this.findLastFocusableChild(i);
        if (n)
          return n;
      }
  }
  render(e) {
    var n;
    e.appendChild(this._hoverContainer);
    const i = this._hoverContainer.contains(this._hoverContainer.ownerDocument.activeElement) && m7(this._configurationService.getValue("accessibility.verbosity.hover") === !0 && this._accessibilityService.isScreenReaderOptimized(), (n = this._keybindingService.lookupKeybinding("editor.action.accessibleView")) == null ? void 0 : n.getAriaLabel());
    i && Rm(i), this.layout(), this.addFocusTrap();
  }
  layout() {
    this._hover.containerDomNode.classList.remove("right-aligned"), this._hover.contentsDomNode.style.maxHeight = "";
    const e = (h) => {
      const d = B4(h), u = h.getBoundingClientRect();
      return {
        top: u.top * d,
        bottom: u.bottom * d,
        right: u.right * d,
        left: u.left * d
      };
    }, t = this._target.targetElements.map((h) => e(h)), { top: i, right: n, bottom: o, left: r } = t[0], a = n - r, l = o - i, c = {
      top: i,
      right: n,
      bottom: o,
      left: r,
      width: a,
      height: l,
      center: {
        x: r + a / 2,
        y: i + l / 2
      }
    };
    if (this.adjustHorizontalHoverPosition(c), this.adjustVerticalHoverPosition(c), this.adjustHoverMaxHeight(c), this._hoverContainer.style.padding = "", this._hoverContainer.style.margin = "", this._hoverPointer) {
      switch (this._hoverPosition) {
        case 1:
          c.left += 3, c.right += 3, this._hoverContainer.style.paddingLeft = "3px", this._hoverContainer.style.marginLeft = "-3px";
          break;
        case 0:
          c.left -= 3, c.right -= 3, this._hoverContainer.style.paddingRight = "3px", this._hoverContainer.style.marginRight = "-3px";
          break;
        case 2:
          c.top += 3, c.bottom += 3, this._hoverContainer.style.paddingTop = "3px", this._hoverContainer.style.marginTop = "-3px";
          break;
        case 3:
          c.top -= 3, c.bottom -= 3, this._hoverContainer.style.paddingBottom = "3px", this._hoverContainer.style.marginBottom = "-3px";
          break;
      }
      c.center.x = c.left + a / 2, c.center.y = c.top + l / 2;
    }
    this.computeXCordinate(c), this.computeYCordinate(c), this._hoverPointer && (this._hoverPointer.classList.remove("top"), this._hoverPointer.classList.remove("left"), this._hoverPointer.classList.remove("right"), this._hoverPointer.classList.remove("bottom"), this.setHoverPointerPosition(c)), this._hover.onContentsChanged();
  }
  computeXCordinate(e) {
    const t = this._hover.containerDomNode.clientWidth + 2;
    this._target.x !== void 0 ? this._x = this._target.x : this._hoverPosition === 1 ? this._x = e.right : this._hoverPosition === 0 ? this._x = e.left - t : (this._hoverPointer ? this._x = e.center.x - this._hover.containerDomNode.clientWidth / 2 : this._x = e.left, this._x + t >= this._targetDocumentElement.clientWidth && (this._hover.containerDomNode.classList.add("right-aligned"), this._x = Math.max(this._targetDocumentElement.clientWidth - t - 2, this._targetDocumentElement.clientLeft))), this._x < this._targetDocumentElement.clientLeft && (this._x = e.left + 2);
  }
  computeYCordinate(e) {
    this._target.y !== void 0 ? this._y = this._target.y : this._hoverPosition === 3 ? this._y = e.top : this._hoverPosition === 2 ? this._y = e.bottom - 2 : this._hoverPointer ? this._y = e.center.y + this._hover.containerDomNode.clientHeight / 2 : this._y = e.bottom, this._y > this._targetWindow.innerHeight && (this._y = e.bottom);
  }
  adjustHorizontalHoverPosition(e) {
    if (this._target.x !== void 0)
      return;
    const t = this._hoverPointer ? 3 : 0;
    if (this._forcePosition) {
      const i = t + 2;
      this._hoverPosition === 1 ? this._hover.containerDomNode.style.maxWidth = `${this._targetDocumentElement.clientWidth - e.right - i}px` : this._hoverPosition === 0 && (this._hover.containerDomNode.style.maxWidth = `${e.left - i}px`);
      return;
    }
    this._hoverPosition === 1 ? this._targetDocumentElement.clientWidth - e.right < this._hover.containerDomNode.clientWidth + t && (e.left >= this._hover.containerDomNode.clientWidth + t ? this._hoverPosition = 0 : this._hoverPosition = 2) : this._hoverPosition === 0 && (e.left < this._hover.containerDomNode.clientWidth + t && (this._targetDocumentElement.clientWidth - e.right >= this._hover.containerDomNode.clientWidth + t ? this._hoverPosition = 1 : this._hoverPosition = 2), e.left - this._hover.containerDomNode.clientWidth - t <= this._targetDocumentElement.clientLeft && (this._hoverPosition = 1));
  }
  adjustVerticalHoverPosition(e) {
    if (this._target.y !== void 0 || this._forcePosition)
      return;
    const t = this._hoverPointer ? 3 : 0;
    this._hoverPosition === 3 ? e.top - this._hover.containerDomNode.clientHeight - t < 0 && (this._hoverPosition = 2) : this._hoverPosition === 2 && e.bottom + this._hover.containerDomNode.clientHeight + t > this._targetWindow.innerHeight && (this._hoverPosition = 3);
  }
  adjustHoverMaxHeight(e) {
    let t = this._targetWindow.innerHeight / 2;
    if (this._forcePosition) {
      const i = (this._hoverPointer ? 3 : 0) + 2;
      this._hoverPosition === 3 ? t = Math.min(t, e.top - i) : this._hoverPosition === 2 && (t = Math.min(t, this._targetWindow.innerHeight - e.bottom - i));
    }
    if (this._hover.containerDomNode.style.maxHeight = `${t}px`, this._hover.contentsDomNode.clientHeight < this._hover.contentsDomNode.scrollHeight) {
      const i = `${this._hover.scrollbar.options.verticalScrollbarSize}px`;
      this._hover.contentsDomNode.style.paddingRight !== i && (this._hover.contentsDomNode.style.paddingRight = i);
    }
  }
  setHoverPointerPosition(e) {
    if (this._hoverPointer)
      switch (this._hoverPosition) {
        case 0:
        case 1: {
          this._hoverPointer.classList.add(this._hoverPosition === 0 ? "right" : "left");
          const t = this._hover.containerDomNode.clientHeight;
          t > e.height ? this._hoverPointer.style.top = `${e.center.y - (this._y - t) - 3}px` : this._hoverPointer.style.top = `${Math.round(t / 2) - 3}px`;
          break;
        }
        case 3:
        case 2: {
          this._hoverPointer.classList.add(this._hoverPosition === 3 ? "bottom" : "top");
          const t = this._hover.containerDomNode.clientWidth;
          let i = Math.round(t / 2) - 3;
          const n = this._x + i;
          (n < e.left || n > e.right) && (i = e.center.x - this._x - 3), this._hoverPointer.style.left = `${i}px`;
          break;
        }
      }
  }
  focus() {
    this._hover.containerDomNode.focus();
  }
  dispose() {
    this._isDisposed || (this._onDispose.fire(), this._hoverContainer.remove(), this._messageListeners.dispose(), this._target.dispose(), super.dispose()), this._isDisposed = !0;
  }
};
Ax = tne([
  hg(1, Lt),
  hg(2, gt),
  hg(3, sr),
  hg(4, Pe),
  hg(5, Ks)
], Ax);
class wA extends qr {
  get onMouseOut() {
    return this._onMouseOut.event;
  }
  get isMouseIn() {
    return this._isMouseIn;
  }
  constructor(e) {
    super(), this._elements = e, this._isMouseIn = !0, this._onMouseOut = this._register(new A()), this._elements.forEach((t) => this.onmouseover(t, () => this._onTargetMouseOver(t))), this._elements.forEach((t) => this.onmouseleave(t, () => this._onTargetMouseLeave(t)));
  }
  _onTargetMouseOver(e) {
    this._isMouseIn = !0, this._clearEvaluateMouseStateTimeout(e);
  }
  _onTargetMouseLeave(e) {
    this._isMouseIn = !1, this._evaluateMouseState(e);
  }
  _evaluateMouseState(e) {
    this._clearEvaluateMouseStateTimeout(e), this._mouseTimeout = fe(e).setTimeout(() => this._fireIfMouseOutside(), 0);
  }
  _clearEvaluateMouseStateTimeout(e) {
    this._mouseTimeout && (fe(e).clearTimeout(this._mouseTimeout), this._mouseTimeout = void 0);
  }
  _fireIfMouseOutside() {
    this._isMouseIn || this._onMouseOut.fire();
  }
}
class ine {
  constructor(e) {
    this._element = e, this.targetElements = [this._element];
  }
  dispose() {
  }
}
function nne(s) {
  const e = s;
  return !!e && typeof e.x == "number" && typeof e.y == "number";
}
var El;
(function(s) {
  s[s.AVOID = 0] = "AVOID", s[s.ALIGN = 1] = "ALIGN";
})(El || (El = {}));
function hu(s, e, t) {
  const i = t.mode === El.ALIGN ? t.offset : t.offset + t.size, n = t.mode === El.ALIGN ? t.offset + t.size : t.offset;
  return t.position === 0 ? e <= s - i ? i : e <= n ? n - e : Math.max(s - e, 0) : e <= n ? n - e : e <= s - i ? i : 0;
}
const Du = class Du extends U {
  constructor(e, t) {
    super(), this.container = null, this.useFixedPosition = !1, this.useShadowDOM = !1, this.delegate = null, this.toDisposeOnClean = U.None, this.toDisposeOnSetContainer = U.None, this.shadowRoot = null, this.shadowRootHostElement = null, this.view = he(".context-view"), yl(this.view), this.setContainer(e, t), this._register(_e(() => this.setContainer(
      null,
      1
      /* ContextViewDOMPosition.ABSOLUTE */
    )));
  }
  setContainer(e, t) {
    var n;
    this.useFixedPosition = t !== 1;
    const i = this.useShadowDOM;
    if (this.useShadowDOM = t === 3, !(e === this.container && i === this.useShadowDOM) && (this.container && (this.toDisposeOnSetContainer.dispose(), this.view.remove(), this.shadowRoot && (this.shadowRoot = null, (n = this.shadowRootHostElement) == null || n.remove(), this.shadowRootHostElement = null), this.container = null), e)) {
      if (this.container = e, this.useShadowDOM) {
        this.shadowRootHostElement = he(".shadow-root-host"), this.container.appendChild(this.shadowRootHostElement), this.shadowRoot = this.shadowRootHostElement.attachShadow({ mode: "open" });
        const r = document.createElement("style");
        r.textContent = sne, this.shadowRoot.appendChild(r), this.shadowRoot.appendChild(this.view), this.shadowRoot.appendChild(he("slot"));
      } else
        this.container.appendChild(this.view);
      const o = new ne();
      Du.BUBBLE_UP_EVENTS.forEach((r) => {
        o.add(Zt(this.container, r, (a) => {
          this.onDOMEvent(a, !1);
        }));
      }), Du.BUBBLE_DOWN_EVENTS.forEach((r) => {
        o.add(Zt(this.container, r, (a) => {
          this.onDOMEvent(a, !0);
        }, !0));
      }), this.toDisposeOnSetContainer = o;
    }
  }
  show(e) {
    var t, i;
    this.isVisible() && this.hide(), ks(this.view), this.view.className = "context-view monaco-component", this.view.style.top = "0px", this.view.style.left = "0px", this.view.style.zIndex = `${2575 + (e.layer ?? 0)}`, this.view.style.position = this.useFixedPosition ? "fixed" : "absolute", oh(this.view), this.toDisposeOnClean = e.render(this.view) || U.None, this.delegate = e, this.doLayout(), (i = (t = this.delegate).focus) == null || i.call(t);
  }
  getViewElement() {
    return this.view;
  }
  layout() {
    var e, t;
    if (this.isVisible()) {
      if (this.delegate.canRelayout === !1 && !(Kl && vE.pointerEvents)) {
        this.hide();
        return;
      }
      (t = (e = this.delegate) == null ? void 0 : e.layout) == null || t.call(e), this.doLayout();
    }
  }
  doLayout() {
    if (!this.isVisible())
      return;
    const e = this.delegate.getAnchor();
    let t;
    if (ki(e)) {
      const u = ui(e), f = B4(e);
      t = {
        top: u.top * f,
        left: u.left * f,
        width: u.width * f,
        height: u.height * f
      };
    } else nne(e) ? t = {
      top: e.y,
      left: e.x,
      width: e.width || 1,
      height: e.height || 2
    } : t = {
      top: e.posy,
      left: e.posx,
      // We are about to position the context view where the mouse
      // cursor is. To prevent the view being exactly under the mouse
      // when showing and thus potentially triggering an action within,
      // we treat the mouse location like a small sized block element.
      width: 2,
      height: 2
    };
    const i = Nm(this.view), n = Xc(this.view), o = this.delegate.anchorPosition || 0, r = this.delegate.anchorAlignment || 0, a = this.delegate.anchorAxisAlignment || 0;
    let l, c;
    const h = mg();
    if (a === 0) {
      const u = {
        offset: t.top - h.pageYOffset,
        size: t.height,
        position: o === 0 ? 0 : 1
        /* LayoutAnchorPosition.After */
      }, f = { offset: t.left, size: t.width, position: r === 0 ? 0 : 1, mode: El.ALIGN };
      l = hu(h.innerHeight, n, u) + h.pageYOffset, Ki.intersects({ start: l, end: l + n }, { start: u.offset, end: u.offset + u.size }) && (f.mode = El.AVOID), c = hu(h.innerWidth, i, f);
    } else {
      const u = {
        offset: t.left,
        size: t.width,
        position: r === 0 ? 0 : 1
        /* LayoutAnchorPosition.After */
      }, f = { offset: t.top, size: t.height, position: o === 0 ? 0 : 1, mode: El.ALIGN };
      c = hu(h.innerWidth, i, u), Ki.intersects({ start: c, end: c + i }, { start: u.offset, end: u.offset + u.size }) && (f.mode = El.AVOID), l = hu(h.innerHeight, n, f) + h.pageYOffset;
    }
    this.view.classList.remove("top", "bottom", "left", "right"), this.view.classList.add(o === 0 ? "bottom" : "top"), this.view.classList.add(r === 0 ? "left" : "right"), this.view.classList.toggle("fixed", this.useFixedPosition);
    const d = ui(this.container);
    this.view.style.top = `${l - (this.useFixedPosition ? ui(this.view).top : d.top)}px`, this.view.style.left = `${c - (this.useFixedPosition ? ui(this.view).left : d.left)}px`, this.view.style.width = "initial";
  }
  hide(e) {
    const t = this.delegate;
    this.delegate = null, t != null && t.onHide && t.onHide(e), this.toDisposeOnClean.dispose(), yl(this.view);
  }
  isVisible() {
    return !!this.delegate;
  }
  onDOMEvent(e, t) {
    this.delegate && (this.delegate.onDOMEvent ? this.delegate.onDOMEvent(e, fe(e).document.activeElement) : t && !_i(e.target, this.container) && this.hide());
  }
  dispose() {
    this.hide(), super.dispose();
  }
};
Du.BUBBLE_UP_EVENTS = ["click", "keydown", "focus", "blur"], Du.BUBBLE_DOWN_EVENTS = ["click"];
let Px = Du;
const sne = (
  /* css */
  `
	:host {
		all: initial; /* 1st rule so subsequent properties are reset. */
	}

	.codicon[class*='codicon-'] {
		font: normal normal normal 16px/1 codicon;
		display: inline-block;
		text-decoration: none;
		text-rendering: auto;
		text-align: center;
		-webkit-font-smoothing: antialiased;
		-moz-osx-font-smoothing: grayscale;
		user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	:host {
		font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "HelveticaNeue-Light", system-ui, "Ubuntu", "Droid Sans", sans-serif;
	}

	:host-context(.mac) { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
	:host-context(.mac:lang(zh-Hans)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Hiragino Sans GB", sans-serif; }
	:host-context(.mac:lang(zh-Hant)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang TC", sans-serif; }
	:host-context(.mac:lang(ja)) { font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic Pro", sans-serif; }
	:host-context(.mac:lang(ko)) { font-family: -apple-system, BlinkMacSystemFont, "Nanum Gothic", "Apple SD Gothic Neo", "AppleGothic", sans-serif; }

	:host-context(.windows) { font-family: "Segoe WPC", "Segoe UI", sans-serif; }
	:host-context(.windows:lang(zh-Hans)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft YaHei", sans-serif; }
	:host-context(.windows:lang(zh-Hant)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft Jhenghei", sans-serif; }
	:host-context(.windows:lang(ja)) { font-family: "Segoe WPC", "Segoe UI", "Yu Gothic UI", "Meiryo UI", sans-serif; }
	:host-context(.windows:lang(ko)) { font-family: "Segoe WPC", "Segoe UI", "Malgun Gothic", "Dotom", sans-serif; }

	:host-context(.linux) { font-family: system-ui, "Ubuntu", "Droid Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hans)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans SC", "Source Han Sans CN", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hant)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans TC", "Source Han Sans TW", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ja)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans J", "Source Han Sans JP", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ko)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans K", "Source Han Sans JR", "Source Han Sans", "UnDotum", "FBaekmuk Gulim", sans-serif; }
`
);
var one = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, rne = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let _C = class extends U {
  constructor(e) {
    super(), this.layoutService = e, this.contextView = this._register(new Px(
      this.layoutService.mainContainer,
      1
      /* ContextViewDOMPosition.ABSOLUTE */
    )), this.layout(), this._register(e.onDidLayoutContainer(() => this.layout()));
  }
  // ContextView
  showContextView(e, t, i) {
    let n;
    t ? t === this.layoutService.getContainer(fe(t)) ? n = 1 : i ? n = 3 : n = 2 : n = 1, this.contextView.setContainer(t ?? this.layoutService.activeContainer, n), this.contextView.show(e);
    const o = {
      close: () => {
        this.openContextView === o && this.hideContextView();
      }
    };
    return this.openContextView = o, o;
  }
  layout() {
    this.contextView.layout();
  }
  hideContextView(e) {
    this.contextView.hide(e), this.openContextView = void 0;
  }
};
_C = one([
  rne(0, oc)
], _C);
class ane extends _C {
  getContextViewElement() {
    return this.contextView.getViewElement();
  }
}
class lne {
  constructor(e, t, i) {
    this.hoverDelegate = e, this.target = t, this.fadeInAnimation = i;
  }
  async update(e, t, i) {
    if (this._cancellationTokenSource && (this._cancellationTokenSource.dispose(!0), this._cancellationTokenSource = void 0), this.isDisposed)
      return;
    let n;
    if (e === void 0 || Ss(e) || ki(e))
      n = e;
    else if (!Wb(e.markdown))
      n = e.markdown ?? e.markdownNotSupportedFallback;
    else {
      this._hoverWidget || this.show(m("iconLabel.loading", "Loading..."), t, i), this._cancellationTokenSource = new Vs();
      const o = this._cancellationTokenSource.token;
      if (n = await e.markdown(o), n === void 0 && (n = e.markdownNotSupportedFallback), this.isDisposed || o.isCancellationRequested)
        return;
    }
    this.show(n, t, i);
  }
  show(e, t, i) {
    var o;
    const n = this._hoverWidget;
    if (this.hasContent(e)) {
      const r = {
        content: e,
        target: this.target,
        actions: i == null ? void 0 : i.actions,
        linkHandler: i == null ? void 0 : i.linkHandler,
        trapFocus: i == null ? void 0 : i.trapFocus,
        appearance: {
          showPointer: this.hoverDelegate.placement === "element",
          skipFadeInAnimation: !this.fadeInAnimation || !!n,
          // do not fade in if the hover is already showing
          showHoverHint: (o = i == null ? void 0 : i.appearance) == null ? void 0 : o.showHoverHint
        },
        position: {
          hoverPosition: 2
        }
      };
      this._hoverWidget = this.hoverDelegate.showHover(r, t);
    }
    n == null || n.dispose();
  }
  hasContent(e) {
    return e ? Mr(e) ? !!e.value : !0 : !1;
  }
  get isDisposed() {
    var e;
    return (e = this._hoverWidget) == null ? void 0 : e.isDisposed;
  }
  dispose() {
    var e, t;
    (e = this._hoverWidget) == null || e.dispose(), (t = this._cancellationTokenSource) == null || t.dispose(!0), this._cancellationTokenSource = void 0;
  }
}
var cne = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, dg = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Ox = class extends U {
  constructor(e, t, i, n, o) {
    super(), this._instantiationService = e, this._keybindingService = i, this._layoutService = n, this._accessibilityService = o, this._managedHovers = /* @__PURE__ */ new Map(), t.onDidShowContextMenu(() => this.hideHover()), this._contextViewHandler = this._register(new _C(this._layoutService));
  }
  showHover(e, t, i) {
    var l, c, h, d;
    if (yA(this._currentHoverOptions) === yA(e) || this._currentHover && ((c = (l = this._currentHoverOptions) == null ? void 0 : l.persistence) != null && c.sticky))
      return;
    this._currentHoverOptions = e, this._lastHoverOptions = e;
    const n = e.trapFocus || this._accessibilityService.isScreenReaderOptimized(), o = Gi();
    i || (n && o ? o.classList.contains("monaco-hover") || (this._lastFocusedElementBeforeOpen = o) : this._lastFocusedElementBeforeOpen = void 0);
    const r = new ne(), a = this._instantiationService.createInstance(Ax, e);
    if ((h = e.persistence) != null && h.sticky && (a.isLocked = !0), a.onDispose(() => {
      var f, g;
      ((f = this._currentHover) == null ? void 0 : f.domNode) && H4(this._currentHover.domNode) && ((g = this._lastFocusedElementBeforeOpen) == null || g.focus()), this._currentHoverOptions === e && (this._currentHoverOptions = void 0), r.dispose();
    }, void 0, r), !e.container) {
      const u = ki(e.target) ? e.target : e.target.targetElements[0];
      e.container = this._layoutService.getContainer(fe(u));
    }
    if (this._contextViewHandler.showContextView(new hne(a, t), e.container), a.onRequestLayout(() => this._contextViewHandler.layout(), void 0, r), (d = e.persistence) != null && d.sticky)
      r.add(z(fe(e.container).document, X.MOUSE_DOWN, (u) => {
        _i(u.target, a.domNode) || this.doHideHover();
      }));
    else {
      if ("targetElements" in e.target)
        for (const f of e.target.targetElements)
          r.add(z(f, X.CLICK, () => this.hideHover()));
      else
        r.add(z(e.target, X.CLICK, () => this.hideHover()));
      const u = Gi();
      if (u) {
        const f = fe(u).document;
        r.add(z(u, X.KEY_DOWN, (g) => {
          var p;
          return this._keyDown(g, a, !!((p = e.persistence) != null && p.hideOnKeyDown));
        })), r.add(z(f, X.KEY_DOWN, (g) => {
          var p;
          return this._keyDown(g, a, !!((p = e.persistence) != null && p.hideOnKeyDown));
        })), r.add(z(u, X.KEY_UP, (g) => this._keyUp(g, a))), r.add(z(f, X.KEY_UP, (g) => this._keyUp(g, a)));
      }
    }
    if ("IntersectionObserver" in pt) {
      const u = new IntersectionObserver((g) => this._intersectionChange(g, a), { threshold: 0 }), f = "targetElements" in e.target ? e.target.targetElements[0] : e.target;
      u.observe(f), r.add(_e(() => u.disconnect()));
    }
    return this._currentHover = a, a;
  }
  hideHover() {
    var e;
    (e = this._currentHover) != null && e.isLocked || !this._currentHoverOptions || this.doHideHover();
  }
  doHideHover() {
    this._currentHover = void 0, this._currentHoverOptions = void 0, this._contextViewHandler.hideContextView();
  }
  _intersectionChange(e, t) {
    e[e.length - 1].isIntersecting || t.dispose();
  }
  showAndFocusLastHover() {
    this._lastHoverOptions && this.showHover(this._lastHoverOptions, !0, !0);
  }
  _keyDown(e, t, i) {
    var r, a;
    if (e.key === "Alt") {
      t.isLocked = !0;
      return;
    }
    const n = new Dt(e);
    this._keybindingService.resolveKeyboardEvent(n).getSingleModifierDispatchChords().some((l) => !!l) || this._keybindingService.softDispatch(n, n.target).kind !== 0 || i && (!((r = this._currentHoverOptions) != null && r.trapFocus) || e.key !== "Tab") && (this.hideHover(), (a = this._lastFocusedElementBeforeOpen) == null || a.focus());
  }
  _keyUp(e, t) {
    var i;
    e.key === "Alt" && (t.isLocked = !1, t.isMouseIn || (this.hideHover(), (i = this._lastFocusedElementBeforeOpen) == null || i.focus()));
  }
  // TODO: Investigate performance of this function. There seems to be a lot of content created
  //       and thrown away on start up
  setupManagedHover(e, t, i, n) {
    t.setAttribute("custom-hover", "true"), t.title !== "" && (console.warn("HTML element already has a title attribute, which will conflict with the custom hover. Please remove the title attribute."), console.trace("Stack trace:", t.title), t.title = "");
    let o, r;
    const a = (w, v) => {
      var L;
      const S = r !== void 0;
      w && (r == null || r.dispose(), r = void 0), v && (o == null || o.dispose(), o = void 0), S && ((L = e.onDidHideHover) == null || L.call(e), r = void 0);
    }, l = (w, v, S, L) => new Ya(async () => {
      (!r || r.isDisposed) && (r = new lne(e, S || t, w > 0), await r.update(typeof i == "function" ? i() : i, v, { ...n, trapFocus: L }));
    }, w);
    let c = !1;
    const h = z(t, X.MOUSE_DOWN, () => {
      c = !0, a(!0, !0);
    }, !0), d = z(t, X.MOUSE_UP, () => {
      c = !1;
    }, !0), u = z(t, X.MOUSE_LEAVE, (w) => {
      c = !1, a(!1, w.fromElement === t);
    }, !0), f = (w) => {
      if (o)
        return;
      const v = new ne(), S = {
        targetElements: [t],
        dispose: () => {
        }
      };
      if (e.placement === void 0 || e.placement === "mouse") {
        const L = (k) => {
          S.x = k.x + 10, ki(k.target) && SA(k.target, t) !== t && a(!0, !0);
        };
        v.add(z(t, X.MOUSE_MOVE, L, !0));
      }
      o = v, !(ki(w.target) && SA(w.target, t) !== t) && v.add(l(e.delay, !1, S));
    }, g = z(t, X.MOUSE_OVER, f, !0), p = () => {
      if (c || o)
        return;
      const w = {
        targetElements: [t],
        dispose: () => {
        }
      }, v = new ne(), S = () => a(!0, !0);
      v.add(z(t, X.BLUR, S, !0)), v.add(l(e.delay, !1, w)), o = v;
    };
    let _;
    const b = t.tagName.toLowerCase();
    b !== "input" && b !== "textarea" && (_ = z(t, X.FOCUS, p, !0));
    const C = {
      show: (w) => {
        a(!1, !0), l(0, w, void 0, w);
      },
      hide: () => {
        a(!0, !0);
      },
      update: async (w, v) => {
        i = w, await (r == null ? void 0 : r.update(i, void 0, v));
      },
      dispose: () => {
        this._managedHovers.delete(t), g.dispose(), u.dispose(), h.dispose(), d.dispose(), _ == null || _.dispose(), a(!0, !0);
      }
    };
    return this._managedHovers.set(t, C), C;
  }
  showManagedHover(e) {
    const t = this._managedHovers.get(e);
    t && t.show(!0);
  }
  dispose() {
    this._managedHovers.forEach((e) => e.dispose()), super.dispose();
  }
};
Ox = cne([
  dg(0, Pe),
  dg(1, nr),
  dg(2, Lt),
  dg(3, oc),
  dg(4, Ks)
], Ox);
function yA(s) {
  if (s !== void 0)
    return (s == null ? void 0 : s.id) ?? s;
}
class hne {
  get anchorPosition() {
    return this._hover.anchor;
  }
  constructor(e, t = !1) {
    this._hover = e, this._focus = t, this.layer = 1;
  }
  render(e) {
    return this._hover.render(e), this._focus && this._hover.focus(), this._hover;
  }
  getAnchor() {
    return {
      x: this._hover.x,
      y: this._hover.y
    };
  }
  layout() {
    this._hover.layout();
  }
}
function SA(s, e) {
  for (e = e ?? fe(s).document.body; !s.hasAttribute("custom-hover") && s !== e; )
    s = s.parentElement;
  return s;
}
Ze(
  Cd,
  Ox,
  1
  /* InstantiationType.Delayed */
);
tr((s, e) => {
  const t = s.getColor(JO);
  t && (e.addRule(`.monaco-workbench .workbench-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${t.transparent(0.5)}; }`), e.addRule(`.monaco-workbench .workbench-hover hr { border-top: 1px solid ${t.transparent(0.5)}; }`));
});
const Ai = {
  enableSplitViewResizing: !0,
  renderSideBySide: !0,
  renderMarginRevertIcon: !0,
  renderGutterMenu: !0,
  maxComputationTime: 5e3,
  maxFileSize: 50,
  ignoreTrimWhitespace: !0,
  renderIndicators: !0,
  originalEditable: !1,
  diffCodeLens: !1,
  renderOverviewRuler: !0,
  diffWordWrap: "inherit",
  diffAlgorithm: "advanced",
  accessibilityVerbose: !1,
  experimental: {
    showMoves: !1,
    showEmptyDecorations: !0,
    useTrueInlineView: !1
  },
  hideUnchangedRegions: {
    enabled: !1,
    contextLineCount: 3,
    minimumLineCount: 3,
    revealLineCount: 20
  },
  isInEmbeddedEditor: !1,
  onlyShowAccessibleDiffViewer: !1,
  renderSideBySideInlineBreakpoint: 900,
  useInlineViewWhenSpaceIsLimited: !0,
  compactMode: !1
}, dne = Object.freeze({
  id: "editor",
  order: 5,
  type: "object",
  title: m("editorConfigurationTitle", "Editor"),
  scope: 5
}), bC = {
  ...dne,
  properties: {
    "editor.tabSize": {
      type: "number",
      default: ji.tabSize,
      minimum: 1,
      markdownDescription: m("tabSize", "The number of spaces a tab is equal to. This setting is overridden based on the file contents when {0} is on.", "`#editor.detectIndentation#`")
    },
    "editor.indentSize": {
      anyOf: [
        {
          type: "string",
          enum: ["tabSize"]
        },
        {
          type: "number",
          minimum: 1
        }
      ],
      default: "tabSize",
      markdownDescription: m("indentSize", 'The number of spaces used for indentation or `"tabSize"` to use the value from `#editor.tabSize#`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.')
    },
    "editor.insertSpaces": {
      type: "boolean",
      default: ji.insertSpaces,
      markdownDescription: m("insertSpaces", "Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when {0} is on.", "`#editor.detectIndentation#`")
    },
    "editor.detectIndentation": {
      type: "boolean",
      default: ji.detectIndentation,
      markdownDescription: m("detectIndentation", "Controls whether {0} and {1} will be automatically detected when a file is opened based on the file contents.", "`#editor.tabSize#`", "`#editor.insertSpaces#`")
    },
    "editor.trimAutoWhitespace": {
      type: "boolean",
      default: ji.trimAutoWhitespace,
      description: m("trimAutoWhitespace", "Remove trailing auto inserted whitespace.")
    },
    "editor.largeFileOptimizations": {
      type: "boolean",
      default: ji.largeFileOptimizations,
      description: m("largeFileOptimizations", "Special handling for large files to disable certain memory intensive features.")
    },
    "editor.wordBasedSuggestions": {
      enum: ["off", "currentDocument", "matchingDocuments", "allDocuments"],
      default: "matchingDocuments",
      enumDescriptions: [
        m("wordBasedSuggestions.off", "Turn off Word Based Suggestions."),
        m("wordBasedSuggestions.currentDocument", "Only suggest words from the active document."),
        m("wordBasedSuggestions.matchingDocuments", "Suggest words from all open documents of the same language."),
        m("wordBasedSuggestions.allDocuments", "Suggest words from all open documents.")
      ],
      description: m("wordBasedSuggestions", "Controls whether completions should be computed based on words in the document and from which documents they are computed.")
    },
    "editor.semanticHighlighting.enabled": {
      enum: [!0, !1, "configuredByTheme"],
      enumDescriptions: [
        m("semanticHighlighting.true", "Semantic highlighting enabled for all color themes."),
        m("semanticHighlighting.false", "Semantic highlighting disabled for all color themes."),
        m("semanticHighlighting.configuredByTheme", "Semantic highlighting is configured by the current color theme's `semanticHighlighting` setting.")
      ],
      default: "configuredByTheme",
      description: m("semanticHighlighting.enabled", "Controls whether the semanticHighlighting is shown for the languages that support it.")
    },
    "editor.stablePeek": {
      type: "boolean",
      default: !1,
      markdownDescription: m("stablePeek", "Keep peek editors open even when double-clicking their content or when hitting `Escape`.")
    },
    "editor.maxTokenizationLineLength": {
      type: "integer",
      default: 2e4,
      description: m("maxTokenizationLineLength", "Lines above this length will not be tokenized for performance reasons")
    },
    "editor.experimental.asyncTokenization": {
      type: "boolean",
      default: !0,
      description: m("editor.experimental.asyncTokenization", "Controls whether the tokenization should happen asynchronously on a web worker."),
      tags: ["experimental"]
    },
    "editor.experimental.asyncTokenizationLogging": {
      type: "boolean",
      default: !1,
      description: m("editor.experimental.asyncTokenizationLogging", "Controls whether async tokenization should be logged. For debugging only.")
    },
    "editor.experimental.asyncTokenizationVerification": {
      type: "boolean",
      default: !1,
      description: m("editor.experimental.asyncTokenizationVerification", "Controls whether async tokenization should be verified against legacy background tokenization. Might slow down tokenization. For debugging only."),
      tags: ["experimental"]
    },
    "editor.experimental.treeSitterTelemetry": {
      type: "boolean",
      default: !1,
      markdownDescription: m("editor.experimental.treeSitterTelemetry", "Controls whether tree sitter parsing should be turned on and telemetry collected. Setting `editor.experimental.preferTreeSitter` for specific languages will take precedence."),
      tags: ["experimental"]
    },
    "editor.language.brackets": {
      type: ["array", "null"],
      default: null,
      // We want to distinguish the empty array from not configured.
      description: m("schema.brackets", "Defines the bracket symbols that increase or decrease the indentation."),
      items: {
        type: "array",
        items: [
          {
            type: "string",
            description: m("schema.openBracket", "The opening bracket character or string sequence.")
          },
          {
            type: "string",
            description: m("schema.closeBracket", "The closing bracket character or string sequence.")
          }
        ]
      }
    },
    "editor.language.colorizedBracketPairs": {
      type: ["array", "null"],
      default: null,
      // We want to distinguish the empty array from not configured.
      description: m("schema.colorizedBracketPairs", "Defines the bracket pairs that are colorized by their nesting level if bracket pair colorization is enabled."),
      items: {
        type: "array",
        items: [
          {
            type: "string",
            description: m("schema.openBracket", "The opening bracket character or string sequence.")
          },
          {
            type: "string",
            description: m("schema.closeBracket", "The closing bracket character or string sequence.")
          }
        ]
      }
    },
    "diffEditor.maxComputationTime": {
      type: "number",
      default: Ai.maxComputationTime,
      description: m("maxComputationTime", "Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout.")
    },
    "diffEditor.maxFileSize": {
      type: "number",
      default: Ai.maxFileSize,
      description: m("maxFileSize", "Maximum file size in MB for which to compute diffs. Use 0 for no limit.")
    },
    "diffEditor.renderSideBySide": {
      type: "boolean",
      default: Ai.renderSideBySide,
      description: m("sideBySide", "Controls whether the diff editor shows the diff side by side or inline.")
    },
    "diffEditor.renderSideBySideInlineBreakpoint": {
      type: "number",
      default: Ai.renderSideBySideInlineBreakpoint,
      description: m("renderSideBySideInlineBreakpoint", "If the diff editor width is smaller than this value, the inline view is used.")
    },
    "diffEditor.useInlineViewWhenSpaceIsLimited": {
      type: "boolean",
      default: Ai.useInlineViewWhenSpaceIsLimited,
      description: m("useInlineViewWhenSpaceIsLimited", "If enabled and the editor width is too small, the inline view is used.")
    },
    "diffEditor.renderMarginRevertIcon": {
      type: "boolean",
      default: Ai.renderMarginRevertIcon,
      description: m("renderMarginRevertIcon", "When enabled, the diff editor shows arrows in its glyph margin to revert changes.")
    },
    "diffEditor.renderGutterMenu": {
      type: "boolean",
      default: Ai.renderGutterMenu,
      description: m("renderGutterMenu", "When enabled, the diff editor shows a special gutter for revert and stage actions.")
    },
    "diffEditor.ignoreTrimWhitespace": {
      type: "boolean",
      default: Ai.ignoreTrimWhitespace,
      description: m("ignoreTrimWhitespace", "When enabled, the diff editor ignores changes in leading or trailing whitespace.")
    },
    "diffEditor.renderIndicators": {
      type: "boolean",
      default: Ai.renderIndicators,
      description: m("renderIndicators", "Controls whether the diff editor shows +/- indicators for added/removed changes.")
    },
    "diffEditor.codeLens": {
      type: "boolean",
      default: Ai.diffCodeLens,
      description: m("codeLens", "Controls whether the editor shows CodeLens.")
    },
    "diffEditor.wordWrap": {
      type: "string",
      enum: ["off", "on", "inherit"],
      default: Ai.diffWordWrap,
      markdownEnumDescriptions: [
        m("wordWrap.off", "Lines will never wrap."),
        m("wordWrap.on", "Lines will wrap at the viewport width."),
        m("wordWrap.inherit", "Lines will wrap according to the {0} setting.", "`#editor.wordWrap#`")
      ]
    },
    "diffEditor.diffAlgorithm": {
      type: "string",
      enum: ["legacy", "advanced"],
      default: Ai.diffAlgorithm,
      markdownEnumDescriptions: [
        m("diffAlgorithm.legacy", "Uses the legacy diffing algorithm."),
        m("diffAlgorithm.advanced", "Uses the advanced diffing algorithm.")
      ],
      tags: ["experimental"]
    },
    "diffEditor.hideUnchangedRegions.enabled": {
      type: "boolean",
      default: Ai.hideUnchangedRegions.enabled,
      markdownDescription: m("hideUnchangedRegions.enabled", "Controls whether the diff editor shows unchanged regions.")
    },
    "diffEditor.hideUnchangedRegions.revealLineCount": {
      type: "integer",
      default: Ai.hideUnchangedRegions.revealLineCount,
      markdownDescription: m("hideUnchangedRegions.revealLineCount", "Controls how many lines are used for unchanged regions."),
      minimum: 1
    },
    "diffEditor.hideUnchangedRegions.minimumLineCount": {
      type: "integer",
      default: Ai.hideUnchangedRegions.minimumLineCount,
      markdownDescription: m("hideUnchangedRegions.minimumLineCount", "Controls how many lines are used as a minimum for unchanged regions."),
      minimum: 1
    },
    "diffEditor.hideUnchangedRegions.contextLineCount": {
      type: "integer",
      default: Ai.hideUnchangedRegions.contextLineCount,
      markdownDescription: m("hideUnchangedRegions.contextLineCount", "Controls how many lines are used as context when comparing unchanged regions."),
      minimum: 1
    },
    "diffEditor.experimental.showMoves": {
      type: "boolean",
      default: Ai.experimental.showMoves,
      markdownDescription: m("showMoves", "Controls whether the diff editor should show detected code moves.")
    },
    "diffEditor.experimental.showEmptyDecorations": {
      type: "boolean",
      default: Ai.experimental.showEmptyDecorations,
      description: m("showEmptyDecorations", "Controls whether the diff editor shows empty decorations to see where characters got inserted or deleted.")
    },
    "diffEditor.experimental.useTrueInlineView": {
      type: "boolean",
      default: Ai.experimental.useTrueInlineView,
      description: m("useTrueInlineView", "If enabled and the editor uses the inline view, word changes are rendered inline.")
    }
  }
};
function une(s) {
  return typeof s.type < "u" || typeof s.anyOf < "u";
}
for (const s of Qd) {
  const e = s.schema;
  if (typeof e < "u")
    if (une(e))
      bC.properties[`editor.${s.name}`] = e;
    else
      for (const t in e)
        Object.hasOwnProperty.call(e, t) && (bC.properties[t] = e[t]);
}
let H_ = null;
function p3() {
  return H_ === null && (H_ = /* @__PURE__ */ Object.create(null), Object.keys(bC.properties).forEach((s) => {
    H_[s] = !0;
  })), H_;
}
function fne(s) {
  return p3()[`editor.${s}`] || !1;
}
function gne(s) {
  return p3()[`diffEditor.${s}`] || !1;
}
const mne = Mi.as(hd.Configuration);
mne.registerConfiguration(bC);
function V_(s) {
  return Object.isFrozen(s) ? s : LW(s);
}
class Ni {
  static createEmptyModel(e) {
    return new Ni({}, [], [], void 0, e);
  }
  constructor(e, t, i, n, o) {
    this._contents = e, this._keys = t, this._overrides = i, this.raw = n, this.logService = o, this.overrideConfigurations = /* @__PURE__ */ new Map();
  }
  get rawConfiguration() {
    var e;
    if (!this._rawConfiguration)
      if ((e = this.raw) != null && e.length) {
        const t = this.raw.map((i) => {
          if (i instanceof Ni)
            return i;
          const n = new pne("", this.logService);
          return n.parseRaw(i), n.configurationModel;
        });
        this._rawConfiguration = t.reduce((i, n) => n === i ? n : i.merge(n), t[0]);
      } else
        this._rawConfiguration = this;
    return this._rawConfiguration;
  }
  get contents() {
    return this._contents;
  }
  get overrides() {
    return this._overrides;
  }
  get keys() {
    return this._keys;
  }
  isEmpty() {
    return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
  }
  getValue(e) {
    return e ? HT(this.contents, e) : this.contents;
  }
  inspect(e, t) {
    const i = this;
    return {
      get value() {
        return V_(i.rawConfiguration.getValue(e));
      },
      get override() {
        return t ? V_(i.rawConfiguration.getOverrideValue(e, t)) : void 0;
      },
      get merged() {
        return V_(t ? i.rawConfiguration.override(t).getValue(e) : i.rawConfiguration.getValue(e));
      },
      get overrides() {
        const n = [];
        for (const { contents: o, identifiers: r, keys: a } of i.rawConfiguration.overrides) {
          const l = new Ni(o, a, [], void 0, i.logService).getValue(e);
          l !== void 0 && n.push({ identifiers: r, value: l });
        }
        return n.length ? V_(n) : void 0;
      }
    };
  }
  getOverrideValue(e, t) {
    const i = this.getContentsForOverrideIdentifer(t);
    return i ? e ? HT(i, e) : i : void 0;
  }
  override(e) {
    let t = this.overrideConfigurations.get(e);
    return t || (t = this.createOverrideConfigurationModel(e), this.overrideConfigurations.set(e, t)), t;
  }
  merge(...e) {
    var r, a;
    const t = pa(this.contents), i = pa(this.overrides), n = [...this.keys], o = (r = this.raw) != null && r.length ? [...this.raw] : [this];
    for (const l of e)
      if (o.push(...(a = l.raw) != null && a.length ? l.raw : [l]), !l.isEmpty()) {
        this.mergeContents(t, l.contents);
        for (const c of l.overrides) {
          const [h] = i.filter((d) => li(d.identifiers, c.identifiers));
          h ? (this.mergeContents(h.contents, c.contents), h.keys.push(...c.keys), h.keys = zh(h.keys)) : i.push(pa(c));
        }
        for (const c of l.keys)
          n.indexOf(c) === -1 && n.push(c);
      }
    return new Ni(t, n, i, o.every((l) => l instanceof Ni) ? void 0 : o, this.logService);
  }
  createOverrideConfigurationModel(e) {
    const t = this.getContentsForOverrideIdentifer(e);
    if (!t || typeof t != "object" || !Object.keys(t).length)
      return this;
    const i = {};
    for (const n of zh([...Object.keys(this.contents), ...Object.keys(t)])) {
      let o = this.contents[n];
      const r = t[n];
      r && (typeof o == "object" && typeof r == "object" ? (o = pa(o), this.mergeContents(o, r)) : o = r), i[n] = o;
    }
    return new Ni(i, this.keys, this.overrides, void 0, this.logService);
  }
  mergeContents(e, t) {
    for (const i of Object.keys(t)) {
      if (i in e && Wi(e[i]) && Wi(t[i])) {
        this.mergeContents(e[i], t[i]);
        continue;
      }
      e[i] = pa(t[i]);
    }
  }
  getContentsForOverrideIdentifer(e) {
    let t = null, i = null;
    const n = (o) => {
      o && (i ? this.mergeContents(i, o) : i = pa(o));
    };
    for (const o of this.overrides)
      o.identifiers.length === 1 && o.identifiers[0] === e ? t = o.contents : o.identifiers.includes(e) && n(o.contents);
    return n(t), i;
  }
  toJSON() {
    return {
      contents: this.contents,
      overrides: this.overrides,
      keys: this.keys
    };
  }
  setValue(e, t) {
    this.updateValue(e, t, !1);
  }
  removeValue(e) {
    const t = this.keys.indexOf(e);
    t !== -1 && (this.keys.splice(t, 1), cj(this.contents, e), Yl.test(e) && this.overrides.splice(this.overrides.findIndex((i) => li(i.identifiers, v1(e))), 1));
  }
  updateValue(e, t, i) {
    if (P5(this.contents, e, t, (n) => this.logService.error(n)), i = i || this.keys.indexOf(e) === -1, i && this.keys.push(e), Yl.test(e)) {
      const n = v1(e), o = {
        identifiers: n,
        keys: Object.keys(this.contents[e]),
        contents: GS(this.contents[e], (a) => this.logService.error(a))
      }, r = this.overrides.findIndex((a) => li(a.identifiers, n));
      r !== -1 ? this.overrides[r] = o : this.overrides.push(o);
    }
  }
}
class pne {
  constructor(e, t) {
    this._name = e, this.logService = t, this._raw = null, this._configurationModel = null, this._restrictedConfigurations = [];
  }
  get configurationModel() {
    return this._configurationModel || Ni.createEmptyModel(this.logService);
  }
  parseRaw(e, t) {
    this._raw = e;
    const { contents: i, keys: n, overrides: o, restricted: r, hasExcludedProperties: a } = this.doParseRaw(e, t);
    this._configurationModel = new Ni(i, n, o, a ? [e] : void 0, this.logService), this._restrictedConfigurations = r || [];
  }
  doParseRaw(e, t) {
    const i = Mi.as(hd.Configuration).getConfigurationProperties(), n = this.filter(e, i, !0, t);
    e = n.raw;
    const o = GS(e, (l) => this.logService.error(`Conflict in settings file ${this._name}: ${l}`)), r = Object.keys(e), a = this.toOverrides(e, (l) => this.logService.error(`Conflict in settings file ${this._name}: ${l}`));
    return { contents: o, keys: r, overrides: a, restricted: n.restricted, hasExcludedProperties: n.hasExcludedProperties };
  }
  filter(e, t, i, n) {
    var l, c, h;
    let o = !1;
    if (!(n != null && n.scopes) && !(n != null && n.skipRestricted) && !((l = n == null ? void 0 : n.exclude) != null && l.length))
      return { raw: e, restricted: [], hasExcludedProperties: o };
    const r = {}, a = [];
    for (const d in e)
      if (Yl.test(d) && i) {
        const u = this.filter(e[d], t, !1, n);
        r[d] = u.raw, o = o || u.hasExcludedProperties, a.push(...u.restricted);
      } else {
        const u = t[d], f = u ? typeof u.scope < "u" ? u.scope : 3 : void 0;
        u != null && u.restricted && a.push(d), !((c = n.exclude) != null && c.includes(d)) && ((h = n.include) != null && h.includes(d) || (f === void 0 || n.scopes === void 0 || n.scopes.includes(f)) && !(n.skipRestricted && (u != null && u.restricted))) ? r[d] = e[d] : o = !0;
      }
    return { raw: r, restricted: a, hasExcludedProperties: o };
  }
  toOverrides(e, t) {
    const i = [];
    for (const n of Object.keys(e))
      if (Yl.test(n)) {
        const o = {};
        for (const r in e[n])
          o[r] = e[n][r];
        i.push({
          identifiers: v1(n),
          keys: Object.keys(o),
          contents: GS(o, t)
        });
      }
    return i;
  }
}
class _ne {
  constructor(e, t, i, n, o, r, a, l, c, h, d, u, f) {
    this.key = e, this.overrides = t, this._value = i, this.overrideIdentifiers = n, this.defaultConfiguration = o, this.policyConfiguration = r, this.applicationConfiguration = a, this.userConfiguration = l, this.localUserConfiguration = c, this.remoteUserConfiguration = h, this.workspaceConfiguration = d, this.folderConfigurationModel = u, this.memoryConfigurationModel = f;
  }
  toInspectValue(e) {
    return (e == null ? void 0 : e.value) !== void 0 || (e == null ? void 0 : e.override) !== void 0 || (e == null ? void 0 : e.overrides) !== void 0 ? e : void 0;
  }
  get userInspectValue() {
    return this._userInspectValue || (this._userInspectValue = this.userConfiguration.inspect(this.key, this.overrides.overrideIdentifier)), this._userInspectValue;
  }
  get user() {
    return this.toInspectValue(this.userInspectValue);
  }
}
class qw {
  constructor(e, t, i, n, o, r, a, l, c, h) {
    this._defaultConfiguration = e, this._policyConfiguration = t, this._applicationConfiguration = i, this._localUserConfiguration = n, this._remoteUserConfiguration = o, this._workspaceConfiguration = r, this._folderConfigurations = a, this._memoryConfiguration = l, this._memoryConfigurationByResource = c, this.logService = h, this._workspaceConsolidatedConfiguration = null, this._foldersConsolidatedConfigurations = new Yn(), this._userConfiguration = null;
  }
  getValue(e, t, i) {
    return this.getConsolidatedConfigurationModel(e, t, i).getValue(e);
  }
  updateValue(e, t, i = {}) {
    let n;
    i.resource ? (n = this._memoryConfigurationByResource.get(i.resource), n || (n = Ni.createEmptyModel(this.logService), this._memoryConfigurationByResource.set(i.resource, n))) : n = this._memoryConfiguration, t === void 0 ? n.removeValue(e) : n.setValue(e, t), i.resource || (this._workspaceConsolidatedConfiguration = null);
  }
  inspect(e, t, i) {
    const n = this.getConsolidatedConfigurationModel(e, t, i), o = this.getFolderConfigurationModelForResource(t.resource, i), r = t.resource ? this._memoryConfigurationByResource.get(t.resource) || this._memoryConfiguration : this._memoryConfiguration, a = /* @__PURE__ */ new Set();
    for (const l of n.overrides)
      for (const c of l.identifiers)
        n.getOverrideValue(e, c) !== void 0 && a.add(c);
    return new _ne(e, t, n.getValue(e), a.size ? [...a] : void 0, this._defaultConfiguration, this._policyConfiguration.isEmpty() ? void 0 : this._policyConfiguration, this.applicationConfiguration.isEmpty() ? void 0 : this.applicationConfiguration, this.userConfiguration, this.localUserConfiguration, this.remoteUserConfiguration, i ? this._workspaceConfiguration : void 0, o || void 0, r);
  }
  get applicationConfiguration() {
    return this._applicationConfiguration;
  }
  get userConfiguration() {
    return this._userConfiguration || (this._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration)), this._userConfiguration;
  }
  get localUserConfiguration() {
    return this._localUserConfiguration;
  }
  get remoteUserConfiguration() {
    return this._remoteUserConfiguration;
  }
  getConsolidatedConfigurationModel(e, t, i) {
    let n = this.getConsolidatedConfigurationModelForResource(t, i);
    return t.overrideIdentifier && (n = n.override(t.overrideIdentifier)), !this._policyConfiguration.isEmpty() && this._policyConfiguration.getValue(e) !== void 0 && (n = n.merge(this._policyConfiguration)), n;
  }
  getConsolidatedConfigurationModelForResource({ resource: e }, t) {
    let i = this.getWorkspaceConsolidatedConfiguration();
    if (t && e) {
      const n = t.getFolder(e);
      n && (i = this.getFolderConsolidatedConfiguration(n.uri) || i);
      const o = this._memoryConfigurationByResource.get(e);
      o && (i = i.merge(o));
    }
    return i;
  }
  getWorkspaceConsolidatedConfiguration() {
    return this._workspaceConsolidatedConfiguration || (this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.applicationConfiguration, this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration)), this._workspaceConsolidatedConfiguration;
  }
  getFolderConsolidatedConfiguration(e) {
    let t = this._foldersConsolidatedConfigurations.get(e);
    if (!t) {
      const i = this.getWorkspaceConsolidatedConfiguration(), n = this._folderConfigurations.get(e);
      n ? (t = i.merge(n), this._foldersConsolidatedConfigurations.set(e, t)) : t = i;
    }
    return t;
  }
  getFolderConfigurationModelForResource(e, t) {
    if (t && e) {
      const i = t.getFolder(e);
      if (i)
        return this._folderConfigurations.get(i.uri);
    }
  }
  toData() {
    return {
      defaults: {
        contents: this._defaultConfiguration.contents,
        overrides: this._defaultConfiguration.overrides,
        keys: this._defaultConfiguration.keys
      },
      policy: {
        contents: this._policyConfiguration.contents,
        overrides: this._policyConfiguration.overrides,
        keys: this._policyConfiguration.keys
      },
      application: {
        contents: this.applicationConfiguration.contents,
        overrides: this.applicationConfiguration.overrides,
        keys: this.applicationConfiguration.keys
      },
      user: {
        contents: this.userConfiguration.contents,
        overrides: this.userConfiguration.overrides,
        keys: this.userConfiguration.keys
      },
      workspace: {
        contents: this._workspaceConfiguration.contents,
        overrides: this._workspaceConfiguration.overrides,
        keys: this._workspaceConfiguration.keys
      },
      folders: [...this._folderConfigurations.keys()].reduce((e, t) => {
        const { contents: i, overrides: n, keys: o } = this._folderConfigurations.get(t);
        return e.push([t, { contents: i, overrides: n, keys: o }]), e;
      }, [])
    };
  }
  static parse(e, t) {
    const i = this.parseConfigurationModel(e.defaults, t), n = this.parseConfigurationModel(e.policy, t), o = this.parseConfigurationModel(e.application, t), r = this.parseConfigurationModel(e.user, t), a = this.parseConfigurationModel(e.workspace, t), l = e.folders.reduce((c, h) => (c.set(we.revive(h[0]), this.parseConfigurationModel(h[1], t)), c), new Yn());
    return new qw(i, n, o, r, Ni.createEmptyModel(t), a, l, Ni.createEmptyModel(t), new Yn(), t);
  }
  static parseConfigurationModel(e, t) {
    return new Ni(e.contents, e.keys, e.overrides, void 0, t);
  }
}
class bne {
  constructor(e, t, i, n, o) {
    this.change = e, this.previous = t, this.currentConfiguraiton = i, this.currentWorkspace = n, this.logService = o, this._marker = `
`, this._markerCode1 = this._marker.charCodeAt(0), this._markerCode2 = 46, this.affectedKeys = /* @__PURE__ */ new Set(), this._previousConfiguration = void 0;
    for (const r of e.keys)
      this.affectedKeys.add(r);
    for (const [, r] of e.overrides)
      for (const a of r)
        this.affectedKeys.add(a);
    this._affectsConfigStr = this._marker;
    for (const r of this.affectedKeys)
      this._affectsConfigStr += r + this._marker;
  }
  get previousConfiguration() {
    return !this._previousConfiguration && this.previous && (this._previousConfiguration = qw.parse(this.previous.data, this.logService)), this._previousConfiguration;
  }
  affectsConfiguration(e, t) {
    var a;
    const i = this._marker + e, n = this._affectsConfigStr.indexOf(i);
    if (n < 0)
      return !1;
    const o = n + i.length;
    if (o >= this._affectsConfigStr.length)
      return !1;
    const r = this._affectsConfigStr.charCodeAt(o);
    if (r !== this._markerCode1 && r !== this._markerCode2)
      return !1;
    if (t) {
      const l = this.previousConfiguration ? this.previousConfiguration.getValue(e, t, (a = this.previous) == null ? void 0 : a.workspace) : void 0, c = this.currentConfiguraiton.getValue(e, t, this.currentWorkspace);
      return !Xn(l, c);
    }
    return !0;
  }
}
const CC = {
  kind: 0
  /* ResultKind.NoMatchingKb */
}, Cne = {
  kind: 1
  /* ResultKind.MoreChordsNeeded */
};
function vne(s, e, t) {
  return { kind: 2, commandId: s, commandArgs: e, isBubble: t };
}
class tm {
  constructor(e, t, i) {
    var n;
    this._log = i, this._defaultKeybindings = e, this._defaultBoundCommands = /* @__PURE__ */ new Map();
    for (const o of e) {
      const r = o.command;
      r && r.charAt(0) !== "-" && this._defaultBoundCommands.set(r, !0);
    }
    this._map = /* @__PURE__ */ new Map(), this._lookupMap = /* @__PURE__ */ new Map(), this._keybindings = tm.handleRemovals([].concat(e).concat(t));
    for (let o = 0, r = this._keybindings.length; o < r; o++) {
      const a = this._keybindings[o];
      if (a.chords.length === 0)
        continue;
      const l = (n = a.when) == null ? void 0 : n.substituteConstants();
      l && l.type === 0 || this._addKeyPress(a.chords[0], a);
    }
  }
  static _isTargetedForRemoval(e, t, i) {
    if (t) {
      for (let n = 0; n < t.length; n++)
        if (t[n] !== e.chords[n])
          return !1;
    }
    return !(i && i.type !== 1 && (!e.when || !W8(i, e.when)));
  }
  /**
   * Looks for rules containing "-commandId" and removes them.
   */
  static handleRemovals(e) {
    const t = /* @__PURE__ */ new Map();
    for (let n = 0, o = e.length; n < o; n++) {
      const r = e[n];
      if (r.command && r.command.charAt(0) === "-") {
        const a = r.command.substring(1);
        t.has(a) ? t.get(a).push(r) : t.set(a, [r]);
      }
    }
    if (t.size === 0)
      return e;
    const i = [];
    for (let n = 0, o = e.length; n < o; n++) {
      const r = e[n];
      if (!r.command || r.command.length === 0) {
        i.push(r);
        continue;
      }
      if (r.command.charAt(0) === "-")
        continue;
      const a = t.get(r.command);
      if (!a || !r.isDefault) {
        i.push(r);
        continue;
      }
      let l = !1;
      for (const c of a) {
        const h = c.when;
        if (this._isTargetedForRemoval(r, c.chords, h)) {
          l = !0;
          break;
        }
      }
      if (!l) {
        i.push(r);
        continue;
      }
    }
    return i;
  }
  _addKeyPress(e, t) {
    const i = this._map.get(e);
    if (typeof i > "u") {
      this._map.set(e, [t]), this._addToLookupMap(t);
      return;
    }
    for (let n = i.length - 1; n >= 0; n--) {
      const o = i[n];
      if (o.command === t.command)
        continue;
      let r = !0;
      for (let a = 1; a < o.chords.length && a < t.chords.length; a++)
        if (o.chords[a] !== t.chords[a]) {
          r = !1;
          break;
        }
      r && tm.whenIsEntirelyIncluded(o.when, t.when) && this._removeFromLookupMap(o);
    }
    i.push(t), this._addToLookupMap(t);
  }
  _addToLookupMap(e) {
    if (!e.command)
      return;
    let t = this._lookupMap.get(e.command);
    typeof t > "u" ? (t = [e], this._lookupMap.set(e.command, t)) : t.push(e);
  }
  _removeFromLookupMap(e) {
    if (!e.command)
      return;
    const t = this._lookupMap.get(e.command);
    if (!(typeof t > "u")) {
      for (let i = 0, n = t.length; i < n; i++)
        if (t[i] === e) {
          t.splice(i, 1);
          return;
        }
    }
  }
  /**
   * Returns true if it is provable `a` implies `b`.
   */
  static whenIsEntirelyIncluded(e, t) {
    return !t || t.type === 1 ? !0 : !e || e.type === 1 ? !1 : zy(e, t);
  }
  getKeybindings() {
    return this._keybindings;
  }
  lookupPrimaryKeybinding(e, t) {
    const i = this._lookupMap.get(e);
    if (typeof i > "u" || i.length === 0)
      return null;
    if (i.length === 1)
      return i[0];
    for (let n = i.length - 1; n >= 0; n--) {
      const o = i[n];
      if (t.contextMatchesRules(o.when))
        return o;
    }
    return i[i.length - 1];
  }
  /**
   * Looks up a keybinding trigged as a result of pressing a sequence of chords - `[...currentChords, keypress]`
   *
   * Example: resolving 3 chords pressed sequentially - `cmd+k cmd+p cmd+i`:
   * 	`currentChords = [ 'cmd+k' , 'cmd+p' ]` and `keypress = `cmd+i` - last pressed chord
   */
  resolve(e, t, i) {
    const n = [...t, i];
    this._log(`| Resolving ${n}`);
    const o = this._map.get(n[0]);
    if (o === void 0)
      return this._log("\\ No keybinding entries."), CC;
    let r = null;
    if (n.length < 2)
      r = o;
    else {
      r = [];
      for (let l = 0, c = o.length; l < c; l++) {
        const h = o[l];
        if (n.length > h.chords.length)
          continue;
        let d = !0;
        for (let u = 1; u < n.length; u++)
          if (h.chords[u] !== n[u]) {
            d = !1;
            break;
          }
        d && r.push(h);
      }
    }
    const a = this._findCommand(e, r);
    return a ? n.length < a.chords.length ? (this._log(`\\ From ${r.length} keybinding entries, awaiting ${a.chords.length - n.length} more chord(s), when: ${LA(a.when)}, source: ${kA(a)}.`), Cne) : (this._log(`\\ From ${r.length} keybinding entries, matched ${a.command}, when: ${LA(a.when)}, source: ${kA(a)}.`), vne(a.command, a.commandArgs, a.bubble)) : (this._log(`\\ From ${r.length} keybinding entries, no when clauses matched the context.`), CC);
  }
  _findCommand(e, t) {
    for (let i = t.length - 1; i >= 0; i--) {
      const n = t[i];
      if (tm._contextMatchesRules(e, n.when))
        return n;
    }
    return null;
  }
  static _contextMatchesRules(e, t) {
    return t ? t.evaluate(e) : !0;
  }
}
function LA(s) {
  return s ? `${s.serialize()}` : "no when condition";
}
function kA(s) {
  return s.extensionId ? s.isBuiltinExtension ? `built-in extension ${s.extensionId}` : `user extension ${s.extensionId}` : s.isDefault ? "built-in" : "user";
}
const wne = /^(cursor|delete|undo|redo|tab|editor\.action\.clipboard)/;
class yne extends U {
  get onDidUpdateKeybindings() {
    return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : ee.None;
  }
  get inChordMode() {
    return this._currentChords.length > 0;
  }
  constructor(e, t, i, n, o) {
    super(), this._contextKeyService = e, this._commandService = t, this._telemetryService = i, this._notificationService = n, this._logService = o, this._onDidUpdateKeybindings = this._register(new A()), this._currentChords = [], this._currentChordChecker = new wE(), this._currentChordStatusMessage = null, this._ignoreSingleModifiers = du.EMPTY, this._currentSingleModifier = null, this._currentSingleModifierClearTimeout = new Ya(), this._currentlyDispatchingCommandId = null, this._logging = !1;
  }
  dispose() {
    super.dispose();
  }
  _log(e) {
    this._logging && this._logService.info(`[KeybindingService]: ${e}`);
  }
  getKeybindings() {
    return this._getResolver().getKeybindings();
  }
  lookupKeybinding(e, t) {
    const i = this._getResolver().lookupPrimaryKeybinding(e, t || this._contextKeyService);
    if (i)
      return i.resolvedKeybinding;
  }
  dispatchEvent(e, t) {
    return this._dispatch(e, t);
  }
  // TODO@ulugbekna: update namings to align with `_doDispatch`
  // TODO@ulugbekna: this fn doesn't seem to take into account single-modifier keybindings, eg `shift shift`
  softDispatch(e, t) {
    this._log("/ Soft dispatching keyboard event");
    const i = this.resolveKeyboardEvent(e);
    if (i.hasMultipleChords())
      return console.warn("keyboard event should not be mapped to multiple chords"), CC;
    const [n] = i.getDispatchChords();
    if (n === null)
      return this._log("\\ Keyboard event cannot be dispatched"), CC;
    const o = this._contextKeyService.getContext(t), r = this._currentChords.map(({ keypress: a }) => a);
    return this._getResolver().resolve(o, r, n);
  }
  _scheduleLeaveChordMode() {
    const e = Date.now();
    this._currentChordChecker.cancelAndSet(() => {
      if (!this._documentHasFocus()) {
        this._leaveChordMode();
        return;
      }
      Date.now() - e > 5e3 && this._leaveChordMode();
    }, 500);
  }
  _expectAnotherChord(e, t) {
    switch (this._currentChords.push({ keypress: e, label: t }), this._currentChords.length) {
      case 0:
        throw oE("impossible");
      case 1:
        this._currentChordStatusMessage = this._notificationService.status(m("first.chord", "({0}) was pressed. Waiting for second key of chord...", t));
        break;
      default: {
        const i = this._currentChords.map(({ label: n }) => n).join(", ");
        this._currentChordStatusMessage = this._notificationService.status(m("next.chord", "({0}) was pressed. Waiting for next key of chord...", i));
      }
    }
    this._scheduleLeaveChordMode(), Fg.enabled && Fg.disable();
  }
  _leaveChordMode() {
    this._currentChordStatusMessage && (this._currentChordStatusMessage.dispose(), this._currentChordStatusMessage = null), this._currentChordChecker.cancel(), this._currentChords = [], Fg.enable();
  }
  _dispatch(e, t) {
    return this._doDispatch(
      this.resolveKeyboardEvent(e),
      t,
      /*isSingleModiferChord*/
      !1
    );
  }
  _singleModifierDispatch(e, t) {
    const i = this.resolveKeyboardEvent(e), [n] = i.getSingleModifierDispatchChords();
    if (n)
      return this._ignoreSingleModifiers.has(n) ? (this._log(`+ Ignoring single modifier ${n} due to it being pressed together with other keys.`), this._ignoreSingleModifiers = du.EMPTY, this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1) : (this._ignoreSingleModifiers = du.EMPTY, this._currentSingleModifier === null ? (this._log(`+ Storing single modifier for possible chord ${n}.`), this._currentSingleModifier = n, this._currentSingleModifierClearTimeout.cancelAndSet(() => {
        this._log("+ Clearing single modifier due to 300ms elapsed."), this._currentSingleModifier = null;
      }, 300), !1) : n === this._currentSingleModifier ? (this._log(`/ Dispatching single modifier chord ${n} ${n}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, this._doDispatch(
        i,
        t,
        /*isSingleModiferChord*/
        !0
      )) : (this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${n}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1));
    const [o] = i.getChords();
    return this._ignoreSingleModifiers = new du(o), this._currentSingleModifier !== null && this._log("+ Clearing single modifier due to other key up."), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1;
  }
  _doDispatch(e, t, i = !1) {
    let n = !1;
    if (e.hasMultipleChords())
      return console.warn("Unexpected keyboard event mapped to multiple chords"), !1;
    let o = null, r = null;
    if (i) {
      const [h] = e.getSingleModifierDispatchChords();
      o = h, r = h ? [h] : [];
    } else
      [o] = e.getDispatchChords(), r = this._currentChords.map(({ keypress: h }) => h);
    if (o === null)
      return this._log("\\ Keyboard event cannot be dispatched in keydown phase."), n;
    const a = this._contextKeyService.getContext(t), l = e.getLabel(), c = this._getResolver().resolve(a, r, o);
    switch (c.kind) {
      case 0: {
        if (this._logService.trace("KeybindingService#dispatch", l, "[ No matching keybinding ]"), this.inChordMode) {
          const h = this._currentChords.map(({ label: d }) => d).join(", ");
          this._log(`+ Leaving multi-chord mode: Nothing bound to "${h}, ${l}".`), this._notificationService.status(m("missing.chord", "The key combination ({0}, {1}) is not a command.", h, l), {
            hideAfter: 10 * 1e3
            /* 10s */
          }), this._leaveChordMode(), n = !0;
        }
        return n;
      }
      case 1:
        return this._logService.trace("KeybindingService#dispatch", l, "[ Several keybindings match - more chords needed ]"), n = !0, this._expectAnotherChord(o, l), this._log(this._currentChords.length === 1 ? "+ Entering multi-chord mode..." : "+ Continuing multi-chord mode..."), n;
      case 2: {
        if (this._logService.trace("KeybindingService#dispatch", l, `[ Will dispatch command ${c.commandId} ]`), c.commandId === null || c.commandId === "") {
          if (this.inChordMode) {
            const h = this._currentChords.map(({ label: d }) => d).join(", ");
            this._log(`+ Leaving chord mode: Nothing bound to "${h}, ${l}".`), this._notificationService.status(m("missing.chord", "The key combination ({0}, {1}) is not a command.", h, l), {
              hideAfter: 10 * 1e3
              /* 10s */
            }), this._leaveChordMode(), n = !0;
          }
        } else {
          this.inChordMode && this._leaveChordMode(), c.isBubble || (n = !0), this._log(`+ Invoking command ${c.commandId}.`), this._currentlyDispatchingCommandId = c.commandId;
          try {
            typeof c.commandArgs > "u" ? this._commandService.executeCommand(c.commandId).then(void 0, (h) => this._notificationService.warn(h)) : this._commandService.executeCommand(c.commandId, c.commandArgs).then(void 0, (h) => this._notificationService.warn(h));
          } finally {
            this._currentlyDispatchingCommandId = null;
          }
          wne.test(c.commandId) || this._telemetryService.publicLog2("workbenchActionExecuted", { id: c.commandId, from: "keybinding", detail: e.getUserSettingsLabel() ?? void 0 });
        }
        return n;
      }
    }
  }
  mightProducePrintableCharacter(e) {
    return e.ctrlKey || e.metaKey ? !1 : e.keyCode >= 31 && e.keyCode <= 56 || e.keyCode >= 21 && e.keyCode <= 30;
  }
}
const yv = class yv {
  constructor(e) {
    this._ctrlKey = e ? e.ctrlKey : !1, this._shiftKey = e ? e.shiftKey : !1, this._altKey = e ? e.altKey : !1, this._metaKey = e ? e.metaKey : !1;
  }
  has(e) {
    switch (e) {
      case "ctrl":
        return this._ctrlKey;
      case "shift":
        return this._shiftKey;
      case "alt":
        return this._altKey;
      case "meta":
        return this._metaKey;
    }
  }
};
yv.EMPTY = new yv(null);
let du = yv;
class xA {
  constructor(e, t, i, n, o, r, a) {
    this._resolvedKeybindingItemBrand = void 0, this.resolvedKeybinding = e, this.chords = e ? Fx(e.getDispatchChords()) : [], e && this.chords.length === 0 && (this.chords = Fx(e.getSingleModifierDispatchChords())), this.bubble = t ? t.charCodeAt(0) === 94 : !1, this.command = this.bubble ? t.substr(1) : t, this.commandArgs = i, this.when = n, this.isDefault = o, this.extensionId = r, this.isBuiltinExtension = a;
  }
}
function Fx(s) {
  const e = [];
  for (let t = 0, i = s.length; t < i; t++) {
    const n = s[t];
    if (!n)
      return [];
    e.push(n);
  }
  return e;
}
class Sne extends V8 {
  constructor(e, t) {
    if (super(), t.length === 0)
      throw Tr("chords");
    this._os = e, this._chords = t;
  }
  getLabel() {
    return YI.toLabel(this._os, this._chords, (e) => this._getLabel(e));
  }
  getAriaLabel() {
    return rX.toLabel(this._os, this._chords, (e) => this._getAriaLabel(e));
  }
  getElectronAccelerator() {
    return this._chords.length > 1 || this._chords[0].isDuplicateModifierCase() ? null : aX.toLabel(this._os, this._chords, (e) => this._getElectronAccelerator(e));
  }
  getUserSettingsLabel() {
    return lX.toLabel(this._os, this._chords, (e) => this._getUserSettingsLabel(e));
  }
  hasMultipleChords() {
    return this._chords.length > 1;
  }
  getChords() {
    return this._chords.map((e) => this._getChord(e));
  }
  _getChord(e) {
    return new H8(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, this._getLabel(e), this._getAriaLabel(e));
  }
  getDispatchChords() {
    return this._chords.map((e) => this._getChordDispatch(e));
  }
  getSingleModifierDispatchChords() {
    return this._chords.map((e) => this._getSingleModifierChordDispatch(e));
  }
}
class bp extends Sne {
  constructor(e, t) {
    super(t, e);
  }
  _keyCodeToUILabel(e) {
    if (this._os === 2)
      switch (e) {
        case 15:
          return "←";
        case 16:
          return "↑";
        case 17:
          return "→";
        case 18:
          return "↓";
      }
    return Ca.toString(e);
  }
  _getLabel(e) {
    return e.isDuplicateModifierCase() ? "" : this._keyCodeToUILabel(e.keyCode);
  }
  _getAriaLabel(e) {
    return e.isDuplicateModifierCase() ? "" : Ca.toString(e.keyCode);
  }
  _getElectronAccelerator(e) {
    return Ca.toElectronAccelerator(e.keyCode);
  }
  _getUserSettingsLabel(e) {
    if (e.isDuplicateModifierCase())
      return "";
    const t = Ca.toUserSettingsUS(e.keyCode);
    return t && t.toLowerCase();
  }
  _getChordDispatch(e) {
    return bp.getDispatchStr(e);
  }
  static getDispatchStr(e) {
    if (e.isModifierKey())
      return null;
    let t = "";
    return e.ctrlKey && (t += "ctrl+"), e.shiftKey && (t += "shift+"), e.altKey && (t += "alt+"), e.metaKey && (t += "meta+"), t += Ca.toString(e.keyCode), t;
  }
  _getSingleModifierChordDispatch(e) {
    return e.keyCode === 5 && !e.shiftKey && !e.altKey && !e.metaKey ? "ctrl" : e.keyCode === 4 && !e.ctrlKey && !e.altKey && !e.metaKey ? "shift" : e.keyCode === 6 && !e.ctrlKey && !e.shiftKey && !e.metaKey ? "alt" : e.keyCode === 57 && !e.ctrlKey && !e.shiftKey && !e.altKey ? "meta" : null;
  }
  /**
   * *NOTE*: Check return value for `KeyCode.Unknown`.
   */
  static _scanCodeToKeyCode(e) {
    const t = iE[e];
    if (t !== -1)
      return t;
    switch (e) {
      case 10:
        return 31;
      case 11:
        return 32;
      case 12:
        return 33;
      case 13:
        return 34;
      case 14:
        return 35;
      case 15:
        return 36;
      case 16:
        return 37;
      case 17:
        return 38;
      case 18:
        return 39;
      case 19:
        return 40;
      case 20:
        return 41;
      case 21:
        return 42;
      case 22:
        return 43;
      case 23:
        return 44;
      case 24:
        return 45;
      case 25:
        return 46;
      case 26:
        return 47;
      case 27:
        return 48;
      case 28:
        return 49;
      case 29:
        return 50;
      case 30:
        return 51;
      case 31:
        return 52;
      case 32:
        return 53;
      case 33:
        return 54;
      case 34:
        return 55;
      case 35:
        return 56;
      case 36:
        return 22;
      case 37:
        return 23;
      case 38:
        return 24;
      case 39:
        return 25;
      case 40:
        return 26;
      case 41:
        return 27;
      case 42:
        return 28;
      case 43:
        return 29;
      case 44:
        return 30;
      case 45:
        return 21;
      case 51:
        return 88;
      case 52:
        return 86;
      case 53:
        return 92;
      case 54:
        return 94;
      case 55:
        return 93;
      case 56:
        return 0;
      // missing
      case 57:
        return 85;
      case 58:
        return 95;
      case 59:
        return 91;
      case 60:
        return 87;
      case 61:
        return 89;
      case 62:
        return 90;
      case 106:
        return 97;
    }
    return 0;
  }
  static _toKeyCodeChord(e) {
    if (!e)
      return null;
    if (e instanceof Bh)
      return e;
    const t = this._scanCodeToKeyCode(e.scanCode);
    return t === 0 ? null : new Bh(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, t);
  }
  static resolveKeybinding(e, t) {
    const i = Fx(e.chords.map((n) => this._toKeyCodeChord(n)));
    return i.length > 0 ? [new bp(i, t)] : [];
  }
}
class Lne {
  constructor() {
    this._value = "", this._pos = 0;
  }
  reset(e) {
    return this._value = e, this._pos = 0, this;
  }
  next() {
    return this._pos += 1, this;
  }
  hasNext() {
    return this._pos < this._value.length - 1;
  }
  cmp(e) {
    const t = e.charCodeAt(0), i = this._value.charCodeAt(this._pos);
    return t - i;
  }
  value() {
    return this._value[this._pos];
  }
}
class kne {
  constructor(e = !0) {
    this._caseSensitive = e;
  }
  reset(e) {
    return this._value = e, this._from = 0, this._to = 0, this.next();
  }
  hasNext() {
    return this._to < this._value.length;
  }
  next() {
    this._from = this._to;
    let e = !0;
    for (; this._to < this._value.length; this._to++)
      if (this._value.charCodeAt(this._to) === 46)
        if (e)
          this._from++;
        else
          break;
      else
        e = !1;
    return this;
  }
  cmp(e) {
    return this._caseSensitive ? lE(e, this._value, 0, e.length, this._from, this._to) : Dp(e, this._value, 0, e.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
}
class xne {
  constructor(e = !0, t = !0) {
    this._splitOnBackslash = e, this._caseSensitive = t;
  }
  reset(e) {
    this._from = 0, this._to = 0, this._value = e, this._valueLen = e.length;
    for (let t = e.length - 1; t >= 0; t--, this._valueLen--) {
      const i = this._value.charCodeAt(t);
      if (!(i === 47 || this._splitOnBackslash && i === 92))
        break;
    }
    return this.next();
  }
  hasNext() {
    return this._to < this._valueLen;
  }
  next() {
    this._from = this._to;
    let e = !0;
    for (; this._to < this._valueLen; this._to++) {
      const t = this._value.charCodeAt(this._to);
      if (t === 47 || this._splitOnBackslash && t === 92)
        if (e)
          this._from++;
        else
          break;
      else
        e = !1;
    }
    return this;
  }
  cmp(e) {
    return this._caseSensitive ? lE(e, this._value, 0, e.length, this._from, this._to) : Dp(e, this._value, 0, e.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
}
class Dne {
  constructor(e, t) {
    this._ignorePathCasing = e, this._ignoreQueryAndFragment = t, this._states = [], this._stateIdx = 0;
  }
  reset(e) {
    return this._value = e, this._states = [], this._value.scheme && this._states.push(
      1
      /* UriIteratorState.Scheme */
    ), this._value.authority && this._states.push(
      2
      /* UriIteratorState.Authority */
    ), this._value.path && (this._pathIterator = new xne(!1, !this._ignorePathCasing(e)), this._pathIterator.reset(e.path), this._pathIterator.value() && this._states.push(
      3
      /* UriIteratorState.Path */
    )), this._ignoreQueryAndFragment(e) || (this._value.query && this._states.push(
      4
      /* UriIteratorState.Query */
    ), this._value.fragment && this._states.push(
      5
      /* UriIteratorState.Fragment */
    )), this._stateIdx = 0, this;
  }
  next() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() ? this._pathIterator.next() : this._stateIdx += 1, this;
  }
  hasNext() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
  }
  cmp(e) {
    if (this._states[this._stateIdx] === 1)
      return g2(e, this._value.scheme);
    if (this._states[this._stateIdx] === 2)
      return g2(e, this._value.authority);
    if (this._states[this._stateIdx] === 3)
      return this._pathIterator.cmp(e);
    if (this._states[this._stateIdx] === 4)
      return Lm(e, this._value.query);
    if (this._states[this._stateIdx] === 5)
      return Lm(e, this._value.fragment);
    throw new Error();
  }
  value() {
    if (this._states[this._stateIdx] === 1)
      return this._value.scheme;
    if (this._states[this._stateIdx] === 2)
      return this._value.authority;
    if (this._states[this._stateIdx] === 3)
      return this._pathIterator.value();
    if (this._states[this._stateIdx] === 4)
      return this._value.query;
    if (this._states[this._stateIdx] === 5)
      return this._value.fragment;
    throw new Error();
  }
}
class z_ {
  constructor() {
    this.height = 1;
  }
  rotateLeft() {
    const e = this.right;
    return this.right = e.left, e.left = this, this.updateHeight(), e.updateHeight(), e;
  }
  rotateRight() {
    const e = this.left;
    return this.left = e.right, e.right = this, this.updateHeight(), e.updateHeight(), e;
  }
  updateHeight() {
    this.height = 1 + Math.max(this.heightLeft, this.heightRight);
  }
  balanceFactor() {
    return this.heightRight - this.heightLeft;
  }
  get heightLeft() {
    var e;
    return ((e = this.left) == null ? void 0 : e.height) ?? 0;
  }
  get heightRight() {
    var e;
    return ((e = this.right) == null ? void 0 : e.height) ?? 0;
  }
}
class im {
  static forUris(e = () => !1, t = () => !1) {
    return new im(new Dne(e, t));
  }
  static forStrings() {
    return new im(new Lne());
  }
  static forConfigKeys() {
    return new im(new kne());
  }
  constructor(e) {
    this._iter = e;
  }
  clear() {
    this._root = void 0;
  }
  set(e, t) {
    const i = this._iter.reset(e);
    let n;
    this._root || (this._root = new z_(), this._root.segment = i.value());
    const o = [];
    for (n = this._root; ; ) {
      const a = i.cmp(n.segment);
      if (a > 0)
        n.left || (n.left = new z_(), n.left.segment = i.value()), o.push([-1, n]), n = n.left;
      else if (a < 0)
        n.right || (n.right = new z_(), n.right.segment = i.value()), o.push([1, n]), n = n.right;
      else if (i.hasNext())
        i.next(), n.mid || (n.mid = new z_(), n.mid.segment = i.value()), o.push([0, n]), n = n.mid;
      else
        break;
    }
    const r = n.value;
    n.value = t, n.key = e;
    for (let a = o.length - 1; a >= 0; a--) {
      const l = o[a][1];
      l.updateHeight();
      const c = l.balanceFactor();
      if (c < -1 || c > 1) {
        const h = o[a][0], d = o[a + 1][0];
        if (h === 1 && d === 1)
          o[a][1] = l.rotateLeft();
        else if (h === -1 && d === -1)
          o[a][1] = l.rotateRight();
        else if (h === 1 && d === -1)
          l.right = o[a + 1][1] = o[a + 1][1].rotateRight(), o[a][1] = l.rotateLeft();
        else if (h === -1 && d === 1)
          l.left = o[a + 1][1] = o[a + 1][1].rotateLeft(), o[a][1] = l.rotateRight();
        else
          throw new Error();
        if (a > 0)
          switch (o[a - 1][0]) {
            case -1:
              o[a - 1][1].left = o[a][1];
              break;
            case 1:
              o[a - 1][1].right = o[a][1];
              break;
            case 0:
              o[a - 1][1].mid = o[a][1];
              break;
          }
        else
          this._root = o[0][1];
      }
    }
    return r;
  }
  get(e) {
    var t;
    return (t = this._getNode(e)) == null ? void 0 : t.value;
  }
  _getNode(e) {
    const t = this._iter.reset(e);
    let i = this._root;
    for (; i; ) {
      const n = t.cmp(i.segment);
      if (n > 0)
        i = i.left;
      else if (n < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), i = i.mid;
      else
        break;
    }
    return i;
  }
  has(e) {
    const t = this._getNode(e);
    return !((t == null ? void 0 : t.value) === void 0 && (t == null ? void 0 : t.mid) === void 0);
  }
  delete(e) {
    return this._delete(e, !1);
  }
  deleteSuperstr(e) {
    return this._delete(e, !0);
  }
  _delete(e, t) {
    const i = this._iter.reset(e), n = [];
    let o = this._root;
    for (; o; ) {
      const r = i.cmp(o.segment);
      if (r > 0)
        n.push([-1, o]), o = o.left;
      else if (r < 0)
        n.push([1, o]), o = o.right;
      else if (i.hasNext())
        i.next(), n.push([0, o]), o = o.mid;
      else
        break;
    }
    if (o) {
      if (t ? (o.left = void 0, o.mid = void 0, o.right = void 0, o.height = 1) : (o.key = void 0, o.value = void 0), !o.mid && !o.value)
        if (o.left && o.right) {
          const r = this._min(o.right);
          if (r.key) {
            const { key: a, value: l, segment: c } = r;
            this._delete(r.key, !1), o.key = a, o.value = l, o.segment = c;
          }
        } else {
          const r = o.left ?? o.right;
          if (n.length > 0) {
            const [a, l] = n[n.length - 1];
            switch (a) {
              case -1:
                l.left = r;
                break;
              case 0:
                l.mid = r;
                break;
              case 1:
                l.right = r;
                break;
            }
          } else
            this._root = r;
        }
      for (let r = n.length - 1; r >= 0; r--) {
        const a = n[r][1];
        a.updateHeight();
        const l = a.balanceFactor();
        if (l > 1 ? (a.right.balanceFactor() >= 0 || (a.right = a.right.rotateRight()), n[r][1] = a.rotateLeft()) : l < -1 && (a.left.balanceFactor() <= 0 || (a.left = a.left.rotateLeft()), n[r][1] = a.rotateRight()), r > 0)
          switch (n[r - 1][0]) {
            case -1:
              n[r - 1][1].left = n[r][1];
              break;
            case 1:
              n[r - 1][1].right = n[r][1];
              break;
            case 0:
              n[r - 1][1].mid = n[r][1];
              break;
          }
        else
          this._root = n[0][1];
      }
    }
  }
  _min(e) {
    for (; e.left; )
      e = e.left;
    return e;
  }
  findSubstr(e) {
    const t = this._iter.reset(e);
    let i = this._root, n;
    for (; i; ) {
      const o = t.cmp(i.segment);
      if (o > 0)
        i = i.left;
      else if (o < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), n = i.value || n, i = i.mid;
      else
        break;
    }
    return i && i.value || n;
  }
  findSuperstr(e) {
    return this._findSuperstrOrElement(e, !1);
  }
  _findSuperstrOrElement(e, t) {
    const i = this._iter.reset(e);
    let n = this._root;
    for (; n; ) {
      const o = i.cmp(n.segment);
      if (o > 0)
        n = n.left;
      else if (o < 0)
        n = n.right;
      else if (i.hasNext())
        i.next(), n = n.mid;
      else
        return n.mid ? this._entries(n.mid) : t ? n.value : void 0;
    }
  }
  forEach(e) {
    for (const [t, i] of this)
      e(i, t);
  }
  *[Symbol.iterator]() {
    yield* this._entries(this._root);
  }
  _entries(e) {
    const t = [];
    return this._dfsEntries(e, t), t[Symbol.iterator]();
  }
  _dfsEntries(e, t) {
    e && (e.left && this._dfsEntries(e.left, t), e.value && t.push([e.key, e.value]), e.mid && this._dfsEntries(e.mid, t), e.right && this._dfsEntries(e.right, t));
  }
}
const Ene = Be("contextService");
class Ine {
  constructor(e, t) {
    this.raw = t, this.uri = e.uri, this.index = e.index, this.name = e.name;
  }
  toJSON() {
    return { uri: this.uri, name: this.name, index: this.index };
  }
}
const Nne = "code-workspace";
m("codeWorkspace", "Code Workspace");
const Tne = "4064f6ec-cb38-4ad0-af64-ee6467e63c82";
var DA;
(function(s) {
  s.inspectTokensAction = m("inspectTokens", "Developer: Inspect Tokens");
})(DA || (DA = {}));
var EA;
(function(s) {
  s.gotoLineActionLabel = m("gotoLineActionLabel", "Go to Line/Column...");
})(EA || (EA = {}));
var IA;
(function(s) {
  s.helpQuickAccessActionLabel = m("helpQuickAccess", "Show all Quick Access Providers");
})(IA || (IA = {}));
var NA;
(function(s) {
  s.quickCommandActionLabel = m("quickCommandActionLabel", "Command Palette"), s.quickCommandHelp = m("quickCommandActionHelp", "Show And Run Commands");
})(NA || (NA = {}));
var TA;
(function(s) {
  s.quickOutlineActionLabel = m("quickOutlineActionLabel", "Go to Symbol..."), s.quickOutlineByCategoryActionLabel = m("quickOutlineByCategoryActionLabel", "Go to Symbol by Category...");
})(TA || (TA = {}));
var Bx;
(function(s) {
  s.editorViewAccessibleLabel = m("editorViewAccessibleLabel", "Editor content");
})(Bx || (Bx = {}));
var MA;
(function(s) {
  s.toggleHighContrast = m("toggleHighContrast", "Toggle High Contrast Theme");
})(MA || (MA = {}));
var Wx;
(function(s) {
  s.bulkEditServiceSummary = m("bulkEditServiceSummary", "Made {0} edits in {1} files");
})(Wx || (Wx = {}));
const Mne = Be("workspaceTrustManagementService");
let Sf = [], AN = [], _3 = [];
function U_(s, e = !1) {
  Rne(s, !1, e);
}
function Rne(s, e, t) {
  const i = Ane(s, e);
  Sf.push(i), i.userConfigured ? _3.push(i) : AN.push(i), t && !i.userConfigured && Sf.forEach((n) => {
    n.mime === i.mime || n.userConfigured || (i.extension && n.extension === i.extension && console.warn(`Overwriting extension <<${i.extension}>> to now point to mime <<${i.mime}>>`), i.filename && n.filename === i.filename && console.warn(`Overwriting filename <<${i.filename}>> to now point to mime <<${i.mime}>>`), i.filepattern && n.filepattern === i.filepattern && console.warn(`Overwriting filepattern <<${i.filepattern}>> to now point to mime <<${i.mime}>>`), i.firstline && n.firstline === i.firstline && console.warn(`Overwriting firstline <<${i.firstline}>> to now point to mime <<${i.mime}>>`));
  });
}
function Ane(s, e) {
  return {
    id: s.id,
    mime: s.mime,
    filename: s.filename,
    extension: s.extension,
    filepattern: s.filepattern,
    firstline: s.firstline,
    userConfigured: e,
    filenameLowercase: s.filename ? s.filename.toLowerCase() : void 0,
    extensionLowercase: s.extension ? s.extension.toLowerCase() : void 0,
    filepatternLowercase: s.filepattern ? u3(s.filepattern.toLowerCase()) : void 0,
    filepatternOnPath: s.filepattern ? s.filepattern.indexOf(ni.sep) >= 0 : !1
  };
}
function Pne() {
  Sf = Sf.filter((s) => s.userConfigured), AN = [];
}
function One(s, e) {
  return Fne(s, e).map((t) => t.id);
}
function Fne(s, e) {
  let t;
  if (s)
    switch (s.scheme) {
      case Ie.file:
        t = s.fsPath;
        break;
      case Ie.data: {
        t = Xb.parseMetaData(s).get(Xb.META_DATA_LABEL);
        break;
      }
      case Ie.vscodeNotebookCell:
        t = void 0;
        break;
      default:
        t = s.path;
    }
  if (!t)
    return [{ id: "unknown", mime: wa.unknown }];
  t = t.toLowerCase();
  const i = XP(t), n = RA(t, i, _3);
  if (n)
    return [n, { id: Fs, mime: wa.text }];
  const o = RA(t, i, AN);
  if (o)
    return [o, { id: Fs, mime: wa.text }];
  if (e) {
    const r = Bne(e);
    if (r)
      return [r, { id: Fs, mime: wa.text }];
  }
  return [{ id: "unknown", mime: wa.unknown }];
}
function RA(s, e, t) {
  var r;
  let i, n, o;
  for (let a = t.length - 1; a >= 0; a--) {
    const l = t[a];
    if (e === l.filenameLowercase) {
      i = l;
      break;
    }
    if (l.filepattern && (!n || l.filepattern.length > n.filepattern.length)) {
      const c = l.filepatternOnPath ? s : e;
      (r = l.filepatternLowercase) != null && r.call(l, c) && (n = l);
    }
    l.extension && (!o || l.extension.length > o.extension.length) && e.endsWith(l.extensionLowercase) && (o = l);
  }
  if (i)
    return i;
  if (n)
    return n;
  if (o)
    return o;
}
function Bne(s) {
  if (mE(s) && (s = s.substr(1)), s.length > 0)
    for (let e = Sf.length - 1; e >= 0; e--) {
      const t = Sf[e];
      if (!t.firstline)
        continue;
      const i = s.match(t.firstline);
      if (i && i.length > 0)
        return t;
    }
}
const $_ = Object.prototype.hasOwnProperty, AA = "vs.editor.nullLanguage";
class Wne {
  constructor() {
    this._languageIdToLanguage = [], this._languageToLanguageId = /* @__PURE__ */ new Map(), this._register(
      AA,
      0
      /* LanguageId.Null */
    ), this._register(
      Fs,
      1
      /* LanguageId.PlainText */
    ), this._nextLanguageId = 2;
  }
  _register(e, t) {
    this._languageIdToLanguage[t] = e, this._languageToLanguageId.set(e, t);
  }
  register(e) {
    if (this._languageToLanguageId.has(e))
      return;
    const t = this._nextLanguageId++;
    this._register(e, t);
  }
  encodeLanguageId(e) {
    return this._languageToLanguageId.get(e) || 0;
  }
  decodeLanguageId(e) {
    return this._languageIdToLanguage[e] || AA;
  }
}
const mm = class mm extends U {
  constructor(e = !0, t = !1) {
    super(), this._onDidChange = this._register(new A()), this.onDidChange = this._onDidChange.event, mm.instanceCount++, this._warnOnOverwrite = t, this.languageIdCodec = new Wne(), this._dynamicLanguages = [], this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, e && (this._initializeFromRegistry(), this._register(gf.onDidChangeLanguages((i) => {
      this._initializeFromRegistry();
    })));
  }
  dispose() {
    mm.instanceCount--, super.dispose();
  }
  _initializeFromRegistry() {
    this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, Pne();
    const e = [].concat(gf.getLanguages()).concat(this._dynamicLanguages);
    this._registerLanguages(e);
  }
  _registerLanguages(e) {
    for (const t of e)
      this._registerLanguage(t);
    this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, Object.keys(this._languages).forEach((t) => {
      const i = this._languages[t];
      i.name && (this._nameMap[i.name] = i.identifier), i.aliases.forEach((n) => {
        this._lowercaseNameMap[n.toLowerCase()] = i.identifier;
      }), i.mimetypes.forEach((n) => {
        this._mimeTypesMap[n] = i.identifier;
      });
    }), Mi.as(hd.Configuration).registerOverrideIdentifiers(this.getRegisteredLanguageIds()), this._onDidChange.fire();
  }
  _registerLanguage(e) {
    const t = e.id;
    let i;
    $_.call(this._languages, t) ? i = this._languages[t] : (this.languageIdCodec.register(t), i = {
      identifier: t,
      name: null,
      mimetypes: [],
      aliases: [],
      extensions: [],
      filenames: [],
      configurationFiles: [],
      icons: []
    }, this._languages[t] = i), this._mergeLanguage(i, e);
  }
  _mergeLanguage(e, t) {
    const i = t.id;
    let n = null;
    if (Array.isArray(t.mimetypes) && t.mimetypes.length > 0 && (e.mimetypes.push(...t.mimetypes), n = t.mimetypes[0]), n || (n = `text/x-${i}`, e.mimetypes.push(n)), Array.isArray(t.extensions)) {
      t.configuration ? e.extensions = t.extensions.concat(e.extensions) : e.extensions = e.extensions.concat(t.extensions);
      for (const a of t.extensions)
        U_({ id: i, mime: n, extension: a }, this._warnOnOverwrite);
    }
    if (Array.isArray(t.filenames))
      for (const a of t.filenames)
        U_({ id: i, mime: n, filename: a }, this._warnOnOverwrite), e.filenames.push(a);
    if (Array.isArray(t.filenamePatterns))
      for (const a of t.filenamePatterns)
        U_({ id: i, mime: n, filepattern: a }, this._warnOnOverwrite);
    if (typeof t.firstLine == "string" && t.firstLine.length > 0) {
      let a = t.firstLine;
      a.charAt(0) !== "^" && (a = "^" + a);
      try {
        const l = new RegExp(a);
        p8(l) || U_({ id: i, mime: n, firstline: l }, this._warnOnOverwrite);
      } catch (l) {
        console.warn(`[${t.id}]: Invalid regular expression \`${a}\`: `, l);
      }
    }
    e.aliases.push(i);
    let o = null;
    if (typeof t.aliases < "u" && Array.isArray(t.aliases) && (t.aliases.length === 0 ? o = [null] : o = t.aliases), o !== null)
      for (const a of o)
        !a || a.length === 0 || e.aliases.push(a);
    const r = o !== null && o.length > 0;
    if (!(r && o[0] === null)) {
      const a = (r ? o[0] : null) || i;
      (r || !e.name) && (e.name = a);
    }
    t.configuration && e.configurationFiles.push(t.configuration), t.icon && e.icons.push(t.icon);
  }
  isRegisteredLanguageId(e) {
    return e ? $_.call(this._languages, e) : !1;
  }
  getRegisteredLanguageIds() {
    return Object.keys(this._languages);
  }
  getLanguageIdByLanguageName(e) {
    const t = e.toLowerCase();
    return $_.call(this._lowercaseNameMap, t) ? this._lowercaseNameMap[t] : null;
  }
  getLanguageIdByMimeType(e) {
    return e && $_.call(this._mimeTypesMap, e) ? this._mimeTypesMap[e] : null;
  }
  guessLanguageIdByFilepathOrFirstLine(e, t) {
    return !e && !t ? [] : One(e, t);
  }
};
mm.instanceCount = 0;
let Hx = mm;
const pm = class pm extends U {
  constructor(e = !1) {
    super(), this._onDidRequestBasicLanguageFeatures = this._register(new A()), this.onDidRequestBasicLanguageFeatures = this._onDidRequestBasicLanguageFeatures.event, this._onDidRequestRichLanguageFeatures = this._register(new A()), this.onDidRequestRichLanguageFeatures = this._onDidRequestRichLanguageFeatures.event, this._onDidChange = this._register(new A({
      leakWarningThreshold: 200
      /* https://github.com/microsoft/vscode/issues/119968 */
    })), this.onDidChange = this._onDidChange.event, this._requestedBasicLanguages = /* @__PURE__ */ new Set(), this._requestedRichLanguages = /* @__PURE__ */ new Set(), pm.instanceCount++, this._registry = this._register(new Hx(!0, e)), this.languageIdCodec = this._registry.languageIdCodec, this._register(this._registry.onDidChange(() => this._onDidChange.fire()));
  }
  dispose() {
    pm.instanceCount--, super.dispose();
  }
  isRegisteredLanguageId(e) {
    return this._registry.isRegisteredLanguageId(e);
  }
  getLanguageIdByLanguageName(e) {
    return this._registry.getLanguageIdByLanguageName(e);
  }
  getLanguageIdByMimeType(e) {
    return this._registry.getLanguageIdByMimeType(e);
  }
  guessLanguageIdByFilepathOrFirstLine(e, t) {
    const i = this._registry.guessLanguageIdByFilepathOrFirstLine(e, t);
    return VE(i, null);
  }
  createById(e) {
    return new PA(this.onDidChange, () => this._createAndGetLanguageIdentifier(e));
  }
  createByFilepathOrFirstLine(e, t) {
    return new PA(this.onDidChange, () => {
      const i = this.guessLanguageIdByFilepathOrFirstLine(e, t);
      return this._createAndGetLanguageIdentifier(i);
    });
  }
  _createAndGetLanguageIdentifier(e) {
    return (!e || !this.isRegisteredLanguageId(e)) && (e = Fs), e;
  }
  requestBasicLanguageFeatures(e) {
    this._requestedBasicLanguages.has(e) || (this._requestedBasicLanguages.add(e), this._onDidRequestBasicLanguageFeatures.fire(e));
  }
  requestRichLanguageFeatures(e) {
    this._requestedRichLanguages.has(e) || (this._requestedRichLanguages.add(e), this.requestBasicLanguageFeatures(e), ii.getOrCreate(e), this._onDidRequestRichLanguageFeatures.fire(e));
  }
};
pm.instanceCount = 0;
let Vx = pm;
class PA {
  constructor(e, t) {
    this._value = zt(this, e, () => t()), this.onDidChange = ee.fromObservable(this._value);
  }
  get languageId() {
    return this._value.get();
  }
}
const zx = /\(&([^\s&])\)|(^|[^&])&([^\s&])/, vy = /(&amp;)?(&amp;)([^\s&])/g;
var vC;
(function(s) {
  s[s.Right = 0] = "Right", s[s.Left = 1] = "Left";
})(vC || (vC = {}));
var Ux;
(function(s) {
  s[s.Above = 0] = "Above", s[s.Below = 1] = "Below";
})(Ux || (Ux = {}));
class Ku extends $o {
  constructor(e, t, i, n) {
    e.classList.add("monaco-menu-container"), e.setAttribute("role", "presentation");
    const o = document.createElement("div");
    o.classList.add("monaco-menu"), o.setAttribute("role", "presentation"), super(o, {
      orientation: 1,
      actionViewItemProvider: (c) => this.doGetActionViewItem(c, i, r),
      context: i.context,
      actionRunner: i.actionRunner,
      ariaLabel: i.ariaLabel,
      ariaRole: "menu",
      focusOnlyEnabledItems: !0,
      triggerKeys: { keys: [3, ...$e || Rn ? [
        10
        /* KeyCode.Space */
      ] : []], keyDown: !0 }
    }), this.menuStyles = n, this.menuElement = o, this.actionsList.tabIndex = 0, this.initializeOrUpdateStyleSheet(e, n), this._register(ln.addTarget(o)), this._register(z(o, X.KEY_DOWN, (c) => {
      new Dt(c).equals(
        2
        /* KeyCode.Tab */
      ) && c.preventDefault();
    })), i.enableMnemonics && this._register(z(o, X.KEY_DOWN, (c) => {
      const h = c.key.toLocaleLowerCase();
      if (this.mnemonics.has(h)) {
        Ge.stop(c, !0);
        const d = this.mnemonics.get(h);
        if (d.length === 1 && (d[0] instanceof OA && d[0].container && this.focusItemByElement(d[0].container), d[0].onClick(c)), d.length > 1) {
          const u = d.shift();
          u && u.container && (this.focusItemByElement(u.container), d.push(u)), this.mnemonics.set(h, d);
        }
      }
    })), Rn && this._register(z(o, X.KEY_DOWN, (c) => {
      const h = new Dt(c);
      h.equals(
        14
        /* KeyCode.Home */
      ) || h.equals(
        11
        /* KeyCode.PageUp */
      ) ? (this.focusedItem = this.viewItems.length - 1, this.focusNext(), Ge.stop(c, !0)) : (h.equals(
        13
        /* KeyCode.End */
      ) || h.equals(
        12
        /* KeyCode.PageDown */
      )) && (this.focusedItem = 0, this.focusPrevious(), Ge.stop(c, !0));
    })), this._register(z(this.domNode, X.MOUSE_OUT, (c) => {
      const h = c.relatedTarget;
      _i(h, this.domNode) || (this.focusedItem = void 0, this.updateFocus(), c.stopPropagation());
    })), this._register(z(this.actionsList, X.MOUSE_OVER, (c) => {
      let h = c.target;
      if (!(!h || !_i(h, this.actionsList) || h === this.actionsList)) {
        for (; h.parentElement !== this.actionsList && h.parentElement !== null; )
          h = h.parentElement;
        if (h.classList.contains("action-item")) {
          const d = this.focusedItem;
          this.setFocusedItem(h), d !== this.focusedItem && this.updateFocus();
        }
      }
    })), this._register(ln.addTarget(this.actionsList)), this._register(z(this.actionsList, vt.Tap, (c) => {
      let h = c.initialTarget;
      if (!(!h || !_i(h, this.actionsList) || h === this.actionsList)) {
        for (; h.parentElement !== this.actionsList && h.parentElement !== null; )
          h = h.parentElement;
        if (h.classList.contains("action-item")) {
          const d = this.focusedItem;
          this.setFocusedItem(h), d !== this.focusedItem && this.updateFocus();
        }
      }
    }));
    const r = {
      parent: this
    };
    this.mnemonics = /* @__PURE__ */ new Map(), this.scrollableElement = this._register(new qE(o, {
      alwaysConsumeMouseWheel: !0,
      horizontal: 2,
      vertical: 3,
      verticalScrollbarSize: 7,
      handleMouseWheel: !0,
      useShadows: !0
    }));
    const a = this.scrollableElement.getDomNode();
    a.style.position = "", this.styleScrollElement(a, n), this._register(z(o, vt.Change, (c) => {
      Ge.stop(c, !0);
      const h = this.scrollableElement.getScrollPosition().scrollTop;
      this.scrollableElement.setScrollPosition({ scrollTop: h - c.translationY });
    })), this._register(z(a, X.MOUSE_UP, (c) => {
      c.preventDefault();
    }));
    const l = fe(e);
    o.style.maxHeight = `${Math.max(10, l.innerHeight - e.getBoundingClientRect().top - 35)}px`, t = t.filter((c, h) => {
      var d;
      return (d = i.submenuIds) != null && d.has(c.id) ? (console.warn(`Found submenu cycle: ${c.id}`), !1) : !(c instanceof Vi && (h === t.length - 1 || h === 0 || t[h - 1] instanceof Vi));
    }), this.push(t, { icon: !0, label: !0, isMenu: !0 }), e.appendChild(this.scrollableElement.getDomNode()), this.scrollableElement.scanDomNode(), this.viewItems.filter((c) => !(c instanceof FA)).forEach((c, h, d) => {
      c.updatePositionInSet(h + 1, d.length);
    });
  }
  initializeOrUpdateStyleSheet(e, t) {
    this.styleSheet || (qb(e) ? this.styleSheet = Us(e) : (Ku.globalStyleSheet || (Ku.globalStyleSheet = Us()), this.styleSheet = Ku.globalStyleSheet)), this.styleSheet.textContent = Vne(t, qb(e));
  }
  styleScrollElement(e, t) {
    const i = t.foregroundColor ?? "", n = t.backgroundColor ?? "", o = t.borderColor ? `1px solid ${t.borderColor}` : "", r = "5px", a = t.shadowColor ? `0 2px 8px ${t.shadowColor}` : "";
    e.style.outline = o, e.style.borderRadius = r, e.style.color = i, e.style.backgroundColor = n, e.style.boxShadow = a;
  }
  getContainer() {
    return this.scrollableElement.getDomNode();
  }
  get onScroll() {
    return this.scrollableElement.onScroll;
  }
  focusItemByElement(e) {
    const t = this.focusedItem;
    this.setFocusedItem(e), t !== this.focusedItem && this.updateFocus();
  }
  setFocusedItem(e) {
    for (let t = 0; t < this.actionsList.children.length; t++) {
      const i = this.actionsList.children[t];
      if (e === i) {
        this.focusedItem = t;
        break;
      }
    }
  }
  updateFocus(e) {
    super.updateFocus(e, !0, !0), typeof this.focusedItem < "u" && this.scrollableElement.setScrollPosition({
      scrollTop: Math.round(this.menuElement.scrollTop)
    });
  }
  doGetActionViewItem(e, t, i) {
    if (e instanceof Vi)
      return new FA(t.context, e, { icon: !0 }, this.menuStyles);
    if (e instanceof Wv) {
      const n = new OA(e, e.actions, i, { ...t, submenuIds: /* @__PURE__ */ new Set([...t.submenuIds || [], e.id]) }, this.menuStyles);
      if (t.enableMnemonics) {
        const o = n.getMnemonic();
        if (o && n.isEnabled()) {
          let r = [];
          this.mnemonics.has(o) && (r = this.mnemonics.get(o)), r.push(n), this.mnemonics.set(o, r);
        }
      }
      return n;
    } else {
      const n = { enableMnemonics: t.enableMnemonics, useEventAsContext: t.useEventAsContext };
      if (t.getKeyBinding) {
        const r = t.getKeyBinding(e);
        if (r) {
          const a = r.getLabel();
          a && (n.keybinding = a);
        }
      }
      const o = new b3(t.context, e, n, this.menuStyles);
      if (t.enableMnemonics) {
        const r = o.getMnemonic();
        if (r && o.isEnabled()) {
          let a = [];
          this.mnemonics.has(r) && (a = this.mnemonics.get(r)), a.push(o), this.mnemonics.set(r, a);
        }
      }
      return o;
    }
  }
}
class b3 extends Fo {
  constructor(e, t, i, n) {
    if (i.isMenu = !0, super(t, t, i), this.menuStyle = n, this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : !1, this.options.label = i.label !== void 0 ? i.label : !0, this.cssClass = "", this.options.label && i.enableMnemonics) {
      const o = this.action.label;
      if (o) {
        const r = zx.exec(o);
        r && (this.mnemonic = (r[1] ? r[1] : r[3]).toLocaleLowerCase());
      }
    }
    this.runOnceToEnableMouseUp = new ai(() => {
      this.element && (this._register(z(this.element, X.MOUSE_UP, (o) => {
        if (Ge.stop(o, !0), uo) {
          if (new Uo(fe(this.element), o).rightButton)
            return;
          this.onClick(o);
        } else
          setTimeout(() => {
            this.onClick(o);
          }, 0);
      })), this._register(z(this.element, X.CONTEXT_MENU, (o) => {
        Ge.stop(o, !0);
      })));
    }, 100), this._register(this.runOnceToEnableMouseUp);
  }
  render(e) {
    super.render(e), this.element && (this.container = e, this.item = te(this.element, he("a.action-menu-item")), this._action.id === Vi.ID ? this.item.setAttribute("role", "presentation") : (this.item.setAttribute("role", "menuitem"), this.mnemonic && this.item.setAttribute("aria-keyshortcuts", `${this.mnemonic}`)), this.check = te(this.item, he("span.menu-item-check" + Te.asCSSSelector(ie.menuSelection))), this.check.setAttribute("role", "none"), this.label = te(this.item, he("span.action-label")), this.options.label && this.options.keybinding && (te(this.item, he("span.keybinding")).textContent = this.options.keybinding), this.runOnceToEnableMouseUp.schedule(), this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked(), this.applyStyle());
  }
  blur() {
    super.blur(), this.applyStyle();
  }
  focus() {
    var e;
    super.focus(), (e = this.item) == null || e.focus(), this.applyStyle();
  }
  updatePositionInSet(e, t) {
    this.item && (this.item.setAttribute("aria-posinset", `${e}`), this.item.setAttribute("aria-setsize", `${t}`));
  }
  updateLabel() {
    var e;
    if (this.label && this.options.label) {
      ks(this.label);
      let t = sO(this.action.label);
      if (t) {
        const i = Hne(t);
        this.options.enableMnemonics || (t = i), this.label.setAttribute("aria-label", i.replace(/&&/g, "&"));
        const n = zx.exec(t);
        if (n) {
          t = Ng(t), vy.lastIndex = 0;
          let o = vy.exec(t);
          for (; o && o[1]; )
            o = vy.exec(t);
          const r = (a) => a.replace(/&amp;&amp;/g, "&amp;");
          o ? this.label.append(Hv(r(t.substr(0, o.index)), " "), he("u", { "aria-hidden": "true" }, o[3]), g8(r(t.substr(o.index + o[0].length)), " ")) : this.label.innerText = r(t).trim(), (e = this.item) == null || e.setAttribute("aria-keyshortcuts", (n[1] ? n[1] : n[3]).toLocaleLowerCase());
        } else
          this.label.innerText = t.replace(/&&/g, "&").trim();
      }
    }
  }
  updateTooltip() {
  }
  updateClass() {
    this.cssClass && this.item && this.item.classList.remove(...this.cssClass.split(" ")), this.options.icon && this.label ? (this.cssClass = this.action.class || "", this.label.classList.add("icon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" ")), this.updateEnabled()) : this.label && this.label.classList.remove("icon");
  }
  updateEnabled() {
    this.action.enabled ? (this.element && (this.element.classList.remove("disabled"), this.element.removeAttribute("aria-disabled")), this.item && (this.item.classList.remove("disabled"), this.item.removeAttribute("aria-disabled"), this.item.tabIndex = 0)) : (this.element && (this.element.classList.add("disabled"), this.element.setAttribute("aria-disabled", "true")), this.item && (this.item.classList.add("disabled"), this.item.setAttribute("aria-disabled", "true")));
  }
  updateChecked() {
    if (!this.item)
      return;
    const e = this.action.checked;
    this.item.classList.toggle("checked", !!e), e !== void 0 ? (this.item.setAttribute("role", "menuitemcheckbox"), this.item.setAttribute("aria-checked", e ? "true" : "false")) : (this.item.setAttribute("role", "menuitem"), this.item.setAttribute("aria-checked", ""));
  }
  getMnemonic() {
    return this.mnemonic;
  }
  applyStyle() {
    const e = this.element && this.element.classList.contains("focused"), t = e && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor, i = e && this.menuStyle.selectionBackgroundColor ? this.menuStyle.selectionBackgroundColor : void 0, n = e && this.menuStyle.selectionBorderColor ? `1px solid ${this.menuStyle.selectionBorderColor}` : "", o = e && this.menuStyle.selectionBorderColor ? "-1px" : "";
    this.item && (this.item.style.color = t ?? "", this.item.style.backgroundColor = i ?? "", this.item.style.outline = n, this.item.style.outlineOffset = o), this.check && (this.check.style.color = t ?? "");
  }
}
class OA extends b3 {
  constructor(e, t, i, n, o) {
    super(e, e, n, o), this.submenuActions = t, this.parentData = i, this.submenuOptions = n, this.mysubmenu = null, this.submenuDisposables = this._register(new ne()), this.mouseOver = !1, this.expandDirection = n && n.expandDirection !== void 0 ? n.expandDirection : { horizontal: vC.Right, vertical: Ux.Below }, this.showScheduler = new ai(() => {
      this.mouseOver && (this.cleanupExistingSubmenu(!1), this.createSubmenu(!1));
    }, 250), this.hideScheduler = new ai(() => {
      this.element && !_i(Gi(), this.element) && this.parentData.submenu === this.mysubmenu && (this.parentData.parent.focus(!1), this.cleanupExistingSubmenu(!0));
    }, 750);
  }
  render(e) {
    super.render(e), this.element && (this.item && (this.item.classList.add("monaco-submenu-item"), this.item.tabIndex = 0, this.item.setAttribute("aria-haspopup", "true"), this.updateAriaExpanded("false"), this.submenuIndicator = te(this.item, he("span.submenu-indicator" + Te.asCSSSelector(ie.menuSubmenu))), this.submenuIndicator.setAttribute("aria-hidden", "true")), this._register(z(this.element, X.KEY_UP, (t) => {
      const i = new Dt(t);
      (i.equals(
        17
        /* KeyCode.RightArrow */
      ) || i.equals(
        3
        /* KeyCode.Enter */
      )) && (Ge.stop(t, !0), this.createSubmenu(!0));
    })), this._register(z(this.element, X.KEY_DOWN, (t) => {
      const i = new Dt(t);
      Gi() === this.item && (i.equals(
        17
        /* KeyCode.RightArrow */
      ) || i.equals(
        3
        /* KeyCode.Enter */
      )) && Ge.stop(t, !0);
    })), this._register(z(this.element, X.MOUSE_OVER, (t) => {
      this.mouseOver || (this.mouseOver = !0, this.showScheduler.schedule());
    })), this._register(z(this.element, X.MOUSE_LEAVE, (t) => {
      this.mouseOver = !1;
    })), this._register(z(this.element, X.FOCUS_OUT, (t) => {
      this.element && !_i(Gi(), this.element) && this.hideScheduler.schedule();
    })), this._register(this.parentData.parent.onScroll(() => {
      this.parentData.submenu === this.mysubmenu && (this.parentData.parent.focus(!1), this.cleanupExistingSubmenu(!0));
    })));
  }
  updateEnabled() {
  }
  onClick(e) {
    Ge.stop(e, !0), this.cleanupExistingSubmenu(!1), this.createSubmenu(!0);
  }
  cleanupExistingSubmenu(e) {
    if (this.parentData.submenu && (e || this.parentData.submenu !== this.mysubmenu)) {
      try {
        this.parentData.submenu.dispose();
      } catch {
      }
      this.parentData.submenu = void 0, this.updateAriaExpanded("false"), this.submenuContainer && (this.submenuDisposables.clear(), this.submenuContainer = void 0);
    }
  }
  calculateSubmenuMenuLayout(e, t, i, n) {
    const o = { top: 0, left: 0 };
    return o.left = hu(e.width, t.width, { position: n.horizontal === vC.Right ? 0 : 1, offset: i.left, size: i.width }), o.left >= i.left && o.left < i.left + i.width && (i.left + 10 + t.width <= e.width && (o.left = i.left + 10), i.top += 10, i.height = 0), o.top = hu(e.height, t.height, { position: 0, offset: i.top, size: 0 }), o.top + t.height === i.top && o.top + i.height + t.height <= e.height && (o.top += i.height), o;
  }
  createSubmenu(e = !0) {
    if (this.element)
      if (this.parentData.submenu)
        this.parentData.submenu.focus(!1);
      else {
        this.updateAriaExpanded("true"), this.submenuContainer = te(this.element, he("div.monaco-submenu")), this.submenuContainer.classList.add("menubar-menu-items-holder", "context-view");
        const t = fe(this.parentData.parent.domNode).getComputedStyle(this.parentData.parent.domNode), i = parseFloat(t.paddingTop || "0") || 0;
        this.submenuContainer.style.zIndex = "1", this.submenuContainer.style.position = "fixed", this.submenuContainer.style.top = "0", this.submenuContainer.style.left = "0", this.parentData.submenu = new Ku(this.submenuContainer, this.submenuActions.length ? this.submenuActions : [new By()], this.submenuOptions, this.menuStyle);
        const n = this.element.getBoundingClientRect(), o = {
          top: n.top - i,
          left: n.left,
          height: n.height + 2 * i,
          width: n.width
        }, r = this.submenuContainer.getBoundingClientRect(), a = fe(this.element), { top: l, left: c } = this.calculateSubmenuMenuLayout(new ti(a.innerWidth, a.innerHeight), ti.lift(r), o, this.expandDirection);
        this.submenuContainer.style.left = `${c - r.left}px`, this.submenuContainer.style.top = `${l - r.top}px`, this.submenuDisposables.add(z(this.submenuContainer, X.KEY_UP, (h) => {
          new Dt(h).equals(
            15
            /* KeyCode.LeftArrow */
          ) && (Ge.stop(h, !0), this.parentData.parent.focus(), this.cleanupExistingSubmenu(!0));
        })), this.submenuDisposables.add(z(this.submenuContainer, X.KEY_DOWN, (h) => {
          new Dt(h).equals(
            15
            /* KeyCode.LeftArrow */
          ) && Ge.stop(h, !0);
        })), this.submenuDisposables.add(this.parentData.submenu.onDidCancel(() => {
          this.parentData.parent.focus(), this.cleanupExistingSubmenu(!0);
        })), this.parentData.submenu.focus(e), this.mysubmenu = this.parentData.submenu;
      }
  }
  updateAriaExpanded(e) {
    var t;
    this.item && ((t = this.item) == null || t.setAttribute("aria-expanded", e));
  }
  applyStyle() {
    super.applyStyle();
    const t = this.element && this.element.classList.contains("focused") && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
    this.submenuIndicator && (this.submenuIndicator.style.color = t ?? "");
  }
  dispose() {
    super.dispose(), this.hideScheduler.dispose(), this.mysubmenu && (this.mysubmenu.dispose(), this.mysubmenu = null), this.submenuContainer && (this.submenuContainer = void 0);
  }
}
class FA extends uw {
  constructor(e, t, i, n) {
    super(e, t, i), this.menuStyles = n;
  }
  render(e) {
    super.render(e), this.label && (this.label.style.borderBottomColor = this.menuStyles.separatorColor ? `${this.menuStyles.separatorColor}` : "");
  }
}
function Hne(s) {
  const e = zx, t = e.exec(s);
  if (!t)
    return s;
  const i = !t[1];
  return s.replace(e, i ? "$2$3" : "").trim();
}
function BA(s) {
  const e = a4()[s.id];
  return `.codicon-${s.id}:before { content: '\\${e.toString(16)}'; }`;
}
function Vne(s, e) {
  let t = (
    /* css */
    `
.monaco-menu {
	font-size: 13px;
	border-radius: 5px;
	min-width: 160px;
}

${BA(ie.menuSelection)}
${BA(ie.menuSubmenu)}

.monaco-menu .monaco-action-bar {
	text-align: right;
	overflow: hidden;
	white-space: nowrap;
}

.monaco-menu .monaco-action-bar .actions-container {
	display: flex;
	margin: 0 auto;
	padding: 0;
	width: 100%;
	justify-content: flex-end;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: inline-block;
}

.monaco-menu .monaco-action-bar.reverse .actions-container {
	flex-direction: row-reverse;
}

.monaco-menu .monaco-action-bar .action-item {
	cursor: pointer;
	display: inline-block;
	transition: transform 50ms ease;
	position: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */
}

.monaco-menu .monaco-action-bar .action-item.disabled {
	cursor: default;
}

.monaco-menu .monaco-action-bar .action-item .icon,
.monaco-menu .monaco-action-bar .action-item .codicon {
	display: inline-block;
}

.monaco-menu .monaco-action-bar .action-item .codicon {
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar .action-label {
	font-size: 11px;
	margin-right: 4px;
}

.monaco-menu .monaco-action-bar .action-item.disabled .action-label,
.monaco-menu .monaco-action-bar .action-item.disabled .action-label:hover {
	color: var(--vscode-disabledForeground);
}

/* Vertical actions */

.monaco-menu .monaco-action-bar.vertical {
	text-align: left;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	display: block;
	border-bottom: 1px solid var(--vscode-menu-separatorBackground);
	padding-top: 1px;
	padding: 30px;
}

.monaco-menu .secondary-actions .monaco-action-bar .action-label {
	margin-left: 6px;
}

/* Action Items */
.monaco-menu .monaco-action-bar .action-item.select-container {
	overflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */
	flex: 1;
	max-width: 170px;
	min-width: 60px;
	display: flex;
	align-items: center;
	justify-content: center;
	margin-right: 10px;
}

.monaco-menu .monaco-action-bar.vertical {
	margin-left: 0;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	padding: 0;
	transform: none;
	display: flex;
}

.monaco-menu .monaco-action-bar.vertical .action-item.active {
	transform: none;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	flex: 1 1 auto;
	display: flex;
	height: 2em;
	align-items: center;
	position: relative;
	margin: 0 4px;
	border-radius: 4px;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item:hover .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-menu-item:focus .keybinding {
	opacity: unset;
}

.monaco-menu .monaco-action-bar.vertical .action-label {
	flex: 1 1 auto;
	text-decoration: none;
	padding: 0 1em;
	background: none;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .keybinding,
.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	display: inline-block;
	flex: 2 1 auto;
	padding: 0 1em;
	text-align: right;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon {
	font-size: 16px !important;
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon::before {
	margin-left: auto;
	margin-right: -20px;
}

.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-item.disabled .submenu-indicator {
	opacity: 0.4;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {
	display: inline-block;
	box-sizing: border-box;
	margin: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	position: static;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .action-item .monaco-submenu {
	position: absolute;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	width: 100%;
	height: 0px !important;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {
	padding: 0.7em 1em 0.1em 1em;
	font-weight: bold;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label:hover {
	color: inherit;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	position: absolute;
	visibility: hidden;
	width: 1em;
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item.checked .menu-item-check {
	visibility: visible;
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Context Menu */

.context-view.monaco-menu-container {
	outline: 0;
	border: none;
	animation: fadeIn 0.083s linear;
	-webkit-app-region: no-drag;
}

.context-view.monaco-menu-container :focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical:focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical :focus {
	outline: 0;
}

.hc-black .context-view.monaco-menu-container,
.hc-light .context-view.monaco-menu-container,
:host-context(.hc-black) .context-view.monaco-menu-container,
:host-context(.hc-light) .context-view.monaco-menu-container {
	box-shadow: none;
}

.hc-black .monaco-menu .monaco-action-bar.vertical .action-item.focused,
.hc-light .monaco-menu .monaco-action-bar.vertical .action-item.focused,
:host-context(.hc-black) .monaco-menu .monaco-action-bar.vertical .action-item.focused,
:host-context(.hc-light) .monaco-menu .monaco-action-bar.vertical .action-item.focused {
	background: none;
}

/* Vertical Action Bar Styles */

.monaco-menu .monaco-action-bar.vertical {
	padding: 4px 0;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	height: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator),
.monaco-menu .monaco-action-bar.vertical .keybinding {
	font-size: inherit;
	padding: 0 2em;
	max-height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	font-size: inherit;
	width: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	font-size: inherit;
	margin: 5px 0 !important;
	padding: 0;
	border-radius: 0;
}

.linux .monaco-menu .monaco-action-bar.vertical .action-label.separator,
:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .action-label.separator {
	margin-left: 0;
	margin-right: 0;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	font-size: 60%;
	padding: 0 1.8em;
}

.linux .monaco-menu .monaco-action-bar.vertical .submenu-indicator,
:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
	mask-size: 10px 10px;
	-webkit-mask-size: 10px 10px;
}

.monaco-menu .action-item {
	cursor: default;
}`
  );
  if (e) {
    t += `
			/* Arrows */
			.monaco-scrollable-element > .scrollbar > .scra {
				cursor: pointer;
				font-size: 11px !important;
			}

			.monaco-scrollable-element > .visible {
				opacity: 1;

				/* Background rule added for IE9 - to allow clicks on dom node */
				background:rgba(0,0,0,0);

				transition: opacity 100ms linear;
			}
			.monaco-scrollable-element > .invisible {
				opacity: 0;
				pointer-events: none;
			}
			.monaco-scrollable-element > .invisible.fade {
				transition: opacity 800ms linear;
			}

			/* Scrollable Content Inset Shadow */
			.monaco-scrollable-element > .shadow {
				position: absolute;
				display: none;
			}
			.monaco-scrollable-element > .shadow.top {
				display: block;
				top: 0;
				left: 3px;
				height: 3px;
				width: 100%;
			}
			.monaco-scrollable-element > .shadow.left {
				display: block;
				top: 3px;
				left: 0;
				height: 100%;
				width: 3px;
			}
			.monaco-scrollable-element > .shadow.top-left-corner {
				display: block;
				top: 0;
				left: 0;
				height: 3px;
				width: 3px;
			}
		`;
    const i = s.scrollbarShadow;
    i && (t += `
				.monaco-scrollable-element > .shadow.top {
					box-shadow: ${i} 0 6px 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.left {
					box-shadow: ${i} 6px 0 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.top.left {
					box-shadow: ${i} 6px 6px 6px -6px inset;
				}
			`);
    const n = s.scrollbarSliderBackground;
    n && (t += `
				.monaco-scrollable-element > .scrollbar > .slider {
					background: ${n};
				}
			`);
    const o = s.scrollbarSliderHoverBackground;
    o && (t += `
				.monaco-scrollable-element > .scrollbar > .slider:hover {
					background: ${o};
				}
			`);
    const r = s.scrollbarSliderActiveBackground;
    r && (t += `
				.monaco-scrollable-element > .scrollbar > .slider.active {
					background: ${r};
				}
			`);
  }
  return t;
}
class zne {
  constructor(e, t, i, n) {
    this.contextViewService = e, this.telemetryService = t, this.notificationService = i, this.keybindingService = n, this.focusToReturn = null, this.lastContainer = null, this.block = null, this.blockDisposable = null, this.options = { blockMouse: !0 };
  }
  configure(e) {
    this.options = e;
  }
  showContextMenu(e) {
    const t = e.getActions();
    if (!t.length)
      return;
    this.focusToReturn = Gi();
    let i;
    const n = ki(e.domForShadowRoot) ? e.domForShadowRoot : void 0;
    this.contextViewService.showContextView({
      getAnchor: () => e.getAnchor(),
      canRelayout: !1,
      anchorAlignment: e.anchorAlignment,
      anchorAxisAlignment: e.anchorAxisAlignment,
      render: (o) => {
        var h;
        this.lastContainer = o;
        const r = e.getMenuClassName ? e.getMenuClassName() : "";
        r && (o.className += " " + r), this.options.blockMouse && (this.block = o.appendChild(he(".context-view-block")), this.block.style.position = "fixed", this.block.style.cursor = "initial", this.block.style.left = "0", this.block.style.top = "0", this.block.style.width = "100%", this.block.style.height = "100%", this.block.style.zIndex = "-1", (h = this.blockDisposable) == null || h.dispose(), this.blockDisposable = z(this.block, X.MOUSE_DOWN, (d) => d.stopPropagation()));
        const a = new ne(), l = e.actionRunner || new Fh();
        l.onWillRun((d) => this.onActionRun(d, !e.skipTelemetry), this, a), l.onDidRun(this.onDidActionRun, this, a), i = new Ku(o, t, {
          actionViewItemProvider: e.getActionViewItem,
          context: e.getActionsContext ? e.getActionsContext() : null,
          actionRunner: l,
          getKeyBinding: e.getKeyBinding ? e.getKeyBinding : (d) => this.keybindingService.lookupKeybinding(d.id)
        }, CX), i.onDidCancel(() => this.contextViewService.hideContextView(!0), null, a), i.onDidBlur(() => this.contextViewService.hideContextView(!0), null, a);
        const c = fe(o);
        return a.add(z(c, X.BLUR, () => this.contextViewService.hideContextView(!0))), a.add(z(c, X.MOUSE_DOWN, (d) => {
          if (d.defaultPrevented)
            return;
          const u = new Uo(c, d);
          let f = u.target;
          if (!u.rightButton) {
            for (; f; ) {
              if (f === o)
                return;
              f = f.parentElement;
            }
            this.contextViewService.hideContextView(!0);
          }
        })), ao(a, i);
      },
      focus: () => {
        i == null || i.focus(!!e.autoSelectFirstItem);
      },
      onHide: (o) => {
        var r, a, l;
        (r = e.onHide) == null || r.call(e, !!o), this.block && (this.block.remove(), this.block = null), (a = this.blockDisposable) == null || a.dispose(), this.blockDisposable = null, this.lastContainer && (Gi() === this.lastContainer || _i(Gi(), this.lastContainer)) && ((l = this.focusToReturn) == null || l.focus()), this.lastContainer = null;
      }
    }, n, !!n);
  }
  onActionRun(e, t) {
    t && this.telemetryService.publicLog2("workbenchActionExecuted", { id: e.action.id, from: "contextMenu" }), this.contextViewService.hideContextView(!1);
  }
  onDidActionRun(e) {
    e.error && !Jh(e.error) && this.notificationService.error(e.error);
  }
}
var Une = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Vd = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let $x = class extends U {
  get contextMenuHandler() {
    return this._contextMenuHandler || (this._contextMenuHandler = new zne(this.contextViewService, this.telemetryService, this.notificationService, this.keybindingService)), this._contextMenuHandler;
  }
  constructor(e, t, i, n, o, r) {
    super(), this.telemetryService = e, this.notificationService = t, this.contextViewService = i, this.keybindingService = n, this.menuService = o, this.contextKeyService = r, this._contextMenuHandler = void 0, this._onDidShowContextMenu = this._store.add(new A()), this.onDidShowContextMenu = this._onDidShowContextMenu.event, this._onDidHideContextMenu = this._store.add(new A());
  }
  configure(e) {
    this.contextMenuHandler.configure(e);
  }
  // ContextMenu
  showContextMenu(e) {
    e = Kx.transform(e, this.menuService, this.contextKeyService), this.contextMenuHandler.showContextMenu({
      ...e,
      onHide: (t) => {
        var i;
        (i = e.onHide) == null || i.call(e, t), this._onDidHideContextMenu.fire();
      }
    }), xa.getInstance().resetKeyStatus(), this._onDidShowContextMenu.fire();
  }
};
$x = Une([
  Vd(0, Jo),
  Vd(1, cn),
  Vd(2, fd),
  Vd(3, Lt),
  Vd(4, $r),
  Vd(5, Fe)
], $x);
var Kx;
(function(s) {
  function e(i) {
    return i && i.menuId instanceof et;
  }
  function t(i, n, o) {
    if (!e(i))
      return i;
    const { menuId: r, menuActionOptions: a, contextKeyService: l } = i;
    return {
      ...i,
      getActions: () => {
        const c = [];
        if (r) {
          const h = n.getMenuActions(r, l ?? o, a);
          vX(h, c);
        }
        return i.getActions ? Vi.join(i.getActions(), c) : c;
      }
    };
  }
  s.transform = t;
})(Kx || (Kx = {}));
var wC;
(function(s) {
  s[s.API = 0] = "API", s[s.USER = 1] = "USER";
})(wC || (wC = {}));
var PN = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, yC = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let jx = class {
  constructor(e) {
    this._commandService = e;
  }
  async open(e, t) {
    if (!yE(e, Ie.command))
      return !1;
    if (!(t != null && t.allowCommands) || (typeof e == "string" && (e = we.parse(e)), Array.isArray(t.allowCommands) && !t.allowCommands.includes(e.path)))
      return !0;
    let i = [];
    try {
      i = hS(decodeURIComponent(e.query));
    } catch {
      try {
        i = hS(e.query);
      } catch {
      }
    }
    return Array.isArray(i) || (i = [i]), await this._commandService.executeCommand(e.path, ...i), !0;
  }
};
jx = PN([
  yC(0, fi)
], jx);
let qx = class {
  constructor(e) {
    this._editorService = e;
  }
  async open(e, t) {
    typeof e == "string" && (e = we.parse(e));
    const { selection: i, uri: n } = ZQ(e);
    return e = n, e.scheme === Ie.file && (e = UB(e)), await this._editorService.openCodeEditor({
      resource: e,
      options: {
        selection: i,
        source: t != null && t.fromUserGesture ? wC.USER : wC.API,
        ...t == null ? void 0 : t.editorOptions
      }
    }, this._editorService.getFocusedCodeEditor(), t == null ? void 0 : t.openToSide), !0;
  }
};
qx = PN([
  yC(0, Tt)
], qx);
let Gx = class {
  constructor(e, t) {
    this._openers = new Tn(), this._validators = new Tn(), this._resolvers = new Tn(), this._resolvedUriTargets = new Yn((i) => i.with({ path: null, fragment: null, query: null }).toString()), this._externalOpeners = new Tn(), this._defaultExternalOpener = {
      openExternal: async (i) => (Zy(i, Ie.http, Ie.https) ? $4(i) : pt.location.href = i, !0)
    }, this._openers.push({
      open: async (i, n) => n != null && n.openExternal || Zy(i, Ie.mailto, Ie.http, Ie.https, Ie.vsls) ? (await this._doOpenExternal(i, n), !0) : !1
    }), this._openers.push(new jx(t)), this._openers.push(new qx(e));
  }
  registerOpener(e) {
    return { dispose: this._openers.unshift(e) };
  }
  async open(e, t) {
    const i = typeof e == "string" ? we.parse(e) : e, n = this._resolvedUriTargets.get(i) ?? e;
    for (const o of this._validators)
      if (!await o.shouldOpen(n, t))
        return !1;
    for (const o of this._openers)
      if (await o.open(e, t))
        return !0;
    return !1;
  }
  async resolveExternalUri(e, t) {
    for (const i of this._resolvers)
      try {
        const n = await i.resolveExternalUri(e, t);
        if (n)
          return this._resolvedUriTargets.has(n.resolved) || this._resolvedUriTargets.set(n.resolved, e), n;
      } catch {
      }
    throw new Error("Could not resolve external URI: " + e.toString());
  }
  async _doOpenExternal(e, t) {
    const i = typeof e == "string" ? we.parse(e) : e;
    let n;
    try {
      n = (await this.resolveExternalUri(i, t)).resolved;
    } catch {
      n = i;
    }
    let o;
    if (typeof e == "string" && i.toString() === n.toString() ? o = e : o = encodeURI(n.toString(!0)), t != null && t.allowContributedOpeners) {
      const r = typeof (t == null ? void 0 : t.allowContributedOpeners) == "string" ? t == null ? void 0 : t.allowContributedOpeners : void 0;
      for (const a of this._externalOpeners)
        if (await a.openExternal(o, {
          sourceUri: i,
          preferredOpenerId: r
        }, _t.None))
          return !0;
    }
    return this._defaultExternalOpener.openExternal(o, { sourceUri: i }, _t.None);
  }
  dispose() {
    this._validators.clear();
  }
};
Gx = PN([
  yC(0, Tt),
  yC(1, fi)
], Gx);
var $ne = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, WA = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Zx = class extends U {
  constructor(e, t) {
    super(), this._markerService = t, this._onDidChangeMarker = this._register(new A()), this._markerDecorations = new Yn(), e.getModels().forEach((i) => this._onModelAdded(i)), this._register(e.onModelAdded(this._onModelAdded, this)), this._register(e.onModelRemoved(this._onModelRemoved, this)), this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));
  }
  dispose() {
    super.dispose(), this._markerDecorations.forEach((e) => e.dispose()), this._markerDecorations.clear();
  }
  getMarker(e, t) {
    const i = this._markerDecorations.get(e);
    return i && i.getMarker(t) || null;
  }
  _handleMarkerChange(e) {
    e.forEach((t) => {
      const i = this._markerDecorations.get(t);
      i && this._updateDecorations(i);
    });
  }
  _onModelAdded(e) {
    const t = new Kne(e);
    this._markerDecorations.set(e.uri, t), this._updateDecorations(t);
  }
  _onModelRemoved(e) {
    var i;
    const t = this._markerDecorations.get(e.uri);
    t && (t.dispose(), this._markerDecorations.delete(e.uri)), (e.uri.scheme === Ie.inMemory || e.uri.scheme === Ie.internal || e.uri.scheme === Ie.vscode) && ((i = this._markerService) == null || i.read({ resource: e.uri }).map((n) => n.owner).forEach((n) => this._markerService.remove(n, [e.uri])));
  }
  _updateDecorations(e) {
    const t = this._markerService.read({ resource: e.model.uri, take: 500 });
    e.update(t) && this._onDidChangeMarker.fire(e.model);
  }
};
Zx = $ne([
  WA(0, Ui),
  WA(1, Zr)
], Zx);
class Kne extends U {
  constructor(e) {
    super(), this.model = e, this._map = new _B(), this._register(_e(() => {
      this.model.deltaDecorations([...this._map.values()], []), this._map.clear();
    }));
  }
  update(e) {
    const { added: t, removed: i } = aJ(new Set(this._map.keys()), new Set(e));
    if (t.length === 0 && i.length === 0)
      return !1;
    const n = i.map((a) => this._map.get(a)), o = t.map((a) => ({
      range: this._createDecorationRange(this.model, a),
      options: this._createDecorationOption(a)
    })), r = this.model.deltaDecorations(n, o);
    for (const a of i)
      this._map.delete(a);
    for (let a = 0; a < r.length; a++)
      this._map.set(t[a], r[a]);
    return !0;
  }
  getMarker(e) {
    return this._map.getKey(e.id);
  }
  _createDecorationRange(e, t) {
    let i = T.lift(t);
    if (t.severity === Bt.Hint && !this._hasMarkerTag(
      t,
      1
      /* MarkerTag.Unnecessary */
    ) && !this._hasMarkerTag(
      t,
      2
      /* MarkerTag.Deprecated */
    ) && (i = i.setEndPosition(i.startLineNumber, i.startColumn + 2)), i = e.validateRange(i), i.isEmpty()) {
      const n = e.getLineLastNonWhitespaceColumn(i.startLineNumber) || e.getLineMaxColumn(i.startLineNumber);
      if (n === 1 || i.endColumn >= n)
        return i;
      const o = e.getWordAtPosition(i.getStartPosition());
      o && (i = new T(i.startLineNumber, o.startColumn, i.endLineNumber, o.endColumn));
    } else if (t.endColumn === Number.MAX_VALUE && t.startColumn === 1 && i.startLineNumber === i.endLineNumber) {
      const n = e.getLineFirstNonWhitespaceColumn(t.startLineNumber);
      n < i.endColumn && (i = new T(i.startLineNumber, n, i.endLineNumber, i.endColumn), t.startColumn = n);
    }
    return i;
  }
  _createDecorationOption(e) {
    let t, i, n, o, r;
    switch (e.severity) {
      case Bt.Hint:
        this._hasMarkerTag(
          e,
          2
          /* MarkerTag.Deprecated */
        ) ? t = void 0 : this._hasMarkerTag(
          e,
          1
          /* MarkerTag.Unnecessary */
        ) ? t = "squiggly-unnecessary" : t = "squiggly-hint", n = 0;
        break;
      case Bt.Info:
        t = "squiggly-info", i = Ts(yK), n = 10, r = {
          color: Ts(Xz),
          position: 1
          /* MinimapPosition.Inline */
        };
        break;
      case Bt.Warning:
        t = "squiggly-warning", i = Ts(wK), n = 20, r = {
          color: Ts(Qz),
          position: 1
          /* MinimapPosition.Inline */
        };
        break;
      case Bt.Error:
      default:
        t = "squiggly-error", i = Ts(vK), n = 30, r = {
          color: Ts(Jz),
          position: 1
          /* MinimapPosition.Inline */
        };
        break;
    }
    return e.tags && (e.tags.indexOf(
      1
      /* MarkerTag.Unnecessary */
    ) !== -1 && (o = "squiggly-inline-unnecessary"), e.tags.indexOf(
      2
      /* MarkerTag.Deprecated */
    ) !== -1 && (o = "squiggly-inline-deprecated")), {
      description: "marker-decoration",
      stickiness: 1,
      className: t,
      showIfCollapsed: !0,
      overviewRuler: {
        color: i,
        position: S1.Right
      },
      minimap: r,
      zIndex: n,
      inlineClassName: o
    };
  }
  _hasMarkerTag(e, t) {
    return e.tags ? e.tags.indexOf(t) >= 0 : !1;
  }
}
var jne = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, K_ = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, jd;
function Cc(s) {
  return s.toString();
}
class qne {
  constructor(e, t, i) {
    this.model = e, this._modelEventListeners = new ne(), this.model = e, this._modelEventListeners.add(e.onWillDispose(() => t(e))), this._modelEventListeners.add(e.onDidChangeLanguage((n) => i(e, n)));
  }
  dispose() {
    this._modelEventListeners.dispose();
  }
}
const Gne = Rn || $e ? 1 : 2;
class Zne {
  constructor(e, t, i, n, o, r, a, l) {
    this.uri = e, this.initialUndoRedoSnapshot = t, this.time = i, this.sharesUndoRedoStack = n, this.heapSize = o, this.sha1 = r, this.versionId = a, this.alternativeVersionId = l;
  }
}
var Th;
let Yx = (Th = class extends U {
  constructor(e, t, i, n) {
    super(), this._configurationService = e, this._resourcePropertiesService = t, this._undoRedoService = i, this._instantiationService = n, this._onModelAdded = this._register(new A()), this.onModelAdded = this._onModelAdded.event, this._onModelRemoved = this._register(new A()), this.onModelRemoved = this._onModelRemoved.event, this._onModelModeChanged = this._register(new A()), this.onModelLanguageChanged = this._onModelModeChanged.event, this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null), this._models = {}, this._disposedModels = /* @__PURE__ */ new Map(), this._disposedModelsHeapSize = 0, this._register(this._configurationService.onDidChangeConfiguration((o) => this._updateModelOptions(o))), this._updateModelOptions(void 0);
  }
  static _readModelOptions(e, t) {
    var u;
    let i = ji.tabSize;
    if (e.editor && typeof e.editor.tabSize < "u") {
      const f = parseInt(e.editor.tabSize, 10);
      isNaN(f) || (i = f), i < 1 && (i = 1);
    }
    let n = "tabSize";
    if (e.editor && typeof e.editor.indentSize < "u" && e.editor.indentSize !== "tabSize") {
      const f = parseInt(e.editor.indentSize, 10);
      isNaN(f) || (n = Math.max(f, 1));
    }
    let o = ji.insertSpaces;
    e.editor && typeof e.editor.insertSpaces < "u" && (o = e.editor.insertSpaces === "false" ? !1 : !!e.editor.insertSpaces);
    let r = Gne;
    const a = e.eol;
    a === `\r
` ? r = 2 : a === `
` && (r = 1);
    let l = ji.trimAutoWhitespace;
    e.editor && typeof e.editor.trimAutoWhitespace < "u" && (l = e.editor.trimAutoWhitespace === "false" ? !1 : !!e.editor.trimAutoWhitespace);
    let c = ji.detectIndentation;
    e.editor && typeof e.editor.detectIndentation < "u" && (c = e.editor.detectIndentation === "false" ? !1 : !!e.editor.detectIndentation);
    let h = ji.largeFileOptimizations;
    e.editor && typeof e.editor.largeFileOptimizations < "u" && (h = e.editor.largeFileOptimizations === "false" ? !1 : !!e.editor.largeFileOptimizations);
    let d = ji.bracketPairColorizationOptions;
    return (u = e.editor) != null && u.bracketPairColorization && typeof e.editor.bracketPairColorization == "object" && (d = {
      enabled: !!e.editor.bracketPairColorization.enabled,
      independentColorPoolPerBracketType: !!e.editor.bracketPairColorization.independentColorPoolPerBracketType
    }), {
      isForSimpleWidget: t,
      tabSize: i,
      indentSize: n,
      insertSpaces: o,
      detectIndentation: c,
      defaultEOL: r,
      trimAutoWhitespace: l,
      largeFileOptimizations: h,
      bracketPairColorizationOptions: d
    };
  }
  _getEOL(e, t) {
    if (e)
      return this._resourcePropertiesService.getEOL(e, t);
    const i = this._configurationService.getValue("files.eol", { overrideIdentifier: t });
    return i && typeof i == "string" && i !== "auto" ? i : bs === 3 || bs === 2 ? `
` : `\r
`;
  }
  _shouldRestoreUndoStack() {
    const e = this._configurationService.getValue("files.restoreUndoStack");
    return typeof e == "boolean" ? e : !0;
  }
  getCreationOptions(e, t, i) {
    const n = typeof e == "string" ? e : e.languageId;
    let o = this._modelCreationOptionsByLanguageAndResource[n + t];
    if (!o) {
      const r = this._configurationService.getValue("editor", { overrideIdentifier: n, resource: t }), a = this._getEOL(t, n);
      o = jd._readModelOptions({ editor: r, eol: a }, i), this._modelCreationOptionsByLanguageAndResource[n + t] = o;
    }
    return o;
  }
  _updateModelOptions(e) {
    const t = this._modelCreationOptionsByLanguageAndResource;
    this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null);
    const i = Object.keys(this._models);
    for (let n = 0, o = i.length; n < o; n++) {
      const r = i[n], a = this._models[r], l = a.model.getLanguageId(), c = a.model.uri;
      if (e && !e.affectsConfiguration("editor", { overrideIdentifier: l, resource: c }) && !e.affectsConfiguration("files.eol", { overrideIdentifier: l, resource: c }))
        continue;
      const h = t[l + c], d = this.getCreationOptions(l, c, a.model.isForSimpleWidget);
      jd._setModelOptionsForModel(a.model, d, h);
    }
  }
  static _setModelOptionsForModel(e, t, i) {
    i && i.defaultEOL !== t.defaultEOL && e.getLineCount() === 1 && e.setEOL(
      t.defaultEOL === 1 ? 0 : 1
      /* EndOfLineSequence.CRLF */
    ), !(i && i.detectIndentation === t.detectIndentation && i.insertSpaces === t.insertSpaces && i.tabSize === t.tabSize && i.indentSize === t.indentSize && i.trimAutoWhitespace === t.trimAutoWhitespace && Xn(i.bracketPairColorizationOptions, t.bracketPairColorizationOptions)) && (t.detectIndentation ? (e.detectIndentation(t.insertSpaces, t.tabSize), e.updateOptions({
      trimAutoWhitespace: t.trimAutoWhitespace,
      bracketColorizationOptions: t.bracketPairColorizationOptions
    })) : e.updateOptions({
      insertSpaces: t.insertSpaces,
      tabSize: t.tabSize,
      indentSize: t.indentSize,
      trimAutoWhitespace: t.trimAutoWhitespace,
      bracketColorizationOptions: t.bracketPairColorizationOptions
    }));
  }
  // --- begin IModelService
  _insertDisposedModel(e) {
    this._disposedModels.set(Cc(e.uri), e), this._disposedModelsHeapSize += e.heapSize;
  }
  _removeDisposedModel(e) {
    const t = this._disposedModels.get(Cc(e));
    return t && (this._disposedModelsHeapSize -= t.heapSize), this._disposedModels.delete(Cc(e)), t;
  }
  _ensureDisposedModelsHeapSize(e) {
    if (this._disposedModelsHeapSize > e) {
      const t = [];
      for (this._disposedModels.forEach((i) => {
        i.sharesUndoRedoStack || t.push(i);
      }), t.sort((i, n) => i.time - n.time); t.length > 0 && this._disposedModelsHeapSize > e; ) {
        const i = t.shift();
        this._removeDisposedModel(i.uri), i.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(i.initialUndoRedoSnapshot);
      }
    }
  }
  _createModelData(e, t, i, n) {
    const o = this.getCreationOptions(t, i, n), r = this._instantiationService.createInstance(ip, e, t, o, i);
    if (i && this._disposedModels.has(Cc(i))) {
      const c = this._removeDisposedModel(i), h = this._undoRedoService.getElements(i), d = this._getSHA1Computer(), u = d.canComputeSHA1(r) ? d.computeSHA1(r) === c.sha1 : !1;
      if (u || c.sharesUndoRedoStack) {
        for (const f of h.past)
          ba(f) && f.matchesResource(i) && f.setModel(r);
        for (const f of h.future)
          ba(f) && f.matchesResource(i) && f.setModel(r);
        this._undoRedoService.setElementsValidFlag(i, !0, (f) => ba(f) && f.matchesResource(i)), u && (r._overwriteVersionId(c.versionId), r._overwriteAlternativeVersionId(c.alternativeVersionId), r._overwriteInitialUndoRedoSnapshot(c.initialUndoRedoSnapshot));
      } else
        c.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(c.initialUndoRedoSnapshot);
    }
    const a = Cc(r.uri);
    if (this._models[a])
      throw new Error("ModelService: Cannot add model because it already exists!");
    const l = new qne(r, (c) => this._onWillDispose(c), (c, h) => this._onDidChangeLanguage(c, h));
    return this._models[a] = l, l;
  }
  createModel(e, t, i, n = !1) {
    let o;
    return t ? o = this._createModelData(e, t, i, n) : o = this._createModelData(e, Fs, i, n), this._onModelAdded.fire(o.model), o.model;
  }
  getModels() {
    const e = [], t = Object.keys(this._models);
    for (let i = 0, n = t.length; i < n; i++) {
      const o = t[i];
      e.push(this._models[o].model);
    }
    return e;
  }
  getModel(e) {
    const t = Cc(e), i = this._models[t];
    return i ? i.model : null;
  }
  // --- end IModelService
  _schemaShouldMaintainUndoRedoElements(e) {
    return e.scheme === Ie.file || e.scheme === Ie.vscodeRemote || e.scheme === Ie.vscodeUserData || e.scheme === Ie.vscodeNotebookCell || e.scheme === "fake-fs";
  }
  _onWillDispose(e) {
    const t = Cc(e.uri), i = this._models[t], n = this._undoRedoService.getUriComparisonKey(e.uri) !== e.uri.toString();
    let o = !1, r = 0;
    if (n || this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(e.uri)) {
      const c = this._undoRedoService.getElements(e.uri);
      if (c.past.length > 0 || c.future.length > 0) {
        for (const h of c.past)
          ba(h) && h.matchesResource(e.uri) && (o = !0, r += h.heapSize(e.uri), h.setModel(e.uri));
        for (const h of c.future)
          ba(h) && h.matchesResource(e.uri) && (o = !0, r += h.heapSize(e.uri), h.setModel(e.uri));
      }
    }
    const a = jd.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK, l = this._getSHA1Computer();
    if (o)
      if (!n && (r > a || !l.canComputeSHA1(e))) {
        const c = i.model.getInitialUndoRedoSnapshot();
        c !== null && this._undoRedoService.restoreSnapshot(c);
      } else
        this._ensureDisposedModelsHeapSize(a - r), this._undoRedoService.setElementsValidFlag(e.uri, !1, (c) => ba(c) && c.matchesResource(e.uri)), this._insertDisposedModel(new Zne(e.uri, i.model.getInitialUndoRedoSnapshot(), Date.now(), n, r, l.computeSHA1(e), e.getVersionId(), e.getAlternativeVersionId()));
    else if (!n) {
      const c = i.model.getInitialUndoRedoSnapshot();
      c !== null && this._undoRedoService.restoreSnapshot(c);
    }
    delete this._models[t], i.dispose(), delete this._modelCreationOptionsByLanguageAndResource[e.getLanguageId() + e.uri], this._onModelRemoved.fire(e);
  }
  _onDidChangeLanguage(e, t) {
    const i = t.oldLanguage, n = e.getLanguageId(), o = this.getCreationOptions(i, e.uri, e.isForSimpleWidget), r = this.getCreationOptions(n, e.uri, e.isForSimpleWidget);
    jd._setModelOptionsForModel(e, r, o), this._onModelModeChanged.fire({ model: e, oldLanguageId: i });
  }
  _getSHA1Computer() {
    return new Xx();
  }
}, jd = Th, Th.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024, Th);
Yx = jd = jne([
  K_(0, gt),
  K_(1, s3),
  K_(2, VI),
  K_(3, Pe)
], Yx);
const Sv = class Sv {
  // takes 200ms to compute a sha1 on a 10MB model on a new machine
  canComputeSHA1(e) {
    return e.getValueLength() <= Sv.MAX_MODEL_SIZE;
  }
  computeSHA1(e) {
    const t = new Qy(), i = e.createSnapshot();
    let n;
    for (; n = i.read(); )
      t.update(n);
    return t.digest();
  }
};
Sv.MAX_MODEL_SIZE = 10 * 1024 * 1024;
let Xx = Sv;
var Qx;
(function(s) {
  s[s.PRESERVE = 0] = "PRESERVE", s[s.LAST = 1] = "LAST";
})(Qx || (Qx = {}));
const C3 = {
  Quickaccess: "workbench.contributions.quickaccess"
};
class Yne {
  constructor() {
    this.providers = [], this.defaultProvider = void 0;
  }
  registerQuickAccessProvider(e) {
    return e.prefix.length === 0 ? this.defaultProvider = e : this.providers.push(e), this.providers.sort((t, i) => i.prefix.length - t.prefix.length), _e(() => {
      this.providers.splice(this.providers.indexOf(e), 1), this.defaultProvider === e && (this.defaultProvider = void 0);
    });
  }
  getQuickAccessProviders() {
    return Rf([this.defaultProvider, ...this.providers]);
  }
  getQuickAccessProvider(e) {
    return e && this.providers.find((i) => e.startsWith(i.prefix)) || void 0 || this.defaultProvider;
  }
}
Mi.add(C3.Quickaccess, new Yne());
const Xne = { ctrlCmd: !1, alt: !1 };
var Lf;
(function(s) {
  s[s.Blur = 1] = "Blur", s[s.Gesture = 2] = "Gesture", s[s.Other = 3] = "Other";
})(Lf || (Lf = {}));
var yr;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.FIRST = 1] = "FIRST", s[s.SECOND = 2] = "SECOND", s[s.LAST = 3] = "LAST";
})(yr || (yr = {}));
var Ct;
(function(s) {
  s[s.First = 1] = "First", s[s.Second = 2] = "Second", s[s.Last = 3] = "Last", s[s.Next = 4] = "Next", s[s.Previous = 5] = "Previous", s[s.NextPage = 6] = "NextPage", s[s.PreviousPage = 7] = "PreviousPage", s[s.NextSeparator = 8] = "NextSeparator", s[s.PreviousSeparator = 9] = "PreviousSeparator";
})(Ct || (Ct = {}));
var SC;
(function(s) {
  s[s.Title = 1] = "Title", s[s.Inline = 2] = "Inline";
})(SC || (SC = {}));
const Gw = Be("quickInputService");
var Qne = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, HA = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Jx = class extends U {
  constructor(e, t) {
    super(), this.quickInputService = e, this.instantiationService = t, this.registry = Mi.as(C3.Quickaccess), this.mapProviderToDescriptor = /* @__PURE__ */ new Map(), this.lastAcceptedPickerValues = /* @__PURE__ */ new Map(), this.visibleQuickAccess = void 0;
  }
  show(e = "", t) {
    this.doShowOrPick(e, !1, t);
  }
  doShowOrPick(e, t, i) {
    var g, p;
    const [n, o] = this.getOrInstantiateProvider(e, i == null ? void 0 : i.enabledProviderPrefixes), r = this.visibleQuickAccess, a = r == null ? void 0 : r.descriptor;
    if (r && o && a === o) {
      e !== o.prefix && !(i != null && i.preserveValue) && (r.picker.value = e), this.adjustValueSelection(r.picker, o, i);
      return;
    }
    if (o && !(i != null && i.preserveValue)) {
      let _;
      if (r && a && a !== o) {
        const b = r.value.substr(a.prefix.length);
        b && (_ = `${o.prefix}${b}`);
      }
      if (!_) {
        const b = n == null ? void 0 : n.defaultFilterValue;
        b === Qx.LAST ? _ = this.lastAcceptedPickerValues.get(o) : typeof b == "string" && (_ = `${o.prefix}${b}`);
      }
      typeof _ == "string" && (e = _);
    }
    const l = (g = r == null ? void 0 : r.picker) == null ? void 0 : g.valueSelection, c = (p = r == null ? void 0 : r.picker) == null ? void 0 : p.value, h = new ne(), d = h.add(this.quickInputService.createQuickPick({ useSeparators: !0 }));
    d.value = e, this.adjustValueSelection(d, o, i), d.placeholder = (i == null ? void 0 : i.placeholder) ?? (o == null ? void 0 : o.placeholder), d.quickNavigate = i == null ? void 0 : i.quickNavigateConfiguration, d.hideInput = !!d.quickNavigate && !r, (typeof (i == null ? void 0 : i.itemActivation) == "number" || i != null && i.quickNavigateConfiguration) && (d.itemActivation = (i == null ? void 0 : i.itemActivation) ?? yr.SECOND), d.contextKey = o == null ? void 0 : o.contextKey, d.filterValue = (_) => _.substring(o ? o.prefix.length : 0);
    let u;
    t && (u = new L4(), h.add(ee.once(d.onWillAccept)((_) => {
      _.veto(), d.hide();
    }))), h.add(this.registerPickerListeners(d, n, o, e, i));
    const f = h.add(new Vs());
    if (n && h.add(n.provide(d, f.token, i == null ? void 0 : i.providerOptions)), ee.once(d.onDidHide)(() => {
      d.selectedItems.length === 0 && f.cancel(), h.dispose(), u == null || u.complete(d.selectedItems.slice(0));
    }), d.show(), l && c === e && (d.valueSelection = l), t)
      return u == null ? void 0 : u.p;
  }
  adjustValueSelection(e, t, i) {
    let n;
    i != null && i.preserveValue ? n = [e.value.length, e.value.length] : n = [(t == null ? void 0 : t.prefix.length) ?? 0, e.value.length], e.valueSelection = n;
  }
  registerPickerListeners(e, t, i, n, o) {
    const r = new ne(), a = this.visibleQuickAccess = { picker: e, descriptor: i, value: n };
    return r.add(_e(() => {
      a === this.visibleQuickAccess && (this.visibleQuickAccess = void 0);
    })), r.add(e.onDidChangeValue((l) => {
      const [c] = this.getOrInstantiateProvider(l, o == null ? void 0 : o.enabledProviderPrefixes);
      c !== t ? this.show(l, {
        enabledProviderPrefixes: o == null ? void 0 : o.enabledProviderPrefixes,
        // do not rewrite value from user typing!
        preserveValue: !0,
        // persist the value of the providerOptions from the original showing
        providerOptions: o == null ? void 0 : o.providerOptions
      }) : a.value = l;
    })), i && r.add(e.onDidAccept(() => {
      this.lastAcceptedPickerValues.set(i, e.value);
    })), r;
  }
  getOrInstantiateProvider(e, t) {
    const i = this.registry.getQuickAccessProvider(e);
    if (!i || t && !(t != null && t.includes(i.prefix)))
      return [void 0, void 0];
    let n = this.mapProviderToDescriptor.get(i);
    return n || (n = this.instantiationService.createInstance(i.ctor), this.mapProviderToDescriptor.set(i, n)), [n, i];
  }
};
Jx = Qne([
  HA(0, Gw),
  HA(1, Pe)
], Jx);
var Jne = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
};
class v3 {
  constructor(e) {
    this.nodes = e;
  }
  toString() {
    return this.nodes.map((e) => typeof e == "string" ? e : e.label).join("");
  }
}
Jne([
  Yt
], v3.prototype, "toString", null);
const ese = /\[([^\]]+)\]\(((?:https?:\/\/|command:|file:)[^\)\s]+)(?: (["'])(.+?)(\3))?\)/gi;
function tse(s) {
  const e = [];
  let t = 0, i;
  for (; i = ese.exec(s); ) {
    i.index - t > 0 && e.push(s.substring(t, i.index));
    const [, n, o, , r] = i;
    r ? e.push({ label: n, href: o, title: r }) : e.push({ label: n, href: o }), t = i.index + i[0].length;
  }
  return t < s.length && e.push(s.substring(t)), new v3(e);
}
const wy = {}, ise = new $E("quick-input-button-icon-");
function nse(s) {
  if (!s)
    return;
  let e;
  const t = s.dark.toString();
  return wy[t] ? e = wy[t] : (e = ise.nextId(), Gb(`.${e}, .hc-light .${e}`, `background-image: ${Ua(s.light || s.dark)}`), Gb(`.vs-dark .${e}, .hc-black .${e}`, `background-image: ${Ua(s.dark)}`), wy[t] = e), e;
}
function nm(s, e, t) {
  let i = s.iconClass || nse(s.iconPath);
  return s.alwaysVisible && (i = i ? `${i} always-visible` : "always-visible"), {
    id: e,
    label: "",
    tooltip: s.tooltip || "",
    class: i,
    enabled: !0,
    run: t
  };
}
function sse(s, e, t) {
  _n(e);
  const i = tse(s);
  let n = 0;
  for (const o of i.nodes)
    if (typeof o == "string")
      e.append(...lh(o));
    else {
      let r = o.title;
      !r && o.href.startsWith("command:") ? r = m("executeCommand", "Click to execute command '{0}'", o.href.substring(8)) : r || (r = o.href);
      const a = he("a", { href: o.href, title: r, tabIndex: n++ }, o.label);
      a.style.textDecoration = "underline";
      const l = (f) => {
        J6(f) && Ge.stop(f, !0), t.callback(o.href);
      }, c = t.disposables.add(new He(a, X.CLICK)).event, h = t.disposables.add(new He(a, X.KEY_DOWN)).event, d = ee.chain(h, (f) => f.filter((g) => {
        const p = new Dt(g);
        return p.equals(
          10
          /* KeyCode.Space */
        ) || p.equals(
          3
          /* KeyCode.Enter */
        );
      }));
      t.disposables.add(ln.addTarget(a));
      const u = t.disposables.add(new He(a, vt.Tap)).event;
      ee.any(c, u, d)(l, null, t.disposables), e.appendChild(a);
    }
}
var ose = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, VA = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const w3 = "inQuickInput", rse = new ce(w3, !1, m("inQuickInput", "Whether keyboard focus is inside the quick input control")), ase = ve.has(w3), y3 = "quickInputType", lse = new ce(y3, void 0, m("quickInputType", "The type of the currently visible quick input")), S3 = "cursorAtEndOfQuickInputBox", cse = new ce(S3, !1, m("cursorAtEndOfQuickInputBox", "Whether the cursor in the quick input is at the end of the input box")), hse = ve.has(S3), eD = {
  iconClass: Te.asClassName(ie.quickInputBack),
  tooltip: m("quickInput.back", "Back")
}, Lv = class Lv extends U {
  constructor(e) {
    super(), this.ui = e, this._widgetUpdated = !1, this.visible = !1, this._enabled = !0, this._busy = !1, this._ignoreFocusOut = !1, this._leftButtons = [], this._rightButtons = [], this._inlineButtons = [], this.buttonsUpdated = !1, this._toggles = [], this.togglesUpdated = !1, this.noValidationMessage = Lv.noPromptMessage, this._severity = Gt.Ignore, this.onDidTriggerButtonEmitter = this._register(new A()), this.onDidHideEmitter = this._register(new A()), this.onWillHideEmitter = this._register(new A()), this.onDisposeEmitter = this._register(new A()), this.visibleDisposables = this._register(new ne()), this.onDidHide = this.onDidHideEmitter.event;
  }
  get title() {
    return this._title;
  }
  set title(e) {
    this._title = e, this.update();
  }
  get description() {
    return this._description;
  }
  set description(e) {
    this._description = e, this.update();
  }
  get step() {
    return this._steps;
  }
  set step(e) {
    this._steps = e, this.update();
  }
  get totalSteps() {
    return this._totalSteps;
  }
  set totalSteps(e) {
    this._totalSteps = e, this.update();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e, this.update();
  }
  get contextKey() {
    return this._contextKey;
  }
  set contextKey(e) {
    this._contextKey = e, this.update();
  }
  get busy() {
    return this._busy;
  }
  set busy(e) {
    this._busy = e, this.update();
  }
  get ignoreFocusOut() {
    return this._ignoreFocusOut;
  }
  set ignoreFocusOut(e) {
    const t = this._ignoreFocusOut !== e && !Kl;
    this._ignoreFocusOut = e && !Kl, t && this.update();
  }
  get titleButtons() {
    return this._leftButtons.length ? [...this._leftButtons, this._rightButtons] : this._rightButtons;
  }
  get buttons() {
    return [
      ...this._leftButtons,
      ...this._rightButtons,
      ...this._inlineButtons
    ];
  }
  set buttons(e) {
    this._leftButtons = e.filter((t) => t === eD), this._rightButtons = e.filter((t) => t !== eD && t.location !== SC.Inline), this._inlineButtons = e.filter((t) => t.location === SC.Inline), this.buttonsUpdated = !0, this.update();
  }
  get toggles() {
    return this._toggles;
  }
  set toggles(e) {
    this._toggles = e ?? [], this.togglesUpdated = !0, this.update();
  }
  get validationMessage() {
    return this._validationMessage;
  }
  set validationMessage(e) {
    this._validationMessage = e, this.update();
  }
  get severity() {
    return this._severity;
  }
  set severity(e) {
    this._severity = e, this.update();
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.onDidTriggerButton((e) => {
      this.buttons.indexOf(e) !== -1 && this.onDidTriggerButtonEmitter.fire(e);
    })), this.ui.show(this), this.visible = !0, this._lastValidationMessage = void 0, this._lastSeverity = void 0, this.buttons.length && (this.buttonsUpdated = !0), this.toggles.length && (this.togglesUpdated = !0), this.update());
  }
  hide() {
    this.visible && this.ui.hide();
  }
  didHide(e = Lf.Other) {
    this.visible = !1, this.visibleDisposables.clear(), this.onDidHideEmitter.fire({ reason: e });
  }
  willHide(e = Lf.Other) {
    this.onWillHideEmitter.fire({ reason: e });
  }
  update() {
    var n;
    if (!this.visible)
      return;
    const e = this.getTitle();
    e && this.ui.title.textContent !== e ? this.ui.title.textContent = e : !e && this.ui.title.innerHTML !== "&nbsp;" && (this.ui.title.innerText = " ");
    const t = this.getDescription();
    if (this.ui.description1.textContent !== t && (this.ui.description1.textContent = t), this.ui.description2.textContent !== t && (this.ui.description2.textContent = t), this._widgetUpdated && (this._widgetUpdated = !1, this._widget ? _n(this.ui.widget, this._widget) : _n(this.ui.widget)), this.busy && !this.busyDelay && (this.busyDelay = new Ya(), this.busyDelay.setIfNotSet(() => {
      this.visible && this.ui.progressBar.infinite();
    }, 800)), !this.busy && this.busyDelay && (this.ui.progressBar.stop(), this.busyDelay.cancel(), this.busyDelay = void 0), this.buttonsUpdated) {
      this.buttonsUpdated = !1, this.ui.leftActionBar.clear();
      const o = this._leftButtons.map((l, c) => nm(l, `id-${c}`, async () => this.onDidTriggerButtonEmitter.fire(l)));
      this.ui.leftActionBar.push(o, { icon: !0, label: !1 }), this.ui.rightActionBar.clear();
      const r = this._rightButtons.map((l, c) => nm(l, `id-${c}`, async () => this.onDidTriggerButtonEmitter.fire(l)));
      this.ui.rightActionBar.push(r, { icon: !0, label: !1 }), this.ui.inlineActionBar.clear();
      const a = this._inlineButtons.map((l, c) => nm(l, `id-${c}`, async () => this.onDidTriggerButtonEmitter.fire(l)));
      this.ui.inlineActionBar.push(a, { icon: !0, label: !1 });
    }
    if (this.togglesUpdated) {
      this.togglesUpdated = !1;
      const o = ((n = this.toggles) == null ? void 0 : n.filter((r) => r instanceof Mw)) ?? [];
      this.ui.inputBox.toggles = o;
    }
    this.ui.ignoreFocusOut = this.ignoreFocusOut, this.ui.setEnabled(this.enabled), this.ui.setContextKey(this.contextKey);
    const i = this.validationMessage || this.noValidationMessage;
    this._lastValidationMessage !== i && (this._lastValidationMessage = i, _n(this.ui.message), sse(i, this.ui.message, {
      callback: (o) => {
        this.ui.linkOpenerDelegate(o);
      },
      disposables: this.visibleDisposables
    })), this._lastSeverity !== this.severity && (this._lastSeverity = this.severity, this.showMessageDecoration(this.severity));
  }
  getTitle() {
    return this.title && this.step ? `${this.title} (${this.getSteps()})` : this.title ? this.title : this.step ? this.getSteps() : "";
  }
  getDescription() {
    return this.description || "";
  }
  getSteps() {
    return this.step && this.totalSteps ? m("quickInput.steps", "{0}/{1}", this.step, this.totalSteps) : this.step ? String(this.step) : "";
  }
  showMessageDecoration(e) {
    if (this.ui.inputBox.showDecoration(e), e !== Gt.Ignore) {
      const t = this.ui.inputBox.stylesForType(e);
      this.ui.message.style.color = t.foreground ? `${t.foreground}` : "", this.ui.message.style.backgroundColor = t.background ? `${t.background}` : "", this.ui.message.style.border = t.border ? `1px solid ${t.border}` : "", this.ui.message.style.marginBottom = "-2px";
    } else
      this.ui.message.style.color = "", this.ui.message.style.backgroundColor = "", this.ui.message.style.border = "", this.ui.message.style.marginBottom = "";
  }
  dispose() {
    this.hide(), this.onDisposeEmitter.fire(), super.dispose();
  }
};
Lv.noPromptMessage = m("inputModeEntry", "Press 'Enter' to confirm your input or 'Escape' to cancel");
let LC = Lv;
const kv = class kv extends LC {
  constructor() {
    super(...arguments), this._value = "", this.onDidChangeValueEmitter = this._register(new A()), this.onWillAcceptEmitter = this._register(new A()), this.onDidAcceptEmitter = this._register(new A()), this.onDidCustomEmitter = this._register(new A()), this._items = [], this.itemsUpdated = !1, this._canSelectMany = !1, this._canAcceptInBackground = !1, this._matchOnDescription = !1, this._matchOnDetail = !1, this._matchOnLabel = !0, this._matchOnLabelMode = "fuzzy", this._sortByLabel = !0, this._keepScrollPosition = !1, this._itemActivation = yr.FIRST, this._activeItems = [], this.activeItemsUpdated = !1, this.activeItemsToConfirm = [], this.onDidChangeActiveEmitter = this._register(new A()), this._selectedItems = [], this.selectedItemsUpdated = !1, this.selectedItemsToConfirm = [], this.onDidChangeSelectionEmitter = this._register(new A()), this.onDidTriggerItemButtonEmitter = this._register(new A()), this.onDidTriggerSeparatorButtonEmitter = this._register(new A()), this.valueSelectionUpdated = !0, this._ok = "default", this._customButton = !1, this._focusEventBufferer = new xp(), this.type = "quickPick", this.filterValue = (e) => e, this.onDidChangeValue = this.onDidChangeValueEmitter.event, this.onWillAccept = this.onWillAcceptEmitter.event, this.onDidAccept = this.onDidAcceptEmitter.event, this.onDidChangeActive = this.onDidChangeActiveEmitter.event, this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event, this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event, this.onDidTriggerSeparatorButton = this.onDidTriggerSeparatorButtonEmitter.event;
  }
  get quickNavigate() {
    return this._quickNavigate;
  }
  set quickNavigate(e) {
    this._quickNavigate = e, this.update();
  }
  get value() {
    return this._value;
  }
  set value(e) {
    this.doSetValue(e);
  }
  doSetValue(e, t) {
    this._value !== e && (this._value = e, t || this.update(), this.visible && this.ui.list.filter(this.filterValue(this._value)) && this.trySelectFirst(), this.onDidChangeValueEmitter.fire(this._value));
  }
  set ariaLabel(e) {
    this._ariaLabel = e, this.update();
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(e) {
    this._placeholder = e, this.update();
  }
  get items() {
    return this._items;
  }
  get scrollTop() {
    return this.ui.list.scrollTop;
  }
  set scrollTop(e) {
    this.ui.list.scrollTop = e;
  }
  set items(e) {
    this._items = e, this.itemsUpdated = !0, this.update();
  }
  get canSelectMany() {
    return this._canSelectMany;
  }
  set canSelectMany(e) {
    this._canSelectMany = e, this.update();
  }
  get canAcceptInBackground() {
    return this._canAcceptInBackground;
  }
  set canAcceptInBackground(e) {
    this._canAcceptInBackground = e;
  }
  get matchOnDescription() {
    return this._matchOnDescription;
  }
  set matchOnDescription(e) {
    this._matchOnDescription = e, this.update();
  }
  get matchOnDetail() {
    return this._matchOnDetail;
  }
  set matchOnDetail(e) {
    this._matchOnDetail = e, this.update();
  }
  get matchOnLabel() {
    return this._matchOnLabel;
  }
  set matchOnLabel(e) {
    this._matchOnLabel = e, this.update();
  }
  get matchOnLabelMode() {
    return this._matchOnLabelMode;
  }
  set matchOnLabelMode(e) {
    this._matchOnLabelMode = e, this.update();
  }
  get sortByLabel() {
    return this._sortByLabel;
  }
  set sortByLabel(e) {
    this._sortByLabel = e, this.update();
  }
  get keepScrollPosition() {
    return this._keepScrollPosition;
  }
  set keepScrollPosition(e) {
    this._keepScrollPosition = e;
  }
  get itemActivation() {
    return this._itemActivation;
  }
  set itemActivation(e) {
    this._itemActivation = e;
  }
  get activeItems() {
    return this._activeItems;
  }
  set activeItems(e) {
    this._activeItems = e, this.activeItemsUpdated = !0, this.update();
  }
  get selectedItems() {
    return this._selectedItems;
  }
  set selectedItems(e) {
    this._selectedItems = e, this.selectedItemsUpdated = !0, this.update();
  }
  get keyMods() {
    return this._quickNavigate ? Xne : this.ui.keyMods;
  }
  get valueSelection() {
    const e = this.ui.inputBox.getSelection();
    if (e)
      return [e.start, e.end];
  }
  set valueSelection(e) {
    this._valueSelection = e, this.valueSelectionUpdated = !0, this.update();
  }
  get customButton() {
    return this._customButton;
  }
  set customButton(e) {
    this._customButton = e, this.update();
  }
  get customLabel() {
    return this._customButtonLabel;
  }
  set customLabel(e) {
    this._customButtonLabel = e, this.update();
  }
  get customHover() {
    return this._customButtonHover;
  }
  set customHover(e) {
    this._customButtonHover = e, this.update();
  }
  get ok() {
    return this._ok;
  }
  set ok(e) {
    this._ok = e, this.update();
  }
  get hideInput() {
    return !!this._hideInput;
  }
  set hideInput(e) {
    this._hideInput = e, this.update();
  }
  trySelectFirst() {
    this.canSelectMany || this.ui.list.focus(Ct.First);
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.inputBox.onDidChange((e) => {
      this.doSetValue(
        e,
        !0
        /* skip update since this originates from the UI */
      );
    })), this.visibleDisposables.add(this.ui.onDidAccept(() => {
      this.canSelectMany ? this.ui.list.getCheckedElements().length || (this._selectedItems = [], this.onDidChangeSelectionEmitter.fire(this.selectedItems)) : this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems)), this.handleAccept(!1);
    })), this.visibleDisposables.add(this.ui.onDidCustom(() => {
      this.onDidCustomEmitter.fire();
    })), this.visibleDisposables.add(this._focusEventBufferer.wrapEvent(
      this.ui.list.onDidChangeFocus,
      // Only fire the last event
      (e, t) => t
    )((e) => {
      this.activeItemsUpdated || this.activeItemsToConfirm !== this._activeItems && li(e, this._activeItems, (t, i) => t === i) || (this._activeItems = e, this.onDidChangeActiveEmitter.fire(e));
    })), this.visibleDisposables.add(this.ui.list.onDidChangeSelection(({ items: e, event: t }) => {
      if (this.canSelectMany) {
        e.length && this.ui.list.setSelectedElements([]);
        return;
      }
      this.selectedItemsToConfirm !== this._selectedItems && li(e, this._selectedItems, (i, n) => i === n) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e), e.length && this.handleAccept(
        IE(t) && t.button === 1
        /* mouse middle click */
      ));
    })), this.visibleDisposables.add(this.ui.list.onChangedCheckedElements((e) => {
      !this.canSelectMany || !this.visible || this.selectedItemsToConfirm !== this._selectedItems && li(e, this._selectedItems, (t, i) => t === i) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e));
    })), this.visibleDisposables.add(this.ui.list.onButtonTriggered((e) => this.onDidTriggerItemButtonEmitter.fire(e))), this.visibleDisposables.add(this.ui.list.onSeparatorButtonTriggered((e) => this.onDidTriggerSeparatorButtonEmitter.fire(e))), this.visibleDisposables.add(this.registerQuickNavigation()), this.valueSelectionUpdated = !0), super.show();
  }
  handleAccept(e) {
    let t = !1;
    this.onWillAcceptEmitter.fire({ veto: () => t = !0 }), t || this.onDidAcceptEmitter.fire({ inBackground: e });
  }
  registerQuickNavigation() {
    return z(this.ui.container, X.KEY_UP, (e) => {
      if (this.canSelectMany || !this._quickNavigate)
        return;
      const t = new Dt(e), i = t.keyCode;
      this._quickNavigate.keybindings.some((r) => {
        const a = r.getChords();
        return a.length > 1 ? !1 : a[0].shiftKey && i === 4 ? !(t.ctrlKey || t.altKey || t.metaKey) : !!(a[0].altKey && i === 6 || a[0].ctrlKey && i === 5 || a[0].metaKey && i === 57);
      }) && (this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(!1)), this._quickNavigate = void 0);
    });
  }
  update() {
    if (!this.visible)
      return;
    const e = this.keepScrollPosition ? this.scrollTop : 0, t = !!this.description, i = {
      title: !!this.title || !!this.step || !!this.titleButtons.length,
      description: t,
      checkAll: this.canSelectMany && !this._hideCheckAll,
      checkBox: this.canSelectMany,
      inputBox: !this._hideInput,
      progressBar: !this._hideInput || t,
      visibleCount: !0,
      count: this.canSelectMany && !this._hideCountBadge,
      ok: this.ok === "default" ? this.canSelectMany : this.ok,
      list: !0,
      message: !!this.validationMessage,
      customButton: this.customButton
    };
    this.ui.setVisibilities(i), super.update(), this.ui.inputBox.value !== this.value && (this.ui.inputBox.value = this.value), this.valueSelectionUpdated && (this.valueSelectionUpdated = !1, this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] })), this.ui.inputBox.placeholder !== (this.placeholder || "") && (this.ui.inputBox.placeholder = this.placeholder || "");
    let n = this.ariaLabel;
    !n && i.inputBox && (n = this.placeholder || kv.DEFAULT_ARIA_LABEL, this.title && (n += ` - ${this.title}`)), this.ui.list.ariaLabel !== n && (this.ui.list.ariaLabel = n ?? null), this.ui.list.matchOnDescription = this.matchOnDescription, this.ui.list.matchOnDetail = this.matchOnDetail, this.ui.list.matchOnLabel = this.matchOnLabel, this.ui.list.matchOnLabelMode = this.matchOnLabelMode, this.ui.list.sortByLabel = this.sortByLabel, this.itemsUpdated && (this.itemsUpdated = !1, this._focusEventBufferer.bufferEvents(() => {
      switch (this.ui.list.setElements(this.items), this.ui.list.shouldLoop = !this.canSelectMany, this.ui.list.filter(this.filterValue(this.ui.inputBox.value)), this._itemActivation) {
        case yr.NONE:
          this._itemActivation = yr.FIRST;
          break;
        case yr.SECOND:
          this.ui.list.focus(Ct.Second), this._itemActivation = yr.FIRST;
          break;
        case yr.LAST:
          this.ui.list.focus(Ct.Last), this._itemActivation = yr.FIRST;
          break;
        default:
          this.trySelectFirst();
          break;
      }
    })), this.ui.container.classList.contains("show-checkboxes") !== !!this.canSelectMany && (this.canSelectMany ? this.ui.list.clearFocus() : this.trySelectFirst()), this.activeItemsUpdated && (this.activeItemsUpdated = !1, this.activeItemsToConfirm = this._activeItems, this.ui.list.setFocusedElements(this.activeItems), this.activeItemsToConfirm === this._activeItems && (this.activeItemsToConfirm = null)), this.selectedItemsUpdated && (this.selectedItemsUpdated = !1, this.selectedItemsToConfirm = this._selectedItems, this.canSelectMany ? this.ui.list.setCheckedElements(this.selectedItems) : this.ui.list.setSelectedElements(this.selectedItems), this.selectedItemsToConfirm === this._selectedItems && (this.selectedItemsToConfirm = null)), this.ui.customButton.label = this.customLabel || "", this.ui.customButton.element.title = this.customHover || "", i.inputBox || (this.ui.list.domFocus(), this.canSelectMany && this.ui.list.focus(Ct.First)), this.keepScrollPosition && (this.scrollTop = e);
  }
  focus(e) {
    this.ui.list.focus(e), this.canSelectMany && this.ui.list.domFocus();
  }
  accept(e) {
    e && !this._canAcceptInBackground || this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(e ?? !1));
  }
};
kv.DEFAULT_ARIA_LABEL = m("quickInputBox.ariaLabel", "Type to narrow down results.");
let kC = kv;
class dse extends LC {
  constructor() {
    super(...arguments), this._value = "", this.valueSelectionUpdated = !0, this._password = !1, this.onDidValueChangeEmitter = this._register(new A()), this.onDidAcceptEmitter = this._register(new A()), this.type = "inputBox", this.onDidChangeValue = this.onDidValueChangeEmitter.event, this.onDidAccept = this.onDidAcceptEmitter.event;
  }
  get value() {
    return this._value;
  }
  set value(e) {
    this._value = e || "", this.update();
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(e) {
    this._placeholder = e, this.update();
  }
  get password() {
    return this._password;
  }
  set password(e) {
    this._password = e, this.update();
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.inputBox.onDidChange((e) => {
      e !== this.value && (this._value = e, this.onDidValueChangeEmitter.fire(e));
    })), this.visibleDisposables.add(this.ui.onDidAccept(() => this.onDidAcceptEmitter.fire())), this.valueSelectionUpdated = !0), super.show();
  }
  update() {
    if (!this.visible)
      return;
    this.ui.container.classList.remove("hidden-input");
    const e = {
      title: !!this.title || !!this.step || !!this.titleButtons.length,
      description: !!this.description || !!this.step,
      inputBox: !0,
      message: !0,
      progressBar: !0
    };
    this.ui.setVisibilities(e), super.update(), this.ui.inputBox.value !== this.value && (this.ui.inputBox.value = this.value), this.valueSelectionUpdated && (this.valueSelectionUpdated = !1, this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] })), this.ui.inputBox.placeholder !== (this.placeholder || "") && (this.ui.inputBox.placeholder = this.placeholder || ""), this.ui.inputBox.password !== this.password && (this.ui.inputBox.password = this.password);
  }
}
let tD = class extends wf {
  constructor(e, t) {
    super("element", !1, (i) => this.getOverrideOptions(i), e, t);
  }
  getOverrideOptions(e) {
    const t = (ki(e.content) ? e.content.textContent ?? "" : typeof e.content == "string" ? e.content : e.content.value).includes(`
`);
    return {
      persistence: {
        hideOnKeyDown: !1
      },
      appearance: {
        showHoverHint: t,
        skipFadeInAnimation: !0
      }
    };
  }
};
tD = ose([
  VA(0, gt),
  VA(1, Cd)
], tD);
j.white.toString(), j.white.toString();
class iD extends U {
  get onDidClick() {
    return this._onDidClick.event;
  }
  constructor(e, t) {
    super(), this._label = "", this._onDidClick = this._register(new A()), this._onDidEscape = this._register(new A()), this.options = t, this._element = document.createElement("a"), this._element.classList.add("monaco-button"), this._element.tabIndex = 0, this._element.setAttribute("role", "button"), this._element.classList.toggle("secondary", !!t.secondary);
    const i = t.secondary ? t.buttonSecondaryBackground : t.buttonBackground, n = t.secondary ? t.buttonSecondaryForeground : t.buttonForeground;
    this._element.style.color = n || "", this._element.style.backgroundColor = i || "", t.supportShortLabel && (this._labelShortElement = document.createElement("div"), this._labelShortElement.classList.add("monaco-button-label-short"), this._element.appendChild(this._labelShortElement), this._labelElement = document.createElement("div"), this._labelElement.classList.add("monaco-button-label"), this._element.appendChild(this._labelElement), this._element.classList.add("monaco-text-button-with-short-label")), typeof t.title == "string" && this.setTitle(t.title), typeof t.ariaLabel == "string" && this._element.setAttribute("aria-label", t.ariaLabel), e.appendChild(this._element), this._register(ln.addTarget(this._element)), [X.CLICK, vt.Tap].forEach((o) => {
      this._register(z(this._element, o, (r) => {
        if (!this.enabled) {
          Ge.stop(r);
          return;
        }
        this._onDidClick.fire(r);
      }));
    }), this._register(z(this._element, X.KEY_DOWN, (o) => {
      const r = new Dt(o);
      let a = !1;
      this.enabled && (r.equals(
        3
        /* KeyCode.Enter */
      ) || r.equals(
        10
        /* KeyCode.Space */
      )) ? (this._onDidClick.fire(o), a = !0) : r.equals(
        9
        /* KeyCode.Escape */
      ) && (this._onDidEscape.fire(o), this._element.blur(), a = !0), a && Ge.stop(r, !0);
    })), this._register(z(this._element, X.MOUSE_OVER, (o) => {
      this._element.classList.contains("disabled") || this.updateBackground(!0);
    })), this._register(z(this._element, X.MOUSE_OUT, (o) => {
      this.updateBackground(!1);
    })), this.focusTracker = this._register(Vh(this._element)), this._register(this.focusTracker.onDidFocus(() => {
      this.enabled && this.updateBackground(!0);
    })), this._register(this.focusTracker.onDidBlur(() => {
      this.enabled && this.updateBackground(!1);
    }));
  }
  dispose() {
    super.dispose(), this._element.remove();
  }
  getContentElements(e) {
    const t = [];
    for (let i of lh(e))
      if (typeof i == "string") {
        if (i = i.trim(), i === "")
          continue;
        const n = document.createElement("span");
        n.textContent = i, t.push(n);
      } else
        t.push(i);
    return t;
  }
  updateBackground(e) {
    let t;
    this.options.secondary ? t = e ? this.options.buttonSecondaryHoverBackground : this.options.buttonSecondaryBackground : t = e ? this.options.buttonHoverBackground : this.options.buttonBackground, t && (this._element.style.backgroundColor = t);
  }
  get element() {
    return this._element;
  }
  set label(e) {
    var n;
    if (this._label === e || Mr(this._label) && Mr(e) && $B(this._label, e))
      return;
    this._element.classList.add("monaco-text-button");
    const t = this.options.supportShortLabel ? this._labelElement : this._element;
    if (Mr(e)) {
      const o = ow(e, { inline: !0 });
      o.dispose();
      const r = (n = o.element.querySelector("p")) == null ? void 0 : n.innerHTML;
      if (r) {
        const a = N4(r, { ADD_TAGS: ["b", "i", "u", "code", "span"], ALLOWED_ATTR: ["class"], RETURN_TRUSTED_TYPE: !0 });
        t.innerHTML = a;
      } else
        _n(t);
    } else
      this.options.supportIcons ? _n(t, ...this.getContentElements(e)) : t.textContent = e;
    let i = "";
    typeof this.options.title == "string" ? i = this.options.title : this.options.title && (i = NW(e)), this.setTitle(i), typeof this.options.ariaLabel == "string" ? this._element.setAttribute("aria-label", this.options.ariaLabel) : this.options.ariaLabel && this._element.setAttribute("aria-label", i), this._label = e;
  }
  get label() {
    return this._label;
  }
  set icon(e) {
    this._element.classList.add(...Te.asClassNameArray(e));
  }
  set enabled(e) {
    e ? (this._element.classList.remove("disabled"), this._element.setAttribute("aria-disabled", String(!1)), this._element.tabIndex = 0) : (this._element.classList.add("disabled"), this._element.setAttribute("aria-disabled", String(!0)));
  }
  get enabled() {
    return !this._element.classList.contains("disabled");
  }
  setTitle(e) {
    !this._hover && e !== "" ? this._hover = this._register(jr().setupManagedHover(this.options.hoverDelegate ?? $s("mouse"), this._element, e)) : this._hover && this._hover.update(e);
  }
}
const zA = "done", UA = "active", yy = "infinite", Sy = "infinite-long-running", $A = "discrete", xv = class xv extends U {
  constructor(e, t) {
    super(), this.progressSignal = this._register(new Hs()), this.workedVal = 0, this.showDelayedScheduler = this._register(new ai(() => oh(this.element), 0)), this.longRunningScheduler = this._register(new ai(() => this.infiniteLongRunning(), xv.LONG_RUNNING_INFINITE_THRESHOLD)), this.create(e, t);
  }
  create(e, t) {
    this.element = document.createElement("div"), this.element.classList.add("monaco-progress-container"), this.element.setAttribute("role", "progressbar"), this.element.setAttribute("aria-valuemin", "0"), e.appendChild(this.element), this.bit = document.createElement("div"), this.bit.classList.add("progress-bit"), this.bit.style.backgroundColor = (t == null ? void 0 : t.progressBarBackground) || "#0E70C0", this.element.appendChild(this.bit);
  }
  off() {
    this.bit.style.width = "inherit", this.bit.style.opacity = "1", this.element.classList.remove(UA, yy, Sy, $A), this.workedVal = 0, this.totalWork = void 0, this.longRunningScheduler.cancel(), this.progressSignal.clear();
  }
  /**
   * Stops the progressbar from showing any progress instantly without fading out.
   */
  stop() {
    return this.doDone(!1);
  }
  doDone(e) {
    return this.element.classList.add(zA), this.element.classList.contains(yy) ? (this.bit.style.opacity = "0", e ? setTimeout(() => this.off(), 200) : this.off()) : (this.bit.style.width = "inherit", e ? setTimeout(() => this.off(), 200) : this.off()), this;
  }
  /**
   * Use this mode to indicate progress that has no total number of work units.
   */
  infinite() {
    return this.bit.style.width = "2%", this.bit.style.opacity = "1", this.element.classList.remove($A, zA, Sy), this.element.classList.add(UA, yy), this.longRunningScheduler.schedule(), this;
  }
  infiniteLongRunning() {
    this.element.classList.add(Sy);
  }
  getContainer() {
    return this.element;
  }
};
xv.LONG_RUNNING_INFINITE_THRESHOLD = 1e4;
let nD = xv;
const use = he;
class fse extends U {
  constructor(e, t, i) {
    super(), this.parent = e, this.onKeyDown = (o) => Zt(this.findInput.inputBox.inputElement, X.KEY_DOWN, o), this.onDidChange = (o) => this.findInput.onDidChange(o), this.container = te(this.parent, use(".quick-input-box")), this.findInput = this._register(new jX(this.container, void 0, { label: "", inputBoxStyles: t, toggleStyles: i }));
    const n = this.findInput.inputBox.inputElement;
    n.role = "combobox", n.ariaHasPopup = "menu", n.ariaAutoComplete = "list", n.ariaExpanded = "true";
  }
  get value() {
    return this.findInput.getValue();
  }
  set value(e) {
    this.findInput.setValue(e);
  }
  select(e = null) {
    this.findInput.inputBox.select(e);
  }
  getSelection() {
    return this.findInput.inputBox.getSelection();
  }
  isSelectionAtEnd() {
    return this.findInput.inputBox.isSelectionAtEnd();
  }
  get placeholder() {
    return this.findInput.inputBox.inputElement.getAttribute("placeholder") || "";
  }
  set placeholder(e) {
    this.findInput.inputBox.setPlaceHolder(e);
  }
  get password() {
    return this.findInput.inputBox.inputElement.type === "password";
  }
  set password(e) {
    this.findInput.inputBox.inputElement.type = e ? "password" : "text";
  }
  set enabled(e) {
    this.findInput.inputBox.inputElement.toggleAttribute("readonly", !e);
  }
  set toggles(e) {
    this.findInput.setAdditionalToggles(e);
  }
  setAttribute(e, t) {
    this.findInput.inputBox.inputElement.setAttribute(e, t);
  }
  showDecoration(e) {
    e === Gt.Ignore ? this.findInput.clearMessage() : this.findInput.showMessage({ type: e === Gt.Info ? 1 : e === Gt.Warning ? 2 : 3, content: "" });
  }
  stylesForType(e) {
    return this.findInput.inputBox.stylesForType(
      e === Gt.Info ? 1 : e === Gt.Warning ? 2 : 3
      /* MessageType.ERROR */
    );
  }
  setFocus() {
    this.findInput.focus();
  }
  layout() {
    this.findInput.inputBox.layout();
  }
}
const KA = new Fr(() => {
  const s = new Intl.Collator(void 0, { numeric: !0, sensitivity: "base" });
  return {
    collator: s,
    collatorIsNumeric: s.resolvedOptions().numeric
  };
});
function gse(s, e, t = !1) {
  const i = s || "", n = e || "", o = KA.value.collator.compare(i, n);
  return KA.value.collatorIsNumeric && o === 0 && i !== n ? i < n ? -1 : 1 : o;
}
function mse(s, e, t) {
  const i = s.toLowerCase(), n = e.toLowerCase(), o = pse(s, e, t);
  if (o)
    return o;
  const r = i.endsWith(t), a = n.endsWith(t);
  if (r !== a)
    return r ? -1 : 1;
  const l = gse(i, n);
  return l !== 0 ? l : i.localeCompare(n);
}
function pse(s, e, t) {
  const i = s.toLowerCase(), n = e.toLowerCase(), o = i.startsWith(t), r = n.startsWith(t);
  if (o !== r)
    return o ? -1 : 1;
  if (o && r) {
    if (i.length < n.length)
      return -1;
    if (i.length > n.length)
      return 1;
  }
  return 0;
}
var Zw = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, sD = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, oD;
const Eo = he;
class L3 {
  constructor(e, t, i) {
    this.index = e, this.hasCheckbox = t, this._hidden = !1, this._init = new Fr(() => {
      const n = i.label ?? "", o = pg(n).text.trim(), r = i.ariaLabel || [n, this.saneDescription, this.saneDetail].map((a) => BB(a)).filter((a) => !!a).join(", ");
      return {
        saneLabel: n,
        saneSortLabel: o,
        saneAriaLabel: r
      };
    }), this._saneDescription = i.description, this._saneTooltip = i.tooltip;
  }
  // #region Lazy Getters
  get saneLabel() {
    return this._init.value.saneLabel;
  }
  get saneSortLabel() {
    return this._init.value.saneSortLabel;
  }
  get saneAriaLabel() {
    return this._init.value.saneAriaLabel;
  }
  get element() {
    return this._element;
  }
  set element(e) {
    this._element = e;
  }
  get hidden() {
    return this._hidden;
  }
  set hidden(e) {
    this._hidden = e;
  }
  get saneDescription() {
    return this._saneDescription;
  }
  set saneDescription(e) {
    this._saneDescription = e;
  }
  get saneDetail() {
    return this._saneDetail;
  }
  set saneDetail(e) {
    this._saneDetail = e;
  }
  get saneTooltip() {
    return this._saneTooltip;
  }
  set saneTooltip(e) {
    this._saneTooltip = e;
  }
  get labelHighlights() {
    return this._labelHighlights;
  }
  set labelHighlights(e) {
    this._labelHighlights = e;
  }
  get descriptionHighlights() {
    return this._descriptionHighlights;
  }
  set descriptionHighlights(e) {
    this._descriptionHighlights = e;
  }
  get detailHighlights() {
    return this._detailHighlights;
  }
  set detailHighlights(e) {
    this._detailHighlights = e;
  }
}
class Oi extends L3 {
  constructor(e, t, i, n, o, r) {
    var a, l, c;
    super(e, t, o), this.fireButtonTriggered = i, this._onChecked = n, this.item = o, this._separator = r, this._checked = !1, this.onChecked = t ? ee.map(ee.filter(this._onChecked.event, (h) => h.element === this), (h) => h.checked) : ee.None, this._saneDetail = o.detail, this._labelHighlights = (a = o.highlights) == null ? void 0 : a.label, this._descriptionHighlights = (l = o.highlights) == null ? void 0 : l.description, this._detailHighlights = (c = o.highlights) == null ? void 0 : c.detail;
  }
  get separator() {
    return this._separator;
  }
  set separator(e) {
    this._separator = e;
  }
  get checked() {
    return this._checked;
  }
  set checked(e) {
    e !== this._checked && (this._checked = e, this._onChecked.fire({ element: this, checked: e }));
  }
  get checkboxDisabled() {
    return !!this.item.disabled;
  }
}
var Sr;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.MOUSE_HOVER = 1] = "MOUSE_HOVER", s[s.ACTIVE_ITEM = 2] = "ACTIVE_ITEM";
})(Sr || (Sr = {}));
class kc extends L3 {
  constructor(e, t, i) {
    super(e, !1, i), this.fireSeparatorButtonTriggered = t, this.separator = i, this.children = new Array(), this.focusInsideSeparator = Sr.NONE;
  }
}
class _se {
  getHeight(e) {
    return e instanceof kc ? 30 : e.saneDetail ? 44 : 22;
  }
  getTemplateId(e) {
    return e instanceof Oi ? xC.ID : DC.ID;
  }
}
class bse {
  getWidgetAriaLabel() {
    return m("quickInput", "Quick Input");
  }
  getAriaLabel(e) {
    var t;
    return (t = e.separator) != null && t.label ? `${e.saneAriaLabel}, ${e.separator.label}` : e.saneAriaLabel;
  }
  getWidgetRole() {
    return "listbox";
  }
  getRole(e) {
    return e.hasCheckbox ? "checkbox" : "option";
  }
  isChecked(e) {
    if (!(!e.hasCheckbox || !(e instanceof Oi)))
      return {
        get value() {
          return e.checked;
        },
        onDidChange: (t) => e.onChecked(() => t())
      };
  }
}
class k3 {
  constructor(e) {
    this.hoverDelegate = e;
  }
  // TODO: only do the common stuff here and have a subclass handle their specific stuff
  renderTemplate(e) {
    const t = /* @__PURE__ */ Object.create(null);
    t.toDisposeElement = new ne(), t.toDisposeTemplate = new ne(), t.entry = te(e, Eo(".quick-input-list-entry"));
    const i = te(t.entry, Eo("label.quick-input-list-label"));
    t.toDisposeTemplate.add(Zt(i, X.CLICK, (c) => {
      t.checkbox.offsetParent || c.preventDefault();
    })), t.checkbox = te(i, Eo("input.quick-input-list-checkbox")), t.checkbox.type = "checkbox";
    const n = te(i, Eo(".quick-input-list-rows")), o = te(n, Eo(".quick-input-list-row")), r = te(n, Eo(".quick-input-list-row"));
    t.label = new AL(o, { supportHighlights: !0, supportDescriptionHighlights: !0, supportIcons: !0, hoverDelegate: this.hoverDelegate }), t.toDisposeTemplate.add(t.label), t.icon = NE(t.label.element, Eo(".quick-input-list-icon"));
    const a = te(o, Eo(".quick-input-list-entry-keybinding"));
    t.keybinding = new Zp(a, bs), t.toDisposeTemplate.add(t.keybinding);
    const l = te(r, Eo(".quick-input-list-label-meta"));
    return t.detail = new AL(l, { supportHighlights: !0, supportIcons: !0, hoverDelegate: this.hoverDelegate }), t.toDisposeTemplate.add(t.detail), t.separator = te(t.entry, Eo(".quick-input-list-separator")), t.actionBar = new $o(t.entry, this.hoverDelegate ? { hoverDelegate: this.hoverDelegate } : void 0), t.actionBar.domNode.classList.add("quick-input-list-entry-action-bar"), t.toDisposeTemplate.add(t.actionBar), t;
  }
  disposeTemplate(e) {
    e.toDisposeElement.dispose(), e.toDisposeTemplate.dispose();
  }
  disposeElement(e, t, i) {
    i.toDisposeElement.clear(), i.actionBar.clear();
  }
}
var Mh;
let xC = (Mh = class extends k3 {
  constructor(e, t) {
    super(e), this.themeService = t, this._itemsWithSeparatorsFrequency = /* @__PURE__ */ new Map();
  }
  get templateId() {
    return oD.ID;
  }
  renderTemplate(e) {
    const t = super.renderTemplate(e);
    return t.toDisposeTemplate.add(Zt(t.checkbox, X.CHANGE, (i) => {
      t.element.checked = t.checkbox.checked;
    })), t;
  }
  renderElement(e, t, i) {
    var u;
    const n = e.element;
    i.element = n, n.element = i.entry ?? void 0;
    const o = n.item;
    i.checkbox.checked = n.checked, i.toDisposeElement.add(n.onChecked((f) => i.checkbox.checked = f)), i.checkbox.disabled = n.checkboxDisabled;
    const { labelHighlights: r, descriptionHighlights: a, detailHighlights: l } = n;
    if (o.iconPath) {
      const f = Sw(this.themeService.getColorTheme().type) ? o.iconPath.dark : o.iconPath.light ?? o.iconPath.dark, g = we.revive(f);
      i.icon.className = "quick-input-list-icon", i.icon.style.backgroundImage = Ua(g);
    } else
      i.icon.style.backgroundImage = "", i.icon.className = o.iconClass ? `quick-input-list-icon ${o.iconClass}` : "";
    let c;
    !n.saneTooltip && n.saneDescription && (c = {
      markdown: {
        value: n.saneDescription,
        supportThemeIcons: !0
      },
      markdownNotSupportedFallback: n.saneDescription
    });
    const h = {
      matches: r || [],
      // If we have a tooltip, we want that to be shown and not any other hover
      descriptionTitle: c,
      descriptionMatches: a || [],
      labelEscapeNewLines: !0
    };
    if (h.extraClasses = o.iconClasses, h.italic = o.italic, h.strikethrough = o.strikethrough, i.entry.classList.remove("quick-input-list-separator-as-item"), i.label.setLabel(n.saneLabel, n.saneDescription, h), i.keybinding.set(o.keybinding), n.saneDetail) {
      let f;
      n.saneTooltip || (f = {
        markdown: {
          value: n.saneDetail,
          supportThemeIcons: !0
        },
        markdownNotSupportedFallback: n.saneDetail
      }), i.detail.element.style.display = "", i.detail.setLabel(n.saneDetail, void 0, {
        matches: l,
        title: f,
        labelEscapeNewLines: !0
      });
    } else
      i.detail.element.style.display = "none";
    (u = n.separator) != null && u.label ? (i.separator.textContent = n.separator.label, i.separator.style.display = "", this.addItemWithSeparator(n)) : i.separator.style.display = "none", i.entry.classList.toggle("quick-input-list-separator-border", !!n.separator);
    const d = o.buttons;
    d && d.length ? (i.actionBar.push(d.map((f, g) => nm(f, `id-${g}`, () => n.fireButtonTriggered({ button: f, item: n.item }))), { icon: !0, label: !1 }), i.entry.classList.add("has-actions")) : i.entry.classList.remove("has-actions");
  }
  disposeElement(e, t, i) {
    this.removeItemWithSeparator(e.element), super.disposeElement(e, t, i);
  }
  isItemWithSeparatorVisible(e) {
    return this._itemsWithSeparatorsFrequency.has(e);
  }
  addItemWithSeparator(e) {
    this._itemsWithSeparatorsFrequency.set(e, (this._itemsWithSeparatorsFrequency.get(e) || 0) + 1);
  }
  removeItemWithSeparator(e) {
    const t = this._itemsWithSeparatorsFrequency.get(e) || 0;
    t > 1 ? this._itemsWithSeparatorsFrequency.set(e, t - 1) : this._itemsWithSeparatorsFrequency.delete(e);
  }
}, oD = Mh, Mh.ID = "quickpickitem", Mh);
xC = oD = Zw([
  sD(1, wn)
], xC);
const Dv = class Dv extends k3 {
  constructor() {
    super(...arguments), this._visibleSeparatorsFrequency = /* @__PURE__ */ new Map();
  }
  get templateId() {
    return Dv.ID;
  }
  get visibleSeparators() {
    return [...this._visibleSeparatorsFrequency.keys()];
  }
  isSeparatorVisible(e) {
    return this._visibleSeparatorsFrequency.has(e);
  }
  renderTemplate(e) {
    const t = super.renderTemplate(e);
    return t.checkbox.style.display = "none", t;
  }
  renderElement(e, t, i) {
    const n = e.element;
    i.element = n, n.element = i.entry ?? void 0, n.element.classList.toggle("focus-inside", !!n.focusInsideSeparator);
    const o = n.separator, { labelHighlights: r, descriptionHighlights: a, detailHighlights: l } = n;
    i.icon.style.backgroundImage = "", i.icon.className = "";
    let c;
    !n.saneTooltip && n.saneDescription && (c = {
      markdown: {
        value: n.saneDescription,
        supportThemeIcons: !0
      },
      markdownNotSupportedFallback: n.saneDescription
    });
    const h = {
      matches: r || [],
      // If we have a tooltip, we want that to be shown and not any other hover
      descriptionTitle: c,
      descriptionMatches: a || [],
      labelEscapeNewLines: !0
    };
    if (i.entry.classList.add("quick-input-list-separator-as-item"), i.label.setLabel(n.saneLabel, n.saneDescription, h), n.saneDetail) {
      let u;
      n.saneTooltip || (u = {
        markdown: {
          value: n.saneDetail,
          supportThemeIcons: !0
        },
        markdownNotSupportedFallback: n.saneDetail
      }), i.detail.element.style.display = "", i.detail.setLabel(n.saneDetail, void 0, {
        matches: l,
        title: u,
        labelEscapeNewLines: !0
      });
    } else
      i.detail.element.style.display = "none";
    i.separator.style.display = "none", i.entry.classList.add("quick-input-list-separator-border");
    const d = o.buttons;
    d && d.length ? (i.actionBar.push(d.map((u, f) => nm(u, `id-${f}`, () => n.fireSeparatorButtonTriggered({ button: u, separator: n.separator }))), { icon: !0, label: !1 }), i.entry.classList.add("has-actions")) : i.entry.classList.remove("has-actions"), this.addSeparator(n);
  }
  disposeElement(e, t, i) {
    var n;
    this.removeSeparator(e.element), this.isSeparatorVisible(e.element) || (n = e.element.element) == null || n.classList.remove("focus-inside"), super.disposeElement(e, t, i);
  }
  addSeparator(e) {
    this._visibleSeparatorsFrequency.set(e, (this._visibleSeparatorsFrequency.get(e) || 0) + 1);
  }
  removeSeparator(e) {
    const t = this._visibleSeparatorsFrequency.get(e) || 0;
    t > 1 ? this._visibleSeparatorsFrequency.set(e, t - 1) : this._visibleSeparatorsFrequency.delete(e);
  }
};
Dv.ID = "quickpickseparator";
let DC = Dv, Cp = class extends U {
  constructor(e, t, i, n, o, r) {
    super(), this.parent = e, this.hoverDelegate = t, this.linkOpenerDelegate = i, this.accessibilityService = r, this._onKeyDown = new A(), this._onLeave = new A(), this.onLeave = this._onLeave.event, this._visibleCountObservable = it("VisibleCount", 0), this.onChangedVisibleCount = ee.fromObservable(this._visibleCountObservable, this._store), this._allVisibleCheckedObservable = it("AllVisibleChecked", !1), this.onChangedAllVisibleChecked = ee.fromObservable(this._allVisibleCheckedObservable, this._store), this._checkedCountObservable = it("CheckedCount", 0), this.onChangedCheckedCount = ee.fromObservable(this._checkedCountObservable, this._store), this._checkedElementsObservable = vS({ equalsFn: li }, new Array()), this.onChangedCheckedElements = ee.fromObservable(this._checkedElementsObservable, this._store), this._onButtonTriggered = new A(), this.onButtonTriggered = this._onButtonTriggered.event, this._onSeparatorButtonTriggered = new A(), this.onSeparatorButtonTriggered = this._onSeparatorButtonTriggered.event, this._elementChecked = new A(), this._elementCheckedEventBufferer = new xp(), this._hasCheckboxes = !1, this._inputElements = new Array(), this._elementTree = new Array(), this._itemElements = new Array(), this._elementDisposable = this._register(new ne()), this._matchOnDescription = !1, this._matchOnDetail = !1, this._matchOnLabel = !0, this._matchOnLabelMode = "fuzzy", this._sortByLabel = !0, this._shouldLoop = !0, this._container = te(this.parent, Eo(".quick-input-list")), this._separatorRenderer = new DC(t), this._itemRenderer = o.createInstance(xC, t), this._tree = this._register(o.createInstance(TL, "QuickInput", this._container, new _se(), [this._itemRenderer, this._separatorRenderer], {
      filter: {
        filter(a) {
          return a.hidden ? 0 : a instanceof kc ? 2 : 1;
        }
      },
      sorter: {
        compare: (a, l) => {
          if (!this.sortByLabel || !this._lastQueryString)
            return 0;
          const c = this._lastQueryString.toLowerCase();
          return vse(a, l, c);
        }
      },
      accessibilityProvider: new bse(),
      setRowLineHeight: !1,
      multipleSelectionSupport: !1,
      hideTwistiesOfChildlessElements: !0,
      renderIndentGuides: Cf.None,
      findWidgetEnabled: !1,
      indent: 0,
      horizontalScrolling: !1,
      allowNonCollapsibleParents: !0,
      alwaysConsumeMouseWheel: !0
    })), this._tree.getHTMLElement().id = n, this._registerListeners();
  }
  //#region public getters/setters
  get onDidChangeFocus() {
    return ee.map(this._tree.onDidChangeFocus, (e) => e.elements.filter((t) => t instanceof Oi).map((t) => t.item), this._store);
  }
  get onDidChangeSelection() {
    return ee.map(this._tree.onDidChangeSelection, (e) => ({
      items: e.elements.filter((t) => t instanceof Oi).map((t) => t.item),
      event: e.browserEvent
    }), this._store);
  }
  get displayed() {
    return this._container.style.display !== "none";
  }
  set displayed(e) {
    this._container.style.display = e ? "" : "none";
  }
  get scrollTop() {
    return this._tree.scrollTop;
  }
  set scrollTop(e) {
    this._tree.scrollTop = e;
  }
  get ariaLabel() {
    return this._tree.ariaLabel;
  }
  set ariaLabel(e) {
    this._tree.ariaLabel = e ?? "";
  }
  set enabled(e) {
    this._tree.getHTMLElement().style.pointerEvents = e ? "" : "none";
  }
  get matchOnDescription() {
    return this._matchOnDescription;
  }
  set matchOnDescription(e) {
    this._matchOnDescription = e;
  }
  get matchOnDetail() {
    return this._matchOnDetail;
  }
  set matchOnDetail(e) {
    this._matchOnDetail = e;
  }
  get matchOnLabel() {
    return this._matchOnLabel;
  }
  set matchOnLabel(e) {
    this._matchOnLabel = e;
  }
  get matchOnLabelMode() {
    return this._matchOnLabelMode;
  }
  set matchOnLabelMode(e) {
    this._matchOnLabelMode = e;
  }
  get sortByLabel() {
    return this._sortByLabel;
  }
  set sortByLabel(e) {
    this._sortByLabel = e;
  }
  get shouldLoop() {
    return this._shouldLoop;
  }
  set shouldLoop(e) {
    this._shouldLoop = e;
  }
  //#endregion
  //#region register listeners
  _registerListeners() {
    this._registerOnKeyDown(), this._registerOnContainerClick(), this._registerOnMouseMiddleClick(), this._registerOnTreeModelChanged(), this._registerOnElementChecked(), this._registerOnContextMenu(), this._registerHoverListeners(), this._registerSelectionChangeListener(), this._registerSeparatorActionShowingListeners();
  }
  _registerOnKeyDown() {
    this._register(this._tree.onKeyDown((e) => {
      const t = new Dt(e);
      switch (t.keyCode) {
        case 10:
          this.toggleCheckbox();
          break;
      }
      this._onKeyDown.fire(t);
    }));
  }
  _registerOnContainerClick() {
    this._register(z(this._container, X.CLICK, (e) => {
      (e.x || e.y) && this._onLeave.fire();
    }));
  }
  _registerOnMouseMiddleClick() {
    this._register(z(this._container, X.AUXCLICK, (e) => {
      e.button === 1 && this._onLeave.fire();
    }));
  }
  _registerOnTreeModelChanged() {
    this._register(this._tree.onDidChangeModel(() => {
      const e = this._itemElements.filter((t) => !t.hidden).length;
      this._visibleCountObservable.set(e, void 0), this._hasCheckboxes && this._updateCheckedObservables();
    }));
  }
  _registerOnElementChecked() {
    this._register(this._elementCheckedEventBufferer.wrapEvent(this._elementChecked.event, (e, t) => t)((e) => this._updateCheckedObservables()));
  }
  _registerOnContextMenu() {
    this._register(this._tree.onContextMenu((e) => {
      e.element && (e.browserEvent.preventDefault(), this._tree.setSelection([e.element]));
    }));
  }
  _registerHoverListeners() {
    const e = this._register(new y4(this.hoverDelegate.delay));
    this._register(this._tree.onMouseOver(async (t) => {
      var i;
      if (R2(t.browserEvent.target)) {
        e.cancel();
        return;
      }
      if (
        // anchors are an exception as called out above so we skip them here
        !(!R2(t.browserEvent.relatedTarget) && // check if the mouse is still over the same element
        _i(t.browserEvent.relatedTarget, (i = t.element) == null ? void 0 : i.element))
      )
        try {
          await e.trigger(async () => {
            t.element instanceof Oi && this.showHover(t.element);
          });
        } catch (n) {
          if (!Jh(n))
            throw n;
        }
    })), this._register(this._tree.onMouseOut((t) => {
      var i;
      _i(t.browserEvent.relatedTarget, (i = t.element) == null ? void 0 : i.element) || e.cancel();
    }));
  }
  /**
   * Register's focus change and mouse events so that we can track when items inside of a
   * separator's section are focused or hovered so that we can display the separator's actions
   */
  _registerSeparatorActionShowingListeners() {
    this._register(this._tree.onDidChangeFocus((e) => {
      const t = e.elements[0] ? this._tree.getParentElement(e.elements[0]) : null;
      for (const i of this._separatorRenderer.visibleSeparators) {
        const n = i === t;
        !!(i.focusInsideSeparator & Sr.ACTIVE_ITEM) !== n && (n ? i.focusInsideSeparator |= Sr.ACTIVE_ITEM : i.focusInsideSeparator &= ~Sr.ACTIVE_ITEM, this._tree.rerender(i));
      }
    })), this._register(this._tree.onMouseOver((e) => {
      const t = e.element ? this._tree.getParentElement(e.element) : null;
      for (const i of this._separatorRenderer.visibleSeparators) {
        if (i !== t)
          continue;
        !!(i.focusInsideSeparator & Sr.MOUSE_HOVER) || (i.focusInsideSeparator |= Sr.MOUSE_HOVER, this._tree.rerender(i));
      }
    })), this._register(this._tree.onMouseOut((e) => {
      const t = e.element ? this._tree.getParentElement(e.element) : null;
      for (const i of this._separatorRenderer.visibleSeparators) {
        if (i !== t)
          continue;
        !!(i.focusInsideSeparator & Sr.MOUSE_HOVER) && (i.focusInsideSeparator &= ~Sr.MOUSE_HOVER, this._tree.rerender(i));
      }
    }));
  }
  _registerSelectionChangeListener() {
    this._register(this._tree.onDidChangeSelection((e) => {
      const t = e.elements.filter((i) => i instanceof Oi);
      t.length !== e.elements.length && (e.elements.length === 1 && e.elements[0] instanceof kc && (this._tree.setFocus([e.elements[0].children[0]]), this._tree.reveal(e.elements[0], 0)), this._tree.setSelection(t));
    }));
  }
  //#endregion
  //#region public methods
  setAllVisibleChecked(e) {
    this._elementCheckedEventBufferer.bufferEvents(() => {
      this._itemElements.forEach((t) => {
        !t.hidden && !t.checkboxDisabled && (t.checked = e);
      });
    });
  }
  setElements(e) {
    this._elementDisposable.clear(), this._lastQueryString = void 0, this._inputElements = e, this._hasCheckboxes = this.parent.classList.contains("show-checkboxes");
    let t;
    this._itemElements = new Array(), this._elementTree = e.reduce((i, n, o) => {
      let r;
      if (n.type === "separator") {
        if (!n.buttons)
          return i;
        t = new kc(o, (a) => this._onSeparatorButtonTriggered.fire(a), n), r = t;
      } else {
        const a = o > 0 ? e[o - 1] : void 0;
        let l;
        a && a.type === "separator" && !a.buttons && (t = void 0, l = a);
        const c = new Oi(o, this._hasCheckboxes, (h) => this._onButtonTriggered.fire(h), this._elementChecked, n, l);
        if (this._itemElements.push(c), t)
          return t.children.push(c), i;
        r = c;
      }
      return i.push(r), i;
    }, new Array()), this._setElementsToTree(this._elementTree), this.accessibilityService.isScreenReaderOptimized() && setTimeout(() => {
      const i = this._tree.getHTMLElement().querySelector(".monaco-list-row.focused"), n = i == null ? void 0 : i.parentNode;
      if (i && n) {
        const o = i.nextSibling;
        i.remove(), n.insertBefore(i, o);
      }
    }, 0);
  }
  setFocusedElements(e) {
    const t = e.map((i) => this._itemElements.find((n) => n.item === i)).filter((i) => !!i).filter((i) => !i.hidden);
    if (this._tree.setFocus(t), e.length > 0) {
      const i = this._tree.getFocus()[0];
      i && this._tree.reveal(i);
    }
  }
  getActiveDescendant() {
    return this._tree.getHTMLElement().getAttribute("aria-activedescendant");
  }
  setSelectedElements(e) {
    const t = e.map((i) => this._itemElements.find((n) => n.item === i)).filter((i) => !!i);
    this._tree.setSelection(t);
  }
  getCheckedElements() {
    return this._itemElements.filter((e) => e.checked).map((e) => e.item);
  }
  setCheckedElements(e) {
    this._elementCheckedEventBufferer.bufferEvents(() => {
      const t = /* @__PURE__ */ new Set();
      for (const i of e)
        t.add(i);
      for (const i of this._itemElements)
        i.checked = t.has(i.item);
    });
  }
  focus(e) {
    var t;
    if (this._itemElements.length)
      switch (e === Ct.Second && this._itemElements.length < 2 && (e = Ct.First), e) {
        case Ct.First:
          this._tree.scrollTop = 0, this._tree.focusFirst(void 0, (i) => i.element instanceof Oi);
          break;
        case Ct.Second: {
          this._tree.scrollTop = 0;
          let i = !1;
          this._tree.focusFirst(void 0, (n) => n.element instanceof Oi ? i ? !0 : (i = !i, !1) : !1);
          break;
        }
        case Ct.Last:
          this._tree.scrollTop = this._tree.scrollHeight, this._tree.focusLast(void 0, (i) => i.element instanceof Oi);
          break;
        case Ct.Next: {
          const i = this._tree.getFocus();
          this._tree.focusNext(void 0, this._shouldLoop, void 0, (o) => o.element instanceof Oi ? (this._tree.reveal(o.element), !0) : !1);
          const n = this._tree.getFocus();
          i.length && i[0] === n[0] && i[0] === this._itemElements[this._itemElements.length - 1] && this._onLeave.fire();
          break;
        }
        case Ct.Previous: {
          const i = this._tree.getFocus();
          this._tree.focusPrevious(void 0, this._shouldLoop, void 0, (o) => {
            if (!(o.element instanceof Oi))
              return !1;
            const r = this._tree.getParentElement(o.element);
            return r === null || r.children[0] !== o.element ? this._tree.reveal(o.element) : this._tree.reveal(r), !0;
          });
          const n = this._tree.getFocus();
          i.length && i[0] === n[0] && i[0] === this._itemElements[0] && this._onLeave.fire();
          break;
        }
        case Ct.NextPage:
          this._tree.focusNextPage(void 0, (i) => i.element instanceof Oi ? (this._tree.reveal(i.element), !0) : !1);
          break;
        case Ct.PreviousPage:
          this._tree.focusPreviousPage(void 0, (i) => {
            if (!(i.element instanceof Oi))
              return !1;
            const n = this._tree.getParentElement(i.element);
            return n === null || n.children[0] !== i.element ? this._tree.reveal(i.element) : this._tree.reveal(n), !0;
          });
          break;
        case Ct.NextSeparator: {
          let i = !1;
          const n = this._tree.getFocus()[0];
          this._tree.focusNext(void 0, !0, void 0, (r) => {
            if (i)
              return !0;
            if (r.element instanceof kc)
              i = !0, this._separatorRenderer.isSeparatorVisible(r.element) ? this._tree.reveal(r.element.children[0]) : this._tree.reveal(r.element, 0);
            else if (r.element instanceof Oi) {
              if (r.element.separator)
                return this._itemRenderer.isItemWithSeparatorVisible(r.element) ? this._tree.reveal(r.element) : this._tree.reveal(r.element, 0), !0;
              if (r.element === this._elementTree[0])
                return this._tree.reveal(r.element, 0), !0;
            }
            return !1;
          });
          const o = this._tree.getFocus()[0];
          n === o && (this._tree.scrollTop = this._tree.scrollHeight, this._tree.focusLast(void 0, (r) => r.element instanceof Oi));
          break;
        }
        case Ct.PreviousSeparator: {
          let i, n = !!((t = this._tree.getFocus()[0]) != null && t.separator);
          this._tree.focusPrevious(void 0, !0, void 0, (o) => {
            if (o.element instanceof kc)
              n ? i || (this._separatorRenderer.isSeparatorVisible(o.element) ? this._tree.reveal(o.element) : this._tree.reveal(o.element, 0), i = o.element.children[0]) : n = !0;
            else if (o.element instanceof Oi && !i) {
              if (o.element.separator)
                this._itemRenderer.isItemWithSeparatorVisible(o.element) ? this._tree.reveal(o.element) : this._tree.reveal(o.element, 0), i = o.element;
              else if (o.element === this._elementTree[0])
                return this._tree.reveal(o.element, 0), !0;
            }
            return !1;
          }), i && this._tree.setFocus([i]);
          break;
        }
      }
  }
  clearFocus() {
    this._tree.setFocus([]);
  }
  domFocus() {
    this._tree.domFocus();
  }
  layout(e) {
    this._tree.getHTMLElement().style.maxHeight = e ? `${// Make sure height aligns with list item heights
    Math.floor(e / 44) * 44 + 6}px` : "", this._tree.layout();
  }
  filter(e) {
    if (this._lastQueryString = e, !(this._sortByLabel || this._matchOnLabel || this._matchOnDescription || this._matchOnDetail))
      return this._tree.layout(), !1;
    const t = e;
    if (e = e.trim(), !e || !(this.matchOnLabel || this.matchOnDescription || this.matchOnDetail))
      this._itemElements.forEach((i) => {
        i.labelHighlights = void 0, i.descriptionHighlights = void 0, i.detailHighlights = void 0, i.hidden = !1;
        const n = i.index && this._inputElements[i.index - 1];
        i.item && (i.separator = n && n.type === "separator" && !n.buttons ? n : void 0);
      });
    else {
      let i;
      this._itemElements.forEach((n) => {
        let o;
        this.matchOnLabelMode === "fuzzy" ? o = this.matchOnLabel ? v0(e, pg(n.saneLabel)) ?? void 0 : void 0 : o = this.matchOnLabel ? Cse(t, pg(n.saneLabel)) ?? void 0 : void 0;
        const r = this.matchOnDescription ? v0(e, pg(n.saneDescription || "")) ?? void 0 : void 0, a = this.matchOnDetail ? v0(e, pg(n.saneDetail || "")) ?? void 0 : void 0;
        if (o || r || a ? (n.labelHighlights = o, n.descriptionHighlights = r, n.detailHighlights = a, n.hidden = !1) : (n.labelHighlights = void 0, n.descriptionHighlights = void 0, n.detailHighlights = void 0, n.hidden = n.item ? !n.item.alwaysShow : !0), n.item ? n.separator = void 0 : n.separator && (n.hidden = !0), !this.sortByLabel) {
          const l = n.index && this._inputElements[n.index - 1] || void 0;
          (l == null ? void 0 : l.type) === "separator" && !l.buttons && (i = l), i && !n.hidden && (n.separator = i, i = void 0);
        }
      });
    }
    return this._setElementsToTree(this._sortByLabel && e ? this._itemElements : this._elementTree), this._tree.layout(), !0;
  }
  toggleCheckbox() {
    this._elementCheckedEventBufferer.bufferEvents(() => {
      const e = this._tree.getFocus().filter((i) => i instanceof Oi), t = this._allVisibleChecked(e);
      for (const i of e)
        i.checkboxDisabled || (i.checked = !t);
    });
  }
  style(e) {
    this._tree.style(e);
  }
  toggleHover() {
    const e = this._tree.getFocus()[0];
    if (!(e != null && e.saneTooltip) || !(e instanceof Oi))
      return;
    if (this._lastHover && !this._lastHover.isDisposed) {
      this._lastHover.dispose();
      return;
    }
    this.showHover(e);
    const t = new ne();
    t.add(this._tree.onDidChangeFocus((i) => {
      i.elements[0] instanceof Oi && this.showHover(i.elements[0]);
    })), this._lastHover && t.add(this._lastHover), this._elementDisposable.add(t);
  }
  //#endregion
  //#region private methods
  _setElementsToTree(e) {
    const t = new Array();
    for (const i of e)
      i instanceof kc ? t.push({
        element: i,
        collapsible: !1,
        collapsed: !1,
        children: i.children.map((n) => ({
          element: n,
          collapsible: !1,
          collapsed: !1
        }))
      }) : t.push({
        element: i,
        collapsible: !1,
        collapsed: !1
      });
    this._tree.setChildren(null, t);
  }
  _allVisibleChecked(e, t = !0) {
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      if (!o.hidden)
        if (o.checked)
          t = !0;
        else
          return !1;
    }
    return t;
  }
  _updateCheckedObservables() {
    bi((e) => {
      this._allVisibleCheckedObservable.set(this._allVisibleChecked(this._itemElements, !1), e);
      const t = this._itemElements.filter((i) => i.checked).length;
      this._checkedCountObservable.set(t, e), this._checkedElementsObservable.set(this.getCheckedElements(), e);
    });
  }
  /**
   * Disposes of the hover and shows a new one for the given index if it has a tooltip.
   * @param element The element to show the hover for
   */
  showHover(e) {
    var t, i, n;
    this._lastHover && !this._lastHover.isDisposed && ((i = (t = this.hoverDelegate).onDidHideHover) == null || i.call(t), (n = this._lastHover) == null || n.dispose()), !(!e.element || !e.saneTooltip) && (this._lastHover = this.hoverDelegate.showHover({
      content: e.saneTooltip,
      target: e.element,
      linkHandler: (o) => {
        this.linkOpenerDelegate(o);
      },
      appearance: {
        showPointer: !0
      },
      container: this._container,
      position: {
        hoverPosition: 1
        /* HoverPosition.RIGHT */
      }
    }, !1));
  }
};
Zw([
  Yt
], Cp.prototype, "onDidChangeFocus", null);
Zw([
  Yt
], Cp.prototype, "onDidChangeSelection", null);
Cp = Zw([
  sD(4, Pe),
  sD(5, Ks)
], Cp);
function Cse(s, e) {
  const { text: t, iconOffsets: i } = e;
  if (!i || i.length === 0)
    return jA(s, t);
  const n = Hv(t, " "), o = t.length - n.length, r = jA(s, n);
  if (r)
    for (const a of r) {
      const l = i[a.start + o] + o;
      a.start += l, a.end += l;
    }
  return r;
}
function jA(s, e) {
  const t = e.toLowerCase().indexOf(s.toLowerCase());
  return t !== -1 ? [{ start: t, end: t + s.length }] : null;
}
function vse(s, e, t) {
  const i = s.labelHighlights || [], n = e.labelHighlights || [];
  return i.length && !n.length ? -1 : !i.length && n.length ? 1 : i.length === 0 && n.length === 0 ? 0 : mse(s.saneSortLabel, e.saneSortLabel, t);
}
const x3 = {
  weight: 200,
  when: ve.and(ve.equals(
    y3,
    "quickPick"
    /* QuickInputType.QuickPick */
  ), ase),
  metadata: { description: m("quickPick", "Used while in the context of the quick pick. If you change one keybinding for this command, you should change all of the other keybindings (modifier variants) of this command as well.") }
};
function Kn(s, e = {}) {
  ts.registerCommandAndKeybindingRule({
    ...x3,
    ...s,
    secondary: wse(s.primary, s.secondary ?? [], e)
  });
}
const EC = $e ? 256 : 2048;
function wse(s, e, t = {}) {
  return t.withAltMod && e.push(512 + s), t.withCtrlMod && (e.push(EC + s), t.withAltMod && e.push(512 + EC + s)), t.withCmdMod && $e && (e.push(2048 + s), t.withCtrlMod && e.push(2304 + s), t.withAltMod && (e.push(2560 + s), t.withCtrlMod && e.push(2816 + s))), e;
}
function fs(s, e) {
  return (t) => {
    const i = t.get(Gw).currentQuickInput;
    if (i)
      return e && i.quickNavigate ? i.focus(e) : i.focus(s);
  };
}
Kn({ id: "quickInput.pageNext", primary: 12, handler: fs(Ct.NextPage) }, { withAltMod: !0, withCtrlMod: !0, withCmdMod: !0 });
Kn({ id: "quickInput.pagePrevious", primary: 11, handler: fs(Ct.PreviousPage) }, { withAltMod: !0, withCtrlMod: !0, withCmdMod: !0 });
Kn({ id: "quickInput.first", primary: EC + 14, handler: fs(Ct.First) }, { withAltMod: !0, withCmdMod: !0 });
Kn({ id: "quickInput.last", primary: EC + 13, handler: fs(Ct.Last) }, { withAltMod: !0, withCmdMod: !0 });
Kn({ id: "quickInput.next", primary: 18, handler: fs(Ct.Next) }, { withCtrlMod: !0 });
Kn({ id: "quickInput.previous", primary: 16, handler: fs(Ct.Previous) }, { withCtrlMod: !0 });
const qA = m("quickInput.nextSeparatorWithQuickAccessFallback", "If we're in quick access mode, this will navigate to the next item. If we are not in quick access mode, this will navigate to the next separator."), GA = m("quickInput.previousSeparatorWithQuickAccessFallback", "If we're in quick access mode, this will navigate to the previous item. If we are not in quick access mode, this will navigate to the previous separator.");
$e ? (Kn({
  id: "quickInput.nextSeparatorWithQuickAccessFallback",
  primary: 2066,
  handler: fs(Ct.NextSeparator, Ct.Next),
  metadata: { description: qA }
}), Kn({
  id: "quickInput.nextSeparator",
  primary: 2578,
  // Since macOS has the cmd key as the primary modifier, we need to add this additional
  // keybinding to capture cmd+ctrl+upArrow
  secondary: [
    2322
    /* KeyCode.DownArrow */
  ],
  handler: fs(Ct.NextSeparator)
}, { withCtrlMod: !0 }), Kn({
  id: "quickInput.previousSeparatorWithQuickAccessFallback",
  primary: 2064,
  handler: fs(Ct.PreviousSeparator, Ct.Previous),
  metadata: { description: GA }
}), Kn({
  id: "quickInput.previousSeparator",
  primary: 2576,
  // Since macOS has the cmd key as the primary modifier, we need to add this additional
  // keybinding to capture cmd+ctrl+upArrow
  secondary: [
    2320
    /* KeyCode.UpArrow */
  ],
  handler: fs(Ct.PreviousSeparator)
}, { withCtrlMod: !0 })) : (Kn({
  id: "quickInput.nextSeparatorWithQuickAccessFallback",
  primary: 530,
  handler: fs(Ct.NextSeparator, Ct.Next),
  metadata: { description: qA }
}), Kn({
  id: "quickInput.nextSeparator",
  primary: 2578,
  handler: fs(Ct.NextSeparator)
}), Kn({
  id: "quickInput.previousSeparatorWithQuickAccessFallback",
  primary: 528,
  handler: fs(Ct.PreviousSeparator, Ct.Previous),
  metadata: { description: GA }
}), Kn({
  id: "quickInput.previousSeparator",
  primary: 2576,
  handler: fs(Ct.PreviousSeparator)
}));
Kn({
  id: "quickInput.acceptInBackground",
  // If we are in the quick pick but the input box is not focused or our cursor is at the end of the input box
  when: ve.and(x3.when, ve.or(ZF.negate(), hse)),
  primary: 17,
  // Need a little extra weight to ensure this keybinding is preferred over the default cmd+alt+right arrow keybinding
  // https://github.com/microsoft/vscode/blob/1451e4fbbbf074a4355cc537c35b547b80ce1c52/src/vs/workbench/browser/parts/editor/editorActions.ts#L1178-L1195
  weight: 250,
  handler: (s) => {
    const e = s.get(Gw).currentQuickInput;
    e == null || e.accept(!0);
  }
}, { withAltMod: !0, withCtrlMod: !0, withCmdMod: !0 });
var yse = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Ly = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, rD;
const Un = he;
var Rh;
let aD = (Rh = class extends U {
  // Max total width of quick input widget
  get currentQuickInput() {
    return this.controller ?? void 0;
  }
  get container() {
    return this._container;
  }
  constructor(e, t, i, n) {
    super(), this.options = e, this.layoutService = t, this.instantiationService = i, this.contextKeyService = n, this.enabled = !0, this.onDidAcceptEmitter = this._register(new A()), this.onDidCustomEmitter = this._register(new A()), this.onDidTriggerButtonEmitter = this._register(new A()), this.keyMods = { ctrlCmd: !1, alt: !1 }, this.controller = null, this.onShowEmitter = this._register(new A()), this.onShow = this.onShowEmitter.event, this.onHideEmitter = this._register(new A()), this.onHide = this.onHideEmitter.event, this.inQuickInputContext = rse.bindTo(this.contextKeyService), this.quickInputTypeContext = lse.bindTo(this.contextKeyService), this.endOfQuickInputBoxContext = cse.bindTo(this.contextKeyService), this.idPrefix = e.idPrefix, this._container = e.container, this.styles = e.styles, this._register(ee.runAndSubscribe(Qv, ({ window: o, disposables: r }) => this.registerKeyModsListeners(o, r), { window: pt, disposables: this._store })), this._register(H6((o) => {
      this.ui && fe(this.ui.container) === o && (this.reparentUI(this.layoutService.mainContainer), this.layout(this.layoutService.mainContainerDimension, this.layoutService.mainContainerOffset.quickPickTop));
    }));
  }
  registerKeyModsListeners(e, t) {
    const i = (n) => {
      this.keyMods.ctrlCmd = n.ctrlKey || n.metaKey, this.keyMods.alt = n.altKey;
    };
    for (const n of [X.KEY_DOWN, X.KEY_UP, X.MOUSE_DOWN])
      t.add(z(e, n, i, !0));
  }
  getUI(e) {
    if (this.ui)
      return e && fe(this._container) !== fe(this.layoutService.activeContainer) && (this.reparentUI(this.layoutService.activeContainer), this.layout(this.layoutService.activeContainerDimension, this.layoutService.activeContainerOffset.quickPickTop)), this.ui;
    const t = te(this._container, Un(".quick-input-widget.show-file-icons"));
    t.tabIndex = -1, t.style.display = "none";
    const i = Us(t), n = te(t, Un(".quick-input-titlebar")), o = this._register(new $o(n, { hoverDelegate: this.options.hoverDelegate }));
    o.domNode.classList.add("quick-input-left-action-bar");
    const r = te(n, Un(".quick-input-title")), a = this._register(new $o(n, { hoverDelegate: this.options.hoverDelegate }));
    a.domNode.classList.add("quick-input-right-action-bar");
    const l = te(t, Un(".quick-input-header")), c = te(l, Un("input.quick-input-check-all"));
    c.type = "checkbox", c.setAttribute("aria-label", m("quickInput.checkAll", "Toggle all checkboxes")), this._register(Zt(c, X.CHANGE, (P) => {
      const q = c.checked;
      W.setAllVisibleChecked(q);
    })), this._register(z(c, X.CLICK, (P) => {
      (P.x || P.y) && f.setFocus();
    }));
    const h = te(l, Un(".quick-input-description")), d = te(l, Un(".quick-input-and-message")), u = te(d, Un(".quick-input-filter")), f = this._register(new fse(u, this.styles.inputBox, this.styles.toggle));
    f.setAttribute("aria-describedby", `${this.idPrefix}message`);
    const g = te(u, Un(".quick-input-visible-count"));
    g.setAttribute("aria-live", "polite"), g.setAttribute("aria-atomic", "true");
    const p = new RL(g, { countFormat: m({ key: "quickInput.visibleCount", comment: ["This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers."] }, "{0} Results") }, this.styles.countBadge), _ = te(u, Un(".quick-input-count"));
    _.setAttribute("aria-live", "polite");
    const b = new RL(_, { countFormat: m({ key: "quickInput.countSelected", comment: ["This tells the user how many items are selected in a list of items to select from. The items can be anything."] }, "{0} Selected") }, this.styles.countBadge), C = this._register(new $o(l, { hoverDelegate: this.options.hoverDelegate }));
    C.domNode.classList.add("quick-input-inline-action-bar");
    const w = te(l, Un(".quick-input-action")), v = this._register(new iD(w, this.styles.button));
    v.label = m("ok", "OK"), this._register(v.onDidClick((P) => {
      this.onDidAcceptEmitter.fire();
    }));
    const S = te(l, Un(".quick-input-action")), L = this._register(new iD(S, { ...this.styles.button, supportIcons: !0 }));
    L.label = m("custom", "Custom"), this._register(L.onDidClick((P) => {
      this.onDidCustomEmitter.fire();
    }));
    const k = te(d, Un(`#${this.idPrefix}message.quick-input-message`)), x = this._register(new nD(t, this.styles.progressBar));
    x.getContainer().classList.add("quick-input-progress");
    const I = te(t, Un(".quick-input-html-widget"));
    I.tabIndex = -1;
    const K = te(t, Un(".quick-input-description")), B = this.idPrefix + "list", W = this._register(this.instantiationService.createInstance(Cp, t, this.options.hoverDelegate, this.options.linkOpenerDelegate, B));
    f.setAttribute("aria-controls", B), this._register(W.onDidChangeFocus(() => {
      f.setAttribute("aria-activedescendant", W.getActiveDescendant() ?? "");
    })), this._register(W.onChangedAllVisibleChecked((P) => {
      c.checked = P;
    })), this._register(W.onChangedVisibleCount((P) => {
      p.setCount(P);
    })), this._register(W.onChangedCheckedCount((P) => {
      b.setCount(P);
    })), this._register(W.onLeave(() => {
      setTimeout(() => {
        this.controller && (f.setFocus(), this.controller instanceof kC && this.controller.canSelectMany && W.clearFocus());
      }, 0);
    }));
    const H = Vh(t);
    return this._register(H), this._register(z(t, X.FOCUS, (P) => {
      const q = this.getUI();
      if (_i(P.relatedTarget, q.inputContainer)) {
        const J = q.inputBox.isSelectionAtEnd();
        this.endOfQuickInputBoxContext.get() !== J && this.endOfQuickInputBoxContext.set(J);
      }
      _i(P.relatedTarget, q.container) || (this.inQuickInputContext.set(!0), this.previousFocusElement = ki(P.relatedTarget) ? P.relatedTarget : void 0);
    }, !0)), this._register(H.onDidBlur(() => {
      !this.getUI().ignoreFocusOut && !this.options.ignoreFocusOut() && this.hide(Lf.Blur), this.inQuickInputContext.set(!1), this.endOfQuickInputBoxContext.set(!1), this.previousFocusElement = void 0;
    })), this._register(f.onKeyDown((P) => {
      const q = this.getUI().inputBox.isSelectionAtEnd();
      this.endOfQuickInputBoxContext.get() !== q && this.endOfQuickInputBoxContext.set(q);
    })), this._register(z(t, X.FOCUS, (P) => {
      f.setFocus();
    })), this._register(Zt(t, X.KEY_DOWN, (P) => {
      if (!_i(P.target, I))
        switch (P.keyCode) {
          case 3:
            Ge.stop(P, !0), this.enabled && this.onDidAcceptEmitter.fire();
            break;
          case 9:
            Ge.stop(P, !0), this.hide(Lf.Gesture);
            break;
          case 2:
            if (!P.altKey && !P.ctrlKey && !P.metaKey) {
              const q = [
                ".quick-input-list .monaco-action-bar .always-visible",
                ".quick-input-list-entry:hover .monaco-action-bar",
                ".monaco-list-row.focused .monaco-action-bar"
              ];
              if (t.classList.contains("show-checkboxes") ? q.push("input") : q.push("input[type=text]"), this.getUI().list.displayed && q.push(".monaco-list"), this.getUI().message && q.push(".quick-input-message a"), this.getUI().widget) {
                if (_i(P.target, this.getUI().widget))
                  break;
                q.push(".quick-input-html-widget");
              }
              const J = t.querySelectorAll(q.join(", "));
              P.shiftKey && P.target === J[0] ? (Ge.stop(P, !0), W.clearFocus()) : !P.shiftKey && _i(P.target, J[J.length - 1]) && (Ge.stop(P, !0), J[0].focus());
            }
            break;
          case 10:
            P.ctrlKey && (Ge.stop(P, !0), this.getUI().list.toggleHover());
            break;
        }
    })), this.ui = {
      container: t,
      styleSheet: i,
      leftActionBar: o,
      titleBar: n,
      title: r,
      description1: K,
      description2: h,
      widget: I,
      rightActionBar: a,
      inlineActionBar: C,
      checkAll: c,
      inputContainer: d,
      filterContainer: u,
      inputBox: f,
      visibleCountContainer: g,
      visibleCount: p,
      countContainer: _,
      count: b,
      okContainer: w,
      ok: v,
      message: k,
      customButtonContainer: S,
      customButton: L,
      list: W,
      progressBar: x,
      onDidAccept: this.onDidAcceptEmitter.event,
      onDidCustom: this.onDidCustomEmitter.event,
      onDidTriggerButton: this.onDidTriggerButtonEmitter.event,
      ignoreFocusOut: !1,
      keyMods: this.keyMods,
      show: (P) => this.show(P),
      hide: () => this.hide(),
      setVisibilities: (P) => this.setVisibilities(P),
      setEnabled: (P) => this.setEnabled(P),
      setContextKey: (P) => this.options.setContextKey(P),
      linkOpenerDelegate: (P) => this.options.linkOpenerDelegate(P)
    }, this.updateStyles(), this.ui;
  }
  reparentUI(e) {
    this.ui && (this._container = e, te(this._container, this.ui.container));
  }
  pick(e, t = {}, i = _t.None) {
    return new Promise((n, o) => {
      let r = (h) => {
        var d;
        r = n, (d = t.onKeyMods) == null || d.call(t, a.keyMods), n(h);
      };
      if (i.isCancellationRequested) {
        r(void 0);
        return;
      }
      const a = this.createQuickPick({ useSeparators: !0 });
      let l;
      const c = [
        a,
        a.onDidAccept(() => {
          if (a.canSelectMany)
            r(a.selectedItems.slice()), a.hide();
          else {
            const h = a.activeItems[0];
            h && (r(h), a.hide());
          }
        }),
        a.onDidChangeActive((h) => {
          const d = h[0];
          d && t.onDidFocus && t.onDidFocus(d);
        }),
        a.onDidChangeSelection((h) => {
          if (!a.canSelectMany) {
            const d = h[0];
            d && (r(d), a.hide());
          }
        }),
        a.onDidTriggerItemButton((h) => t.onDidTriggerItemButton && t.onDidTriggerItemButton({
          ...h,
          removeItem: () => {
            const d = a.items.indexOf(h.item);
            if (d !== -1) {
              const u = a.items.slice(), f = u.splice(d, 1), g = a.activeItems.filter((_) => _ !== f[0]), p = a.keepScrollPosition;
              a.keepScrollPosition = !0, a.items = u, g && (a.activeItems = g), a.keepScrollPosition = p;
            }
          }
        })),
        a.onDidTriggerSeparatorButton((h) => {
          var d;
          return (d = t.onDidTriggerSeparatorButton) == null ? void 0 : d.call(t, h);
        }),
        a.onDidChangeValue((h) => {
          l && !h && (a.activeItems.length !== 1 || a.activeItems[0] !== l) && (a.activeItems = [l]);
        }),
        i.onCancellationRequested(() => {
          a.hide();
        }),
        a.onDidHide(() => {
          Ft(c), r(void 0);
        })
      ];
      a.title = t.title, t.value && (a.value = t.value), a.canSelectMany = !!t.canPickMany, a.placeholder = t.placeHolder, a.ignoreFocusOut = !!t.ignoreFocusLost, a.matchOnDescription = !!t.matchOnDescription, a.matchOnDetail = !!t.matchOnDetail, a.matchOnLabel = t.matchOnLabel === void 0 || t.matchOnLabel, a.quickNavigate = t.quickNavigate, a.hideInput = !!t.hideInput, a.contextKey = t.contextKey, a.busy = !0, Promise.all([e, t.activeItem]).then(([h, d]) => {
        l = d, a.busy = !1, a.items = h, a.canSelectMany && (a.selectedItems = h.filter((u) => u.type !== "separator" && u.picked)), l && (a.activeItems = [l]);
      }), a.show(), Promise.resolve(e).then(void 0, (h) => {
        o(h), a.hide();
      });
    });
  }
  createQuickPick(e = { useSeparators: !1 }) {
    const t = this.getUI(!0);
    return new kC(t);
  }
  createInputBox() {
    const e = this.getUI(!0);
    return new dse(e);
  }
  show(e) {
    const t = this.getUI(!0);
    this.onShowEmitter.fire();
    const i = this.controller;
    this.controller = e, i == null || i.didHide(), this.setEnabled(!0), t.leftActionBar.clear(), t.title.textContent = "", t.description1.textContent = "", t.description2.textContent = "", _n(t.widget), t.rightActionBar.clear(), t.inlineActionBar.clear(), t.checkAll.checked = !1, t.inputBox.placeholder = "", t.inputBox.password = !1, t.inputBox.showDecoration(Gt.Ignore), t.visibleCount.setCount(0), t.count.setCount(0), _n(t.message), t.progressBar.stop(), t.list.setElements([]), t.list.matchOnDescription = !1, t.list.matchOnDetail = !1, t.list.matchOnLabel = !0, t.list.sortByLabel = !0, t.ignoreFocusOut = !1, t.inputBox.toggles = void 0;
    const n = this.options.backKeybindingLabel();
    eD.tooltip = n ? m("quickInput.backWithKeybinding", "Back ({0})", n) : m("quickInput.back", "Back"), t.container.style.display = "", this.updateLayout(), t.inputBox.setFocus(), this.quickInputTypeContext.set(e.type);
  }
  isVisible() {
    return !!this.ui && this.ui.container.style.display !== "none";
  }
  setVisibilities(e) {
    const t = this.getUI();
    t.title.style.display = e.title ? "" : "none", t.description1.style.display = e.description && (e.inputBox || e.checkAll) ? "" : "none", t.description2.style.display = e.description && !(e.inputBox || e.checkAll) ? "" : "none", t.checkAll.style.display = e.checkAll ? "" : "none", t.inputContainer.style.display = e.inputBox ? "" : "none", t.filterContainer.style.display = e.inputBox ? "" : "none", t.visibleCountContainer.style.display = e.visibleCount ? "" : "none", t.countContainer.style.display = e.count ? "" : "none", t.okContainer.style.display = e.ok ? "" : "none", t.customButtonContainer.style.display = e.customButton ? "" : "none", t.message.style.display = e.message ? "" : "none", t.progressBar.getContainer().style.display = e.progressBar ? "" : "none", t.list.displayed = !!e.list, t.container.classList.toggle("show-checkboxes", !!e.checkBox), t.container.classList.toggle("hidden-input", !e.inputBox && !e.description), this.updateLayout();
  }
  setEnabled(e) {
    if (e !== this.enabled) {
      this.enabled = e;
      for (const t of this.getUI().leftActionBar.viewItems)
        t.action.enabled = e;
      for (const t of this.getUI().rightActionBar.viewItems)
        t.action.enabled = e;
      this.getUI().checkAll.disabled = !e, this.getUI().inputBox.enabled = e, this.getUI().ok.enabled = e, this.getUI().list.enabled = e;
    }
  }
  hide(e) {
    var o;
    const t = this.controller;
    if (!t)
      return;
    t.willHide(e);
    const i = (o = this.ui) == null ? void 0 : o.container, n = i && !H4(i);
    if (this.controller = null, this.onHideEmitter.fire(), i && (i.style.display = "none"), !n) {
      let r = this.previousFocusElement;
      for (; r && !r.offsetParent; )
        r = r.parentElement ?? void 0;
      r != null && r.offsetParent ? (r.focus(), this.previousFocusElement = void 0) : this.options.returnFocus();
    }
    t.didHide(e);
  }
  layout(e, t) {
    this.dimension = e, this.titleBarOffset = t, this.updateLayout();
  }
  updateLayout() {
    if (this.ui && this.isVisible()) {
      this.ui.container.style.top = `${this.titleBarOffset}px`;
      const e = this.ui.container.style, t = Math.min(this.dimension.width * 0.62, rD.MAX_WIDTH);
      e.width = t + "px", e.marginLeft = "-" + t / 2 + "px", this.ui.inputBox.layout(), this.ui.list.layout(this.dimension && this.dimension.height * 0.4);
    }
  }
  applyStyles(e) {
    this.styles = e, this.updateStyles();
  }
  updateStyles() {
    if (this.ui) {
      const { quickInputTitleBackground: e, quickInputBackground: t, quickInputForeground: i, widgetBorder: n, widgetShadow: o } = this.styles.widget;
      this.ui.titleBar.style.backgroundColor = e ?? "", this.ui.container.style.backgroundColor = t ?? "", this.ui.container.style.color = i ?? "", this.ui.container.style.border = n ? `1px solid ${n}` : "", this.ui.container.style.boxShadow = o ? `0 0 8px 2px ${o}` : "", this.ui.list.style(this.styles.list);
      const r = [];
      this.styles.pickerGroup.pickerGroupBorder && r.push(`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.styles.pickerGroup.pickerGroupBorder}; }`), this.styles.pickerGroup.pickerGroupForeground && r.push(`.quick-input-list .quick-input-list-separator { color:  ${this.styles.pickerGroup.pickerGroupForeground}; }`), this.styles.pickerGroup.pickerGroupForeground && r.push(".quick-input-list .quick-input-list-separator-as-item { color: var(--vscode-descriptionForeground); }"), (this.styles.keybindingLabel.keybindingLabelBackground || this.styles.keybindingLabel.keybindingLabelBorder || this.styles.keybindingLabel.keybindingLabelBottomBorder || this.styles.keybindingLabel.keybindingLabelShadow || this.styles.keybindingLabel.keybindingLabelForeground) && (r.push(".quick-input-list .monaco-keybinding > .monaco-keybinding-key {"), this.styles.keybindingLabel.keybindingLabelBackground && r.push(`background-color: ${this.styles.keybindingLabel.keybindingLabelBackground};`), this.styles.keybindingLabel.keybindingLabelBorder && r.push(`border-color: ${this.styles.keybindingLabel.keybindingLabelBorder};`), this.styles.keybindingLabel.keybindingLabelBottomBorder && r.push(`border-bottom-color: ${this.styles.keybindingLabel.keybindingLabelBottomBorder};`), this.styles.keybindingLabel.keybindingLabelShadow && r.push(`box-shadow: inset 0 -1px 0 ${this.styles.keybindingLabel.keybindingLabelShadow};`), this.styles.keybindingLabel.keybindingLabelForeground && r.push(`color: ${this.styles.keybindingLabel.keybindingLabelForeground};`), r.push("}"));
      const a = r.join(`
`);
      a !== this.ui.styleSheet.textContent && (this.ui.styleSheet.textContent = a);
    }
  }
}, rD = Rh, Rh.MAX_WIDTH = 600, Rh);
aD = rD = yse([
  Ly(1, oc),
  Ly(2, Pe),
  Ly(3, Fe)
], aD);
var Sse = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, ug = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let lD = class extends Q$ {
  get controller() {
    return this._controller || (this._controller = this._register(this.createController())), this._controller;
  }
  get hasController() {
    return !!this._controller;
  }
  get currentQuickInput() {
    return this.controller.currentQuickInput;
  }
  get quickAccess() {
    return this._quickAccess || (this._quickAccess = this._register(this.instantiationService.createInstance(Jx))), this._quickAccess;
  }
  constructor(e, t, i, n, o) {
    super(i), this.instantiationService = e, this.contextKeyService = t, this.layoutService = n, this.configurationService = o, this._onShow = this._register(new A()), this._onHide = this._register(new A()), this.contexts = /* @__PURE__ */ new Map();
  }
  createController(e = this.layoutService, t) {
    const i = {
      idPrefix: "quickInput_",
      container: e.activeContainer,
      ignoreFocusOut: () => !1,
      backKeybindingLabel: () => {
      },
      setContextKey: (o) => this.setContextKey(o),
      linkOpenerDelegate: (o) => {
        this.instantiationService.invokeFunction((r) => {
          r.get(sr).open(o, { allowCommands: !0, fromUserGesture: !0 });
        });
      },
      returnFocus: () => e.focus(),
      styles: this.computeStyles(),
      hoverDelegate: this._register(this.instantiationService.createInstance(tD))
    }, n = this._register(this.instantiationService.createInstance(aD, {
      ...i,
      ...t
    }));
    return n.layout(e.activeContainerDimension, e.activeContainerOffset.quickPickTop), this._register(e.onDidLayoutActiveContainer((o) => {
      fe(e.activeContainer) === fe(n.container) && n.layout(o, e.activeContainerOffset.quickPickTop);
    })), this._register(e.onDidChangeActiveContainer(() => {
      n.isVisible() || n.layout(e.activeContainerDimension, e.activeContainerOffset.quickPickTop);
    })), this._register(n.onShow(() => {
      this.resetContextKeys(), this._onShow.fire();
    })), this._register(n.onHide(() => {
      this.resetContextKeys(), this._onHide.fire();
    })), n;
  }
  setContextKey(e) {
    let t;
    e && (t = this.contexts.get(e), t || (t = new ce(e, !1).bindTo(this.contextKeyService), this.contexts.set(e, t))), !(t && t.get()) && (this.resetContextKeys(), t == null || t.set(!0));
  }
  resetContextKeys() {
    this.contexts.forEach((e) => {
      e.get() && e.reset();
    });
  }
  pick(e, t, i = _t.None) {
    return this.controller.pick(e, t, i);
  }
  createQuickPick(e = { useSeparators: !1 }) {
    return this.controller.createQuickPick(e);
  }
  createInputBox() {
    return this.controller.createInputBox();
  }
  updateStyles() {
    this.hasController && this.controller.applyStyles(this.computeStyles());
  }
  computeStyles() {
    return {
      widget: {
        quickInputBackground: se(yT),
        quickInputForeground: se(o$),
        quickInputTitleBackground: se(r$),
        widgetBorder: se(Uz),
        widgetShadow: se(Op)
      },
      inputBox: DF,
      toggle: xF,
      countBadge: EF,
      button: mX,
      progressBar: pX,
      keybindingLabel: gX,
      list: Up({
        listBackground: yT,
        listFocusBackground: PS,
        listFocusForeground: AS,
        // Look like focused when inactive.
        listInactiveFocusForeground: AS,
        listInactiveSelectionIconForeground: c5,
        listInactiveFocusBackground: PS,
        listFocusOutline: Ut,
        listInactiveFocusOutline: Ut
      }),
      pickerGroup: {
        pickerGroupBorder: se(a$),
        pickerGroupForeground: se(l5)
      }
    };
  }
};
lD = Sse([
  ug(0, Pe),
  ug(1, Fe),
  ug(2, wn),
  ug(3, oc),
  ug(4, gt)
], lD);
var D3 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Vc = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let cD = class extends lD {
  constructor(e, t, i, n, o, r) {
    super(t, i, n, new Ix(e.getContainerDomNode(), o), r), this.host = void 0;
    const a = vp.get(e);
    if (a) {
      const l = a.widget;
      this.host = {
        _serviceBrand: void 0,
        get mainContainer() {
          return l.getDomNode();
        },
        getContainer() {
          return l.getDomNode();
        },
        whenContainerStylesLoaded() {
        },
        get containers() {
          return [l.getDomNode()];
        },
        get activeContainer() {
          return l.getDomNode();
        },
        get mainContainerDimension() {
          return e.getLayoutInfo();
        },
        get activeContainerDimension() {
          return e.getLayoutInfo();
        },
        get onDidLayoutMainContainer() {
          return e.onDidLayoutChange;
        },
        get onDidLayoutActiveContainer() {
          return e.onDidLayoutChange;
        },
        get onDidLayoutContainer() {
          return ee.map(e.onDidLayoutChange, (c) => ({ container: l.getDomNode(), dimension: c }));
        },
        get onDidChangeActiveContainer() {
          return ee.None;
        },
        get onDidAddContainer() {
          return ee.None;
        },
        get mainContainerOffset() {
          return { top: 0, quickPickTop: 0 };
        },
        get activeContainerOffset() {
          return { top: 0, quickPickTop: 0 };
        },
        focus: () => e.focus()
      };
    } else
      this.host = void 0;
  }
  createController() {
    return super.createController(this.host);
  }
};
cD = D3([
  Vc(1, Pe),
  Vc(2, Fe),
  Vc(3, wn),
  Vc(4, Tt),
  Vc(5, gt)
], cD);
let hD = class {
  get activeService() {
    const e = this.codeEditorService.getFocusedCodeEditor();
    if (!e)
      throw new Error("Quick input service needs a focused editor to work.");
    let t = this.mapEditorToService.get(e);
    if (!t) {
      const i = t = this.instantiationService.createInstance(cD, e);
      this.mapEditorToService.set(e, t), tf(e.onDidDispose)(() => {
        i.dispose(), this.mapEditorToService.delete(e);
      });
    }
    return t;
  }
  get currentQuickInput() {
    return this.activeService.currentQuickInput;
  }
  get quickAccess() {
    return this.activeService.quickAccess;
  }
  constructor(e, t) {
    this.instantiationService = e, this.codeEditorService = t, this.mapEditorToService = /* @__PURE__ */ new Map();
  }
  pick(e, t, i = _t.None) {
    return this.activeService.pick(e, t, i);
  }
  createQuickPick(e = { useSeparators: !1 }) {
    return this.activeService.createQuickPick(e);
  }
  createInputBox() {
    return this.activeService.createInputBox();
  }
};
hD = D3([
  Vc(0, Pe),
  Vc(1, Tt)
], hD);
const Ev = class Ev {
  static get(e) {
    return e.getContribution(Ev.ID);
  }
  constructor(e) {
    this.editor = e, this.widget = new dD(this.editor);
  }
  dispose() {
    this.widget.dispose();
  }
};
Ev.ID = "editor.controller.quickInput";
let vp = Ev;
const Iv = class Iv {
  constructor(e) {
    this.codeEditor = e, this.domNode = document.createElement("div"), this.codeEditor.addOverlayWidget(this);
  }
  getId() {
    return Iv.ID;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      preference: 2
      /* OverlayWidgetPositionPreference.TOP_CENTER */
    };
  }
  dispose() {
    this.codeEditor.removeOverlayWidget(this);
  }
};
Iv.ID = "editor.contrib.quickInputWidget";
let dD = Iv;
Xa(
  vp.ID,
  vp,
  4
  /* EditorContributionInstantiation.Lazy */
);
class Lse {
  constructor(e, t, i, n, o) {
    this._parsedThemeRuleBrand = void 0, this.token = e, this.index = t, this.fontStyle = i, this.foreground = n, this.background = o;
  }
}
function kse(s) {
  if (!s || !Array.isArray(s))
    return [];
  const e = [];
  let t = 0;
  for (let i = 0, n = s.length; i < n; i++) {
    const o = s[i];
    let r = -1;
    if (typeof o.fontStyle == "string") {
      r = 0;
      const c = o.fontStyle.split(" ");
      for (let h = 0, d = c.length; h < d; h++)
        switch (c[h]) {
          case "italic":
            r = r | 1;
            break;
          case "bold":
            r = r | 2;
            break;
          case "underline":
            r = r | 4;
            break;
          case "strikethrough":
            r = r | 8;
            break;
        }
    }
    let a = null;
    typeof o.foreground == "string" && (a = o.foreground);
    let l = null;
    typeof o.background == "string" && (l = o.background), e[t++] = new Lse(o.token || "", i, r, a, l);
  }
  return e;
}
function xse(s, e) {
  s.sort((h, d) => {
    const u = Tse(h.token, d.token);
    return u !== 0 ? u : h.index - d.index;
  });
  let t = 0, i = "000000", n = "ffffff";
  for (; s.length >= 1 && s[0].token === ""; ) {
    const h = s.shift();
    h.fontStyle !== -1 && (t = h.fontStyle), h.foreground !== null && (i = h.foreground), h.background !== null && (n = h.background);
  }
  const o = new Ese();
  for (const h of e)
    o.getId(h);
  const r = o.getId(i), a = o.getId(n), l = new ON(t, r, a), c = new FN(l);
  for (let h = 0, d = s.length; h < d; h++) {
    const u = s[h];
    c.insert(u.token, u.fontStyle, o.getId(u.foreground), o.getId(u.background));
  }
  return new E3(o, c);
}
const Dse = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
class Ese {
  constructor() {
    this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ new Map();
  }
  getId(e) {
    if (e === null)
      return 0;
    const t = e.match(Dse);
    if (!t)
      throw new Error("Illegal value for token color: " + e);
    e = t[1].toUpperCase();
    let i = this._color2id.get(e);
    return i || (i = ++this._lastColorId, this._color2id.set(e, i), this._id2color[i] = j.fromHex("#" + e), i);
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}
class E3 {
  static createFromRawTokenTheme(e, t) {
    return this.createFromParsedTokenTheme(kse(e), t);
  }
  static createFromParsedTokenTheme(e, t) {
    return xse(e, t);
  }
  constructor(e, t) {
    this._colorMap = e, this._root = t, this._cache = /* @__PURE__ */ new Map();
  }
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  _match(e) {
    return this._root.match(e);
  }
  match(e, t) {
    let i = this._cache.get(t);
    if (typeof i > "u") {
      const n = this._match(t), o = Nse(t);
      i = (n.metadata | o << 8) >>> 0, this._cache.set(t, i);
    }
    return (i | e << 0) >>> 0;
  }
}
const Ise = /\b(comment|string|regex|regexp)\b/;
function Nse(s) {
  const e = s.match(Ise);
  if (!e)
    return 0;
  switch (e[1]) {
    case "comment":
      return 1;
    case "string":
      return 2;
    case "regex":
      return 3;
    case "regexp":
      return 3;
  }
  throw new Error("Unexpected match for standard token type!");
}
function Tse(s, e) {
  return s < e ? -1 : s > e ? 1 : 0;
}
class ON {
  constructor(e, t, i) {
    this._themeTrieElementRuleBrand = void 0, this._fontStyle = e, this._foreground = t, this._background = i, this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
  }
  clone() {
    return new ON(this._fontStyle, this._foreground, this._background);
  }
  acceptOverwrite(e, t, i) {
    e !== -1 && (this._fontStyle = e), t !== 0 && (this._foreground = t), i !== 0 && (this._background = i), this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
  }
}
class FN {
  constructor(e) {
    this._themeTrieElementBrand = void 0, this._mainRule = e, this._children = /* @__PURE__ */ new Map();
  }
  match(e) {
    if (e === "")
      return this._mainRule;
    const t = e.indexOf(".");
    let i, n;
    t === -1 ? (i = e, n = "") : (i = e.substring(0, t), n = e.substring(t + 1));
    const o = this._children.get(i);
    return typeof o < "u" ? o.match(n) : this._mainRule;
  }
  insert(e, t, i, n) {
    if (e === "") {
      this._mainRule.acceptOverwrite(t, i, n);
      return;
    }
    const o = e.indexOf(".");
    let r, a;
    o === -1 ? (r = e, a = "") : (r = e.substring(0, o), a = e.substring(o + 1));
    let l = this._children.get(r);
    typeof l > "u" && (l = new FN(this._mainRule.clone()), this._children.set(r, l)), l.insert(a, t, i, n);
  }
}
function Mse(s) {
  const e = [];
  for (let t = 1, i = s.length; t < i; t++) {
    const n = s[t];
    e[t] = `.mtk${t} { color: ${n}; }`;
  }
  return e.push(".mtki { font-style: italic; }"), e.push(".mtkb { font-weight: bold; }"), e.push(".mtku { text-decoration: underline; text-underline-position: under; }"), e.push(".mtks { text-decoration: line-through; }"), e.push(".mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }"), e.join(`
`);
}
const Rse = {
  base: "vs",
  inherit: !1,
  rules: [
    { token: "", foreground: "000000", background: "fffffe" },
    { token: "invalid", foreground: "cd3131" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "001188" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "delimiter.xml", foreground: "0000FF" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "FF0000" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "FF0000" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "attribute.value.number", foreground: "098658" },
    { token: "attribute.value.unit", foreground: "098658" },
    { token: "attribute.value.html", foreground: "0000FF" },
    { token: "attribute.value.xml", foreground: "0000FF" },
    { token: "string", foreground: "A31515" },
    { token: "string.html", foreground: "0000FF" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "string.yaml", foreground: "0451A5" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.json", foreground: "0451A5" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "keyword.flow.scss", foreground: "0000FF" },
    { token: "operator.scss", foreground: "666666" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [po]: "#FFFFFE",
    [Ja]: "#000000",
    [XO]: "#E5EBF1",
    [Bp]: "#D3D3D3",
    [Wp]: "#939393",
    [QO]: "#ADD6FF4D"
  }
}, Ase = {
  base: "vs-dark",
  inherit: !1,
  rules: [
    { token: "", foreground: "D4D4D4", background: "1E1E1E" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "74B0DF" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "B5CEA8" },
    { token: "number.hex", foreground: "5BB498" },
    { token: "regexp", foreground: "B46695" },
    { token: "annotation", foreground: "cc6666" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "DCDCDC" },
    { token: "delimiter.html", foreground: "808080" },
    { token: "delimiter.xml", foreground: "808080" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "A79873" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "DD6A6F" },
    { token: "metatag.content.html", foreground: "9CDCFE" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key.json", foreground: "9CDCFE" },
    { token: "string.value.json", foreground: "CE9178" },
    { token: "attribute.name", foreground: "9CDCFE" },
    { token: "attribute.value", foreground: "CE9178" },
    { token: "attribute.value.number.css", foreground: "B5CEA8" },
    { token: "attribute.value.unit.css", foreground: "B5CEA8" },
    { token: "attribute.value.hex.css", foreground: "D4D4D4" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "keyword.json", foreground: "CE9178" },
    { token: "keyword.flow.scss", foreground: "569CD6" },
    { token: "operator.scss", foreground: "909090" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [po]: "#1E1E1E",
    [Ja]: "#D4D4D4",
    [XO]: "#3A3D41",
    [Bp]: "#404040",
    [Wp]: "#707070",
    [QO]: "#ADD6FF26"
  }
}, Pse = {
  base: "hc-black",
  inherit: !1,
  rules: [
    { token: "", foreground: "FFFFFF", background: "000000" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "1AEBFF" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "FFFFFF" },
    { token: "regexp", foreground: "C0C0C0" },
    { token: "annotation", foreground: "569CD6" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "FFFF00" },
    { token: "delimiter.html", foreground: "FFFF00" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta", foreground: "D4D4D4" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "569CD6" },
    { token: "metatag.content.html", foreground: "1AEBFF" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key", foreground: "9CDCFE" },
    { token: "string.value", foreground: "CE9178" },
    { token: "attribute.name", foreground: "569CD6" },
    { token: "attribute.value", foreground: "3FF23F" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [po]: "#000000",
    [Ja]: "#FFFFFF",
    [Bp]: "#FFFFFF",
    [Wp]: "#FFFFFF"
  }
}, Ose = {
  base: "hc-light",
  inherit: !1,
  rules: [
    { token: "", foreground: "292929", background: "FFFFFF" },
    { token: "invalid", foreground: "B5200D" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "264F70" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "B5200D" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "264F78" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "string", foreground: "A31515" },
    { token: "string.sql", foreground: "B5200D" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [po]: "#FFFFFF",
    [Ja]: "#292929",
    [Bp]: "#292929",
    [Wp]: "#292929"
  }
};
function Fse(s) {
  const e = new ne(), t = e.add(new A()), i = d7();
  return e.add(i.onDidChange(() => t.fire())), s && e.add(s.onDidProductIconThemeChange(() => t.fire())), {
    dispose: () => e.dispose(),
    onDidChange: t.event,
    getCSS() {
      const n = s ? s.getProductIconTheme() : new I3(), o = {}, r = [], a = [];
      for (const l of i.getIcons()) {
        const c = n.getIcon(l);
        if (!c)
          continue;
        const h = c.font, d = `--vscode-icon-${l.id}-font-family`, u = `--vscode-icon-${l.id}-content`;
        h ? (o[h.id] = h.definition, a.push(`${d}: ${b0(h.id)};`, `${u}: '${c.fontCharacter}';`), r.push(`.codicon-${l.id}:before { content: '${c.fontCharacter}'; font-family: ${b0(h.id)}; }`)) : (a.push(`${u}: '${c.fontCharacter}'; ${d}: 'codicon';`), r.push(`.codicon-${l.id}:before { content: '${c.fontCharacter}'; }`));
      }
      for (const l in o) {
        const c = o[l], h = c.weight ? `font-weight: ${c.weight};` : "", d = c.style ? `font-style: ${c.style};` : "", u = c.src.map((f) => `${Ua(f.location)} format('${f.format}')`).join(", ");
        r.push(`@font-face { src: ${u}; font-family: ${b0(l)};${h}${d} font-display: block; }`);
      }
      return r.push(`:root { ${a.join(" ")} }`), r.join(`
`);
    }
  };
}
class I3 {
  getIcon(e) {
    const t = d7();
    let i = e.defaults;
    for (; Te.isThemeIcon(i); ) {
      const n = t.getIcon(i.id);
      if (!n)
        return;
      i = n.defaults;
    }
    return i;
  }
}
const Cl = "vs", sm = "vs-dark", ju = "hc-black", qu = "hc-light", N3 = Mi.as($O.ColorContribution), Bse = Mi.as(v5.ThemingContribution);
class T3 {
  constructor(e, t) {
    this.semanticHighlighting = !1, this.themeData = t;
    const i = t.base;
    e.length > 0 ? (Db(e) ? this.id = e : this.id = i + " " + e, this.themeName = e) : (this.id = i, this.themeName = i), this.colors = null, this.defaultColors = /* @__PURE__ */ Object.create(null), this._tokenTheme = null;
  }
  get base() {
    return this.themeData.base;
  }
  notifyBaseUpdated() {
    this.themeData.inherit && (this.colors = null, this._tokenTheme = null);
  }
  getColors() {
    if (!this.colors) {
      const e = /* @__PURE__ */ new Map();
      for (const t in this.themeData.colors)
        e.set(t, j.fromHex(this.themeData.colors[t]));
      if (this.themeData.inherit) {
        const t = uD(this.themeData.base);
        for (const i in t.colors)
          e.has(i) || e.set(i, j.fromHex(t.colors[i]));
      }
      this.colors = e;
    }
    return this.colors;
  }
  getColor(e, t) {
    const i = this.getColors().get(e);
    if (i)
      return i;
    if (t !== !1)
      return this.getDefault(e);
  }
  getDefault(e) {
    let t = this.defaultColors[e];
    return t || (t = N3.resolveDefaultColor(e, this), this.defaultColors[e] = t, t);
  }
  defines(e) {
    return this.getColors().has(e);
  }
  get type() {
    switch (this.base) {
      case Cl:
        return Ps.LIGHT;
      case ju:
        return Ps.HIGH_CONTRAST_DARK;
      case qu:
        return Ps.HIGH_CONTRAST_LIGHT;
      default:
        return Ps.DARK;
    }
  }
  get tokenTheme() {
    if (!this._tokenTheme) {
      let e = [], t = [];
      if (this.themeData.inherit) {
        const o = uD(this.themeData.base);
        e = o.rules, o.encodedTokensColors && (t = o.encodedTokensColors);
      }
      const i = this.themeData.colors["editor.foreground"], n = this.themeData.colors["editor.background"];
      if (i || n) {
        const o = { token: "" };
        i && (o.foreground = i), n && (o.background = n), e.push(o);
      }
      e = e.concat(this.themeData.rules), this.themeData.encodedTokensColors && (t = this.themeData.encodedTokensColors), this._tokenTheme = E3.createFromRawTokenTheme(e, t);
    }
    return this._tokenTheme;
  }
  getTokenStyleMetadata(e, t, i) {
    const o = this.tokenTheme._match([e].concat(t).join(".")).metadata, r = Bo.getForeground(o), a = Bo.getFontStyle(o);
    return {
      foreground: r,
      italic: !!(a & 1),
      bold: !!(a & 2),
      underline: !!(a & 4),
      strikethrough: !!(a & 8)
    };
  }
}
function Db(s) {
  return s === Cl || s === sm || s === ju || s === qu;
}
function uD(s) {
  switch (s) {
    case Cl:
      return Rse;
    case sm:
      return Ase;
    case ju:
      return Pse;
    case qu:
      return Ose;
  }
}
function j_(s) {
  const e = uD(s);
  return new T3(s, e);
}
class Wse extends U {
  constructor() {
    super(), this._onColorThemeChange = this._register(new A()), this.onDidColorThemeChange = this._onColorThemeChange.event, this._onProductIconThemeChange = this._register(new A()), this.onDidProductIconThemeChange = this._onProductIconThemeChange.event, this._environment = /* @__PURE__ */ Object.create(null), this._builtInProductIconTheme = new I3(), this._autoDetectHighContrast = !0, this._knownThemes = /* @__PURE__ */ new Map(), this._knownThemes.set(Cl, j_(Cl)), this._knownThemes.set(sm, j_(sm)), this._knownThemes.set(ju, j_(ju)), this._knownThemes.set(qu, j_(qu));
    const e = this._register(Fse(this));
    this._codiconCSS = e.getCSS(), this._themeCSS = "", this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._globalStyleElement = null, this._styleElements = [], this._colorMapOverride = null, this.setTheme(Cl), this._onOSSchemeChanged(), this._register(e.onDidChange(() => {
      this._codiconCSS = e.getCSS(), this._updateCSS();
    })), b4(pt, "(forced-colors: active)", () => {
      this._onOSSchemeChanged();
    });
  }
  registerEditorContainer(e) {
    return qb(e) ? this._registerShadowDomContainer(e) : this._registerRegularEditorContainer();
  }
  _registerRegularEditorContainer() {
    return this._globalStyleElement || (this._globalStyleElement = Us(void 0, (e) => {
      e.className = "monaco-colors", e.textContent = this._allCSS;
    }), this._styleElements.push(this._globalStyleElement)), U.None;
  }
  _registerShadowDomContainer(e) {
    const t = Us(e, (i) => {
      i.className = "monaco-colors", i.textContent = this._allCSS;
    });
    return this._styleElements.push(t), {
      dispose: () => {
        for (let i = 0; i < this._styleElements.length; i++)
          if (this._styleElements[i] === t) {
            this._styleElements.splice(i, 1);
            return;
          }
      }
    };
  }
  defineTheme(e, t) {
    if (!/^[a-z0-9\-]+$/i.test(e))
      throw new Error("Illegal theme name!");
    if (!Db(t.base) && !Db(e))
      throw new Error("Illegal theme base!");
    this._knownThemes.set(e, new T3(e, t)), Db(e) && this._knownThemes.forEach((i) => {
      i.base === e && i.notifyBaseUpdated();
    }), this._theme.themeName === e && this.setTheme(e);
  }
  getColorTheme() {
    return this._theme;
  }
  setColorMapOverride(e) {
    this._colorMapOverride = e, this._updateThemeOrColorMap();
  }
  setTheme(e) {
    let t;
    this._knownThemes.has(e) ? t = this._knownThemes.get(e) : t = this._knownThemes.get(Cl), this._updateActualTheme(t);
  }
  _updateActualTheme(e) {
    !e || this._theme === e || (this._theme = e, this._updateThemeOrColorMap());
  }
  _onOSSchemeChanged() {
    if (this._autoDetectHighContrast) {
      const e = pt.matchMedia("(forced-colors: active)").matches;
      if (e !== dh(this._theme.type)) {
        let t;
        Sw(this._theme.type) ? t = e ? ju : sm : t = e ? qu : Cl, this._updateActualTheme(this._knownThemes.get(t));
      }
    }
  }
  setAutoDetectHighContrast(e) {
    this._autoDetectHighContrast = e, this._onOSSchemeChanged();
  }
  _updateThemeOrColorMap() {
    const e = [], t = {}, i = {
      addRule: (r) => {
        t[r] || (e.push(r), t[r] = !0);
      }
    };
    Bse.getThemingParticipants().forEach((r) => r(this._theme, i, this._environment));
    const n = [];
    for (const r of N3.getColors()) {
      const a = this._theme.getColor(r.id, !0);
      a && n.push(`${nI(r.id)}: ${a.toString()};`);
    }
    i.addRule(`.monaco-editor, .monaco-diff-editor, .monaco-component { ${n.join(`
`)} }`);
    const o = this._colorMapOverride || this._theme.tokenTheme.getColorMap();
    i.addRule(Mse(o)), this._themeCSS = e.join(`
`), this._updateCSS(), ii.setColorMap(o), this._onColorThemeChange.fire(this._theme);
  }
  _updateCSS() {
    this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._styleElements.forEach((e) => e.textContent = this._allCSS);
  }
  getFileIconTheme() {
    return {
      hasFileIcons: !1,
      hasFolderIcons: !1,
      hidesExplorerArrows: !1
    };
  }
  getProductIconTheme() {
    return this._builtInProductIconTheme;
  }
}
const yo = Be("themeService");
var Hse = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, ky = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let fD = class extends U {
  constructor(e, t, i) {
    super(), this._contextKeyService = e, this._layoutService = t, this._configurationService = i, this._accessibilitySupport = 0, this._onDidChangeScreenReaderOptimized = new A(), this._onDidChangeReducedMotion = new A(), this._onDidChangeLinkUnderline = new A(), this._accessibilityModeEnabledContext = hz.bindTo(this._contextKeyService);
    const n = () => this._accessibilityModeEnabledContext.set(this.isScreenReaderOptimized());
    this._register(this._configurationService.onDidChangeConfiguration((r) => {
      r.affectsConfiguration("editor.accessibilitySupport") && (n(), this._onDidChangeScreenReaderOptimized.fire()), r.affectsConfiguration("workbench.reduceMotion") && (this._configMotionReduced = this._configurationService.getValue("workbench.reduceMotion"), this._onDidChangeReducedMotion.fire());
    })), n(), this._register(this.onDidChangeScreenReaderOptimized(() => n()));
    const o = pt.matchMedia("(prefers-reduced-motion: reduce)");
    this._systemMotionReduced = o.matches, this._configMotionReduced = this._configurationService.getValue("workbench.reduceMotion"), this._linkUnderlinesEnabled = this._configurationService.getValue("accessibility.underlineLinks"), this.initReducedMotionListeners(o), this.initLinkUnderlineListeners();
  }
  initReducedMotionListeners(e) {
    this._register(z(e, "change", () => {
      this._systemMotionReduced = e.matches, this._configMotionReduced === "auto" && this._onDidChangeReducedMotion.fire();
    }));
    const t = () => {
      const i = this.isMotionReduced();
      this._layoutService.mainContainer.classList.toggle("reduce-motion", i), this._layoutService.mainContainer.classList.toggle("enable-motion", !i);
    };
    t(), this._register(this.onDidChangeReducedMotion(() => t()));
  }
  initLinkUnderlineListeners() {
    this._register(this._configurationService.onDidChangeConfiguration((t) => {
      if (t.affectsConfiguration("accessibility.underlineLinks")) {
        const i = this._configurationService.getValue("accessibility.underlineLinks");
        this._linkUnderlinesEnabled = i, this._onDidChangeLinkUnderline.fire();
      }
    }));
    const e = () => {
      const t = this._linkUnderlinesEnabled;
      this._layoutService.mainContainer.classList.toggle("underline-links", t);
    };
    e(), this._register(this.onDidChangeLinkUnderlines(() => e()));
  }
  onDidChangeLinkUnderlines(e) {
    return this._onDidChangeLinkUnderline.event(e);
  }
  get onDidChangeScreenReaderOptimized() {
    return this._onDidChangeScreenReaderOptimized.event;
  }
  isScreenReaderOptimized() {
    const e = this._configurationService.getValue("editor.accessibilitySupport");
    return e === "on" || e === "auto" && this._accessibilitySupport === 2;
  }
  get onDidChangeReducedMotion() {
    return this._onDidChangeReducedMotion.event;
  }
  isMotionReduced() {
    const e = this._configMotionReduced;
    return e === "on" || e === "auto" && this._systemMotionReduced;
  }
  getAccessibilitySupport() {
    return this._accessibilitySupport;
  }
};
fD = Hse([
  ky(0, Fe),
  ky(1, oc),
  ky(2, gt)
], fD);
var Vse = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, ZA = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, gD;
const YA = "application/vnd.code.resources";
var Ah;
let mD = (Ah = class extends U {
  constructor(e, t) {
    super(), this.layoutService = e, this.logService = t, this.mapTextToType = /* @__PURE__ */ new Map(), this.findText = "", this.resources = [], this.resourcesStateHash = void 0, (ql || C4) && this.installWebKitWriteTextWorkaround(), this._register(ee.runAndSubscribe(Qv, ({ window: i, disposables: n }) => {
      n.add(z(i.document, "copy", () => this.clearResourcesState()));
    }, { window: pt, disposables: this._store }));
  }
  // In Safari, it has the following note:
  //
  // "The request to write to the clipboard must be triggered during a user gesture.
  // A call to clipboard.write or clipboard.writeText outside the scope of a user
  // gesture(such as "click" or "touch" event handlers) will result in the immediate
  // rejection of the promise returned by the API call."
  // From: https://webkit.org/blog/10855/async-clipboard-api/
  //
  // Since extensions run in a web worker, and handle gestures in an asynchronous way,
  // they are not classified by Safari as "in response to a user gesture" and will reject.
  //
  // This function sets up some handlers to work around that behavior.
  installWebKitWriteTextWorkaround() {
    const e = () => {
      const t = new L4();
      this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled && this.webKitPendingClipboardWritePromise.cancel(), this.webKitPendingClipboardWritePromise = t, mg().navigator.clipboard.write([new ClipboardItem({
        "text/plain": t.p
      })]).catch(async (i) => {
        (!(i instanceof Error) || i.name !== "NotAllowedError" || !t.isRejected) && this.logService.error(i);
      });
    };
    this._register(ee.runAndSubscribe(this.layoutService.onDidAddContainer, ({ container: t, disposables: i }) => {
      i.add(z(t, "click", e)), i.add(z(t, "keydown", e));
    }, { container: this.layoutService.mainContainer, disposables: this._store }));
  }
  async writeText(e, t) {
    if (this.clearResourcesState(), t) {
      this.mapTextToType.set(t, e);
      return;
    }
    if (this.webKitPendingClipboardWritePromise)
      return this.webKitPendingClipboardWritePromise.complete(e);
    try {
      return await mg().navigator.clipboard.writeText(e);
    } catch (i) {
      console.error(i);
    }
    this.fallbackWriteText(e);
  }
  fallbackWriteText(e) {
    const t = DE(), i = t.activeElement, n = t.body.appendChild(he("textarea", { "aria-hidden": !0 }));
    n.style.height = "1px", n.style.width = "1px", n.style.position = "absolute", n.value = e, n.focus(), n.select(), t.execCommand("copy"), ki(i) && i.focus(), n.remove();
  }
  async readText(e) {
    if (e)
      return this.mapTextToType.get(e) || "";
    try {
      return await mg().navigator.clipboard.readText();
    } catch (t) {
      console.error(t);
    }
    return "";
  }
  async readFindText() {
    return this.findText;
  }
  async writeFindText(e) {
    this.findText = e;
  }
  async readResources() {
    try {
      const t = await mg().navigator.clipboard.read();
      for (const i of t)
        if (i.types.includes(`web ${YA}`)) {
          const n = await i.getType(`web ${YA}`);
          return JSON.parse(await n.text()).map((r) => we.from(r));
        }
    } catch {
    }
    const e = await this.computeResourcesStateHash();
    return this.resourcesStateHash !== e && this.clearResourcesState(), this.resources;
  }
  async computeResourcesStateHash() {
    if (this.resources.length === 0)
      return;
    const e = await this.readText();
    return A4(e.substring(0, gD.MAX_RESOURCE_STATE_SOURCE_LENGTH));
  }
  clearInternalState() {
    this.clearResourcesState();
  }
  clearResourcesState() {
    this.resources = [], this.resourcesStateHash = void 0;
  }
}, gD = Ah, Ah.MAX_RESOURCE_STATE_SOURCE_LENGTH = 1e3, Ah);
mD = gD = Vse([
  ZA(0, oc),
  ZA(1, Co)
], mD);
const BN = Be("clipboardService");
var zse = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Use = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const om = "data-keybinding-context";
class WN {
  constructor(e, t) {
    this._id = e, this._parent = t, this._value = /* @__PURE__ */ Object.create(null), this._value._contextId = e;
  }
  get value() {
    return { ...this._value };
  }
  setValue(e, t) {
    return this._value[e] !== t ? (this._value[e] = t, !0) : !1;
  }
  removeValue(e) {
    return e in this._value ? (delete this._value[e], !0) : !1;
  }
  getValue(e) {
    const t = this._value[e];
    return typeof t > "u" && this._parent ? this._parent.getValue(e) : t;
  }
}
const Nv = class Nv extends WN {
  constructor() {
    super(-1, null);
  }
  setValue(e, t) {
    return !1;
  }
  removeValue(e) {
    return !1;
  }
  getValue(e) {
  }
};
Nv.INSTANCE = new Nv();
let kf = Nv;
const _m = class _m extends WN {
  constructor(e, t, i) {
    super(e, null), this._configurationService = t, this._values = im.forConfigKeys(), this._listener = this._configurationService.onDidChangeConfiguration((n) => {
      if (n.source === 7) {
        const o = Array.from(this._values, ([r]) => r);
        this._values.clear(), i.fire(new QA(o));
      } else {
        const o = [];
        for (const r of n.affectedKeys) {
          const a = `config.${r}`, l = this._values.findSuperstr(a);
          l !== void 0 && (o.push(...nt.map(l, ([c]) => c)), this._values.deleteSuperstr(a)), this._values.has(a) && (o.push(a), this._values.delete(a));
        }
        i.fire(new QA(o));
      }
    });
  }
  dispose() {
    this._listener.dispose();
  }
  getValue(e) {
    if (e.indexOf(_m._keyPrefix) !== 0)
      return super.getValue(e);
    if (this._values.has(e))
      return this._values.get(e);
    const t = e.substr(_m._keyPrefix.length), i = this._configurationService.getValue(t);
    let n;
    switch (typeof i) {
      case "number":
      case "boolean":
      case "string":
        n = i;
        break;
      default:
        Array.isArray(i) ? n = JSON.stringify(i) : n = i;
    }
    return this._values.set(e, n), n;
  }
  setValue(e, t) {
    return super.setValue(e, t);
  }
  removeValue(e) {
    return super.removeValue(e);
  }
};
_m._keyPrefix = "config.";
let pD = _m;
class $se {
  constructor(e, t, i) {
    this._service = e, this._key = t, this._defaultValue = i, this.reset();
  }
  set(e) {
    this._service.setContext(this._key, e);
  }
  reset() {
    typeof this._defaultValue > "u" ? this._service.removeContext(this._key) : this._service.setContext(this._key, this._defaultValue);
  }
  get() {
    return this._service.getContextKeyValue(this._key);
  }
}
class XA {
  constructor(e) {
    this.key = e;
  }
  affectsSome(e) {
    return e.has(this.key);
  }
  allKeysContainedIn(e) {
    return this.affectsSome(e);
  }
}
class QA {
  constructor(e) {
    this.keys = e;
  }
  affectsSome(e) {
    for (const t of this.keys)
      if (e.has(t))
        return !0;
    return !1;
  }
  allKeysContainedIn(e) {
    return this.keys.every((t) => e.has(t));
  }
}
class Kse {
  constructor(e) {
    this.events = e;
  }
  affectsSome(e) {
    for (const t of this.events)
      if (t.affectsSome(e))
        return !0;
    return !1;
  }
  allKeysContainedIn(e) {
    return this.events.every((t) => t.allKeysContainedIn(e));
  }
}
function jse(s, e) {
  return s.allKeysContainedIn(new Set(Object.keys(e)));
}
class M3 extends U {
  constructor(e) {
    super(), this._onDidChangeContext = this._register(new Sm({ merge: (t) => new Kse(t) })), this.onDidChangeContext = this._onDidChangeContext.event, this._isDisposed = !1, this._myContextId = e;
  }
  createKey(e, t) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    return new $se(this, e, t);
  }
  bufferChangeEvents(e) {
    this._onDidChangeContext.pause();
    try {
      e();
    } finally {
      this._onDidChangeContext.resume();
    }
  }
  createScoped(e) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    return new qse(this, e);
  }
  contextMatchesRules(e) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    const t = this.getContextValuesContainer(this._myContextId);
    return e ? e.evaluate(t) : !0;
  }
  getContextKeyValue(e) {
    if (!this._isDisposed)
      return this.getContextValuesContainer(this._myContextId).getValue(e);
  }
  setContext(e, t) {
    if (this._isDisposed)
      return;
    const i = this.getContextValuesContainer(this._myContextId);
    i && i.setValue(e, t) && this._onDidChangeContext.fire(new XA(e));
  }
  removeContext(e) {
    this._isDisposed || this.getContextValuesContainer(this._myContextId).removeValue(e) && this._onDidChangeContext.fire(new XA(e));
  }
  getContext(e) {
    return this._isDisposed ? kf.INSTANCE : this.getContextValuesContainer(Gse(e));
  }
  dispose() {
    super.dispose(), this._isDisposed = !0;
  }
}
let _D = class extends M3 {
  constructor(e) {
    super(0), this._contexts = /* @__PURE__ */ new Map(), this._lastContextId = 0;
    const t = this._register(new pD(this._myContextId, e, this._onDidChangeContext));
    this._contexts.set(this._myContextId, t);
  }
  getContextValuesContainer(e) {
    return this._isDisposed ? kf.INSTANCE : this._contexts.get(e) || kf.INSTANCE;
  }
  createChildContext(e = this._myContextId) {
    if (this._isDisposed)
      throw new Error("ContextKeyService has been disposed");
    const t = ++this._lastContextId;
    return this._contexts.set(t, new WN(t, this.getContextValuesContainer(e))), t;
  }
  disposeContext(e) {
    this._isDisposed || this._contexts.delete(e);
  }
};
_D = zse([
  Use(0, gt)
], _D);
class qse extends M3 {
  constructor(e, t) {
    if (super(e.createChildContext()), this._parentChangeListener = this._register(new Hs()), this._parent = e, this._updateParentChangeListener(), this._domNode = t, this._domNode.hasAttribute(om)) {
      let i = "";
      this._domNode.classList && (i = Array.from(this._domNode.classList.values()).join(", ")), console.error(`Element already has context attribute${i ? ": " + i : ""}`);
    }
    this._domNode.setAttribute(om, String(this._myContextId));
  }
  _updateParentChangeListener() {
    this._parentChangeListener.value = this._parent.onDidChangeContext((e) => {
      const i = this._parent.getContextValuesContainer(this._myContextId).value;
      jse(e, i) || this._onDidChangeContext.fire(e);
    });
  }
  dispose() {
    this._isDisposed || (this._parent.disposeContext(this._myContextId), this._domNode.removeAttribute(om), super.dispose());
  }
  getContextValuesContainer(e) {
    return this._isDisposed ? kf.INSTANCE : this._parent.getContextValuesContainer(e);
  }
  createChildContext(e = this._myContextId) {
    if (this._isDisposed)
      throw new Error("ScopedContextKeyService has been disposed");
    return this._parent.createChildContext(e);
  }
  disposeContext(e) {
    this._isDisposed || this._parent.disposeContext(e);
  }
}
function Gse(s) {
  for (; s; ) {
    if (s.hasAttribute(om)) {
      const e = s.getAttribute(om);
      return e ? parseInt(e, 10) : NaN;
    }
    s = s.parentElement;
  }
  return 0;
}
function Zse(s, e, t) {
  s.get(Fe).createKey(String(e), Yse(t));
}
function Yse(s) {
  return bO(s, (e) => {
    if (typeof e == "object" && e.$mid === 1)
      return we.revive(e).toString();
    if (e instanceof we)
      return e.toString();
  });
}
St.registerCommand("_setContext", Zse);
St.registerCommand({
  id: "getContextKeyInfo",
  handler() {
    return [...ce.all()].sort((s, e) => s.key.localeCompare(e.key));
  },
  metadata: {
    description: m("getContextKeyInfo", "A command that returns information about context keys"),
    args: []
  }
});
St.registerCommand("_generateContextKeyInfo", function() {
  const s = [], e = /* @__PURE__ */ new Set();
  for (const t of ce.all())
    e.has(t.key) || (e.add(t.key), s.push(t));
  s.sort((t, i) => t.key.localeCompare(i.key)), console.log(JSON.stringify(s, void 0, 2));
});
let Xse = class {
  constructor(e, t) {
    this.key = e, this.data = t, this.incoming = /* @__PURE__ */ new Map(), this.outgoing = /* @__PURE__ */ new Map();
  }
};
class JA {
  constructor(e) {
    this._hashFn = e, this._nodes = /* @__PURE__ */ new Map();
  }
  roots() {
    const e = [];
    for (const t of this._nodes.values())
      t.outgoing.size === 0 && e.push(t);
    return e;
  }
  insertEdge(e, t) {
    const i = this.lookupOrInsertNode(e), n = this.lookupOrInsertNode(t);
    i.outgoing.set(n.key, n), n.incoming.set(i.key, i);
  }
  removeNode(e) {
    const t = this._hashFn(e);
    this._nodes.delete(t);
    for (const i of this._nodes.values())
      i.outgoing.delete(t), i.incoming.delete(t);
  }
  lookupOrInsertNode(e) {
    const t = this._hashFn(e);
    let i = this._nodes.get(t);
    return i || (i = new Xse(t, e), this._nodes.set(t, i)), i;
  }
  isEmpty() {
    return this._nodes.size === 0;
  }
  toString() {
    const e = [];
    for (const [t, i] of this._nodes)
      e.push(`${t}
	(-> incoming)[${[...i.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...i.outgoing.keys()].join(",")}]
`);
    return e.join(`
`);
  }
  /**
   * This is brute force and slow and **only** be used
   * to trouble shoot.
   */
  findCycleSlow() {
    for (const [e, t] of this._nodes) {
      const i = /* @__PURE__ */ new Set([e]), n = this._findCycle(t, i);
      if (n)
        return n;
    }
  }
  _findCycle(e, t) {
    for (const [i, n] of e.outgoing) {
      if (t.has(i))
        return [...t, i].join(" -> ");
      t.add(i);
      const o = this._findCycle(n, t);
      if (o)
        return o;
      t.delete(i);
    }
  }
}
const Qse = !1;
class eP extends Error {
  constructor(e) {
    super("cyclic dependency between services"), this.message = e.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: 
${e.toString()}`;
  }
}
class IC {
  constructor(e = new Hf(), t = !1, i, n = Qse) {
    this._services = e, this._strict = t, this._parent = i, this._enableTracing = n, this._isDisposed = !1, this._servicesToMaybeDispose = /* @__PURE__ */ new Set(), this._children = /* @__PURE__ */ new Set(), this._activeInstantiations = /* @__PURE__ */ new Set(), this._services.set(Pe, this), this._globalGraph = n ? (i == null ? void 0 : i._globalGraph) ?? new JA((o) => o) : void 0;
  }
  dispose() {
    if (!this._isDisposed) {
      this._isDisposed = !0, Ft(this._children), this._children.clear();
      for (const e of this._servicesToMaybeDispose)
        i4(e) && e.dispose();
      this._servicesToMaybeDispose.clear();
    }
  }
  _throwIfDisposed() {
    if (this._isDisposed)
      throw new Error("InstantiationService has been disposed");
  }
  createChild(e, t) {
    this._throwIfDisposed();
    const i = this, n = new class extends IC {
      dispose() {
        i._children.delete(n), super.dispose();
      }
    }(e, this._strict, this, this._enableTracing);
    return this._children.add(n), t == null || t.add(n), n;
  }
  invokeFunction(e, ...t) {
    this._throwIfDisposed();
    const i = rm.traceInvocation(this._enableTracing, e);
    let n = !1;
    try {
      return e({
        get: (r) => {
          if (n)
            throw oE("service accessor is only valid during the invocation of its target method");
          const a = this._getOrCreateServiceInstance(r, i);
          if (!a)
            throw new Error(`[invokeFunction] unknown service '${r}'`);
          return a;
        }
      }, ...t);
    } finally {
      n = !0, i.stop();
    }
  }
  createInstance(e, ...t) {
    this._throwIfDisposed();
    let i, n;
    return e instanceof Lr ? (i = rm.traceCreation(this._enableTracing, e.ctor), n = this._createInstance(e.ctor, e.staticArguments.concat(t), i)) : (i = rm.traceCreation(this._enableTracing, e), n = this._createInstance(e, t, i)), i.stop(), n;
  }
  _createInstance(e, t = [], i) {
    const n = zo.getServiceDependencies(e).sort((a, l) => a.index - l.index), o = [];
    for (const a of n) {
      const l = this._getOrCreateServiceInstance(a.id, i);
      l || this._throwIfStrict(`[createInstance] ${e.name} depends on UNKNOWN service ${a.id}.`, !1), o.push(l);
    }
    const r = n.length > 0 ? n[0].index : t.length;
    if (t.length !== r) {
      console.trace(`[createInstance] First service dependency of ${e.name} at position ${r + 1} conflicts with ${t.length} static arguments`);
      const a = r - t.length;
      a > 0 ? t = t.concat(new Array(a)) : t = t.slice(0, r);
    }
    return Reflect.construct(e, t.concat(o));
  }
  _setCreatedServiceInstance(e, t) {
    if (this._services.get(e) instanceof Lr)
      this._services.set(e, t);
    else if (this._parent)
      this._parent._setCreatedServiceInstance(e, t);
    else
      throw new Error("illegalState - setting UNKNOWN service instance");
  }
  _getServiceInstanceOrDescriptor(e) {
    const t = this._services.get(e);
    return !t && this._parent ? this._parent._getServiceInstanceOrDescriptor(e) : t;
  }
  _getOrCreateServiceInstance(e, t) {
    this._globalGraph && this._globalGraphImplicitDependency && this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(e));
    const i = this._getServiceInstanceOrDescriptor(e);
    return i instanceof Lr ? this._safeCreateAndCacheServiceInstance(e, i, t.branch(e, !0)) : (t.branch(e, !1), i);
  }
  _safeCreateAndCacheServiceInstance(e, t, i) {
    if (this._activeInstantiations.has(e))
      throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);
    this._activeInstantiations.add(e);
    try {
      return this._createAndCacheServiceInstance(e, t, i);
    } finally {
      this._activeInstantiations.delete(e);
    }
  }
  _createAndCacheServiceInstance(e, t, i) {
    var l;
    const n = new JA((c) => c.id.toString());
    let o = 0;
    const r = [{ id: e, desc: t, _trace: i }], a = /* @__PURE__ */ new Set();
    for (; r.length; ) {
      const c = r.pop();
      if (!a.has(String(c.id))) {
        if (a.add(String(c.id)), n.lookupOrInsertNode(c), o++ > 1e3)
          throw new eP(n);
        for (const h of zo.getServiceDependencies(c.desc.ctor)) {
          const d = this._getServiceInstanceOrDescriptor(h.id);
          if (d || this._throwIfStrict(`[createInstance] ${e} depends on ${h.id} which is NOT registered.`, !0), (l = this._globalGraph) == null || l.insertEdge(String(c.id), String(h.id)), d instanceof Lr) {
            const u = { id: h.id, desc: d, _trace: c._trace.branch(h.id, !0) };
            n.insertEdge(c, u), r.push(u);
          }
        }
      }
    }
    for (; ; ) {
      const c = n.roots();
      if (c.length === 0) {
        if (!n.isEmpty())
          throw new eP(n);
        break;
      }
      for (const { data: h } of c) {
        if (this._getServiceInstanceOrDescriptor(h.id) instanceof Lr) {
          const u = this._createServiceInstanceWithOwner(h.id, h.desc.ctor, h.desc.staticArguments, h.desc.supportsDelayedInstantiation, h._trace);
          this._setCreatedServiceInstance(h.id, u);
        }
        n.removeNode(h);
      }
    }
    return this._getServiceInstanceOrDescriptor(e);
  }
  _createServiceInstanceWithOwner(e, t, i = [], n, o) {
    if (this._services.get(e) instanceof Lr)
      return this._createServiceInstance(e, t, i, n, o, this._servicesToMaybeDispose);
    if (this._parent)
      return this._parent._createServiceInstanceWithOwner(e, t, i, n, o);
    throw new Error(`illegalState - creating UNKNOWN service instance ${t.name}`);
  }
  _createServiceInstance(e, t, i = [], n, o, r) {
    if (n) {
      const a = new IC(void 0, this._strict, this, this._enableTracing);
      a._globalGraphImplicitDependency = String(e);
      const l = /* @__PURE__ */ new Map(), c = new h6(() => {
        const h = a._createInstance(t, i, o);
        for (const [d, u] of l) {
          const f = h[d];
          if (typeof f == "function")
            for (const g of u)
              g.disposable = f.apply(h, g.listener);
        }
        return l.clear(), r.add(h), h;
      });
      return new Proxy(/* @__PURE__ */ Object.create(null), {
        get(h, d) {
          if (!c.isInitialized && typeof d == "string" && (d.startsWith("onDid") || d.startsWith("onWill"))) {
            let g = l.get(d);
            return g || (g = new Tn(), l.set(d, g)), (_, b, C) => {
              if (c.isInitialized)
                return c.value[d](_, b, C);
              {
                const w = { listener: [_, b, C], disposable: void 0 }, v = g.push(w);
                return _e(() => {
                  var L;
                  v(), (L = w.disposable) == null || L.dispose();
                });
              }
            };
          }
          if (d in h)
            return h[d];
          const u = c.value;
          let f = u[d];
          return typeof f != "function" || (f = f.bind(u), h[d] = f), f;
        },
        set(h, d, u) {
          return c.value[d] = u, !0;
        },
        getPrototypeOf(h) {
          return t.prototype;
        }
      });
    } else {
      const a = this._createInstance(t, i, o);
      return r.add(a), a;
    }
  }
  _throwIfStrict(e, t) {
    if (t && console.warn(e), this._strict)
      throw new Error(e);
  }
}
const ds = class ds {
  static traceInvocation(e, t) {
    return e ? new ds(2, t.name || new Error().stack.split(`
`).slice(3, 4).join(`
`)) : ds._None;
  }
  static traceCreation(e, t) {
    return e ? new ds(1, t.name) : ds._None;
  }
  constructor(e, t) {
    this.type = e, this.name = t, this._start = Date.now(), this._dep = [];
  }
  branch(e, t) {
    const i = new ds(3, e.toString());
    return this._dep.push([e, t, i]), i;
  }
  stop() {
    const e = Date.now() - this._start;
    ds._totals += e;
    let t = !1;
    function i(o, r) {
      const a = [], l = new Array(o + 1).join("	");
      for (const [c, h, d] of r._dep)
        if (h && d) {
          t = !0, a.push(`${l}CREATES -> ${c}`);
          const u = i(o + 1, d);
          u && a.push(u);
        } else
          a.push(`${l}uses -> ${c}`);
      return a.join(`
`);
    }
    const n = [
      `${this.type === 1 ? "CREATE" : "CALL"} ${this.name}`,
      `${i(1, this)}`,
      `DONE, took ${e.toFixed(2)}ms (grand total ${ds._totals.toFixed(2)}ms)`
    ];
    (e > 2 || t) && ds.all.add(n.join(`
`));
  }
};
ds.all = /* @__PURE__ */ new Set(), ds._None = new class extends ds {
  constructor() {
    super(0, null);
  }
  stop() {
  }
  branch() {
    return this;
  }
}(), ds._totals = 0;
let rm = ds;
const Jse = /* @__PURE__ */ new Set([
  Ie.inMemory,
  Ie.vscodeSourceControl,
  Ie.walkThrough,
  Ie.walkThroughSnippet,
  Ie.vscodeChatCodeBlock
]);
class eoe {
  constructor() {
    this._byResource = new Yn(), this._byOwner = /* @__PURE__ */ new Map();
  }
  set(e, t, i) {
    let n = this._byResource.get(e);
    n || (n = /* @__PURE__ */ new Map(), this._byResource.set(e, n)), n.set(t, i);
    let o = this._byOwner.get(t);
    o || (o = new Yn(), this._byOwner.set(t, o)), o.set(e, i);
  }
  get(e, t) {
    const i = this._byResource.get(e);
    return i == null ? void 0 : i.get(t);
  }
  delete(e, t) {
    let i = !1, n = !1;
    const o = this._byResource.get(e);
    o && (i = o.delete(t));
    const r = this._byOwner.get(t);
    if (r && (n = r.delete(e)), i !== n)
      throw new Error("illegal state");
    return i && n;
  }
  values(e) {
    var t, i;
    return typeof e == "string" ? ((t = this._byOwner.get(e)) == null ? void 0 : t.values()) ?? nt.empty() : we.isUri(e) ? ((i = this._byResource.get(e)) == null ? void 0 : i.values()) ?? nt.empty() : nt.map(nt.concat(...this._byOwner.values()), (n) => n[1]);
  }
}
class toe {
  constructor(e) {
    this.errors = 0, this.infos = 0, this.warnings = 0, this.unknowns = 0, this._data = new Yn(), this._service = e, this._subscription = e.onMarkerChanged(this._update, this);
  }
  dispose() {
    this._subscription.dispose();
  }
  _update(e) {
    for (const t of e) {
      const i = this._data.get(t);
      i && this._substract(i);
      const n = this._resourceStats(t);
      this._add(n), this._data.set(t, n);
    }
  }
  _resourceStats(e) {
    const t = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };
    if (Jse.has(e.scheme))
      return t;
    for (const { severity: i } of this._service.read({ resource: e }))
      i === Bt.Error ? t.errors += 1 : i === Bt.Warning ? t.warnings += 1 : i === Bt.Info ? t.infos += 1 : t.unknowns += 1;
    return t;
  }
  _substract(e) {
    this.errors -= e.errors, this.warnings -= e.warnings, this.infos -= e.infos, this.unknowns -= e.unknowns;
  }
  _add(e) {
    this.errors += e.errors, this.warnings += e.warnings, this.infos += e.infos, this.unknowns += e.unknowns;
  }
}
class ul {
  constructor() {
    this._onMarkerChanged = new s4({
      delay: 0,
      merge: ul._merge
    }), this.onMarkerChanged = this._onMarkerChanged.event, this._data = new eoe(), this._stats = new toe(this);
  }
  dispose() {
    this._stats.dispose(), this._onMarkerChanged.dispose();
  }
  remove(e, t) {
    for (const i of t || [])
      this.changeOne(e, i, []);
  }
  changeOne(e, t, i) {
    if (iW(i))
      this._data.delete(t, e) && this._onMarkerChanged.fire([t]);
    else {
      const n = [];
      for (const o of i) {
        const r = ul._toMarker(e, t, o);
        r && n.push(r);
      }
      this._data.set(t, e, n), this._onMarkerChanged.fire([t]);
    }
  }
  static _toMarker(e, t, i) {
    let { code: n, severity: o, message: r, source: a, startLineNumber: l, startColumn: c, endLineNumber: h, endColumn: d, relatedInformation: u, tags: f } = i;
    if (r)
      return l = l > 0 ? l : 1, c = c > 0 ? c : 1, h = h >= l ? h : l, d = d > 0 ? d : c, {
        resource: t,
        owner: e,
        code: n,
        severity: o,
        message: r,
        source: a,
        startLineNumber: l,
        startColumn: c,
        endLineNumber: h,
        endColumn: d,
        relatedInformation: u,
        tags: f
      };
  }
  changeAll(e, t) {
    const i = [], n = this._data.values(e);
    if (n)
      for (const o of n) {
        const r = nt.first(o);
        r && (i.push(r.resource), this._data.delete(r.resource, e));
      }
    if (co(t)) {
      const o = new Yn();
      for (const { resource: r, marker: a } of t) {
        const l = ul._toMarker(e, r, a);
        if (!l)
          continue;
        const c = o.get(r);
        c ? c.push(l) : (o.set(r, [l]), i.push(r));
      }
      for (const [r, a] of o)
        this._data.set(r, e, a);
    }
    i.length > 0 && this._onMarkerChanged.fire(i);
  }
  read(e = /* @__PURE__ */ Object.create(null)) {
    let { owner: t, resource: i, severities: n, take: o } = e;
    if ((!o || o < 0) && (o = -1), t && i) {
      const r = this._data.get(i, t);
      if (r) {
        const a = [];
        for (const l of r)
          if (ul._accept(l, n)) {
            const c = a.push(l);
            if (o > 0 && c === o)
              break;
          }
        return a;
      } else
        return [];
    } else if (!t && !i) {
      const r = [];
      for (const a of this._data.values())
        for (const l of a)
          if (ul._accept(l, n)) {
            const c = r.push(l);
            if (o > 0 && c === o)
              return r;
          }
      return r;
    } else {
      const r = this._data.values(i ?? t), a = [];
      for (const l of r)
        for (const c of l)
          if (ul._accept(c, n)) {
            const h = a.push(c);
            if (o > 0 && h === o)
              return a;
          }
      return a;
    }
  }
  static _accept(e, t) {
    return t === void 0 || (t & e.severity) === e.severity;
  }
  // --- event debounce logic
  static _merge(e) {
    const t = new Yn();
    for (const i of e)
      for (const n of i)
        t.set(n, !0);
    return Array.from(t.keys());
  }
}
class ioe extends U {
  get configurationModel() {
    return this._configurationModel;
  }
  constructor(e) {
    super(), this.logService = e, this._configurationModel = Ni.createEmptyModel(this.logService);
  }
  reload() {
    return this.resetConfigurationModel(), this.configurationModel;
  }
  getConfigurationDefaultOverrides() {
    return {};
  }
  resetConfigurationModel() {
    this._configurationModel = Ni.createEmptyModel(this.logService);
    const e = Mi.as(hd.Configuration).getConfigurationProperties();
    this.updateConfigurationModel(Object.keys(e), e);
  }
  updateConfigurationModel(e, t) {
    const i = this.getConfigurationDefaultOverrides();
    for (const n of e) {
      const o = i[n], r = t[n];
      o !== void 0 ? this._configurationModel.setValue(n, o) : r ? this._configurationModel.setValue(n, r.default) : this._configurationModel.removeValue(n);
    }
  }
}
const Yw = Be("accessibilitySignalService"), Ye = class Ye {
  static register(e) {
    return new Ye(e.fileName);
  }
  constructor(e) {
    this.fileName = e;
  }
};
Ye.error = Ye.register({ fileName: "error.mp3" }), Ye.warning = Ye.register({ fileName: "warning.mp3" }), Ye.success = Ye.register({ fileName: "success.mp3" }), Ye.foldedArea = Ye.register({ fileName: "foldedAreas.mp3" }), Ye.break = Ye.register({ fileName: "break.mp3" }), Ye.quickFixes = Ye.register({ fileName: "quickFixes.mp3" }), Ye.taskCompleted = Ye.register({ fileName: "taskCompleted.mp3" }), Ye.taskFailed = Ye.register({ fileName: "taskFailed.mp3" }), Ye.terminalBell = Ye.register({ fileName: "terminalBell.mp3" }), Ye.diffLineInserted = Ye.register({ fileName: "diffLineInserted.mp3" }), Ye.diffLineDeleted = Ye.register({ fileName: "diffLineDeleted.mp3" }), Ye.diffLineModified = Ye.register({ fileName: "diffLineModified.mp3" }), Ye.chatRequestSent = Ye.register({ fileName: "chatRequestSent.mp3" }), Ye.chatResponseReceived1 = Ye.register({ fileName: "chatResponseReceived1.mp3" }), Ye.chatResponseReceived2 = Ye.register({ fileName: "chatResponseReceived2.mp3" }), Ye.chatResponseReceived3 = Ye.register({ fileName: "chatResponseReceived3.mp3" }), Ye.chatResponseReceived4 = Ye.register({ fileName: "chatResponseReceived4.mp3" }), Ye.clear = Ye.register({ fileName: "clear.mp3" }), Ye.save = Ye.register({ fileName: "save.mp3" }), Ye.format = Ye.register({ fileName: "format.mp3" }), Ye.voiceRecordingStarted = Ye.register({ fileName: "voiceRecordingStarted.mp3" }), Ye.voiceRecordingStopped = Ye.register({ fileName: "voiceRecordingStopped.mp3" }), Ye.progress = Ye.register({ fileName: "progress.mp3" });
let Nt = Ye;
class noe {
  constructor(e) {
    this.randomOneOf = e;
  }
}
const Ee = class Ee {
  constructor(e, t, i, n, o, r) {
    this.sound = e, this.name = t, this.legacySoundSettingsKey = i, this.settingsKey = n, this.legacyAnnouncementSettingsKey = o, this.announcementMessage = r;
  }
  static register(e) {
    const t = new noe("randomOneOf" in e.sound ? e.sound.randomOneOf : [e.sound]), i = new Ee(t, e.name, e.legacySoundSettingsKey, e.settingsKey, e.legacyAnnouncementSettingsKey, e.announcementMessage);
    return Ee._signals.add(i), i;
  }
};
Ee._signals = /* @__PURE__ */ new Set(), Ee.errorAtPosition = Ee.register({
  name: m("accessibilitySignals.positionHasError.name", "Error at Position"),
  sound: Nt.error,
  announcementMessage: m("accessibility.signals.positionHasError", "Error"),
  settingsKey: "accessibility.signals.positionHasError",
  delaySettingsKey: "accessibility.signalOptions.delays.errorAtPosition"
}), Ee.warningAtPosition = Ee.register({
  name: m("accessibilitySignals.positionHasWarning.name", "Warning at Position"),
  sound: Nt.warning,
  announcementMessage: m("accessibility.signals.positionHasWarning", "Warning"),
  settingsKey: "accessibility.signals.positionHasWarning",
  delaySettingsKey: "accessibility.signalOptions.delays.warningAtPosition"
}), Ee.errorOnLine = Ee.register({
  name: m("accessibilitySignals.lineHasError.name", "Error on Line"),
  sound: Nt.error,
  legacySoundSettingsKey: "audioCues.lineHasError",
  legacyAnnouncementSettingsKey: "accessibility.alert.error",
  announcementMessage: m("accessibility.signals.lineHasError", "Error on Line"),
  settingsKey: "accessibility.signals.lineHasError"
}), Ee.warningOnLine = Ee.register({
  name: m("accessibilitySignals.lineHasWarning.name", "Warning on Line"),
  sound: Nt.warning,
  legacySoundSettingsKey: "audioCues.lineHasWarning",
  legacyAnnouncementSettingsKey: "accessibility.alert.warning",
  announcementMessage: m("accessibility.signals.lineHasWarning", "Warning on Line"),
  settingsKey: "accessibility.signals.lineHasWarning"
}), Ee.foldedArea = Ee.register({
  name: m("accessibilitySignals.lineHasFoldedArea.name", "Folded Area on Line"),
  sound: Nt.foldedArea,
  legacySoundSettingsKey: "audioCues.lineHasFoldedArea",
  legacyAnnouncementSettingsKey: "accessibility.alert.foldedArea",
  announcementMessage: m("accessibility.signals.lineHasFoldedArea", "Folded"),
  settingsKey: "accessibility.signals.lineHasFoldedArea"
}), Ee.break = Ee.register({
  name: m("accessibilitySignals.lineHasBreakpoint.name", "Breakpoint on Line"),
  sound: Nt.break,
  legacySoundSettingsKey: "audioCues.lineHasBreakpoint",
  legacyAnnouncementSettingsKey: "accessibility.alert.breakpoint",
  announcementMessage: m("accessibility.signals.lineHasBreakpoint", "Breakpoint"),
  settingsKey: "accessibility.signals.lineHasBreakpoint"
}), Ee.inlineSuggestion = Ee.register({
  name: m("accessibilitySignals.lineHasInlineSuggestion.name", "Inline Suggestion on Line"),
  sound: Nt.quickFixes,
  legacySoundSettingsKey: "audioCues.lineHasInlineSuggestion",
  settingsKey: "accessibility.signals.lineHasInlineSuggestion"
}), Ee.terminalQuickFix = Ee.register({
  name: m("accessibilitySignals.terminalQuickFix.name", "Terminal Quick Fix"),
  sound: Nt.quickFixes,
  legacySoundSettingsKey: "audioCues.terminalQuickFix",
  legacyAnnouncementSettingsKey: "accessibility.alert.terminalQuickFix",
  announcementMessage: m("accessibility.signals.terminalQuickFix", "Quick Fix"),
  settingsKey: "accessibility.signals.terminalQuickFix"
}), Ee.onDebugBreak = Ee.register({
  name: m("accessibilitySignals.onDebugBreak.name", "Debugger Stopped on Breakpoint"),
  sound: Nt.break,
  legacySoundSettingsKey: "audioCues.onDebugBreak",
  legacyAnnouncementSettingsKey: "accessibility.alert.onDebugBreak",
  announcementMessage: m("accessibility.signals.onDebugBreak", "Breakpoint"),
  settingsKey: "accessibility.signals.onDebugBreak"
}), Ee.noInlayHints = Ee.register({
  name: m("accessibilitySignals.noInlayHints", "No Inlay Hints on Line"),
  sound: Nt.error,
  legacySoundSettingsKey: "audioCues.noInlayHints",
  legacyAnnouncementSettingsKey: "accessibility.alert.noInlayHints",
  announcementMessage: m("accessibility.signals.noInlayHints", "No Inlay Hints"),
  settingsKey: "accessibility.signals.noInlayHints"
}), Ee.taskCompleted = Ee.register({
  name: m("accessibilitySignals.taskCompleted", "Task Completed"),
  sound: Nt.taskCompleted,
  legacySoundSettingsKey: "audioCues.taskCompleted",
  legacyAnnouncementSettingsKey: "accessibility.alert.taskCompleted",
  announcementMessage: m("accessibility.signals.taskCompleted", "Task Completed"),
  settingsKey: "accessibility.signals.taskCompleted"
}), Ee.taskFailed = Ee.register({
  name: m("accessibilitySignals.taskFailed", "Task Failed"),
  sound: Nt.taskFailed,
  legacySoundSettingsKey: "audioCues.taskFailed",
  legacyAnnouncementSettingsKey: "accessibility.alert.taskFailed",
  announcementMessage: m("accessibility.signals.taskFailed", "Task Failed"),
  settingsKey: "accessibility.signals.taskFailed"
}), Ee.terminalCommandFailed = Ee.register({
  name: m("accessibilitySignals.terminalCommandFailed", "Terminal Command Failed"),
  sound: Nt.error,
  legacySoundSettingsKey: "audioCues.terminalCommandFailed",
  legacyAnnouncementSettingsKey: "accessibility.alert.terminalCommandFailed",
  announcementMessage: m("accessibility.signals.terminalCommandFailed", "Command Failed"),
  settingsKey: "accessibility.signals.terminalCommandFailed"
}), Ee.terminalCommandSucceeded = Ee.register({
  name: m("accessibilitySignals.terminalCommandSucceeded", "Terminal Command Succeeded"),
  sound: Nt.success,
  announcementMessage: m("accessibility.signals.terminalCommandSucceeded", "Command Succeeded"),
  settingsKey: "accessibility.signals.terminalCommandSucceeded"
}), Ee.terminalBell = Ee.register({
  name: m("accessibilitySignals.terminalBell", "Terminal Bell"),
  sound: Nt.terminalBell,
  legacySoundSettingsKey: "audioCues.terminalBell",
  legacyAnnouncementSettingsKey: "accessibility.alert.terminalBell",
  announcementMessage: m("accessibility.signals.terminalBell", "Terminal Bell"),
  settingsKey: "accessibility.signals.terminalBell"
}), Ee.notebookCellCompleted = Ee.register({
  name: m("accessibilitySignals.notebookCellCompleted", "Notebook Cell Completed"),
  sound: Nt.taskCompleted,
  legacySoundSettingsKey: "audioCues.notebookCellCompleted",
  legacyAnnouncementSettingsKey: "accessibility.alert.notebookCellCompleted",
  announcementMessage: m("accessibility.signals.notebookCellCompleted", "Notebook Cell Completed"),
  settingsKey: "accessibility.signals.notebookCellCompleted"
}), Ee.notebookCellFailed = Ee.register({
  name: m("accessibilitySignals.notebookCellFailed", "Notebook Cell Failed"),
  sound: Nt.taskFailed,
  legacySoundSettingsKey: "audioCues.notebookCellFailed",
  legacyAnnouncementSettingsKey: "accessibility.alert.notebookCellFailed",
  announcementMessage: m("accessibility.signals.notebookCellFailed", "Notebook Cell Failed"),
  settingsKey: "accessibility.signals.notebookCellFailed"
}), Ee.diffLineInserted = Ee.register({
  name: m("accessibilitySignals.diffLineInserted", "Diff Line Inserted"),
  sound: Nt.diffLineInserted,
  legacySoundSettingsKey: "audioCues.diffLineInserted",
  settingsKey: "accessibility.signals.diffLineInserted"
}), Ee.diffLineDeleted = Ee.register({
  name: m("accessibilitySignals.diffLineDeleted", "Diff Line Deleted"),
  sound: Nt.diffLineDeleted,
  legacySoundSettingsKey: "audioCues.diffLineDeleted",
  settingsKey: "accessibility.signals.diffLineDeleted"
}), Ee.diffLineModified = Ee.register({
  name: m("accessibilitySignals.diffLineModified", "Diff Line Modified"),
  sound: Nt.diffLineModified,
  legacySoundSettingsKey: "audioCues.diffLineModified",
  settingsKey: "accessibility.signals.diffLineModified"
}), Ee.chatRequestSent = Ee.register({
  name: m("accessibilitySignals.chatRequestSent", "Chat Request Sent"),
  sound: Nt.chatRequestSent,
  legacySoundSettingsKey: "audioCues.chatRequestSent",
  legacyAnnouncementSettingsKey: "accessibility.alert.chatRequestSent",
  announcementMessage: m("accessibility.signals.chatRequestSent", "Chat Request Sent"),
  settingsKey: "accessibility.signals.chatRequestSent"
}), Ee.chatResponseReceived = Ee.register({
  name: m("accessibilitySignals.chatResponseReceived", "Chat Response Received"),
  legacySoundSettingsKey: "audioCues.chatResponseReceived",
  sound: {
    randomOneOf: [
      Nt.chatResponseReceived1,
      Nt.chatResponseReceived2,
      Nt.chatResponseReceived3,
      Nt.chatResponseReceived4
    ]
  },
  settingsKey: "accessibility.signals.chatResponseReceived"
}), Ee.progress = Ee.register({
  name: m("accessibilitySignals.progress", "Progress"),
  sound: Nt.progress,
  legacySoundSettingsKey: "audioCues.chatResponsePending",
  legacyAnnouncementSettingsKey: "accessibility.alert.progress",
  announcementMessage: m("accessibility.signals.progress", "Progress"),
  settingsKey: "accessibility.signals.progress"
}), Ee.clear = Ee.register({
  name: m("accessibilitySignals.clear", "Clear"),
  sound: Nt.clear,
  legacySoundSettingsKey: "audioCues.clear",
  legacyAnnouncementSettingsKey: "accessibility.alert.clear",
  announcementMessage: m("accessibility.signals.clear", "Clear"),
  settingsKey: "accessibility.signals.clear"
}), Ee.save = Ee.register({
  name: m("accessibilitySignals.save", "Save"),
  sound: Nt.save,
  legacySoundSettingsKey: "audioCues.save",
  legacyAnnouncementSettingsKey: "accessibility.alert.save",
  announcementMessage: m("accessibility.signals.save", "Save"),
  settingsKey: "accessibility.signals.save"
}), Ee.format = Ee.register({
  name: m("accessibilitySignals.format", "Format"),
  sound: Nt.format,
  legacySoundSettingsKey: "audioCues.format",
  legacyAnnouncementSettingsKey: "accessibility.alert.format",
  announcementMessage: m("accessibility.signals.format", "Format"),
  settingsKey: "accessibility.signals.format"
}), Ee.voiceRecordingStarted = Ee.register({
  name: m("accessibilitySignals.voiceRecordingStarted", "Voice Recording Started"),
  sound: Nt.voiceRecordingStarted,
  legacySoundSettingsKey: "audioCues.voiceRecordingStarted",
  settingsKey: "accessibility.signals.voiceRecordingStarted"
}), Ee.voiceRecordingStopped = Ee.register({
  name: m("accessibilitySignals.voiceRecordingStopped", "Voice Recording Stopped"),
  sound: Nt.voiceRecordingStopped,
  legacySoundSettingsKey: "audioCues.voiceRecordingStopped",
  settingsKey: "accessibility.signals.voiceRecordingStopped"
});
let xr = Ee;
class soe extends U {
  constructor(e, t = []) {
    super(), this.logger = new G8([e, ...t]), this._register(e.onDidChangeLogLevel((i) => this.setLevel(i)));
  }
  get onDidChangeLogLevel() {
    return this.logger.onDidChangeLogLevel;
  }
  setLevel(e) {
    this.logger.setLevel(e);
  }
  getLevel() {
    return this.logger.getLevel();
  }
  trace(e, ...t) {
    this.logger.trace(e, ...t);
  }
  debug(e, ...t) {
    this.logger.debug(e, ...t);
  }
  info(e, ...t) {
    this.logger.info(e, ...t);
  }
  warn(e, ...t) {
    this.logger.warn(e, ...t);
  }
  error(e, ...t) {
    this.logger.error(e, ...t);
  }
}
class ooe {
  getParseResult(e) {
  }
}
var Yr = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, si = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class roe {
  constructor(e) {
    this.disposed = !1, this.model = e, this._onWillDispose = new A();
  }
  get textEditorModel() {
    return this.model;
  }
  dispose() {
    this.disposed = !0, this._onWillDispose.fire();
  }
}
let bD = class {
  constructor(e) {
    this.modelService = e;
  }
  createModelReference(e) {
    const t = this.modelService.getModel(e);
    return t ? Promise.resolve(new Y9(new roe(t))) : Promise.reject(new Error("Model not found"));
  }
};
bD = Yr([
  si(0, Ui)
], bD);
const Tv = class Tv {
  show() {
    return Tv.NULL_PROGRESS_RUNNER;
  }
  async showWhile(e, t) {
    await e;
  }
};
Tv.NULL_PROGRESS_RUNNER = {
  done: () => {
  },
  total: () => {
  },
  worked: () => {
  }
};
let CD = Tv;
class aoe {
  withProgress(e, t, i) {
    return t({
      report: () => {
      }
    });
  }
}
class loe {
  constructor() {
    this.isExtensionDevelopment = !1, this.isBuilt = !1;
  }
}
class coe {
  async confirm(e) {
    return {
      confirmed: this.doConfirm(e.message, e.detail),
      checkboxChecked: !1
      // unsupported
    };
  }
  doConfirm(e, t) {
    let i = e;
    return t && (i = i + `

` + t), pt.confirm(i);
  }
  async prompt(e) {
    var n;
    let t;
    if (this.doConfirm(e.message, e.detail)) {
      const o = [...e.buttons ?? []];
      e.cancelButton && typeof e.cancelButton != "string" && typeof e.cancelButton != "boolean" && o.push(e.cancelButton), t = await ((n = o[0]) == null ? void 0 : n.run({ checkboxChecked: !1 }));
    }
    return { result: t };
  }
  async error(e, t) {
    await this.prompt({ type: Gt.Error, message: e, detail: t });
  }
}
const bm = class bm {
  info(e) {
    return this.notify({ severity: Gt.Info, message: e });
  }
  warn(e) {
    return this.notify({ severity: Gt.Warning, message: e });
  }
  error(e) {
    return this.notify({ severity: Gt.Error, message: e });
  }
  notify(e) {
    switch (e.severity) {
      case Gt.Error:
        console.error(e.message);
        break;
      case Gt.Warning:
        console.warn(e.message);
        break;
      default:
        console.log(e.message);
        break;
    }
    return bm.NO_OP;
  }
  prompt(e, t, i, n) {
    return bm.NO_OP;
  }
  status(e, t) {
    return U.None;
  }
};
bm.NO_OP = new AY();
let vD = bm, wD = class {
  constructor(e) {
    this._onWillExecuteCommand = new A(), this._onDidExecuteCommand = new A(), this.onDidExecuteCommand = this._onDidExecuteCommand.event, this._instantiationService = e;
  }
  executeCommand(e, ...t) {
    const i = St.getCommand(e);
    if (!i)
      return Promise.reject(new Error(`command '${e}' not found`));
    try {
      this._onWillExecuteCommand.fire({ commandId: e, args: t });
      const n = this._instantiationService.invokeFunction.apply(this._instantiationService, [i.handler, ...t]);
      return this._onDidExecuteCommand.fire({ commandId: e, args: t }), Promise.resolve(n);
    } catch (n) {
      return Promise.reject(n);
    }
  }
};
wD = Yr([
  si(0, Pe)
], wD);
let xf = class extends yne {
  constructor(e, t, i, n, o, r) {
    super(e, t, i, n, o), this._cachedResolver = null, this._dynamicKeybindings = [], this._domNodeListeners = [];
    const a = (f) => {
      const g = new ne();
      g.add(z(f, X.KEY_DOWN, (p) => {
        const _ = new Dt(p);
        this._dispatch(_, _.target) && (_.preventDefault(), _.stopPropagation());
      })), g.add(z(f, X.KEY_UP, (p) => {
        const _ = new Dt(p);
        this._singleModifierDispatch(_, _.target) && _.preventDefault();
      })), this._domNodeListeners.push(new hoe(f, g));
    }, l = (f) => {
      for (let g = 0; g < this._domNodeListeners.length; g++) {
        const p = this._domNodeListeners[g];
        p.domNode === f && (this._domNodeListeners.splice(g, 1), p.dispose());
      }
    }, c = (f) => {
      f.getOption(
        61
        /* EditorOption.inDiffEditor */
      ) || a(f.getContainerDomNode());
    }, h = (f) => {
      f.getOption(
        61
        /* EditorOption.inDiffEditor */
      ) || l(f.getContainerDomNode());
    };
    this._register(r.onCodeEditorAdd(c)), this._register(r.onCodeEditorRemove(h)), r.listCodeEditors().forEach(c);
    const d = (f) => {
      a(f.getContainerDomNode());
    }, u = (f) => {
      l(f.getContainerDomNode());
    };
    this._register(r.onDiffEditorAdd(d)), this._register(r.onDiffEditorRemove(u)), r.listDiffEditors().forEach(d);
  }
  addDynamicKeybinding(e, t, i, n) {
    return ao(St.registerCommand(e, i), this.addDynamicKeybindings([{
      keybinding: t,
      command: e,
      when: n
    }]));
  }
  addDynamicKeybindings(e) {
    const t = e.map((i) => ({
      keybinding: Uy(i.keybinding, bs),
      command: i.command ?? null,
      commandArgs: i.commandArgs,
      when: i.when,
      weight1: 1e3,
      weight2: 0,
      extensionId: null,
      isBuiltinExtension: !1
    }));
    return this._dynamicKeybindings = this._dynamicKeybindings.concat(t), this.updateResolver(), _e(() => {
      for (let i = 0; i < this._dynamicKeybindings.length; i++)
        if (this._dynamicKeybindings[i] === t[0]) {
          this._dynamicKeybindings.splice(i, t.length), this.updateResolver();
          return;
        }
    });
  }
  updateResolver() {
    this._cachedResolver = null, this._onDidUpdateKeybindings.fire();
  }
  _getResolver() {
    if (!this._cachedResolver) {
      const e = this._toNormalizedKeybindingItems(ts.getDefaultKeybindings(), !0), t = this._toNormalizedKeybindingItems(this._dynamicKeybindings, !1);
      this._cachedResolver = new tm(e, t, (i) => this._log(i));
    }
    return this._cachedResolver;
  }
  _documentHasFocus() {
    return pt.document.hasFocus();
  }
  _toNormalizedKeybindingItems(e, t) {
    const i = [];
    let n = 0;
    for (const o of e) {
      const r = o.when || void 0, a = o.keybinding;
      if (!a)
        i[n++] = new xA(void 0, o.command, o.commandArgs, r, t, null, !1);
      else {
        const l = bp.resolveKeybinding(a, bs);
        for (const c of l)
          i[n++] = new xA(c, o.command, o.commandArgs, r, t, null, !1);
      }
    }
    return i;
  }
  resolveKeyboardEvent(e) {
    const t = new Bh(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, e.keyCode);
    return new bp([t], bs);
  }
};
xf = Yr([
  si(0, Fe),
  si(1, fi),
  si(2, Jo),
  si(3, cn),
  si(4, Co),
  si(5, Tt)
], xf);
class hoe extends U {
  constructor(e, t) {
    super(), this.domNode = e, this._register(t);
  }
}
function tP(s) {
  return s && typeof s == "object" && (!s.overrideIdentifier || typeof s.overrideIdentifier == "string") && (!s.resource || s.resource instanceof we);
}
let NC = class {
  constructor(e) {
    this.logService = e, this._onDidChangeConfiguration = new A(), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    const t = new ioe(e);
    this._configuration = new qw(t.reload(), Ni.createEmptyModel(e), Ni.createEmptyModel(e), Ni.createEmptyModel(e), Ni.createEmptyModel(e), Ni.createEmptyModel(e), new Yn(), Ni.createEmptyModel(e), new Yn(), e), t.dispose();
  }
  getValue(e, t) {
    const i = typeof e == "string" ? e : void 0, n = tP(e) ? e : tP(t) ? t : {};
    return this._configuration.getValue(i, n, void 0);
  }
  updateValues(e) {
    const t = { data: this._configuration.toData() }, i = [];
    for (const n of e) {
      const [o, r] = n;
      this.getValue(o) !== r && (this._configuration.updateValue(o, r), i.push(o));
    }
    if (i.length > 0) {
      const n = new bne({ keys: i, overrides: [] }, t, this._configuration, void 0, this.logService);
      n.source = 8, this._onDidChangeConfiguration.fire(n);
    }
    return Promise.resolve();
  }
  updateValue(e, t, i, n) {
    return this.updateValues([[e, t]]);
  }
  inspect(e, t = {}) {
    return this._configuration.inspect(e, t, void 0);
  }
};
NC = Yr([
  si(0, Co)
], NC);
let yD = class {
  constructor(e, t, i) {
    this.configurationService = e, this.modelService = t, this.languageService = i, this._onDidChangeConfiguration = new A(), this.configurationService.onDidChangeConfiguration((n) => {
      this._onDidChangeConfiguration.fire({ affectedKeys: n.affectedKeys, affectsConfiguration: (o, r) => n.affectsConfiguration(r) });
    });
  }
  getValue(e, t, i) {
    const n = F.isIPosition(t) ? t : null, o = n ? typeof i == "string" ? i : void 0 : typeof t == "string" ? t : void 0, r = e ? this.getLanguage(e, n) : void 0;
    return typeof o > "u" ? this.configurationService.getValue({
      resource: e,
      overrideIdentifier: r
    }) : this.configurationService.getValue(o, {
      resource: e,
      overrideIdentifier: r
    });
  }
  getLanguage(e, t) {
    const i = this.modelService.getModel(e);
    return i ? t ? i.getLanguageIdAtPosition(t.lineNumber, t.column) : i.getLanguageId() : this.languageService.guessLanguageIdByFilepathOrFirstLine(e);
  }
};
yD = Yr([
  si(0, gt),
  si(1, Ui),
  si(2, ci)
], yD);
let SD = class {
  constructor(e) {
    this.configurationService = e;
  }
  getEOL(e, t) {
    const i = this.configurationService.getValue("files.eol", { overrideIdentifier: t, resource: e });
    return i && typeof i == "string" && i !== "auto" ? i : Rn || $e ? `
` : `\r
`;
  }
};
SD = Yr([
  si(0, gt)
], SD);
class doe {
  publicLog2() {
  }
}
const Cm = class Cm {
  constructor() {
    const e = we.from({ scheme: Cm.SCHEME, authority: "model", path: "/" });
    this.workspace = { id: Tne, folders: [new Ine({ uri: e, name: "", index: 0 })] };
  }
  getWorkspace() {
    return this.workspace;
  }
  getWorkspaceFolder(e) {
    return e && e.scheme === Cm.SCHEME ? this.workspace.folders[0] : null;
  }
};
Cm.SCHEME = "inmemory";
let LD = Cm;
function TC(s, e, t) {
  if (!e || !(s instanceof NC))
    return;
  const i = [];
  Object.keys(e).forEach((n) => {
    fne(n) && i.push([`editor.${n}`, e[n]]), t && gne(n) && i.push([`diffEditor.${n}`, e[n]]);
  }), i.length > 0 && s.updateValues(i);
}
let kD = class {
  constructor(e) {
    this._modelService = e;
  }
  hasPreviewHandler() {
    return !1;
  }
  async apply(e, t) {
    const i = Array.isArray(e) ? e : EN.convert(e), n = /* @__PURE__ */ new Map();
    for (const a of i) {
      if (!(a instanceof mh))
        throw new Error("bad edit - only text edits are supported");
      const l = this._modelService.getModel(a.resource);
      if (!l)
        throw new Error("bad edit - model not found");
      if (typeof a.versionId == "number" && l.getVersionId() !== a.versionId)
        throw new Error("bad state - model changed in the meantime");
      let c = n.get(l);
      c || (c = [], n.set(l, c)), c.push(R7.replaceMove(T.lift(a.textEdit.range), a.textEdit.text));
    }
    let o = 0, r = 0;
    for (const [a, l] of n)
      a.pushStackElement(), a.pushEditOperations([], l, () => []), a.pushStackElement(), r += 1, o += l.length;
    return {
      ariaSummary: Hb(Wx.bulkEditServiceSummary, o, r),
      isApplied: o > 0
    };
  }
};
kD = Yr([
  si(0, Ui)
], kD);
class uoe {
  getUriLabel(e, t) {
    return e.scheme === "file" ? e.fsPath : e.path;
  }
  getUriBasenameLabel(e) {
    return qo(e);
  }
}
let xD = class extends ane {
  constructor(e, t) {
    super(e), this._codeEditorService = t;
  }
  showContextView(e, t, i) {
    if (!t) {
      const n = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();
      n && (t = n.getContainerDomNode());
    }
    return super.showContextView(e, t, i);
  }
};
xD = Yr([
  si(0, oc),
  si(1, Tt)
], xD);
class foe {
  constructor() {
    this._neverEmitter = new A(), this.onDidChangeTrust = this._neverEmitter.event;
  }
  isWorkspaceTrusted() {
    return !0;
  }
}
class goe extends Vx {
  constructor() {
    super();
  }
}
class moe extends soe {
  constructor() {
    super(new q8());
  }
}
let DD = class extends $x {
  constructor(e, t, i, n, o, r) {
    super(e, t, i, n, o, r), this.configure({ blockMouse: !1 });
  }
};
DD = Yr([
  si(0, Jo),
  si(1, cn),
  si(2, fd),
  si(3, Lt),
  si(4, $r),
  si(5, Fe)
], DD);
const ED = {
  amdModuleId: "vs/editor/common/services/editorSimpleWorker",
  esmModuleLocation: void 0,
  label: "editorWorkerService"
};
let ID = class extends xx {
  constructor(e, t, i, n, o) {
    super(ED, e, t, i, n, o);
  }
};
ID = Yr([
  si(0, Ui),
  si(1, TN),
  si(2, Co),
  si(3, ir),
  si(4, De)
], ID);
class poe {
  async playSignal(e, t) {
  }
}
Ze(
  Co,
  moe,
  0
  /* InstantiationType.Eager */
);
Ze(
  gt,
  NC,
  0
  /* InstantiationType.Eager */
);
Ze(
  TN,
  yD,
  0
  /* InstantiationType.Eager */
);
Ze(
  s3,
  SD,
  0
  /* InstantiationType.Eager */
);
Ze(
  Ene,
  LD,
  0
  /* InstantiationType.Eager */
);
Ze(
  Bw,
  uoe,
  0
  /* InstantiationType.Eager */
);
Ze(
  Jo,
  doe,
  0
  /* InstantiationType.Eager */
);
Ze(
  a3,
  coe,
  0
  /* InstantiationType.Eager */
);
Ze(
  x7,
  loe,
  0
  /* InstantiationType.Eager */
);
Ze(
  cn,
  vD,
  0
  /* InstantiationType.Eager */
);
Ze(
  Zr,
  ul,
  0
  /* InstantiationType.Eager */
);
Ze(
  ci,
  goe,
  0
  /* InstantiationType.Eager */
);
Ze(
  yo,
  Wse,
  0
  /* InstantiationType.Eager */
);
Ze(
  Ui,
  Yx,
  0
  /* InstantiationType.Eager */
);
Ze(
  JE,
  Zx,
  0
  /* InstantiationType.Eager */
);
Ze(
  Fe,
  _D,
  0
  /* InstantiationType.Eager */
);
Ze(
  eJ,
  aoe,
  0
  /* InstantiationType.Eager */
);
Ze(
  Kp,
  CD,
  0
  /* InstantiationType.Eager */
);
Ze(
  zp,
  uX,
  0
  /* InstantiationType.Eager */
);
Ze(
  vd,
  ID,
  0
  /* InstantiationType.Eager */
);
Ze(
  O7,
  kD,
  0
  /* InstantiationType.Eager */
);
Ze(
  Mne,
  foe,
  0
  /* InstantiationType.Eager */
);
Ze(
  bo,
  bD,
  0
  /* InstantiationType.Eager */
);
Ze(
  Ks,
  fD,
  0
  /* InstantiationType.Eager */
);
Ze(
  js,
  DQ,
  0
  /* InstantiationType.Eager */
);
Ze(
  fi,
  wD,
  0
  /* InstantiationType.Eager */
);
Ze(
  Lt,
  xf,
  0
  /* InstantiationType.Eager */
);
Ze(
  Gw,
  hD,
  0
  /* InstantiationType.Eager */
);
Ze(
  fd,
  xD,
  0
  /* InstantiationType.Eager */
);
Ze(
  sr,
  Gx,
  0
  /* InstantiationType.Eager */
);
Ze(
  BN,
  mD,
  0
  /* InstantiationType.Eager */
);
Ze(
  nr,
  DD,
  0
  /* InstantiationType.Eager */
);
Ze(
  $r,
  KL,
  0
  /* InstantiationType.Eager */
);
Ze(
  Yw,
  poe,
  0
  /* InstantiationType.Eager */
);
Ze(
  CF,
  ooe,
  0
  /* InstantiationType.Eager */
);
var ge;
(function(s) {
  const e = new Hf();
  for (const [l, c] of K2())
    e.set(l, c);
  const t = new IC(e, !0);
  e.set(Pe, t);
  function i(l) {
    n || r({});
    const c = e.get(l);
    if (!c)
      throw new Error("Missing service " + l);
    return c instanceof Lr ? t.invokeFunction((h) => h.get(l)) : c;
  }
  s.get = i;
  let n = !1;
  const o = new A();
  function r(l) {
    if (n)
      return t;
    n = !0;
    for (const [h, d] of K2())
      e.get(h) || e.set(h, d);
    for (const h in l)
      if (l.hasOwnProperty(h)) {
        const d = Be(h);
        e.get(d) instanceof Lr && e.set(d, l[h]);
      }
    const c = WJ();
    for (const h of c)
      try {
        t.createInstance(h);
      } catch (d) {
        Je(d);
      }
    return o.fire(), t;
  }
  s.initialize = r;
  function a(l) {
    if (n)
      return l();
    const c = new ne(), h = c.add(o.event(() => {
      h.dispose(), c.add(l());
    }));
    return c;
  }
  s.withServices = a;
})(ge || (ge = {}));
function _oe(s, e) {
  return new boe(s, e);
}
class boe extends gC {
  constructor(e, t) {
    const i = {
      amdModuleId: ED.amdModuleId,
      esmModuleLocation: ED.esmModuleLocation,
      label: t.label
    };
    super(i, t.keepIdleModels || !1, e), this._foreignModuleId = t.moduleId, this._foreignModuleCreateData = t.createData || null, this._foreignModuleHost = t.host || null, this._foreignProxy = null;
  }
  // foreign host request
  fhr(e, t) {
    if (!this._foreignModuleHost || typeof this._foreignModuleHost[e] != "function")
      return Promise.reject(new Error("Missing method " + e + " or missing main thread foreign host."));
    try {
      return Promise.resolve(this._foreignModuleHost[e].apply(this._foreignModuleHost, t));
    } catch (i) {
      return Promise.reject(i);
    }
  }
  _getForeignProxy() {
    return this._foreignProxy || (this._foreignProxy = this._getProxy().then((e) => {
      const t = this._foreignModuleHost ? fS(this._foreignModuleHost) : [];
      return e.$loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, t).then((i) => {
        this._foreignModuleCreateData = null;
        const n = (a, l) => e.$fmr(a, l), o = (a, l) => function() {
          const c = Array.prototype.slice.call(arguments, 0);
          return l(a, c);
        }, r = {};
        for (const a of i)
          r[a] = o(a, n);
        return r;
      });
    })), this._foreignProxy;
  }
  getProxy() {
    return this._getForeignProxy();
  }
  withSyncedResources(e) {
    return this.workerWithSyncedResources(e).then((t) => this.getProxy());
  }
}
function Coe(s) {
  return Array.isArray(s);
}
function voe(s) {
  return !Coe(s);
}
function R3(s) {
  return typeof s == "string";
}
function iP(s) {
  return !R3(s);
}
function zc(s) {
  return !s;
}
function Va(s, e) {
  return s.ignoreCase && e ? e.toLowerCase() : e;
}
function nP(s) {
  return s.replace(/[&<>'"_]/g, "-");
}
function woe(s, e) {
  console.log(`${s.languageId}: ${e}`);
}
function xt(s, e) {
  return new Error(`${s.languageId}: ${e}`);
}
function vl(s, e, t, i, n) {
  const o = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
  let r = null;
  return e.replace(o, function(a, l, c, h, d, u, f, g, p) {
    return zc(c) ? zc(h) ? !zc(d) && d < i.length ? Va(s, i[d]) : !zc(f) && s && typeof s[f] == "string" ? s[f] : (r === null && (r = n.split("."), r.unshift(n)), !zc(u) && u < r.length ? Va(s, r[u]) : "") : Va(s, t) : "$";
  });
}
function yoe(s, e, t) {
  const i = /\$[sS](\d\d?)/g;
  let n = null;
  return e.replace(i, function(o, r) {
    return n === null && (n = t.split("."), n.unshift(t)), !zc(r) && r < n.length ? Va(s, n[r]) : "";
  });
}
function q_(s, e) {
  let t = e;
  for (; t && t.length > 0; ) {
    const i = s.tokenizer[t];
    if (i)
      return i;
    const n = t.lastIndexOf(".");
    n < 0 ? t = null : t = t.substr(0, n);
  }
  return null;
}
function Soe(s, e) {
  let t = e;
  for (; t && t.length > 0; ) {
    if (s.stateNames[t])
      return !0;
    const n = t.lastIndexOf(".");
    n < 0 ? t = null : t = t.substr(0, n);
  }
  return !1;
}
var Loe = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, koe = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, ND;
const A3 = 5, Mv = class Mv {
  static create(e, t) {
    return this._INSTANCE.create(e, t);
  }
  constructor(e) {
    this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
  }
  create(e, t) {
    if (e !== null && e.depth >= this._maxCacheDepth)
      return new Gu(e, t);
    let i = Gu.getStackElementId(e);
    i.length > 0 && (i += "|"), i += t;
    let n = this._entries[i];
    return n || (n = new Gu(e, t), this._entries[i] = n, n);
  }
};
Mv._INSTANCE = new Mv(A3);
let wp = Mv;
class Gu {
  constructor(e, t) {
    this.parent = e, this.state = t, this.depth = (this.parent ? this.parent.depth : 0) + 1;
  }
  static getStackElementId(e) {
    let t = "";
    for (; e !== null; )
      t.length > 0 && (t += "|"), t += e.state, e = e.parent;
    return t;
  }
  static _equals(e, t) {
    for (; e !== null && t !== null; ) {
      if (e === t)
        return !0;
      if (e.state !== t.state)
        return !1;
      e = e.parent, t = t.parent;
    }
    return e === null && t === null;
  }
  equals(e) {
    return Gu._equals(this, e);
  }
  push(e) {
    return wp.create(this, e);
  }
  pop() {
    return this.parent;
  }
  popall() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  switchTo(e) {
    return wp.create(this.parent, e);
  }
}
class uu {
  constructor(e, t) {
    this.languageId = e, this.state = t;
  }
  equals(e) {
    return this.languageId === e.languageId && this.state.equals(e.state);
  }
  clone() {
    return this.state.clone() === this.state ? this : new uu(this.languageId, this.state);
  }
}
const Rv = class Rv {
  static create(e, t) {
    return this._INSTANCE.create(e, t);
  }
  constructor(e) {
    this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
  }
  create(e, t) {
    if (t !== null)
      return new am(e, t);
    if (e !== null && e.depth >= this._maxCacheDepth)
      return new am(e, t);
    const i = Gu.getStackElementId(e);
    let n = this._entries[i];
    return n || (n = new am(e, null), this._entries[i] = n, n);
  }
};
Rv._INSTANCE = new Rv(A3);
let wl = Rv;
class am {
  constructor(e, t) {
    this.stack = e, this.embeddedLanguageData = t;
  }
  clone() {
    return (this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null) === this.embeddedLanguageData ? this : wl.create(this.stack, this.embeddedLanguageData);
  }
  equals(e) {
    return !(e instanceof am) || !this.stack.equals(e.stack) ? !1 : this.embeddedLanguageData === null && e.embeddedLanguageData === null ? !0 : this.embeddedLanguageData === null || e.embeddedLanguageData === null ? !1 : this.embeddedLanguageData.equals(e.embeddedLanguageData);
  }
}
class xoe {
  constructor() {
    this._tokens = [], this._languageId = null, this._lastTokenType = null, this._lastTokenLanguage = null;
  }
  enterLanguage(e) {
    this._languageId = e;
  }
  emit(e, t) {
    this._lastTokenType === t && this._lastTokenLanguage === this._languageId || (this._lastTokenType = t, this._lastTokenLanguage = this._languageId, this._tokens.push(new Km(e, t, this._languageId)));
  }
  nestedLanguageTokenize(e, t, i, n) {
    const o = i.languageId, r = i.state, a = ii.get(o);
    if (!a)
      return this.enterLanguage(o), this.emit(n, ""), r;
    const l = a.tokenize(e, t, r);
    if (n !== 0)
      for (const c of l.tokens)
        this._tokens.push(new Km(c.offset + n, c.type, c.language));
    else
      this._tokens = this._tokens.concat(l.tokens);
    return this._lastTokenType = null, this._lastTokenLanguage = null, this._languageId = null, l.endState;
  }
  finalize(e) {
    return new _I(this._tokens, e);
  }
}
class MC {
  constructor(e, t) {
    this._languageService = e, this._theme = t, this._prependTokens = null, this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0;
  }
  enterLanguage(e) {
    this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(e);
  }
  emit(e, t) {
    const i = this._theme.match(this._currentLanguageId, t) | 1024;
    this._lastTokenMetadata !== i && (this._lastTokenMetadata = i, this._tokens.push(e), this._tokens.push(i));
  }
  static _merge(e, t, i) {
    const n = e !== null ? e.length : 0, o = t.length, r = i !== null ? i.length : 0;
    if (n === 0 && o === 0 && r === 0)
      return new Uint32Array(0);
    if (n === 0 && o === 0)
      return i;
    if (o === 0 && r === 0)
      return e;
    const a = new Uint32Array(n + o + r);
    e !== null && a.set(e);
    for (let l = 0; l < o; l++)
      a[n + l] = t[l];
    return i !== null && a.set(i, n + o), a;
  }
  nestedLanguageTokenize(e, t, i, n) {
    const o = i.languageId, r = i.state, a = ii.get(o);
    if (!a)
      return this.enterLanguage(o), this.emit(n, ""), r;
    const l = a.tokenizeEncoded(e, t, r);
    if (n !== 0)
      for (let c = 0, h = l.tokens.length; c < h; c += 2)
        l.tokens[c] += n;
    return this._prependTokens = MC._merge(this._prependTokens, this._tokens, l.tokens), this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0, l.endState;
  }
  finalize(e) {
    return new kw(MC._merge(this._prependTokens, this._tokens, null), e);
  }
}
let yp = ND = class extends U {
  constructor(e, t, i, n, o) {
    super(), this._configurationService = o, this._languageService = e, this._standaloneThemeService = t, this._languageId = i, this._lexer = n, this._embeddedLanguages = /* @__PURE__ */ Object.create(null), this.embeddedLoaded = Promise.resolve(void 0);
    let r = !1;
    this._register(ii.onDidChange((a) => {
      if (r)
        return;
      let l = !1;
      for (let c = 0, h = a.changedLanguages.length; c < h; c++) {
        const d = a.changedLanguages[c];
        if (this._embeddedLanguages[d]) {
          l = !0;
          break;
        }
      }
      l && (r = !0, ii.handleChange([this._languageId]), r = !1);
    })), this._maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
      overrideIdentifier: this._languageId
    }), this._register(this._configurationService.onDidChangeConfiguration((a) => {
      a.affectsConfiguration("editor.maxTokenizationLineLength") && (this._maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
        overrideIdentifier: this._languageId
      }));
    }));
  }
  getLoadStatus() {
    const e = [];
    for (const t in this._embeddedLanguages) {
      const i = ii.get(t);
      if (i) {
        if (i instanceof ND) {
          const n = i.getLoadStatus();
          n.loaded === !1 && e.push(n.promise);
        }
        continue;
      }
      ii.isResolved(t) || e.push(ii.getOrCreate(t));
    }
    return e.length === 0 ? {
      loaded: !0
    } : {
      loaded: !1,
      promise: Promise.all(e).then((t) => {
      })
    };
  }
  getInitialState() {
    const e = wp.create(null, this._lexer.start);
    return wl.create(e, null);
  }
  tokenize(e, t, i) {
    if (e.length >= this._maxTokenizationLineLength)
      return _F(this._languageId, i);
    const n = new xoe(), o = this._tokenize(e, t, i, n);
    return n.finalize(o);
  }
  tokenizeEncoded(e, t, i) {
    if (e.length >= this._maxTokenizationLineLength)
      return WI(this._languageService.languageIdCodec.encodeLanguageId(this._languageId), i);
    const n = new MC(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme), o = this._tokenize(e, t, i, n);
    return n.finalize(o);
  }
  _tokenize(e, t, i, n) {
    return i.embeddedLanguageData ? this._nestedTokenize(e, t, i, 0, n) : this._myTokenize(e, t, i, 0, n);
  }
  _findLeavingNestedLanguageOffset(e, t) {
    let i = this._lexer.tokenizer[t.stack.state];
    if (!i && (i = q_(this._lexer, t.stack.state), !i))
      throw xt(this._lexer, "tokenizer state is not defined: " + t.stack.state);
    let n = -1, o = !1;
    for (const r of i) {
      if (!iP(r.action) || r.action.nextEmbedded !== "@pop")
        continue;
      o = !0;
      let a = r.resolveRegex(t.stack.state);
      const l = a.source;
      if (l.substr(0, 4) === "^(?:" && l.substr(l.length - 1, 1) === ")") {
        const h = (a.ignoreCase ? "i" : "") + (a.unicode ? "u" : "");
        a = new RegExp(l.substr(4, l.length - 5), h);
      }
      const c = e.search(a);
      c === -1 || c !== 0 && r.matchOnlyAtLineStart || (n === -1 || c < n) && (n = c);
    }
    if (!o)
      throw xt(this._lexer, 'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: ' + t.stack.state);
    return n;
  }
  _nestedTokenize(e, t, i, n, o) {
    const r = this._findLeavingNestedLanguageOffset(e, i);
    if (r === -1) {
      const c = o.nestedLanguageTokenize(e, t, i.embeddedLanguageData, n);
      return wl.create(i.stack, new uu(i.embeddedLanguageData.languageId, c));
    }
    const a = e.substring(0, r);
    a.length > 0 && o.nestedLanguageTokenize(a, !1, i.embeddedLanguageData, n);
    const l = e.substring(r);
    return this._myTokenize(l, t, i, n + r, o);
  }
  _safeRuleName(e) {
    return e ? e.name : "(unknown)";
  }
  _myTokenize(e, t, i, n, o) {
    o.enterLanguage(this._languageId);
    const r = e.length, a = t && this._lexer.includeLF ? e + `
` : e, l = a.length;
    let c = i.embeddedLanguageData, h = i.stack, d = 0, u = null, f = !0;
    for (; f || d < l; ) {
      const g = d, p = h.depth, _ = u ? u.groups.length : 0, b = h.state;
      let C = null, w = null, v = null, S = null, L = null;
      if (u) {
        C = u.matches;
        const I = u.groups.shift();
        w = I.matched, v = I.action, S = u.rule, u.groups.length === 0 && (u = null);
      } else {
        if (!f && d >= l)
          break;
        f = !1;
        let I = this._lexer.tokenizer[b];
        if (!I && (I = q_(this._lexer, b), !I))
          throw xt(this._lexer, "tokenizer state is not defined: " + b);
        const K = a.substr(d);
        for (const B of I)
          if ((d === 0 || !B.matchOnlyAtLineStart) && (C = K.match(B.resolveRegex(b)), C)) {
            w = C[0], v = B.action;
            break;
          }
      }
      if (C || (C = [""], w = ""), v || (d < l && (C = [a.charAt(d)], w = C[0]), v = this._lexer.defaultToken), w === null)
        break;
      for (d += w.length; voe(v) && iP(v) && v.test; )
        v = v.test(w, C, b, d === l);
      let k = null;
      if (typeof v == "string" || Array.isArray(v))
        k = v;
      else if (v.group)
        k = v.group;
      else if (v.token !== null && v.token !== void 0) {
        if (v.tokenSubst ? k = vl(this._lexer, v.token, w, C, b) : k = v.token, v.nextEmbedded)
          if (v.nextEmbedded === "@pop") {
            if (!c)
              throw xt(this._lexer, "cannot pop embedded language if not inside one");
            c = null;
          } else {
            if (c)
              throw xt(this._lexer, "cannot enter embedded language from within an embedded language");
            L = vl(this._lexer, v.nextEmbedded, w, C, b);
          }
        if (v.goBack && (d = Math.max(0, d - v.goBack)), v.switchTo && typeof v.switchTo == "string") {
          let I = vl(this._lexer, v.switchTo, w, C, b);
          if (I[0] === "@" && (I = I.substr(1)), q_(this._lexer, I))
            h = h.switchTo(I);
          else
            throw xt(this._lexer, "trying to switch to a state '" + I + "' that is undefined in rule: " + this._safeRuleName(S));
        } else {
          if (v.transform && typeof v.transform == "function")
            throw xt(this._lexer, "action.transform not supported");
          if (v.next)
            if (v.next === "@push") {
              if (h.depth >= this._lexer.maxStack)
                throw xt(this._lexer, "maximum tokenizer stack size reached: [" + h.state + "," + h.parent.state + ",...]");
              h = h.push(b);
            } else if (v.next === "@pop") {
              if (h.depth <= 1)
                throw xt(this._lexer, "trying to pop an empty stack in rule: " + this._safeRuleName(S));
              h = h.pop();
            } else if (v.next === "@popall")
              h = h.popall();
            else {
              let I = vl(this._lexer, v.next, w, C, b);
              if (I[0] === "@" && (I = I.substr(1)), q_(this._lexer, I))
                h = h.push(I);
              else
                throw xt(this._lexer, "trying to set a next state '" + I + "' that is undefined in rule: " + this._safeRuleName(S));
            }
        }
        v.log && typeof v.log == "string" && woe(this._lexer, this._lexer.languageId + ": " + vl(this._lexer, v.log, w, C, b));
      }
      if (k === null)
        throw xt(this._lexer, "lexer rule has no well-defined action in rule: " + this._safeRuleName(S));
      const x = (I) => {
        const K = this._languageService.getLanguageIdByLanguageName(I) || this._languageService.getLanguageIdByMimeType(I) || I, B = this._getNestedEmbeddedLanguageData(K);
        if (d < l) {
          const W = e.substr(d);
          return this._nestedTokenize(W, t, wl.create(h, B), n + d, o);
        } else
          return wl.create(h, B);
      };
      if (Array.isArray(k)) {
        if (u && u.groups.length > 0)
          throw xt(this._lexer, "groups cannot be nested: " + this._safeRuleName(S));
        if (C.length !== k.length + 1)
          throw xt(this._lexer, "matched number of groups does not match the number of actions in rule: " + this._safeRuleName(S));
        let I = 0;
        for (let K = 1; K < C.length; K++)
          I += C[K].length;
        if (I !== w.length)
          throw xt(this._lexer, "with groups, all characters should be matched in consecutive groups in rule: " + this._safeRuleName(S));
        u = {
          rule: S,
          matches: C,
          groups: []
        };
        for (let K = 0; K < k.length; K++)
          u.groups[K] = {
            action: k[K],
            matched: C[K + 1]
          };
        d -= w.length;
        continue;
      } else {
        if (k === "@rematch" && (d -= w.length, w = "", C = null, k = "", L !== null))
          return x(L);
        if (w.length === 0) {
          if (l === 0 || p !== h.depth || b !== h.state || (u ? u.groups.length : 0) !== _)
            continue;
          throw xt(this._lexer, "no progress in tokenizer in rule: " + this._safeRuleName(S));
        }
        let I = null;
        if (R3(k) && k.indexOf("@brackets") === 0) {
          const K = k.substr(9), B = Doe(this._lexer, w);
          if (!B)
            throw xt(this._lexer, "@brackets token returned but no bracket defined as: " + w);
          I = nP(B.token + K);
        } else {
          const K = k === "" ? "" : k + this._lexer.tokenPostfix;
          I = nP(K);
        }
        g < r && o.emit(g + n, I);
      }
      if (L !== null)
        return x(L);
    }
    return wl.create(h, c);
  }
  _getNestedEmbeddedLanguageData(e) {
    if (!this._languageService.isRegisteredLanguageId(e))
      return new uu(e, ep);
    e !== this._languageId && (this._languageService.requestBasicLanguageFeatures(e), ii.getOrCreate(e), this._embeddedLanguages[e] = !0);
    const t = ii.get(e);
    return t ? new uu(e, t.getInitialState()) : new uu(e, ep);
  }
};
yp = ND = Loe([
  koe(4, gt)
], yp);
function Doe(s, e) {
  if (!e)
    return null;
  e = Va(s, e);
  const t = s.brackets;
  for (const i of t) {
    if (i.open === e)
      return {
        token: i.token,
        bracketType: 1
        /* monarchCommon.MonarchBracket.Open */
      };
    if (i.close === e)
      return {
        token: i.token,
        bracketType: -1
        /* monarchCommon.MonarchBracket.Close */
      };
  }
  return null;
}
const xy = ud("standaloneColorizer", { createHTML: (s) => s });
class HN {
  static colorizeElement(e, t, i, n) {
    n = n || {};
    const o = n.theme || "vs", r = n.mimeType || i.getAttribute("lang") || i.getAttribute("data-lang");
    if (!r)
      return console.error("Mode not detected"), Promise.resolve();
    const a = t.getLanguageIdByMimeType(r) || r;
    e.setTheme(o);
    const l = i.firstChild ? i.firstChild.nodeValue : "";
    i.className += " " + o;
    const c = (h) => {
      const d = (xy == null ? void 0 : xy.createHTML(h)) ?? h;
      i.innerHTML = d;
    };
    return this.colorize(t, l || "", a, n).then(c, (h) => console.error(h));
  }
  static async colorize(e, t, i, n) {
    const o = e.languageIdCodec;
    let r = 4;
    n && typeof n.tabSize == "number" && (r = n.tabSize), mE(t) && (t = t.substr(1));
    const a = td(t);
    if (!e.isRegisteredLanguageId(i))
      return sP(a, r, o);
    const l = await ii.getOrCreate(i);
    return l ? Eoe(a, r, l, o) : sP(a, r, o);
  }
  static colorizeLine(e, t, i, n, o = 4) {
    const r = xs.isBasicASCII(e, t), a = xs.containsRTL(e, r, i);
    return yw(new Bf(!1, !0, e, !1, r, a, 0, n, [], o, 0, 0, 0, 0, -1, "none", !1, !1, null)).html;
  }
  static colorizeModelLine(e, t, i = 4) {
    const n = e.getLineContent(t);
    e.tokenization.forceTokenization(t);
    const r = e.tokenization.getLineTokens(t).inflate();
    return this.colorizeLine(n, e.mightContainNonBasicASCII(), e.mightContainRTL(), r, i);
  }
}
function Eoe(s, e, t, i) {
  return new Promise((n, o) => {
    const r = () => {
      const a = Ioe(s, e, t, i);
      if (t instanceof yp) {
        const l = t.getLoadStatus();
        if (l.loaded === !1) {
          l.promise.then(r, o);
          return;
        }
      }
      n(a);
    };
    r();
  });
}
function sP(s, e, t) {
  let i = [];
  const o = new Uint32Array(2);
  o[0] = 0, o[1] = 33587200;
  for (let r = 0, a = s.length; r < a; r++) {
    const l = s[r];
    o[0] = l.length;
    const c = new Ti(o, l, t), h = xs.isBasicASCII(
      l,
      /* check for basic ASCII */
      !0
    ), d = xs.containsRTL(
      l,
      h,
      /* check for RTL */
      !0
    ), u = yw(new Bf(!1, !0, l, !1, h, d, 0, c, [], e, 0, 0, 0, 0, -1, "none", !1, !1, null));
    i = i.concat(u.html), i.push("<br/>");
  }
  return i.join("");
}
function Ioe(s, e, t, i) {
  let n = [], o = t.getInitialState();
  for (let r = 0, a = s.length; r < a; r++) {
    const l = s[r], c = t.tokenizeEncoded(l, !0, o);
    Ti.convertToEndOffset(c.tokens, l.length);
    const h = new Ti(c.tokens, l, i), d = xs.isBasicASCII(
      l,
      /* check for basic ASCII */
      !0
    ), u = xs.containsRTL(
      l,
      d,
      /* check for RTL */
      !0
    ), f = yw(new Bf(!1, !0, l, !1, d, u, 0, h.inflate(), [], e, 0, 0, 0, 0, -1, "none", !1, !1, null));
    n = n.concat(f.html), n.push("<br/>"), o = c.endState;
  }
  return n.join("");
}
function Noe(s, e, t, i) {
  if (s.length === 0)
    return e;
  if (e.length === 0)
    return s;
  const n = [];
  let o = 0, r = 0;
  for (; o < s.length && r < e.length; ) {
    const a = s[o], l = e[r], c = t(a), h = t(l);
    c < h ? (n.push(a), o++) : c > h ? (n.push(l), r++) : (n.push(i(a, l)), o++, r++);
  }
  for (; o < s.length; )
    n.push(s[o]), o++;
  for (; r < e.length; )
    n.push(e[r]), r++;
  return n;
}
function RC(s, e) {
  const t = new ne(), i = s.createDecorationsCollection();
  return t.add(lw({ debugName: () => `Apply decorations from ${e.debugName}` }, (n) => {
    const o = e.read(n);
    i.set(o);
  })), t.add({
    dispose: () => {
      i.clear();
    }
  }), t;
}
function Ig(s, e) {
  return s.appendChild(e), _e(() => {
    e.remove();
  });
}
function Toe(s, e) {
  return s.prepend(e), _e(() => {
    e.remove();
  });
}
class P3 extends U {
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get automaticLayout() {
    return this._automaticLayout;
  }
  constructor(e, t) {
    super(), this._automaticLayout = !1, this.elementSizeObserver = this._register(new WO(e, t)), this._width = it(this, this.elementSizeObserver.getWidth()), this._height = it(this, this.elementSizeObserver.getHeight()), this._register(this.elementSizeObserver.onDidChange((i) => bi((n) => {
      this._width.set(this.elementSizeObserver.getWidth(), n), this._height.set(this.elementSizeObserver.getHeight(), n);
    })));
  }
  observe(e) {
    this.elementSizeObserver.observe(e);
  }
  setAutomaticLayout(e) {
    this._automaticLayout = e, e ? this.elementSizeObserver.startObserving() : this.elementSizeObserver.stopObserving();
  }
}
function oP(s, e, t) {
  let i = e.get(), n = i, o = i;
  const r = it("animatedValue", i);
  let a = -1;
  const l = 300;
  let c;
  t.add(cw({
    createEmptyChangeSummary: () => ({ animate: !1 }),
    handleChange: (d, u) => (d.didChange(e) && (u.animate = u.animate || d.change), !0)
  }, (d, u) => {
    c !== void 0 && (s.cancelAnimationFrame(c), c = void 0), n = o, i = e.read(d), a = Date.now() - (u.animate ? 0 : l), h();
  }));
  function h() {
    const d = Date.now() - a;
    o = Math.floor(Moe(d, n, i - n, l)), d < l ? c = s.requestAnimationFrame(h) : o = i, r.set(o, void 0);
  }
  return r;
}
function Moe(s, e, t, i) {
  return s === i ? e + t : t * (-Math.pow(2, -10 * s / i) + 1) + e;
}
class VN extends U {
  constructor(e, t, i) {
    super(), this._register(new TD(e, i)), this._register(ic(i, {
      height: t.actualHeight,
      top: t.actualTop
    }));
  }
}
class fu {
  get afterLineNumber() {
    return this._afterLineNumber.get();
  }
  constructor(e, t) {
    this._afterLineNumber = e, this.heightInPx = t, this.domNode = document.createElement("div"), this._actualTop = it(this, void 0), this._actualHeight = it(this, void 0), this.actualTop = this._actualTop, this.actualHeight = this._actualHeight, this.showInHiddenAreas = !0, this.onChange = this._afterLineNumber, this.onDomNodeTop = (i) => {
      this._actualTop.set(i, void 0);
    }, this.onComputedHeight = (i) => {
      this._actualHeight.set(i, void 0);
    };
  }
}
const Av = class Av {
  constructor(e, t) {
    this._editor = e, this._domElement = t, this._overlayWidgetId = `managedOverlayWidget-${Av._counter++}`, this._overlayWidget = {
      getId: () => this._overlayWidgetId,
      getDomNode: () => this._domElement,
      getPosition: () => null
    }, this._editor.addOverlayWidget(this._overlayWidget);
  }
  dispose() {
    this._editor.removeOverlayWidget(this._overlayWidget);
  }
};
Av._counter = 0;
let TD = Av;
function ic(s, e) {
  return Qe((t) => {
    for (let [i, n] of Object.entries(e))
      n && typeof n == "object" && "read" in n && (n = n.read(t)), typeof n == "number" && (n = `${n}px`), i = i.replace(/[A-Z]/g, (o) => "-" + o.toLowerCase()), s.style[i] = n;
  });
}
function AC(s, e, t, i) {
  const n = new ne(), o = [];
  return n.add(ho((r, a) => {
    const l = e.read(r), c = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map();
    t && t(!0), s.changeViewZones((d) => {
      for (const u of o)
        d.removeZone(u), i == null || i.delete(u);
      o.length = 0;
      for (const u of l) {
        const f = d.addZone(u);
        u.setZoneId && u.setZoneId(f), o.push(f), i == null || i.add(f), c.set(u, f);
      }
    }), t && t(!1), a.add(cw({
      createEmptyChangeSummary() {
        return { zoneIds: [] };
      },
      handleChange(d, u) {
        const f = h.get(d.changedObservable);
        return f !== void 0 && u.zoneIds.push(f), !0;
      }
    }, (d, u) => {
      for (const f of l)
        f.onChange && (h.set(f.onChange, c.get(f)), f.onChange.read(d));
      t && t(!0), s.changeViewZones((f) => {
        for (const g of u.zoneIds)
          f.layoutZone(g);
      }), t && t(!1);
    }));
  })), n.add({
    dispose() {
      t && t(!0), s.changeViewZones((r) => {
        for (const a of o)
          r.removeZone(a);
      }), i == null || i.clear(), t && t(!1);
    }
  }), n;
}
function rP(s, e) {
  const t = L1(e, (n) => n.original.startLineNumber <= s.lineNumber);
  if (!t)
    return T.fromPositions(s);
  if (t.original.endLineNumberExclusive <= s.lineNumber) {
    const n = s.lineNumber - t.original.endLineNumberExclusive + t.modified.endLineNumberExclusive;
    return T.fromPositions(new F(n, s.column));
  }
  if (!t.innerChanges)
    return T.fromPositions(new F(t.modified.startLineNumber, 1));
  const i = L1(t.innerChanges, (n) => n.originalRange.getStartPosition().isBeforeOrEqual(s));
  if (!i) {
    const n = s.lineNumber - t.original.startLineNumber + t.modified.startLineNumber;
    return T.fromPositions(new F(n, s.column));
  }
  if (i.originalRange.containsPosition(s))
    return i.modifiedRange;
  {
    const n = Roe(i.originalRange.getEndPosition(), s);
    return T.fromPositions(n.addToPosition(i.modifiedRange.getEndPosition()));
  }
}
function Roe(s, e) {
  return s.lineNumber === e.lineNumber ? new Xl(0, e.column - s.column) : new Xl(e.lineNumber - s.lineNumber, e.column - 1);
}
function Aoe(s, e) {
  let t;
  return s.filter((i) => {
    const n = e(i, t);
    return t = i, n;
  });
}
class PC {
  static create(e, t = void 0) {
    return new aP(e, e, t);
  }
  static createWithDisposable(e, t, i = void 0) {
    const n = new ne();
    return n.add(t), n.add(e), new aP(e, n, i);
  }
}
class aP extends PC {
  constructor(e, t, i) {
    super(), this.object = e, this._disposable = t, this._debugOwner = i, this._refCount = 1, this._isDisposed = !1, this._owners = [], i && this._addOwner(i);
  }
  _addOwner(e) {
    e && this._owners.push(e);
  }
  createNewRef(e) {
    return this._refCount++, e && this._addOwner(e), new Poe(this, e);
  }
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this._decreaseRefCount(this._debugOwner));
  }
  _decreaseRefCount(e) {
    if (this._refCount--, this._refCount === 0 && this._disposable.dispose(), e) {
      const t = this._owners.indexOf(e);
      t !== -1 && this._owners.splice(t, 1);
    }
  }
}
class Poe extends PC {
  constructor(e, t) {
    super(), this._base = e, this._debugOwner = t, this._isDisposed = !1;
  }
  get object() {
    return this._base.object;
  }
  createNewRef(e) {
    return this._base.createNewRef(e);
  }
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this._base._decreaseRefCount(this._debugOwner));
  }
}
var zN = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, UN = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const Ooe = $i("diff-review-insert", ie.add, m("accessibleDiffViewerInsertIcon", "Icon for 'Insert' in accessible diff viewer.")), Foe = $i("diff-review-remove", ie.remove, m("accessibleDiffViewerRemoveIcon", "Icon for 'Remove' in accessible diff viewer.")), Boe = $i("diff-review-close", ie.close, m("accessibleDiffViewerCloseIcon", "Icon for 'Close' in accessible diff viewer."));
var Ju;
let sh = (Ju = class extends U {
  constructor(e, t, i, n, o, r, a, l, c) {
    super(), this._parentNode = e, this._visible = t, this._setVisible = i, this._canClose = n, this._width = o, this._height = r, this._diffs = a, this._models = l, this._instantiationService = c, this._state = rd(this, (h, d) => {
      const u = this._visible.read(h);
      if (this._parentNode.style.visibility = u ? "visible" : "hidden", !u)
        return null;
      const f = d.add(this._instantiationService.createInstance(MD, this._diffs, this._models, this._setVisible, this._canClose)), g = d.add(this._instantiationService.createInstance(RD, this._parentNode, f, this._width, this._height, this._models));
      return { model: f, view: g };
    }).recomputeInitiallyAndOnChange(this._store);
  }
  next() {
    bi((e) => {
      const t = this._visible.get();
      this._setVisible(!0, e), t && this._state.get().model.nextGroup(e);
    });
  }
  prev() {
    bi((e) => {
      this._setVisible(!0, e), this._state.get().model.previousGroup(e);
    });
  }
  close() {
    bi((e) => {
      this._setVisible(!1, e);
    });
  }
}, Ju._ttPolicy = ud("diffReview", { createHTML: (e) => e }), Ju);
sh = zN([
  UN(8, Pe)
], sh);
let MD = class extends U {
  constructor(e, t, i, n, o) {
    super(), this._diffs = e, this._models = t, this._setVisible = i, this.canClose = n, this._accessibilitySignalService = o, this._groups = it(this, []), this._currentGroupIdx = it(this, 0), this._currentElementIdx = it(this, 0), this.groups = this._groups, this.currentGroup = this._currentGroupIdx.map((r, a) => this._groups.read(a)[r]), this.currentGroupIndex = this._currentGroupIdx, this.currentElement = this._currentElementIdx.map((r, a) => {
      var l;
      return (l = this.currentGroup.read(a)) == null ? void 0 : l.lines[r];
    }), this._register(Qe((r) => {
      const a = this._diffs.read(r);
      if (!a) {
        this._groups.set([], void 0);
        return;
      }
      const l = Woe(a, this._models.getOriginalModel().getLineCount(), this._models.getModifiedModel().getLineCount());
      bi((c) => {
        const h = this._models.getModifiedPosition();
        if (h) {
          const d = l.findIndex((u) => (h == null ? void 0 : h.lineNumber) < u.range.modified.endLineNumberExclusive);
          d !== -1 && this._currentGroupIdx.set(d, c);
        }
        this._groups.set(l, c);
      });
    })), this._register(Qe((r) => {
      const a = this.currentElement.read(r);
      (a == null ? void 0 : a.type) === mn.Deleted ? this._accessibilitySignalService.playSignal(xr.diffLineDeleted, { source: "accessibleDiffViewer.currentElementChanged" }) : (a == null ? void 0 : a.type) === mn.Added && this._accessibilitySignalService.playSignal(xr.diffLineInserted, { source: "accessibleDiffViewer.currentElementChanged" });
    })), this._register(Qe((r) => {
      const a = this.currentElement.read(r);
      if (a && a.type !== mn.Header) {
        const l = a.modifiedLineNumber ?? a.diff.modified.startLineNumber;
        this._models.modifiedSetSelection(T.fromPositions(new F(l, 1)));
      }
    }));
  }
  _goToGroupDelta(e, t) {
    const i = this.groups.get();
    !i || i.length <= 1 || ZE(t, (n) => {
      this._currentGroupIdx.set(Ne.ofLength(i.length).clipCyclic(this._currentGroupIdx.get() + e), n), this._currentElementIdx.set(0, n);
    });
  }
  nextGroup(e) {
    this._goToGroupDelta(1, e);
  }
  previousGroup(e) {
    this._goToGroupDelta(-1, e);
  }
  _goToLineDelta(e) {
    const t = this.currentGroup.get();
    !t || t.lines.length <= 1 || bi((i) => {
      this._currentElementIdx.set(Ne.ofLength(t.lines.length).clip(this._currentElementIdx.get() + e), i);
    });
  }
  goToNextLine() {
    this._goToLineDelta(1);
  }
  goToPreviousLine() {
    this._goToLineDelta(-1);
  }
  goToLine(e) {
    const t = this.currentGroup.get();
    if (!t)
      return;
    const i = t.lines.indexOf(e);
    i !== -1 && bi((n) => {
      this._currentElementIdx.set(i, n);
    });
  }
  revealCurrentElementInEditor() {
    if (!this.canClose.get())
      return;
    this._setVisible(!1, void 0);
    const e = this.currentElement.get();
    e && (e.type === mn.Deleted ? this._models.originalReveal(T.fromPositions(new F(e.originalLineNumber, 1))) : this._models.modifiedReveal(e.type !== mn.Header ? T.fromPositions(new F(e.modifiedLineNumber, 1)) : void 0));
  }
  close() {
    this.canClose.get() && (this._setVisible(!1, void 0), this._models.modifiedFocus());
  }
};
MD = zN([
  UN(4, Yw)
], MD);
const fg = 3;
function Woe(s, e, t) {
  const i = [];
  for (const n of HE(s, (o, r) => r.modified.startLineNumber - o.modified.endLineNumberExclusive < 2 * fg)) {
    const o = [];
    o.push(new Voe());
    const r = new pe(Math.max(1, n[0].original.startLineNumber - fg), Math.min(n[n.length - 1].original.endLineNumberExclusive + fg, e + 1)), a = new pe(Math.max(1, n[0].modified.startLineNumber - fg), Math.min(n[n.length - 1].modified.endLineNumberExclusive + fg, t + 1));
    dO(n, (h, d) => {
      const u = new pe(h ? h.original.endLineNumberExclusive : r.startLineNumber, d ? d.original.startLineNumber : r.endLineNumberExclusive), f = new pe(h ? h.modified.endLineNumberExclusive : a.startLineNumber, d ? d.modified.startLineNumber : a.endLineNumberExclusive);
      u.forEach((g) => {
        o.push(new $oe(g, f.startLineNumber + (g - u.startLineNumber)));
      }), d && (d.original.forEach((g) => {
        o.push(new zoe(d, g));
      }), d.modified.forEach((g) => {
        o.push(new Uoe(d, g));
      }));
    });
    const l = n[0].modified.join(n[n.length - 1].modified), c = n[0].original.join(n[n.length - 1].original);
    i.push(new Hoe(new an(l, c), o));
  }
  return i;
}
var mn;
(function(s) {
  s[s.Header = 0] = "Header", s[s.Unchanged = 1] = "Unchanged", s[s.Deleted = 2] = "Deleted", s[s.Added = 3] = "Added";
})(mn || (mn = {}));
class Hoe {
  constructor(e, t) {
    this.range = e, this.lines = t;
  }
}
class Voe {
  constructor() {
    this.type = mn.Header;
  }
}
class zoe {
  constructor(e, t) {
    this.diff = e, this.originalLineNumber = t, this.type = mn.Deleted, this.modifiedLineNumber = void 0;
  }
}
class Uoe {
  constructor(e, t) {
    this.diff = e, this.modifiedLineNumber = t, this.type = mn.Added, this.originalLineNumber = void 0;
  }
}
class $oe {
  constructor(e, t) {
    this.originalLineNumber = e, this.modifiedLineNumber = t, this.type = mn.Unchanged;
  }
}
let RD = class extends U {
  constructor(e, t, i, n, o, r) {
    super(), this._element = e, this._model = t, this._width = i, this._height = n, this._models = o, this._languageService = r, this.domNode = this._element, this.domNode.className = "monaco-component diff-review monaco-editor-background";
    const a = document.createElement("div");
    a.className = "diff-review-actions", this._actionBar = this._register(new $o(a)), this._register(Qe((l) => {
      this._actionBar.clear(), this._model.canClose.read(l) && this._actionBar.push(new ys("diffreview.close", m("label.close", "Close"), "close-diff-review " + Te.asClassName(Boe), !0, async () => t.close()), { label: !1, icon: !0 });
    })), this._content = document.createElement("div"), this._content.className = "diff-review-content", this._content.setAttribute("role", "code"), this._scrollbar = this._register(new qE(this._content, {})), _n(this.domNode, this._scrollbar.getDomNode(), a), this._register(Qe((l) => {
      this._height.read(l), this._width.read(l), this._scrollbar.scanDomNode();
    })), this._register(_e(() => {
      _n(this.domNode);
    })), this._register(ic(this.domNode, { width: this._width, height: this._height })), this._register(ic(this._content, { width: this._width, height: this._height })), this._register(ho((l, c) => {
      this._model.currentGroup.read(l), this._render(c);
    })), this._register(Zt(this.domNode, "keydown", (l) => {
      (l.equals(
        18
        /* KeyCode.DownArrow */
      ) || l.equals(
        2066
        /* KeyCode.DownArrow */
      ) || l.equals(
        530
        /* KeyCode.DownArrow */
      )) && (l.preventDefault(), this._model.goToNextLine()), (l.equals(
        16
        /* KeyCode.UpArrow */
      ) || l.equals(
        2064
        /* KeyCode.UpArrow */
      ) || l.equals(
        528
        /* KeyCode.UpArrow */
      )) && (l.preventDefault(), this._model.goToPreviousLine()), (l.equals(
        9
        /* KeyCode.Escape */
      ) || l.equals(
        2057
        /* KeyCode.Escape */
      ) || l.equals(
        521
        /* KeyCode.Escape */
      ) || l.equals(
        1033
        /* KeyCode.Escape */
      )) && (l.preventDefault(), this._model.close()), (l.equals(
        10
        /* KeyCode.Space */
      ) || l.equals(
        3
        /* KeyCode.Enter */
      )) && (l.preventDefault(), this._model.revealCurrentElementInEditor());
    }));
  }
  _render(e) {
    const t = this._models.getOriginalOptions(), i = this._models.getModifiedOptions(), n = document.createElement("div");
    n.className = "diff-review-table", n.setAttribute("role", "list"), n.setAttribute("aria-label", m("ariaLabel", "Accessible Diff Viewer. Use arrow up and down to navigate.")), Zi(n, i.get(
      50
      /* EditorOption.fontInfo */
    )), _n(this._content, n);
    const o = this._models.getOriginalModel(), r = this._models.getModifiedModel();
    if (!o || !r)
      return;
    const a = o.getOptions(), l = r.getOptions(), c = i.get(
      67
      /* EditorOption.lineHeight */
    ), h = this._model.currentGroup.get();
    for (const d of (h == null ? void 0 : h.lines) || []) {
      if (!h)
        break;
      let u;
      if (d.type === mn.Header) {
        const g = document.createElement("div");
        g.className = "diff-review-row", g.setAttribute("role", "listitem");
        const p = h.range, _ = this._model.currentGroupIndex.get(), b = this._model.groups.get().length, C = (L) => L === 0 ? m("no_lines_changed", "no lines changed") : L === 1 ? m("one_line_changed", "1 line changed") : m("more_lines_changed", "{0} lines changed", L), w = C(p.original.length), v = C(p.modified.length);
        g.setAttribute("aria-label", m({
          key: "header",
          comment: [
            "This is the ARIA label for a git diff header.",
            "A git diff header looks like this: @@ -154,12 +159,39 @@.",
            "That encodes that at original line 154 (which is now line 159), 12 lines were removed/changed with 39 lines.",
            "Variables 0 and 1 refer to the diff index out of total number of diffs.",
            "Variables 2 and 4 will be numbers (a line number).",
            'Variables 3 and 5 will be "no lines changed", "1 line changed" or "X lines changed", localized separately.'
          ]
        }, "Difference {0} of {1}: original line {2}, {3}, modified line {4}, {5}", _ + 1, b, p.original.startLineNumber, w, p.modified.startLineNumber, v));
        const S = document.createElement("div");
        S.className = "diff-review-cell diff-review-summary", S.appendChild(document.createTextNode(`${_ + 1}/${b}: @@ -${p.original.startLineNumber},${p.original.length} +${p.modified.startLineNumber},${p.modified.length} @@`)), g.appendChild(S), u = g;
      } else
        u = this._createRow(d, c, this._width.get(), t, o, a, i, r, l);
      n.appendChild(u);
      const f = xe((g) => (
        /** @description isSelected */
        this._model.currentElement.read(g) === d
      ));
      e.add(Qe((g) => {
        const p = f.read(g);
        u.tabIndex = p ? 0 : -1, p && u.focus();
      })), e.add(z(u, "focus", () => {
        this._model.goToLine(d);
      }));
    }
    this._scrollbar.scanDomNode();
  }
  _createRow(e, t, i, n, o, r, a, l, c) {
    const h = n.get(
      146
      /* EditorOption.layoutInfo */
    ), d = h.glyphMarginWidth + h.lineNumbersWidth, u = a.get(
      146
      /* EditorOption.layoutInfo */
    ), f = 10 + u.glyphMarginWidth + u.lineNumbersWidth;
    let g = "diff-review-row", p = "";
    const _ = "diff-review-spacer";
    let b = null;
    switch (e.type) {
      case mn.Added:
        g = "diff-review-row line-insert", p = " char-insert", b = Ooe;
        break;
      case mn.Deleted:
        g = "diff-review-row line-delete", p = " char-delete", b = Foe;
        break;
    }
    const C = document.createElement("div");
    C.style.minWidth = i + "px", C.className = g, C.setAttribute("role", "listitem"), C.ariaLevel = "";
    const w = document.createElement("div");
    w.className = "diff-review-cell", w.style.height = `${t}px`, C.appendChild(w);
    const v = document.createElement("span");
    v.style.width = d + "px", v.style.minWidth = d + "px", v.className = "diff-review-line-number" + p, e.originalLineNumber !== void 0 ? v.appendChild(document.createTextNode(String(e.originalLineNumber))) : v.innerText = " ", w.appendChild(v);
    const S = document.createElement("span");
    S.style.width = f + "px", S.style.minWidth = f + "px", S.style.paddingRight = "10px", S.className = "diff-review-line-number" + p, e.modifiedLineNumber !== void 0 ? S.appendChild(document.createTextNode(String(e.modifiedLineNumber))) : S.innerText = " ", w.appendChild(S);
    const L = document.createElement("span");
    if (L.className = _, b) {
      const I = document.createElement("span");
      I.className = Te.asClassName(b), I.innerText = "  ", L.appendChild(I);
    } else
      L.innerText = "  ";
    w.appendChild(L);
    let k;
    if (e.modifiedLineNumber !== void 0) {
      let I = this._getLineHtml(l, a, c.tabSize, e.modifiedLineNumber, this._languageService.languageIdCodec);
      sh._ttPolicy && (I = sh._ttPolicy.createHTML(I)), w.insertAdjacentHTML("beforeend", I), k = l.getLineContent(e.modifiedLineNumber);
    } else {
      let I = this._getLineHtml(o, n, r.tabSize, e.originalLineNumber, this._languageService.languageIdCodec);
      sh._ttPolicy && (I = sh._ttPolicy.createHTML(I)), w.insertAdjacentHTML("beforeend", I), k = o.getLineContent(e.originalLineNumber);
    }
    k.length === 0 && (k = m("blankLine", "blank"));
    let x = "";
    switch (e.type) {
      case mn.Unchanged:
        e.originalLineNumber === e.modifiedLineNumber ? x = m({ key: "unchangedLine", comment: ["The placeholders are contents of the line and should not be translated."] }, "{0} unchanged line {1}", k, e.originalLineNumber) : x = m("equalLine", "{0} original line {1} modified line {2}", k, e.originalLineNumber, e.modifiedLineNumber);
        break;
      case mn.Added:
        x = m("insertLine", "+ {0} modified line {1}", k, e.modifiedLineNumber);
        break;
      case mn.Deleted:
        x = m("deleteLine", "- {0} original line {1}", k, e.originalLineNumber);
        break;
    }
    return C.setAttribute("aria-label", x), C;
  }
  _getLineHtml(e, t, i, n, o) {
    const r = e.getLineContent(n), a = t.get(
      50
      /* EditorOption.fontInfo */
    ), l = Ti.createEmpty(r, o), c = xs.isBasicASCII(r, e.mightContainNonBasicASCII()), h = xs.containsRTL(r, c, e.mightContainRTL());
    return yw(new Bf(a.isMonospace && !t.get(
      33
      /* EditorOption.disableMonospaceOptimizations */
    ), a.canUseHalfwidthRightwardsArrow, r, !1, c, h, 0, l, [], i, 0, a.spaceWidth, a.middotWidth, a.wsmiddotWidth, t.get(
      118
      /* EditorOption.stopRenderingLineAfter */
    ), t.get(
      100
      /* EditorOption.renderWhitespace */
    ), t.get(
      95
      /* EditorOption.renderControlCharacters */
    ), t.get(
      51
      /* EditorOption.fontLigatures */
    ) !== $h.OFF, null)).html;
  }
};
RD = zN([
  UN(5, ci)
], RD);
class Koe {
  constructor(e) {
    this.editors = e;
  }
  getOriginalModel() {
    return this.editors.original.getModel();
  }
  getOriginalOptions() {
    return this.editors.original.getOptions();
  }
  originalReveal(e) {
    this.editors.original.revealRange(e), this.editors.original.setSelection(e), this.editors.original.focus();
  }
  getModifiedModel() {
    return this.editors.modified.getModel();
  }
  getModifiedOptions() {
    return this.editors.modified.getOptions();
  }
  modifiedReveal(e) {
    e && (this.editors.modified.revealRange(e), this.editors.modified.setSelection(e)), this.editors.modified.focus();
  }
  modifiedSetSelection(e) {
    this.editors.modified.setSelection(e);
  }
  modifiedFocus() {
    this.editors.modified.focus();
  }
  getModifiedPosition() {
    return this.editors.modified.getPosition() ?? void 0;
  }
}
E("diffEditor.move.border", "#8b8b8b9c", m("diffEditor.move.border", "The border color for text that got moved in the diff editor."));
E("diffEditor.moveActive.border", "#FFA500", m("diffEditor.moveActive.border", "The active border color for text that got moved in the diff editor."));
E("diffEditor.unchangedRegionShadow", { dark: "#000000", light: "#737373BF", hcDark: "#000000", hcLight: "#737373BF" }, m("diffEditor.unchangedRegionShadow", "The color of the shadow around unchanged region widgets."));
const joe = $i("diff-insert", ie.add, m("diffInsertIcon", "Line decoration for inserts in the diff editor.")), O3 = $i("diff-remove", ie.remove, m("diffRemoveIcon", "Line decoration for removals in the diff editor.")), lP = Wt.register({
  className: "line-insert",
  description: "line-insert",
  isWholeLine: !0,
  linesDecorationsClassName: "insert-sign " + Te.asClassName(joe),
  marginClassName: "gutter-insert"
}), cP = Wt.register({
  className: "line-delete",
  description: "line-delete",
  isWholeLine: !0,
  linesDecorationsClassName: "delete-sign " + Te.asClassName(O3),
  marginClassName: "gutter-delete"
}), hP = Wt.register({
  className: "line-insert",
  description: "line-insert",
  isWholeLine: !0,
  marginClassName: "gutter-insert"
}), dP = Wt.register({
  className: "line-delete",
  description: "line-delete",
  isWholeLine: !0,
  marginClassName: "gutter-delete"
}), uP = Wt.register({
  className: "char-insert",
  description: "char-insert",
  shouldFillLineOnLineBreak: !0
}), qoe = Wt.register({
  className: "char-insert",
  description: "char-insert",
  isWholeLine: !0
}), Goe = Wt.register({
  className: "char-insert diff-range-empty",
  description: "char-insert diff-range-empty"
}), AD = Wt.register({
  className: "char-delete",
  description: "char-delete",
  shouldFillLineOnLineBreak: !0
}), Zoe = Wt.register({
  className: "char-delete",
  description: "char-delete",
  isWholeLine: !0
}), Yoe = Wt.register({
  className: "char-delete diff-range-empty",
  description: "char-delete diff-range-empty"
});
var F3 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, PD = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, xc;
const B3 = Be("diffProviderFactoryService");
let OD = class {
  constructor(e) {
    this.instantiationService = e;
  }
  createDiffProvider(e) {
    return this.instantiationService.createInstance(FD, e);
  }
};
OD = F3([
  PD(0, Pe)
], OD);
Ze(
  B3,
  OD,
  1
  /* InstantiationType.Delayed */
);
var Ph;
let FD = (Ph = class {
  constructor(e, t, i) {
    this.editorWorkerService = t, this.telemetryService = i, this.onDidChangeEventEmitter = new A(), this.onDidChange = this.onDidChangeEventEmitter.event, this.diffAlgorithm = "advanced", this.diffAlgorithmOnDidChangeSubscription = void 0, this.setOptions(e);
  }
  dispose() {
    var e;
    (e = this.diffAlgorithmOnDidChangeSubscription) == null || e.dispose();
  }
  async computeDiff(e, t, i, n) {
    if (typeof this.diffAlgorithm != "string")
      return this.diffAlgorithm.computeDiff(e, t, i, n);
    if (e.isDisposed() || t.isDisposed())
      return {
        changes: [],
        identical: !0,
        quitEarly: !1,
        moves: []
      };
    if (e.getLineCount() === 1 && e.getLineMaxColumn(1) === 1)
      return t.getLineCount() === 1 && t.getLineMaxColumn(1) === 1 ? {
        changes: [],
        identical: !0,
        quitEarly: !1,
        moves: []
      } : {
        changes: [
          new Ls(new pe(1, 2), new pe(1, t.getLineCount() + 1), [
            new gs(e.getFullModelRange(), t.getFullModelRange())
          ])
        ],
        identical: !1,
        quitEarly: !1,
        moves: []
      };
    const o = JSON.stringify([e.uri.toString(), t.uri.toString()]), r = JSON.stringify([e.id, t.id, e.getAlternativeVersionId(), t.getAlternativeVersionId(), JSON.stringify(i)]), a = xc.diffCache.get(o);
    if (a && a.context === r)
      return a.result;
    const l = Ga.create(), c = await this.editorWorkerService.computeDiff(e.uri, t.uri, i, this.diffAlgorithm), h = l.elapsed();
    if (this.telemetryService.publicLog2("diffEditor.computeDiff", {
      timeMs: h,
      timedOut: (c == null ? void 0 : c.quitEarly) ?? !0,
      detectedMoves: i.computeMoves ? (c == null ? void 0 : c.moves.length) ?? 0 : -1
    }), n.isCancellationRequested)
      return {
        changes: [],
        identical: !1,
        quitEarly: !0,
        moves: []
      };
    if (!c)
      throw new Error("no diff result available");
    return xc.diffCache.size > 10 && xc.diffCache.delete(xc.diffCache.keys().next().value), xc.diffCache.set(o, { result: c, context: r }), c;
  }
  setOptions(e) {
    var i;
    let t = !1;
    e.diffAlgorithm && this.diffAlgorithm !== e.diffAlgorithm && ((i = this.diffAlgorithmOnDidChangeSubscription) == null || i.dispose(), this.diffAlgorithmOnDidChangeSubscription = void 0, this.diffAlgorithm = e.diffAlgorithm, typeof e.diffAlgorithm != "string" && (this.diffAlgorithmOnDidChangeSubscription = e.diffAlgorithm.onDidChange(() => this.onDidChangeEventEmitter.fire())), t = !0), t && this.onDidChangeEventEmitter.fire();
  }
}, xc = Ph, Ph.diffCache = /* @__PURE__ */ new Map(), Ph);
FD = xc = F3([
  PD(1, vd),
  PD(2, Jo)
], FD);
function $N() {
  return Ry && !!Ry.VSCODE_DEV;
}
function W3(s) {
  if ($N()) {
    const e = Xoe();
    return e.add(s), {
      dispose() {
        e.delete(s);
      }
    };
  } else
    return { dispose() {
    } };
}
function Xoe() {
  G_ || (G_ = /* @__PURE__ */ new Set());
  const s = globalThis;
  return s.$hotReload_applyNewExports || (s.$hotReload_applyNewExports = (e) => {
    const t = { config: { mode: void 0 }, ...e }, i = [];
    for (const n of G_) {
      const o = n(t);
      o && i.push(o);
    }
    if (i.length > 0)
      return (n) => {
        let o = !1;
        for (const r of i)
          r(n) && (o = !0);
        return o;
      };
  }), G_;
}
let G_;
$N() && W3(({ oldExports: s, newSrc: e, config: t }) => {
  if (t.mode === "patch-prototype")
    return (i) => {
      var n, o;
      for (const r in i) {
        const a = i[r];
        if (console.log(`[hot-reload] Patching prototype methods of '${r}'`, { exportedItem: a }), typeof a == "function" && a.prototype) {
          const l = s[r];
          if (l) {
            for (const c of Object.getOwnPropertyNames(a.prototype)) {
              const h = Object.getOwnPropertyDescriptor(a.prototype, c), d = Object.getOwnPropertyDescriptor(l.prototype, c);
              ((n = h == null ? void 0 : h.value) == null ? void 0 : n.toString()) !== ((o = d == null ? void 0 : d.value) == null ? void 0 : o.toString()) && console.log(`[hot-reload] Patching prototype method '${r}.${c}'`), Object.defineProperty(l.prototype, c, h);
            }
            i[r] = l;
          }
        }
      }
      return !0;
    };
});
function Js(s, e) {
  return Qoe([s], e), s;
}
function Qoe(s, e) {
  $N() && Ms("reload", (i) => W3(({ oldExports: n }) => {
    if ([...Object.values(n)].some((o) => s.includes(o)))
      return (o) => (i(void 0), !0);
  })).read(e);
}
var Joe = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, ere = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let BD = class extends U {
  setActiveMovedText(e) {
    this._activeMovedText.set(e, void 0);
  }
  constructor(e, t, i) {
    super(), this.model = e, this._options = t, this._diffProviderFactoryService = i, this._isDiffUpToDate = it(this, !1), this.isDiffUpToDate = this._isDiffUpToDate, this._diff = it(this, void 0), this.diff = this._diff, this._unchangedRegions = it(this, void 0), this.unchangedRegions = xe(this, (a) => {
      var l;
      return this._options.hideUnchangedRegions.read(a) ? ((l = this._unchangedRegions.read(a)) == null ? void 0 : l.regions) ?? [] : (bi((c) => {
        var h;
        for (const d of ((h = this._unchangedRegions.get()) == null ? void 0 : h.regions) || [])
          d.collapseAll(c);
      }), []);
    }), this.movedTextToCompare = it(this, void 0), this._activeMovedText = it(this, void 0), this._hoveredMovedText = it(this, void 0), this.activeMovedText = xe(this, (a) => this.movedTextToCompare.read(a) ?? this._hoveredMovedText.read(a) ?? this._activeMovedText.read(a)), this._cancellationTokenSource = new Vs(), this._diffProvider = xe(this, (a) => {
      const l = this._diffProviderFactoryService.createDiffProvider({
        diffAlgorithm: this._options.diffAlgorithm.read(a)
      }), c = Ms("onDidChange", l.onDidChange);
      return {
        diffProvider: l,
        onChangeSignal: c
      };
    }), this._register(_e(() => this._cancellationTokenSource.cancel()));
    const n = QE("contentChangedSignal"), o = this._register(new ai(() => n.trigger(void 0), 200));
    this._register(Qe((a) => {
      const l = this._unchangedRegions.read(a);
      if (!l || l.regions.some((g) => g.isDragged.read(a)))
        return;
      const c = l.originalDecorationIds.map((g) => e.original.getDecorationRange(g)).map((g) => g ? pe.fromRangeInclusive(g) : void 0), h = l.modifiedDecorationIds.map((g) => e.modified.getDecorationRange(g)).map((g) => g ? pe.fromRangeInclusive(g) : void 0), d = l.regions.map((g, p) => !c[p] || !h[p] ? void 0 : new Il(c[p].startLineNumber, h[p].startLineNumber, c[p].length, g.visibleLineCountTop.read(a), g.visibleLineCountBottom.read(a))).filter(nf), u = [];
      let f = !1;
      for (const g of HE(d, (p, _) => p.getHiddenModifiedRange(a).endLineNumberExclusive === _.getHiddenModifiedRange(a).startLineNumber))
        if (g.length > 1) {
          f = !0;
          const p = g.reduce((b, C) => b + C.lineCount, 0), _ = new Il(g[0].originalLineNumber, g[0].modifiedLineNumber, p, g[0].visibleLineCountTop.get(), g[g.length - 1].visibleLineCountBottom.get());
          u.push(_);
        } else
          u.push(g[0]);
      if (f) {
        const g = e.original.deltaDecorations(l.originalDecorationIds, u.map((_) => ({ range: _.originalUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } }))), p = e.modified.deltaDecorations(l.modifiedDecorationIds, u.map((_) => ({ range: _.modifiedUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } })));
        bi((_) => {
          this._unchangedRegions.set({
            regions: u,
            originalDecorationIds: g,
            modifiedDecorationIds: p
          }, _);
        });
      }
    }));
    const r = (a, l, c) => {
      const h = Il.fromDiffs(a.changes, e.original.getLineCount(), e.modified.getLineCount(), this._options.hideUnchangedRegionsMinimumLineCount.read(c), this._options.hideUnchangedRegionsContextLineCount.read(c));
      let d;
      const u = this._unchangedRegions.get();
      if (u) {
        const _ = u.originalDecorationIds.map((v) => e.original.getDecorationRange(v)).map((v) => v ? pe.fromRangeInclusive(v) : void 0), b = u.modifiedDecorationIds.map((v) => e.modified.getDecorationRange(v)).map((v) => v ? pe.fromRangeInclusive(v) : void 0);
        let w = Aoe(u.regions.map((v, S) => {
          if (!_[S] || !b[S])
            return;
          const L = _[S].length;
          return new Il(
            _[S].startLineNumber,
            b[S].startLineNumber,
            L,
            // The visible area can shrink by edits -> we have to account for this
            Math.min(v.visibleLineCountTop.get(), L),
            Math.min(v.visibleLineCountBottom.get(), L - v.visibleLineCountTop.get())
          );
        }).filter(nf), (v, S) => !S || v.modifiedLineNumber >= S.modifiedLineNumber + S.lineCount && v.originalLineNumber >= S.originalLineNumber + S.lineCount).map((v) => new an(v.getHiddenOriginalRange(c), v.getHiddenModifiedRange(c)));
        w = an.clip(w, pe.ofLength(1, e.original.getLineCount()), pe.ofLength(1, e.modified.getLineCount())), d = an.inverse(w, e.original.getLineCount(), e.modified.getLineCount());
      }
      const f = [];
      if (d)
        for (const _ of h) {
          const b = d.filter((C) => C.original.intersectsStrict(_.originalUnchangedRange) && C.modified.intersectsStrict(_.modifiedUnchangedRange));
          f.push(..._.setVisibleRanges(b, l));
        }
      else
        f.push(...h);
      const g = e.original.deltaDecorations((u == null ? void 0 : u.originalDecorationIds) || [], f.map((_) => ({ range: _.originalUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } }))), p = e.modified.deltaDecorations((u == null ? void 0 : u.modifiedDecorationIds) || [], f.map((_) => ({ range: _.modifiedUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } })));
      this._unchangedRegions.set({
        regions: f,
        originalDecorationIds: g,
        modifiedDecorationIds: p
      }, l);
    };
    this._register(e.modified.onDidChangeContent((a) => {
      if (this._diff.get()) {
        const c = Ia.fromModelContentChanges(a.changes);
        this._lastDiff, e.original, e.modified;
      }
      this._isDiffUpToDate.set(!1, void 0), o.schedule();
    })), this._register(e.original.onDidChangeContent((a) => {
      if (this._diff.get()) {
        const c = Ia.fromModelContentChanges(a.changes);
        this._lastDiff, e.original, e.modified;
      }
      this._isDiffUpToDate.set(!1, void 0), o.schedule();
    })), this._register(ho(async (a, l) => {
      this._options.hideUnchangedRegionsMinimumLineCount.read(a), this._options.hideUnchangedRegionsContextLineCount.read(a), o.cancel(), n.read(a);
      const c = this._diffProvider.read(a);
      c.onChangeSignal.read(a), Js(t3, a), Js(Lx, a), this._isDiffUpToDate.set(!1, void 0);
      let h = [];
      l.add(e.original.onDidChangeContent((f) => {
        const g = Ia.fromModelContentChanges(f.changes);
        h = T1(h, g);
      }));
      let d = [];
      l.add(e.modified.onDidChangeContent((f) => {
        const g = Ia.fromModelContentChanges(f.changes);
        d = T1(d, g);
      }));
      let u = await c.diffProvider.computeDiff(e.original, e.modified, {
        ignoreTrimWhitespace: this._options.ignoreTrimWhitespace.read(a),
        maxComputationTimeMs: this._options.maxComputationTimeMs.read(a),
        computeMoves: this._options.showMoves.read(a)
      }, this._cancellationTokenSource.token);
      this._cancellationTokenSource.token.isCancellationRequested || e.original.isDisposed() || e.modified.isDisposed() || (u = tre(u, e.original, e.modified), u = (e.original, e.modified, void 0) ?? u, u = (e.original, e.modified, void 0) ?? u, bi((f) => {
        r(u, f), this._lastDiff = u;
        const g = KN.fromDiffResult(u);
        this._diff.set(g, f), this._isDiffUpToDate.set(!0, f);
        const p = this.movedTextToCompare.get();
        this.movedTextToCompare.set(p ? this._lastDiff.moves.find((_) => _.lineRangeMapping.modified.intersect(p.lineRangeMapping.modified)) : void 0, f);
      }));
    }));
  }
  ensureModifiedLineIsVisible(e, t, i) {
    var o, r;
    if (((o = this.diff.get()) == null ? void 0 : o.mappings.length) === 0)
      return;
    const n = ((r = this._unchangedRegions.get()) == null ? void 0 : r.regions) || [];
    for (const a of n)
      if (a.getHiddenModifiedRange(void 0).contains(e)) {
        a.showModifiedLine(e, t, i);
        return;
      }
  }
  ensureOriginalLineIsVisible(e, t, i) {
    var o, r;
    if (((o = this.diff.get()) == null ? void 0 : o.mappings.length) === 0)
      return;
    const n = ((r = this._unchangedRegions.get()) == null ? void 0 : r.regions) || [];
    for (const a of n)
      if (a.getHiddenOriginalRange(void 0).contains(e)) {
        a.showOriginalLine(e, t, i);
        return;
      }
  }
  async waitForDiff() {
    await OH(this.isDiffUpToDate, (e) => e);
  }
  serializeState() {
    const e = this._unchangedRegions.get();
    return {
      collapsedRegions: e == null ? void 0 : e.regions.map((t) => ({ range: t.getHiddenModifiedRange(void 0).serialize() }))
    };
  }
  restoreSerializedState(e) {
    var n;
    const t = (n = e.collapsedRegions) == null ? void 0 : n.map((o) => pe.deserialize(o.range)), i = this._unchangedRegions.get();
    !i || !t || bi((o) => {
      for (const r of i.regions)
        for (const a of t)
          if (r.modifiedUnchangedRange.intersect(a)) {
            r.setHiddenModifiedRange(a, o);
            break;
          }
    });
  }
};
BD = Joe([
  ere(2, B3)
], BD);
function tre(s, e, t) {
  return {
    changes: s.changes.map((i) => new Ls(i.original, i.modified, i.innerChanges ? i.innerChanges.map((n) => ire(n, e, t)) : void 0)),
    moves: s.moves,
    identical: s.identical,
    quitEarly: s.quitEarly
  };
}
function ire(s, e, t) {
  let i = s.originalRange, n = s.modifiedRange;
  return i.startColumn === 1 && n.startColumn === 1 && (i.endColumn !== 1 || n.endColumn !== 1) && i.endColumn === e.getLineMaxColumn(i.endLineNumber) && n.endColumn === t.getLineMaxColumn(n.endLineNumber) && i.endLineNumber < e.getLineCount() && n.endLineNumber < t.getLineCount() && (i = i.setEndPosition(i.endLineNumber + 1, 1), n = n.setEndPosition(n.endLineNumber + 1, 1)), new gs(i, n);
}
class KN {
  static fromDiffResult(e) {
    return new KN(e.changes.map((t) => new H3(t)), e.moves || [], e.identical, e.quitEarly);
  }
  constructor(e, t, i, n) {
    this.mappings = e, this.movedTexts = t, this.identical = i, this.quitEarly = n;
  }
}
class H3 {
  constructor(e) {
    this.lineRangeMapping = e;
  }
}
class Il {
  static fromDiffs(e, t, i, n, o) {
    const r = Ls.inverse(e, t, i), a = [];
    for (const l of r) {
      let c = l.original.startLineNumber, h = l.modified.startLineNumber, d = l.original.length;
      const u = c === 1 && h === 1, f = c + d === t + 1 && h + d === i + 1;
      (u || f) && d >= o + n ? (u && !f && (d -= o), f && !u && (c += o, h += o, d -= o), a.push(new Il(c, h, d, 0, 0))) : d >= o * 2 + n && (c += o, h += o, d -= o * 2, a.push(new Il(c, h, d, 0, 0)));
    }
    return a;
  }
  get originalUnchangedRange() {
    return pe.ofLength(this.originalLineNumber, this.lineCount);
  }
  get modifiedUnchangedRange() {
    return pe.ofLength(this.modifiedLineNumber, this.lineCount);
  }
  constructor(e, t, i, n, o) {
    this.originalLineNumber = e, this.modifiedLineNumber = t, this.lineCount = i, this._visibleLineCountTop = it(this, 0), this.visibleLineCountTop = this._visibleLineCountTop, this._visibleLineCountBottom = it(this, 0), this.visibleLineCountBottom = this._visibleLineCountBottom, this._shouldHideControls = xe(this, (l) => (
      /** @description isVisible */
      this.visibleLineCountTop.read(l) + this.visibleLineCountBottom.read(l) === this.lineCount && !this.isDragged.read(l)
    )), this.isDragged = it(this, void 0);
    const r = Math.max(Math.min(n, this.lineCount), 0), a = Math.max(Math.min(o, this.lineCount - n), 0);
    C2(n === r), C2(o === a), this._visibleLineCountTop.set(r, void 0), this._visibleLineCountBottom.set(a, void 0);
  }
  setVisibleRanges(e, t) {
    const i = [], n = new Rs(e.map((l) => l.modified)).subtractFrom(this.modifiedUnchangedRange);
    let o = this.originalLineNumber, r = this.modifiedLineNumber;
    const a = this.modifiedLineNumber + this.lineCount;
    if (n.ranges.length === 0)
      this.showAll(t), i.push(this);
    else {
      let l = 0;
      for (const c of n.ranges) {
        const h = l === n.ranges.length - 1;
        l++;
        const d = (h ? a : c.endLineNumberExclusive) - r, u = new Il(o, r, d, 0, 0);
        u.setHiddenModifiedRange(c, t), i.push(u), o = u.originalUnchangedRange.endLineNumberExclusive, r = u.modifiedUnchangedRange.endLineNumberExclusive;
      }
    }
    return i;
  }
  shouldHideControls(e) {
    return this._shouldHideControls.read(e);
  }
  getHiddenOriginalRange(e) {
    return pe.ofLength(this.originalLineNumber + this._visibleLineCountTop.read(e), this.lineCount - this._visibleLineCountTop.read(e) - this._visibleLineCountBottom.read(e));
  }
  getHiddenModifiedRange(e) {
    return pe.ofLength(this.modifiedLineNumber + this._visibleLineCountTop.read(e), this.lineCount - this._visibleLineCountTop.read(e) - this._visibleLineCountBottom.read(e));
  }
  setHiddenModifiedRange(e, t) {
    const i = e.startLineNumber - this.modifiedLineNumber, n = this.modifiedLineNumber + this.lineCount - e.endLineNumberExclusive;
    this.setState(i, n, t);
  }
  getMaxVisibleLineCountTop() {
    return this.lineCount - this._visibleLineCountBottom.get();
  }
  getMaxVisibleLineCountBottom() {
    return this.lineCount - this._visibleLineCountTop.get();
  }
  showMoreAbove(e = 10, t) {
    const i = this.getMaxVisibleLineCountTop();
    this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + e, i), t);
  }
  showMoreBelow(e = 10, t) {
    const i = this.lineCount - this._visibleLineCountTop.get();
    this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + e, i), t);
  }
  showAll(e) {
    this._visibleLineCountBottom.set(this.lineCount - this._visibleLineCountTop.get(), e);
  }
  showModifiedLine(e, t, i) {
    const n = e + 1 - (this.modifiedLineNumber + this._visibleLineCountTop.get()), o = this.modifiedLineNumber - this._visibleLineCountBottom.get() + this.lineCount - e;
    t === 0 && n < o || t === 1 ? this._visibleLineCountTop.set(this._visibleLineCountTop.get() + n, i) : this._visibleLineCountBottom.set(this._visibleLineCountBottom.get() + o, i);
  }
  showOriginalLine(e, t, i) {
    const n = e - this.originalLineNumber, o = this.originalLineNumber + this.lineCount - e;
    t === 0 && n < o || t === 1 ? this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + o - n, this.getMaxVisibleLineCountTop()), i) : this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + n - o, this.getMaxVisibleLineCountBottom()), i);
  }
  collapseAll(e) {
    this._visibleLineCountTop.set(0, e), this._visibleLineCountBottom.set(0, e);
  }
  setState(e, t, i) {
    e = Math.max(Math.min(e, this.lineCount), 0), t = Math.max(Math.min(t, this.lineCount - e), 0), this._visibleLineCountTop.set(e, i), this._visibleLineCountBottom.set(t, i);
  }
}
class nre extends U {
  get visibility() {
    return this._visibility;
  }
  set visibility(e) {
    this._visibility !== e && (this._visibility = e, this._diffActions.style.visibility = e ? "visible" : "hidden");
  }
  constructor(e, t, i, n, o, r, a, l, c) {
    super(), this._getViewZoneId = e, this._marginDomNode = t, this._modifiedEditor = i, this._diff = n, this._editor = o, this._viewLineCounts = r, this._originalTextModel = a, this._contextMenuService = l, this._clipboardService = c, this._visibility = !1, this._marginDomNode.style.zIndex = "10", this._diffActions = document.createElement("div"), this._diffActions.className = Te.asClassName(ie.lightBulb) + " lightbulb-glyph", this._diffActions.style.position = "absolute";
    const h = this._modifiedEditor.getOption(
      67
      /* EditorOption.lineHeight */
    );
    this._diffActions.style.right = "0px", this._diffActions.style.visibility = "hidden", this._diffActions.style.height = `${h}px`, this._diffActions.style.lineHeight = `${h}px`, this._marginDomNode.appendChild(this._diffActions);
    let d = 0;
    const u = i.getOption(
      128
      /* EditorOption.useShadowDOM */
    ) && !Kl, f = (g, p) => {
      this._contextMenuService.showContextMenu({
        domForShadowRoot: u ? i.getDomNode() ?? void 0 : void 0,
        getAnchor: () => ({ x: g, y: p }),
        getActions: () => {
          const _ = [], b = n.modified.isEmpty;
          return _.push(new ys("diff.clipboard.copyDeletedContent", b ? n.original.length > 1 ? m("diff.clipboard.copyDeletedLinesContent.label", "Copy deleted lines") : m("diff.clipboard.copyDeletedLinesContent.single.label", "Copy deleted line") : n.original.length > 1 ? m("diff.clipboard.copyChangedLinesContent.label", "Copy changed lines") : m("diff.clipboard.copyChangedLinesContent.single.label", "Copy changed line"), void 0, !0, async () => {
            const w = this._originalTextModel.getValueInRange(n.original.toExclusiveRange());
            await this._clipboardService.writeText(w);
          })), n.original.length > 1 && _.push(new ys("diff.clipboard.copyDeletedLineContent", b ? m("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", n.original.startLineNumber + d) : m("diff.clipboard.copyChangedLineContent.label", "Copy changed line ({0})", n.original.startLineNumber + d), void 0, !0, async () => {
            let w = this._originalTextModel.getLineContent(n.original.startLineNumber + d);
            w === "" && (w = this._originalTextModel.getEndOfLineSequence() === 0 ? `
` : `\r
`), await this._clipboardService.writeText(w);
          })), i.getOption(
            92
            /* EditorOption.readOnly */
          ) || _.push(new ys("diff.inline.revertChange", m("diff.inline.revertChange.label", "Revert this change"), void 0, !0, async () => {
            this._editor.revert(this._diff);
          })), _;
        },
        autoSelectFirstItem: !0
      });
    };
    this._register(Zt(this._diffActions, "mousedown", (g) => {
      if (!g.leftButton)
        return;
      const { top: p, height: _ } = ui(this._diffActions), b = Math.floor(h / 3);
      g.preventDefault(), f(g.posx, p + _ + b);
    })), this._register(i.onMouseMove((g) => {
      (g.target.type === 8 || g.target.type === 5) && g.target.detail.viewZoneId === this._getViewZoneId() ? (d = this._updateLightBulbPosition(this._marginDomNode, g.event.browserEvent.y, h), this.visibility = !0) : this.visibility = !1;
    })), this._register(i.onMouseDown((g) => {
      g.event.leftButton && (g.target.type === 8 || g.target.type === 5) && g.target.detail.viewZoneId === this._getViewZoneId() && (g.event.preventDefault(), d = this._updateLightBulbPosition(this._marginDomNode, g.event.browserEvent.y, h), f(g.event.posx, g.event.posy + h));
    }));
  }
  _updateLightBulbPosition(e, t, i) {
    const { top: n } = ui(e), o = t - n, r = Math.floor(o / i), a = r * i;
    if (this._diffActions.style.top = `${a}px`, this._viewLineCounts) {
      let l = 0;
      for (let c = 0; c < this._viewLineCounts.length; c++)
        if (l += this._viewLineCounts[c], r < l)
          return c;
    }
    return r;
  }
}
const fP = ud("diffEditorWidget", { createHTML: (s) => s });
function sre(s, e, t, i) {
  Zi(i, e.fontInfo);
  const n = t.length > 0, o = new ww(1e4);
  let r = 0, a = 0;
  const l = [];
  for (let u = 0; u < s.lineTokens.length; u++) {
    const f = u + 1, g = s.lineTokens[u], p = s.lineBreakData[u], _ = ro.filter(t, f, 1, Number.MAX_SAFE_INTEGER);
    if (p) {
      let b = 0;
      for (const C of p.breakOffsets) {
        const w = g.sliceAndInflate(b, C, 0);
        r = Math.max(r, gP(a, w, ro.extractWrapped(_, b, C), n, s.mightContainNonBasicASCII, s.mightContainRTL, e, o)), a++, b = C;
      }
      l.push(p.breakOffsets.length);
    } else
      l.push(1), r = Math.max(r, gP(a, g, _, n, s.mightContainNonBasicASCII, s.mightContainRTL, e, o)), a++;
  }
  r += e.scrollBeyondLastColumn;
  const c = o.build(), h = fP ? fP.createHTML(c) : c;
  i.innerHTML = h;
  const d = r * e.typicalHalfwidthCharacterWidth;
  return {
    heightInLines: a,
    minWidthInPx: d,
    viewLineCounts: l
  };
}
class ore {
  constructor(e, t, i, n) {
    this.lineTokens = e, this.lineBreakData = t, this.mightContainNonBasicASCII = i, this.mightContainRTL = n;
  }
}
class jN {
  static fromEditor(e) {
    var o;
    const t = e.getOptions(), i = t.get(
      50
      /* EditorOption.fontInfo */
    ), n = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return new jN(((o = e.getModel()) == null ? void 0 : o.getOptions().tabSize) || 0, i, t.get(
      33
      /* EditorOption.disableMonospaceOptimizations */
    ), i.typicalHalfwidthCharacterWidth, t.get(
      105
      /* EditorOption.scrollBeyondLastColumn */
    ), t.get(
      67
      /* EditorOption.lineHeight */
    ), n.decorationsWidth, t.get(
      118
      /* EditorOption.stopRenderingLineAfter */
    ), t.get(
      100
      /* EditorOption.renderWhitespace */
    ), t.get(
      95
      /* EditorOption.renderControlCharacters */
    ), t.get(
      51
      /* EditorOption.fontLigatures */
    ));
  }
  constructor(e, t, i, n, o, r, a, l, c, h, d) {
    this.tabSize = e, this.fontInfo = t, this.disableMonospaceOptimizations = i, this.typicalHalfwidthCharacterWidth = n, this.scrollBeyondLastColumn = o, this.lineHeight = r, this.lineDecorationsWidth = a, this.stopRenderingLineAfter = l, this.renderWhitespace = c, this.renderControlCharacters = h, this.fontLigatures = d;
  }
}
function gP(s, e, t, i, n, o, r, a) {
  a.appendString('<div class="view-line'), i || a.appendString(" char-delete"), a.appendString('" style="top:'), a.appendString(String(s * r.lineHeight)), a.appendString('px;width:1000000px;">');
  const l = e.getLineContent(), c = xs.isBasicASCII(l, n), h = xs.containsRTL(l, c, o), d = fI(new Bf(
    r.fontInfo.isMonospace && !r.disableMonospaceOptimizations,
    r.fontInfo.canUseHalfwidthRightwardsArrow,
    l,
    !1,
    c,
    h,
    0,
    e,
    t,
    r.tabSize,
    0,
    r.fontInfo.spaceWidth,
    r.fontInfo.middotWidth,
    r.fontInfo.wsmiddotWidth,
    r.stopRenderingLineAfter,
    r.renderWhitespace,
    r.renderControlCharacters,
    r.fontLigatures !== $h.OFF,
    null
    // Send no selections, original line cannot be selected
  ), a);
  return a.appendString("</div>"), d.characterMapping.getHorizontalOffset(d.characterMapping.length);
}
var rre = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, mP = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let WD = class extends U {
  constructor(e, t, i, n, o, r, a, l, c, h) {
    super(), this._targetWindow = e, this._editors = t, this._diffModel = i, this._options = n, this._diffEditorWidget = o, this._canIgnoreViewZoneUpdateEvent = r, this._origViewZonesToIgnore = a, this._modViewZonesToIgnore = l, this._clipboardService = c, this._contextMenuService = h, this._originalTopPadding = it(this, 0), this._originalScrollOffset = it(this, 0), this._originalScrollOffsetAnimated = oP(this._targetWindow, this._originalScrollOffset, this._store), this._modifiedTopPadding = it(this, 0), this._modifiedScrollOffset = it(this, 0), this._modifiedScrollOffsetAnimated = oP(this._targetWindow, this._modifiedScrollOffset, this._store);
    const d = it("invalidateAlignmentsState", 0), u = this._register(new ai(() => {
      d.set(d.get() + 1, void 0);
    }, 0));
    this._register(this._editors.original.onDidChangeViewZones((w) => {
      this._canIgnoreViewZoneUpdateEvent() || u.schedule();
    })), this._register(this._editors.modified.onDidChangeViewZones((w) => {
      this._canIgnoreViewZoneUpdateEvent() || u.schedule();
    })), this._register(this._editors.original.onDidChangeConfiguration((w) => {
      (w.hasChanged(
        147
        /* EditorOption.wrappingInfo */
      ) || w.hasChanged(
        67
        /* EditorOption.lineHeight */
      )) && u.schedule();
    })), this._register(this._editors.modified.onDidChangeConfiguration((w) => {
      (w.hasChanged(
        147
        /* EditorOption.wrappingInfo */
      ) || w.hasChanged(
        67
        /* EditorOption.lineHeight */
      )) && u.schedule();
    }));
    const f = this._diffModel.map((w) => w ? zt(
      this,
      w.model.original.onDidChangeTokens,
      () => w.model.original.tokenization.backgroundTokenizationState === 2
      /* BackgroundTokenizationState.Completed */
    ) : void 0).map((w, v) => w == null ? void 0 : w.read(v)), g = xe((w) => {
      const v = this._diffModel.read(w), S = v == null ? void 0 : v.diff.read(w);
      if (!v || !S)
        return null;
      d.read(w);
      const k = this._options.renderSideBySide.read(w);
      return pP(this._editors.original, this._editors.modified, S.mappings, this._origViewZonesToIgnore, this._modViewZonesToIgnore, k);
    }), p = xe((w) => {
      var L;
      const v = (L = this._diffModel.read(w)) == null ? void 0 : L.movedTextToCompare.read(w);
      if (!v)
        return null;
      d.read(w);
      const S = v.changes.map((k) => new H3(k));
      return pP(this._editors.original, this._editors.modified, S, this._origViewZonesToIgnore, this._modViewZonesToIgnore, !0);
    });
    function _() {
      const w = document.createElement("div");
      return w.className = "diagonal-fill", w;
    }
    const b = this._register(new ne());
    this.viewZones = rd(this, (w, v) => {
      var re, be, Ce, At;
      b.clear();
      const S = g.read(w) || [], L = [], k = [], x = this._modifiedTopPadding.read(w);
      x > 0 && k.push({
        afterLineNumber: 0,
        domNode: document.createElement("div"),
        heightInPx: x,
        showInHiddenAreas: !0,
        suppressMouseDown: !0
      });
      const I = this._originalTopPadding.read(w);
      I > 0 && L.push({
        afterLineNumber: 0,
        domNode: document.createElement("div"),
        heightInPx: I,
        showInHiddenAreas: !0,
        suppressMouseDown: !0
      });
      const K = this._options.renderSideBySide.read(w), B = K || (re = this._editors.modified._getViewModel()) == null ? void 0 : re.createLineBreaksComputer();
      if (B) {
        const ye = this._editors.original.getModel();
        for (const ct of S)
          if (ct.diff)
            for (let ot = ct.originalRange.startLineNumber; ot < ct.originalRange.endLineNumberExclusive; ot++) {
              if (ot > ye.getLineCount())
                return { orig: L, mod: k };
              B == null || B.addRequest(ye.getLineContent(ot), null, null);
            }
      }
      const W = (B == null ? void 0 : B.finalize()) ?? [];
      let H = 0;
      const P = this._editors.modified.getOption(
        67
        /* EditorOption.lineHeight */
      ), q = (be = this._diffModel.read(w)) == null ? void 0 : be.movedTextToCompare.read(w), J = ((Ce = this._editors.original.getModel()) == null ? void 0 : Ce.mightContainNonBasicASCII()) ?? !1, oe = ((At = this._editors.original.getModel()) == null ? void 0 : At.mightContainRTL()) ?? !1, ae = jN.fromEditor(this._editors.modified);
      for (const ye of S)
        if (ye.diff && !K && (!this._options.useTrueInlineDiffRendering.read(w) || !qN(ye.diff))) {
          if (!ye.originalRange.isEmpty) {
            f.read(w);
            const ot = document.createElement("div");
            ot.classList.add("view-lines", "line-delete", "monaco-mouse-cursor-text");
            const Xt = this._editors.original.getModel();
            if (ye.originalRange.endLineNumberExclusive - 1 > Xt.getLineCount())
              return { orig: L, mod: k };
            const hn = new ore(ye.originalRange.mapToLineArray((di) => Xt.tokenization.getLineTokens(di)), ye.originalRange.mapToLineArray((di) => W[H++]), J, oe), Sn = [];
            for (const di of ye.diff.innerChanges || [])
              Sn.push(new Wg(
                di.originalRange.delta(-(ye.diff.original.startLineNumber - 1)),
                AD.className,
                0
                /* InlineDecorationType.Regular */
              ));
            const qs = sre(hn, ae, Sn, ot), as = document.createElement("div");
            if (as.className = "inline-deleted-margin-view-zone", Zi(as, ae.fontInfo), this._options.renderIndicators.read(w))
              for (let di = 0; di < qs.heightInLines; di++) {
                const Gs = document.createElement("div");
                Gs.className = `delete-sign ${Te.asClassName(O3)}`, Gs.setAttribute("style", `position:absolute;top:${di * P}px;width:${ae.lineDecorationsWidth}px;height:${P}px;right:0;`), as.appendChild(Gs);
              }
            let rc;
            b.add(new nre(() => r4(rc), as, this._editors.modified, ye.diff, this._diffEditorWidget, qs.viewLineCounts, this._editors.original.getModel(), this._contextMenuService, this._clipboardService));
            for (let di = 0; di < qs.viewLineCounts.length; di++) {
              const Gs = qs.viewLineCounts[di];
              Gs > 1 && L.push({
                afterLineNumber: ye.originalRange.startLineNumber + di,
                domNode: _(),
                heightInPx: (Gs - 1) * P,
                showInHiddenAreas: !0,
                suppressMouseDown: !0
              });
            }
            k.push({
              afterLineNumber: ye.modifiedRange.startLineNumber - 1,
              domNode: ot,
              heightInPx: qs.heightInLines * P,
              minWidthInPx: qs.minWidthInPx,
              marginDomNode: as,
              setZoneId(di) {
                rc = di;
              },
              showInHiddenAreas: !0,
              suppressMouseDown: !0
            });
          }
          const ct = document.createElement("div");
          ct.className = "gutter-delete", L.push({
            afterLineNumber: ye.originalRange.endLineNumberExclusive - 1,
            domNode: _(),
            heightInPx: ye.modifiedHeightInPx,
            marginDomNode: ct,
            showInHiddenAreas: !0,
            suppressMouseDown: !0
          });
        } else {
          const ct = ye.modifiedHeightInPx - ye.originalHeightInPx;
          if (ct > 0) {
            if (q != null && q.lineRangeMapping.original.delta(-1).deltaLength(2).contains(ye.originalRange.endLineNumberExclusive - 1))
              continue;
            L.push({
              afterLineNumber: ye.originalRange.endLineNumberExclusive - 1,
              domNode: _(),
              heightInPx: ct,
              showInHiddenAreas: !0,
              suppressMouseDown: !0
            });
          } else {
            let ot = function() {
              const hn = document.createElement("div");
              return hn.className = "arrow-revert-change " + Te.asClassName(ie.arrowRight), v.add(z(hn, "mousedown", (Sn) => Sn.stopPropagation())), v.add(z(hn, "click", (Sn) => {
                Sn.stopPropagation(), o.revert(ye.diff);
              })), he("div", {}, hn);
            };
            if (q != null && q.lineRangeMapping.modified.delta(-1).deltaLength(2).contains(ye.modifiedRange.endLineNumberExclusive - 1))
              continue;
            let Xt;
            ye.diff && ye.diff.modified.isEmpty && this._options.shouldRenderOldRevertArrows.read(w) && (Xt = ot()), k.push({
              afterLineNumber: ye.modifiedRange.endLineNumberExclusive - 1,
              domNode: _(),
              heightInPx: -ct,
              marginDomNode: Xt,
              showInHiddenAreas: !0,
              suppressMouseDown: !0
            });
          }
        }
      for (const ye of p.read(w) ?? []) {
        if (!(q != null && q.lineRangeMapping.original.intersect(ye.originalRange)) || !(q != null && q.lineRangeMapping.modified.intersect(ye.modifiedRange)))
          continue;
        const ct = ye.modifiedHeightInPx - ye.originalHeightInPx;
        ct > 0 ? L.push({
          afterLineNumber: ye.originalRange.endLineNumberExclusive - 1,
          domNode: _(),
          heightInPx: ct,
          showInHiddenAreas: !0,
          suppressMouseDown: !0
        }) : k.push({
          afterLineNumber: ye.modifiedRange.endLineNumberExclusive - 1,
          domNode: _(),
          heightInPx: -ct,
          showInHiddenAreas: !0,
          suppressMouseDown: !0
        });
      }
      return { orig: L, mod: k };
    });
    let C = !1;
    this._register(this._editors.original.onDidScrollChange((w) => {
      w.scrollLeftChanged && !C && (C = !0, this._editors.modified.setScrollLeft(w.scrollLeft), C = !1);
    })), this._register(this._editors.modified.onDidScrollChange((w) => {
      w.scrollLeftChanged && !C && (C = !0, this._editors.original.setScrollLeft(w.scrollLeft), C = !1);
    })), this._originalScrollTop = zt(this._editors.original.onDidScrollChange, () => (
      /** @description original.getScrollTop */
      this._editors.original.getScrollTop()
    )), this._modifiedScrollTop = zt(this._editors.modified.onDidScrollChange, () => (
      /** @description modified.getScrollTop */
      this._editors.modified.getScrollTop()
    )), this._register(Qe((w) => {
      const v = this._originalScrollTop.read(w) - (this._originalScrollOffsetAnimated.get() - this._modifiedScrollOffsetAnimated.read(w)) - (this._originalTopPadding.get() - this._modifiedTopPadding.read(w));
      v !== this._editors.modified.getScrollTop() && this._editors.modified.setScrollTop(
        v,
        1
        /* ScrollType.Immediate */
      );
    })), this._register(Qe((w) => {
      const v = this._modifiedScrollTop.read(w) - (this._modifiedScrollOffsetAnimated.get() - this._originalScrollOffsetAnimated.read(w)) - (this._modifiedTopPadding.get() - this._originalTopPadding.read(w));
      v !== this._editors.original.getScrollTop() && this._editors.original.setScrollTop(
        v,
        1
        /* ScrollType.Immediate */
      );
    })), this._register(Qe((w) => {
      var L;
      const v = (L = this._diffModel.read(w)) == null ? void 0 : L.movedTextToCompare.read(w);
      let S = 0;
      if (v) {
        const k = this._editors.original.getTopForLineNumber(v.lineRangeMapping.original.startLineNumber, !0) - this._originalTopPadding.get();
        S = this._editors.modified.getTopForLineNumber(v.lineRangeMapping.modified.startLineNumber, !0) - this._modifiedTopPadding.get() - k;
      }
      S > 0 ? (this._modifiedTopPadding.set(0, void 0), this._originalTopPadding.set(S, void 0)) : S < 0 ? (this._modifiedTopPadding.set(-S, void 0), this._originalTopPadding.set(0, void 0)) : setTimeout(() => {
        this._modifiedTopPadding.set(0, void 0), this._originalTopPadding.set(0, void 0);
      }, 400), this._editors.modified.hasTextFocus() ? this._originalScrollOffset.set(this._modifiedScrollOffset.get() - S, void 0, !0) : this._modifiedScrollOffset.set(this._originalScrollOffset.get() + S, void 0, !0);
    }));
  }
};
WD = rre([
  mP(8, BN),
  mP(9, nr)
], WD);
function pP(s, e, t, i, n, o) {
  const r = new $a(_P(s, i)), a = new $a(_P(e, n)), l = s.getOption(
    67
    /* EditorOption.lineHeight */
  ), c = e.getOption(
    67
    /* EditorOption.lineHeight */
  ), h = [];
  let d = 0, u = 0;
  function f(g, p) {
    for (; ; ) {
      let _ = r.peek(), b = a.peek();
      if (_ && _.lineNumber >= g && (_ = void 0), b && b.lineNumber >= p && (b = void 0), !_ && !b)
        break;
      const C = _ ? _.lineNumber - d : Number.MAX_VALUE, w = b ? b.lineNumber - u : Number.MAX_VALUE;
      C < w ? (r.dequeue(), b = {
        lineNumber: _.lineNumber - d + u,
        heightInPx: 0
      }) : C > w ? (a.dequeue(), _ = {
        lineNumber: b.lineNumber - u + d,
        heightInPx: 0
      }) : (r.dequeue(), a.dequeue()), h.push({
        originalRange: pe.ofLength(_.lineNumber, 1),
        modifiedRange: pe.ofLength(b.lineNumber, 1),
        originalHeightInPx: l + _.heightInPx,
        modifiedHeightInPx: c + b.heightInPx,
        diff: void 0
      });
    }
  }
  for (const g of t) {
    let w = function(v, S, L = !1) {
      var B, W;
      if (v < C || S < b)
        return;
      if (_)
        _ = !1;
      else if (!L && (v === C || S === b))
        return;
      const k = new pe(C, v), x = new pe(b, S);
      if (k.isEmpty && x.isEmpty)
        return;
      const I = ((B = r.takeWhile((H) => H.lineNumber < v)) == null ? void 0 : B.reduce((H, P) => H + P.heightInPx, 0)) ?? 0, K = ((W = a.takeWhile((H) => H.lineNumber < S)) == null ? void 0 : W.reduce((H, P) => H + P.heightInPx, 0)) ?? 0;
      h.push({
        originalRange: k,
        modifiedRange: x,
        originalHeightInPx: k.length * l + I,
        modifiedHeightInPx: x.length * c + K,
        diff: g.lineRangeMapping
      }), C = v, b = S;
    };
    const p = g.lineRangeMapping;
    f(p.original.startLineNumber, p.modified.startLineNumber);
    let _ = !0, b = p.modified.startLineNumber, C = p.original.startLineNumber;
    if (o)
      for (const v of p.innerChanges || []) {
        v.originalRange.startColumn > 1 && v.modifiedRange.startColumn > 1 && w(v.originalRange.startLineNumber, v.modifiedRange.startLineNumber);
        const S = s.getModel(), L = v.originalRange.endLineNumber <= S.getLineCount() ? S.getLineMaxColumn(v.originalRange.endLineNumber) : Number.MAX_SAFE_INTEGER;
        v.originalRange.endColumn < L && w(v.originalRange.endLineNumber, v.modifiedRange.endLineNumber);
      }
    w(p.original.endLineNumberExclusive, p.modified.endLineNumberExclusive, !0), d = p.original.endLineNumberExclusive, u = p.modified.endLineNumberExclusive;
  }
  return f(Number.MAX_VALUE, Number.MAX_VALUE), h;
}
function _P(s, e) {
  const t = [], i = [], n = s.getOption(
    147
    /* EditorOption.wrappingInfo */
  ).wrappingColumn !== -1, o = s._getViewModel().coordinatesConverter, r = s.getOption(
    67
    /* EditorOption.lineHeight */
  );
  if (n)
    for (let l = 1; l <= s.getModel().getLineCount(); l++) {
      const c = o.getModelLineViewLineCount(l);
      c > 1 && i.push({ lineNumber: l, heightInPx: r * (c - 1) });
    }
  for (const l of s.getWhitespaces()) {
    if (e.has(l.id))
      continue;
    const c = l.afterLineNumber === 0 ? 0 : o.convertViewPositionToModelPosition(new F(l.afterLineNumber, 1)).lineNumber;
    t.push({ lineNumber: c, heightInPx: l.height });
  }
  return Noe(t, i, (l) => l.lineNumber, (l, c) => ({ lineNumber: l.lineNumber, heightInPx: l.heightInPx + c.heightInPx }));
}
function qN(s) {
  return s.innerChanges ? s.innerChanges.every((e) => bP(e.modifiedRange) && bP(e.originalRange) || e.originalRange.equalsRange(new T(1, 1, 1, 1))) : !1;
}
function bP(s) {
  return s.startLineNumber === s.endLineNumber;
}
const vm = class vm extends U {
  constructor(e, t, i, n, o) {
    super(), this._rootElement = e, this._diffModel = t, this._originalEditorLayoutInfo = i, this._modifiedEditorLayoutInfo = n, this._editors = o, this._originalScrollTop = zt(this, this._editors.original.onDidScrollChange, () => this._editors.original.getScrollTop()), this._modifiedScrollTop = zt(this, this._editors.modified.onDidScrollChange, () => this._editors.modified.getScrollTop()), this._viewZonesChanged = Ms("onDidChangeViewZones", this._editors.modified.onDidChangeViewZones), this.width = it(this, 0), this._modifiedViewZonesChangedSignal = Ms("modified.onDidChangeViewZones", this._editors.modified.onDidChangeViewZones), this._originalViewZonesChangedSignal = Ms("original.onDidChangeViewZones", this._editors.original.onDidChangeViewZones), this._state = rd(this, (h, d) => {
      var k;
      this._element.replaceChildren();
      const u = this._diffModel.read(h), f = (k = u == null ? void 0 : u.diff.read(h)) == null ? void 0 : k.movedTexts;
      if (!f || f.length === 0) {
        this.width.set(0, void 0);
        return;
      }
      this._viewZonesChanged.read(h);
      const g = this._originalEditorLayoutInfo.read(h), p = this._modifiedEditorLayoutInfo.read(h);
      if (!g || !p) {
        this.width.set(0, void 0);
        return;
      }
      this._modifiedViewZonesChangedSignal.read(h), this._originalViewZonesChangedSignal.read(h);
      const _ = f.map((x) => {
        function I(ae, re) {
          const be = re.getTopForLineNumber(ae.startLineNumber, !0), Ce = re.getTopForLineNumber(ae.endLineNumberExclusive, !0);
          return (be + Ce) / 2;
        }
        const K = I(x.lineRangeMapping.original, this._editors.original), B = this._originalScrollTop.read(h), W = I(x.lineRangeMapping.modified, this._editors.modified), H = this._modifiedScrollTop.read(h), P = K - B, q = W - H, J = Math.min(K, W), oe = Math.max(K, W);
        return { range: new Ne(J, oe), from: P, to: q, fromWithoutScroll: K, toWithoutScroll: W, move: x };
      });
      _.sort(sW(Os((x) => x.fromWithoutScroll > x.toWithoutScroll, oW), Os((x) => x.fromWithoutScroll > x.toWithoutScroll ? x.fromWithoutScroll : -x.toWithoutScroll, Ba)));
      const b = GN.compute(_.map((x) => x.range)), C = 10, w = g.verticalScrollbarWidth, v = (b.getTrackCount() - 1) * 10 + C * 2, S = w + v + (p.contentLeft - vm.movedCodeBlockPadding);
      let L = 0;
      for (const x of _) {
        const I = b.getTrack(L), K = w + C + I * 10, B = 15, W = 15, H = S, P = p.glyphMarginWidth + p.lineNumbersWidth, q = 18, J = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        J.classList.add("arrow-rectangle"), J.setAttribute("x", `${H - P}`), J.setAttribute("y", `${x.to - q / 2}`), J.setAttribute("width", `${P}`), J.setAttribute("height", `${q}`), this._element.appendChild(J);
        const oe = document.createElementNS("http://www.w3.org/2000/svg", "g"), ae = document.createElementNS("http://www.w3.org/2000/svg", "path");
        ae.setAttribute("d", `M 0 ${x.from} L ${K} ${x.from} L ${K} ${x.to} L ${H - W} ${x.to}`), ae.setAttribute("fill", "none"), oe.appendChild(ae);
        const re = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        re.classList.add("arrow"), d.add(Qe((be) => {
          ae.classList.toggle("currentMove", x.move === u.activeMovedText.read(be)), re.classList.toggle("currentMove", x.move === u.activeMovedText.read(be));
        })), re.setAttribute("points", `${H - W},${x.to - B / 2} ${H},${x.to} ${H - W},${x.to + B / 2}`), oe.appendChild(re), this._element.appendChild(oe), L++;
      }
      this.width.set(v, void 0);
    }), this._element = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("class", "moved-blocks-lines"), this._rootElement.appendChild(this._element), this._register(_e(() => this._element.remove())), this._register(Qe((h) => {
      const d = this._originalEditorLayoutInfo.read(h), u = this._modifiedEditorLayoutInfo.read(h);
      !d || !u || (this._element.style.left = `${d.width - d.verticalScrollbarWidth}px`, this._element.style.height = `${d.height}px`, this._element.style.width = `${d.verticalScrollbarWidth + d.contentLeft - vm.movedCodeBlockPadding + this.width.read(h)}px`);
    })), this._register(dw(this._state));
    const r = xe((h) => {
      const d = this._diffModel.read(h), u = d == null ? void 0 : d.diff.read(h);
      return u ? u.movedTexts.map((f) => ({
        move: f,
        original: new fu(n1(f.lineRangeMapping.original.startLineNumber - 1), 18),
        modified: new fu(n1(f.lineRangeMapping.modified.startLineNumber - 1), 18)
      })) : [];
    });
    this._register(AC(this._editors.original, r.map((h) => (
      /** @description movedBlockViewZones.original */
      h.map((d) => d.original)
    )))), this._register(AC(this._editors.modified, r.map((h) => (
      /** @description movedBlockViewZones.modified */
      h.map((d) => d.modified)
    )))), this._register(ho((h, d) => {
      const u = r.read(h);
      for (const f of u)
        d.add(new CP(this._editors.original, f.original, f.move, "original", this._diffModel.get())), d.add(new CP(this._editors.modified, f.modified, f.move, "modified", this._diffModel.get()));
    }));
    const a = Ms("original.onDidFocusEditorWidget", (h) => this._editors.original.onDidFocusEditorWidget(() => setTimeout(() => h(void 0), 0))), l = Ms("modified.onDidFocusEditorWidget", (h) => this._editors.modified.onDidFocusEditorWidget(() => setTimeout(() => h(void 0), 0)));
    let c = "modified";
    this._register(cw({
      createEmptyChangeSummary: () => {
      },
      handleChange: (h, d) => (h.didChange(a) && (c = "original"), h.didChange(l) && (c = "modified"), !0)
    }, (h) => {
      a.read(h), l.read(h);
      const d = this._diffModel.read(h);
      if (!d)
        return;
      const u = d.diff.read(h);
      let f;
      if (u && c === "original") {
        const g = this._editors.originalCursor.read(h);
        g && (f = u.movedTexts.find((p) => p.lineRangeMapping.original.contains(g.lineNumber)));
      }
      if (u && c === "modified") {
        const g = this._editors.modifiedCursor.read(h);
        g && (f = u.movedTexts.find((p) => p.lineRangeMapping.modified.contains(g.lineNumber)));
      }
      f !== d.movedTextToCompare.get() && d.movedTextToCompare.set(void 0, void 0), d.setActiveMovedText(f);
    }));
  }
};
vm.movedCodeBlockPadding = 4;
let Zu = vm;
class GN {
  static compute(e) {
    const t = [], i = [];
    for (const n of e) {
      let o = t.findIndex((r) => !r.intersectsStrict(n));
      o === -1 && (t.length >= 6 ? o = vq(t, Os((a) => a.intersectWithRangeLength(n), Ba)) : (o = t.length, t.push(new BI()))), t[o].addRange(n), i.push(o);
    }
    return new GN(t.length, i);
  }
  constructor(e, t) {
    this._trackCount = e, this.trackPerLineIdx = t;
  }
  getTrack(e) {
    return this.trackPerLineIdx[e];
  }
  getTrackCount() {
    return this._trackCount;
  }
}
class CP extends VN {
  constructor(e, t, i, n, o) {
    const r = Xe("div.diff-hidden-lines-widget");
    super(e, t, r.root), this._editor = e, this._move = i, this._kind = n, this._diffModel = o, this._nodes = Xe("div.diff-moved-code-block", { style: { marginRight: "4px" } }, [
      Xe("div.text-content@textContent"),
      Xe("div.action-bar@actionBar")
    ]), r.root.appendChild(this._nodes.root);
    const a = zt(this._editor.onDidLayoutChange, () => this._editor.getLayoutInfo());
    this._register(ic(this._nodes.root, {
      paddingRight: a.map((u) => u.verticalScrollbarWidth)
    }));
    let l;
    i.changes.length > 0 ? l = this._kind === "original" ? m("codeMovedToWithChanges", "Code moved with changes to line {0}-{1}", this._move.lineRangeMapping.modified.startLineNumber, this._move.lineRangeMapping.modified.endLineNumberExclusive - 1) : m("codeMovedFromWithChanges", "Code moved with changes from line {0}-{1}", this._move.lineRangeMapping.original.startLineNumber, this._move.lineRangeMapping.original.endLineNumberExclusive - 1) : l = this._kind === "original" ? m("codeMovedTo", "Code moved to line {0}-{1}", this._move.lineRangeMapping.modified.startLineNumber, this._move.lineRangeMapping.modified.endLineNumberExclusive - 1) : m("codeMovedFrom", "Code moved from line {0}-{1}", this._move.lineRangeMapping.original.startLineNumber, this._move.lineRangeMapping.original.endLineNumberExclusive - 1);
    const c = this._register(new $o(this._nodes.actionBar, {
      highlightToggledItems: !0
    })), h = new ys("", l, "", !1);
    c.push(h, { icon: !1, label: !0 });
    const d = new ys("", "Compare", Te.asClassName(ie.compareChanges), !0, () => {
      this._editor.focus(), this._diffModel.movedTextToCompare.set(this._diffModel.movedTextToCompare.get() === i ? void 0 : this._move, void 0);
    });
    this._register(Qe((u) => {
      const f = this._diffModel.movedTextToCompare.read(u) === i;
      d.checked = f;
    })), c.push(d, { icon: !1, label: !0 });
  }
}
class are extends U {
  constructor(e, t, i, n) {
    super(), this._editors = e, this._diffModel = t, this._options = i, this._decorations = xe(this, (o) => {
      const r = this._diffModel.read(o), a = r == null ? void 0 : r.diff.read(o);
      if (!a)
        return null;
      const l = this._diffModel.read(o).movedTextToCompare.read(o), c = this._options.renderIndicators.read(o), h = this._options.showEmptyDecorations.read(o), d = [], u = [];
      if (!l)
        for (const g of a.mappings)
          if (g.lineRangeMapping.original.isEmpty || d.push({ range: g.lineRangeMapping.original.toInclusiveRange(), options: c ? cP : dP }), g.lineRangeMapping.modified.isEmpty || u.push({ range: g.lineRangeMapping.modified.toInclusiveRange(), options: c ? lP : hP }), g.lineRangeMapping.modified.isEmpty || g.lineRangeMapping.original.isEmpty)
            g.lineRangeMapping.original.isEmpty || d.push({ range: g.lineRangeMapping.original.toInclusiveRange(), options: Zoe }), g.lineRangeMapping.modified.isEmpty || u.push({ range: g.lineRangeMapping.modified.toInclusiveRange(), options: qoe });
          else {
            const p = this._options.useTrueInlineDiffRendering.read(o) && qN(g.lineRangeMapping);
            for (const _ of g.lineRangeMapping.innerChanges || [])
              if (g.lineRangeMapping.original.contains(_.originalRange.startLineNumber) && d.push({ range: _.originalRange, options: _.originalRange.isEmpty() && h ? Yoe : AD }), g.lineRangeMapping.modified.contains(_.modifiedRange.startLineNumber) && u.push({ range: _.modifiedRange, options: _.modifiedRange.isEmpty() && h && !p ? Goe : uP }), p) {
                const b = r.model.original.getValueInRange(_.originalRange);
                u.push({
                  range: _.modifiedRange,
                  options: {
                    description: "deleted-text",
                    before: {
                      content: b,
                      inlineClassName: "inline-deleted-text"
                    },
                    zIndex: 1e5,
                    showIfCollapsed: !0
                  }
                });
              }
          }
      if (l)
        for (const g of l.changes) {
          const p = g.original.toInclusiveRange();
          p && d.push({ range: p, options: c ? cP : dP });
          const _ = g.modified.toInclusiveRange();
          _ && u.push({ range: _, options: c ? lP : hP });
          for (const b of g.innerChanges || [])
            d.push({ range: b.originalRange, options: AD }), u.push({ range: b.modifiedRange, options: uP });
        }
      const f = this._diffModel.read(o).activeMovedText.read(o);
      for (const g of a.movedTexts)
        d.push({
          range: g.lineRangeMapping.original.toInclusiveRange(),
          options: {
            description: "moved",
            blockClassName: "movedOriginal" + (g === f ? " currentMove" : ""),
            blockPadding: [Zu.movedCodeBlockPadding, 0, Zu.movedCodeBlockPadding, Zu.movedCodeBlockPadding]
          }
        }), u.push({
          range: g.lineRangeMapping.modified.toInclusiveRange(),
          options: {
            description: "moved",
            blockClassName: "movedModified" + (g === f ? " currentMove" : ""),
            blockPadding: [4, 0, 4, 4]
          }
        });
      return { originalDecorations: d, modifiedDecorations: u };
    }), this._register(RC(this._editors.original, this._decorations.map((o) => (o == null ? void 0 : o.originalDecorations) || []))), this._register(RC(this._editors.modified, this._decorations.map((o) => (o == null ? void 0 : o.modifiedDecorations) || [])));
  }
}
class lre {
  resetSash() {
    this._sashRatio.set(void 0, void 0);
  }
  constructor(e, t) {
    this._options = e, this.dimensions = t, this.sashLeft = XE(this, (i) => {
      const n = this._sashRatio.read(i) ?? this._options.splitViewDefaultRatio.read(i);
      return this._computeSashLeft(n, i);
    }, (i, n) => {
      const o = this.dimensions.width.get();
      this._sashRatio.set(i / o, n);
    }), this._sashRatio = it(this, void 0);
  }
  /** @pure */
  _computeSashLeft(e, t) {
    const i = this.dimensions.width.read(t), n = Math.floor(this._options.splitViewDefaultRatio.read(t) * i), o = this._options.enableSplitViewResizing.read(t) ? Math.floor(e * i) : n, r = 100;
    return i <= r * 2 ? n : o < r ? r : o > i - r ? i - r : o;
  }
}
class V3 extends U {
  constructor(e, t, i, n, o, r) {
    super(), this._domNode = e, this._dimensions = t, this._enabled = i, this._boundarySashes = n, this.sashLeft = o, this._resetSash = r, this._sash = this._register(new on(this._domNode, {
      getVerticalSashTop: (a) => 0,
      getVerticalSashLeft: (a) => this.sashLeft.get(),
      getVerticalSashHeight: (a) => this._dimensions.height.get()
    }, {
      orientation: 0
      /* Orientation.VERTICAL */
    })), this._startSashPosition = void 0, this._register(this._sash.onDidStart(() => {
      this._startSashPosition = this.sashLeft.get();
    })), this._register(this._sash.onDidChange((a) => {
      this.sashLeft.set(this._startSashPosition + (a.currentX - a.startX), void 0);
    })), this._register(this._sash.onDidEnd(() => this._sash.layout())), this._register(this._sash.onDidReset(() => this._resetSash())), this._register(Qe((a) => {
      const l = this._boundarySashes.read(a);
      l && (this._sash.orthogonalEndSash = l.bottom);
    })), this._register(Qe((a) => {
      const l = this._enabled.read(a);
      this._sash.state = l ? 3 : 0, this.sashLeft.read(a), this._dimensions.height.read(a), this._sash.layout();
    }));
  }
}
class cre extends U {
  constructor(e, t, i) {
    super(), this._editor = e, this._domNode = t, this.itemProvider = i, this.scrollTop = zt(this, this._editor.onDidScrollChange, (r) => (
      /** @description editor.onDidScrollChange */
      this._editor.getScrollTop()
    )), this.isScrollTopZero = this.scrollTop.map((r) => (
      /** @description isScrollTopZero */
      r === 0
    )), this.modelAttached = zt(this, this._editor.onDidChangeModel, (r) => (
      /** @description editor.onDidChangeModel */
      this._editor.hasModel()
    )), this.editorOnDidChangeViewZones = Ms("onDidChangeViewZones", this._editor.onDidChangeViewZones), this.editorOnDidContentSizeChange = Ms("onDidContentSizeChange", this._editor.onDidContentSizeChange), this.domNodeSizeChanged = QE("domNodeSizeChanged"), this.views = /* @__PURE__ */ new Map(), this._domNode.className = "gutter monaco-editor";
    const n = this._domNode.appendChild(Xe("div.scroll-decoration", { role: "presentation", ariaHidden: "true", style: { width: "100%" } }).root), o = new ResizeObserver(() => {
      bi((r) => {
        this.domNodeSizeChanged.trigger(r);
      });
    });
    o.observe(this._domNode), this._register(_e(() => o.disconnect())), this._register(Qe((r) => {
      n.className = this.isScrollTopZero.read(r) ? "" : "scroll-decoration";
    })), this._register(Qe((r) => (
      /** @description EditorGutter.Render */
      this.render(r)
    )));
  }
  dispose() {
    super.dispose(), _n(this._domNode);
  }
  render(e) {
    if (!this.modelAttached.read(e))
      return;
    this.domNodeSizeChanged.read(e), this.editorOnDidChangeViewZones.read(e), this.editorOnDidContentSizeChange.read(e);
    const t = this.scrollTop.read(e), i = this._editor.getVisibleRanges(), n = new Set(this.views.keys()), o = Ne.ofStartAndLength(0, this._domNode.clientHeight);
    if (!o.isEmpty)
      for (const r of i) {
        const a = new pe(r.startLineNumber, r.endLineNumber + 1), l = this.itemProvider.getIntersectingGutterItems(a, e);
        bi((c) => {
          for (const h of l) {
            if (!h.range.intersect(a))
              continue;
            n.delete(h.id);
            let d = this.views.get(h.id);
            if (d)
              d.item.set(h, c);
            else {
              const p = document.createElement("div");
              this._domNode.appendChild(p);
              const _ = it("item", h), b = this.itemProvider.createView(_, p);
              d = new hre(_, b, p), this.views.set(h.id, d);
            }
            const u = h.range.startLineNumber <= this._editor.getModel().getLineCount() ? this._editor.getTopForLineNumber(h.range.startLineNumber, !0) - t : this._editor.getBottomForLineNumber(h.range.startLineNumber - 1, !1) - t, g = (h.range.endLineNumberExclusive === 1 ? Math.max(u, this._editor.getTopForLineNumber(h.range.startLineNumber, !1) - t) : Math.max(u, this._editor.getBottomForLineNumber(h.range.endLineNumberExclusive - 1, !0) - t)) - u;
            d.domNode.style.top = `${u}px`, d.domNode.style.height = `${g}px`, d.gutterItemView.layout(Ne.ofStartAndLength(u, g), o);
          }
        });
      }
    for (const r of n) {
      const a = this.views.get(r);
      a.gutterItemView.dispose(), a.domNode.remove(), this.views.delete(r);
    }
  }
}
class hre {
  constructor(e, t, i) {
    this.item = e, this.gutterItemView = t, this.domNode = i;
  }
}
class z3 extends Fh {
  constructor(e) {
    super(), this._getContext = e;
  }
  runAction(e, t) {
    const i = this._getContext();
    return super.runAction(e, i);
  }
}
class vP extends Q7 {
  constructor(e) {
    super(), this._textModel = e;
  }
  getValueOfRange(e) {
    return this._textModel.getValueInRange(e);
  }
  get length() {
    const e = this._textModel.getLineCount(), t = this._textModel.getLineLength(e);
    return new Xl(e - 1, t);
  }
}
var U3 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Eb = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const Dy = [], Z_ = 35;
let HD = class extends U {
  constructor(e, t, i, n, o, r, a, l, c) {
    super(), this._diffModel = t, this._editors = i, this._options = n, this._sashLayout = o, this._boundarySashes = r, this._instantiationService = a, this._contextKeyService = l, this._menuService = c, this._menu = this._register(this._menuService.createMenu(et.DiffEditorHunkToolbar, this._contextKeyService)), this._actions = zt(this, this._menu.onDidChange, () => this._menu.getActions()), this._hasActions = this._actions.map((h) => h.length > 0), this._showSash = xe(this, (h) => this._options.renderSideBySide.read(h) && this._hasActions.read(h)), this.width = xe(this, (h) => this._hasActions.read(h) ? Z_ : 0), this.elements = Xe("div.gutter@gutter", { style: { position: "absolute", height: "100%", width: Z_ + "px" } }, []), this._currentDiff = xe(this, (h) => {
      var g;
      const d = this._diffModel.read(h);
      if (!d)
        return;
      const u = (g = d.diff.read(h)) == null ? void 0 : g.mappings, f = this._editors.modifiedCursor.read(h);
      if (f)
        return u == null ? void 0 : u.find((p) => p.lineRangeMapping.modified.contains(f.lineNumber));
    }), this._selectedDiffs = xe(this, (h) => {
      const d = this._diffModel.read(h), u = d == null ? void 0 : d.diff.read(h);
      if (!u)
        return Dy;
      const f = this._editors.modifiedSelections.read(h);
      if (f.every((b) => b.isEmpty()))
        return Dy;
      const g = new Rs(f.map((b) => pe.fromRangeInclusive(b))), _ = u.mappings.filter((b) => b.lineRangeMapping.innerChanges && g.intersects(b.lineRangeMapping.modified)).map((b) => ({
        mapping: b,
        rangeMappings: b.lineRangeMapping.innerChanges.filter((C) => f.some((w) => T.areIntersecting(C.modifiedRange, w)))
      }));
      return _.length === 0 || _.every((b) => b.rangeMappings.length === 0) ? Dy : _;
    }), this._register(Toe(e, this.elements.root)), this._register(z(this.elements.root, "click", () => {
      this._editors.modified.focus();
    })), this._register(ic(this.elements.root, { display: this._hasActions.map((h) => h ? "block" : "none") })), mr(this, (h) => this._showSash.read(h) ? new V3(e, this._sashLayout.dimensions, this._options.enableSplitViewResizing, this._boundarySashes, XE(this, (u) => this._sashLayout.sashLeft.read(u) - Z_, (u, f) => this._sashLayout.sashLeft.set(u + Z_, f)), () => this._sashLayout.resetSash()) : void 0).recomputeInitiallyAndOnChange(this._store), this._register(new cre(this._editors.modified, this.elements.root, {
      getIntersectingGutterItems: (h, d) => {
        const u = this._diffModel.read(d);
        if (!u)
          return [];
        const f = u.diff.read(d);
        if (!f)
          return [];
        const g = this._selectedDiffs.read(d);
        if (g.length > 0) {
          const _ = Ls.fromRangeMappings(g.flatMap((b) => b.rangeMappings));
          return [
            new wP(_, !0, et.DiffEditorSelectionToolbar, void 0, u.model.original.uri, u.model.modified.uri)
          ];
        }
        const p = this._currentDiff.read(d);
        return f.mappings.map((_) => new wP(_.lineRangeMapping.withInnerChangesFromLineRanges(), _.lineRangeMapping === (p == null ? void 0 : p.lineRangeMapping), et.DiffEditorHunkToolbar, void 0, u.model.original.uri, u.model.modified.uri));
      },
      createView: (h, d) => this._instantiationService.createInstance(VD, h, d, this)
    })), this._register(z(this.elements.gutter, X.MOUSE_WHEEL, (h) => {
      this._editors.modified.getOption(
        104
        /* EditorOption.scrollbar */
      ).handleMouseWheel && this._editors.modified.delegateScrollFromMouseWheelEvent(h);
    }, { passive: !1 }));
  }
  computeStagedValue(e) {
    const t = e.innerChanges ?? [], i = new vP(this._editors.modifiedModel.get()), n = new vP(this._editors.original.getModel());
    return new Ute(t.map((a) => a.toTextEdit(i))).apply(n);
  }
  layout(e) {
    this.elements.gutter.style.left = e + "px";
  }
};
HD = U3([
  Eb(6, Pe),
  Eb(7, Fe),
  Eb(8, $r)
], HD);
class wP {
  constructor(e, t, i, n, o, r) {
    this.mapping = e, this.showAlways = t, this.menuId = i, this.rangeOverride = n, this.originalUri = o, this.modifiedUri = r;
  }
  get id() {
    return this.mapping.modified.toString();
  }
  get range() {
    return this.rangeOverride ?? this.mapping.modified;
  }
}
let VD = class extends U {
  constructor(e, t, i, n) {
    super(), this._item = e, this._elements = Xe("div.gutterItem", { style: { height: "20px", width: "34px" } }, [
      Xe("div.background@background", {}, []),
      Xe("div.buttons@buttons", {}, [])
    ]), this._showAlways = this._item.map(this, (r) => r.showAlways), this._menuId = this._item.map(this, (r) => r.menuId), this._isSmall = it(this, !1), this._lastItemRange = void 0, this._lastViewRange = void 0;
    const o = this._register(n.createInstance(wf, "element", !0, { position: {
      hoverPosition: 1
      /* HoverPosition.RIGHT */
    } }));
    this._register(Ig(t, this._elements.root)), this._register(Qe((r) => {
      const a = this._showAlways.read(r);
      this._elements.root.classList.toggle("noTransition", !0), this._elements.root.classList.toggle("showAlways", a), setTimeout(() => {
        this._elements.root.classList.toggle("noTransition", !1);
      }, 0);
    })), this._register(ho((r, a) => {
      this._elements.buttons.replaceChildren();
      const l = a.add(n.createInstance(Q1, this._elements.buttons, this._menuId.read(r), {
        orientation: 1,
        hoverDelegate: o,
        toolbarOptions: {
          primaryGroup: (c) => c.startsWith("primary")
        },
        overflowBehavior: { maxItems: this._isSmall.read(r) ? 1 : 3 },
        hiddenItemStrategy: 0,
        actionRunner: new z3(() => {
          const c = this._item.get(), h = c.mapping;
          return {
            mapping: h,
            originalWithModifiedChanges: i.computeStagedValue(h),
            originalUri: c.originalUri,
            modifiedUri: c.modifiedUri
          };
        }),
        menuOptions: {
          shouldForwardArgs: !0
        }
      }));
      a.add(l.onDidChangeMenuItems(() => {
        this._lastItemRange && this.layout(this._lastItemRange, this._lastViewRange);
      }));
    }));
  }
  layout(e, t) {
    this._lastItemRange = e, this._lastViewRange = t;
    let i = this._elements.buttons.clientHeight;
    this._isSmall.set(this._item.get().mapping.original.startLineNumber === 1 && e.length < 30, void 0), i = this._elements.buttons.clientHeight;
    const n = e.length / 2 - i / 2, o = i;
    let r = e.start + n;
    const a = Ne.tryCreate(o, t.endExclusive - o - i), l = Ne.tryCreate(e.start + o, e.endExclusive - i - o);
    l && a && l.start < l.endExclusive && (r = a.clip(r), r = l.clip(r)), this._elements.buttons.style.top = `${r - e.start}px`;
  }
};
VD = U3([
  Eb(3, Pe)
], VD);
function Sp(s) {
  return zD.get(s);
}
const ml = class ml extends U {
  /**
   * Make sure that editor is not disposed yet!
  */
  static get(e) {
    let t = ml._map.get(e);
    if (!t) {
      t = new ml(e), ml._map.set(e, t);
      const i = e.onDidDispose(() => {
        const n = ml._map.get(e);
        n && (ml._map.delete(e), n.dispose(), i.dispose());
      });
    }
    return t;
  }
  _beginUpdate() {
    this._updateCounter++, this._updateCounter === 1 && (this._currentTransaction = new Rp(() => {
    }));
  }
  _endUpdate() {
    if (this._updateCounter--, this._updateCounter === 0) {
      const e = this._currentTransaction;
      this._currentTransaction = void 0, e.finish();
    }
  }
  constructor(e) {
    var t;
    super(), this.editor = e, this._updateCounter = 0, this._currentTransaction = void 0, this._model = it(this, this.editor.getModel()), this.model = this._model, this.isReadonly = zt(this, this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      92
      /* EditorOption.readOnly */
    )), this._versionId = vS({ owner: this, lazy: !0 }, ((t = this.editor.getModel()) == null ? void 0 : t.getVersionId()) ?? null), this.versionId = this._versionId, this._selections = vS({ owner: this, equalsFn: oT(vH(Ue.selectionsEqual)), lazy: !0 }, this.editor.getSelections() ?? null), this.selections = this._selections, this.isFocused = zt(this, (i) => {
      const n = this.editor.onDidFocusEditorWidget(i), o = this.editor.onDidBlurEditorWidget(i);
      return {
        dispose() {
          n.dispose(), o.dispose();
        }
      };
    }, () => this.editor.hasWidgetFocus()), this.value = XE(this, (i) => {
      var n;
      return this.versionId.read(i), ((n = this.model.read(i)) == null ? void 0 : n.getValue()) ?? "";
    }, (i, n) => {
      const o = this.model.get();
      o !== null && i !== o.getValue() && o.setValue(i);
    }), this.valueIsEmpty = xe(this, (i) => {
      var n;
      return this.versionId.read(i), ((n = this.editor.getModel()) == null ? void 0 : n.getValueLength()) === 0;
    }), this.cursorSelection = aw({ owner: this, equalsFn: oT(Ue.selectionsEqual) }, (i) => {
      var n;
      return ((n = this.selections.read(i)) == null ? void 0 : n[0]) ?? null;
    }), this.onDidType = QE(this), this.scrollTop = zt(this.editor.onDidScrollChange, () => this.editor.getScrollTop()), this.scrollLeft = zt(this.editor.onDidScrollChange, () => this.editor.getScrollLeft()), this.layoutInfo = zt(this.editor.onDidLayoutChange, () => this.editor.getLayoutInfo()), this.layoutInfoContentLeft = this.layoutInfo.map((i) => i.contentLeft), this.layoutInfoDecorationsLeft = this.layoutInfo.map((i) => i.decorationsLeft), this.contentWidth = zt(this.editor.onDidContentSizeChange, () => this.editor.getContentWidth()), this._overlayWidgetCounter = 0, this._register(this.editor.onBeginUpdate(() => this._beginUpdate())), this._register(this.editor.onEndUpdate(() => this._endUpdate())), this._register(this.editor.onDidChangeModel(() => {
      this._beginUpdate();
      try {
        this._model.set(this.editor.getModel(), this._currentTransaction), this._forceUpdate();
      } finally {
        this._endUpdate();
      }
    })), this._register(this.editor.onDidType((i) => {
      this._beginUpdate();
      try {
        this._forceUpdate(), this.onDidType.trigger(this._currentTransaction, i);
      } finally {
        this._endUpdate();
      }
    })), this._register(this.editor.onDidChangeModelContent((i) => {
      var n;
      this._beginUpdate();
      try {
        this._versionId.set(((n = this.editor.getModel()) == null ? void 0 : n.getVersionId()) ?? null, this._currentTransaction, i), this._forceUpdate();
      } finally {
        this._endUpdate();
      }
    })), this._register(this.editor.onDidChangeCursorSelection((i) => {
      this._beginUpdate();
      try {
        this._selections.set(this.editor.getSelections(), this._currentTransaction, i), this._forceUpdate();
      } finally {
        this._endUpdate();
      }
    }));
  }
  forceUpdate(e) {
    this._beginUpdate();
    try {
      return this._forceUpdate(), e ? e(this._currentTransaction) : void 0;
    } finally {
      this._endUpdate();
    }
  }
  _forceUpdate() {
    var e;
    this._beginUpdate();
    try {
      this._model.set(this.editor.getModel(), this._currentTransaction), this._versionId.set(((e = this.editor.getModel()) == null ? void 0 : e.getVersionId()) ?? null, this._currentTransaction, void 0), this._selections.set(this.editor.getSelections(), this._currentTransaction, void 0);
    } finally {
      this._endUpdate();
    }
  }
  getOption(e) {
    return zt(this, (t) => this.editor.onDidChangeConfiguration((i) => {
      i.hasChanged(e) && t(void 0);
    }), () => this.editor.getOption(e));
  }
  setDecorations(e) {
    const t = new ne(), i = this.editor.createDecorationsCollection();
    return t.add(lw({ owner: this, debugName: () => `Apply decorations from ${e.debugName}` }, (n) => {
      const o = e.read(n);
      i.set(o);
    })), t.add({
      dispose: () => {
        i.clear();
      }
    }), t;
  }
  createOverlayWidget(e) {
    const t = "observableOverlayWidget" + this._overlayWidgetCounter++, i = {
      getDomNode: () => e.domNode,
      getPosition: () => e.position.get(),
      getId: () => t,
      allowEditorOverflow: e.allowEditorOverflow,
      getMinContentWidthInPx: () => e.minContentWidthInPx.get()
    };
    this.editor.addOverlayWidget(i);
    const n = Qe((o) => {
      e.position.read(o), e.minContentWidthInPx.read(o), this.editor.layoutOverlayWidget(i);
    });
    return _e(() => {
      n.dispose(), this.editor.removeOverlayWidget(i);
    });
  }
};
ml._map = /* @__PURE__ */ new Map();
let zD = ml;
var dre = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, ure = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Ib, Oh;
let UD = (Oh = class extends U {
  static setBreadcrumbsSourceFactory(e) {
    this._breadcrumbsSourceFactory.set(e, void 0);
  }
  get isUpdatingHiddenAreas() {
    return this._isUpdatingHiddenAreas;
  }
  constructor(e, t, i, n) {
    super(), this._editors = e, this._diffModel = t, this._options = i, this._instantiationService = n, this._modifiedOutlineSource = mr(this, (l) => {
      const c = this._editors.modifiedModel.read(l), h = Ib._breadcrumbsSourceFactory.read(l);
      return !c || !h ? void 0 : h(c, this._instantiationService);
    }), this._isUpdatingHiddenAreas = !1, this._register(this._editors.original.onDidChangeCursorPosition((l) => {
      if (l.reason === 1)
        return;
      const c = this._diffModel.get();
      bi((h) => {
        for (const d of this._editors.original.getSelections() || [])
          c == null || c.ensureOriginalLineIsVisible(d.getStartPosition().lineNumber, 0, h), c == null || c.ensureOriginalLineIsVisible(d.getEndPosition().lineNumber, 0, h);
      });
    })), this._register(this._editors.modified.onDidChangeCursorPosition((l) => {
      if (l.reason === 1)
        return;
      const c = this._diffModel.get();
      bi((h) => {
        for (const d of this._editors.modified.getSelections() || [])
          c == null || c.ensureModifiedLineIsVisible(d.getStartPosition().lineNumber, 0, h), c == null || c.ensureModifiedLineIsVisible(d.getEndPosition().lineNumber, 0, h);
      });
    }));
    const o = this._diffModel.map((l, c) => {
      var d;
      const h = (l == null ? void 0 : l.unchangedRegions.read(c)) ?? [];
      return h.length === 1 && h[0].modifiedLineNumber === 1 && h[0].lineCount === ((d = this._editors.modifiedModel.read(c)) == null ? void 0 : d.getLineCount()) ? [] : h;
    });
    this.viewZones = rd(this, (l, c) => {
      const h = this._modifiedOutlineSource.read(l);
      if (!h)
        return { origViewZones: [], modViewZones: [] };
      const d = [], u = [], f = this._options.renderSideBySide.read(l), g = this._options.compactMode.read(l), p = o.read(l);
      for (let _ = 0; _ < p.length; _++) {
        const b = p[_];
        if (!b.shouldHideControls(l) && !(g && (_ === 0 || _ === p.length - 1)))
          if (g) {
            {
              const C = xe(this, (v) => (
                /** @description hiddenOriginalRangeStart */
                b.getHiddenOriginalRange(v).startLineNumber - 1
              )), w = new fu(C, 12);
              d.push(w), c.add(new yP(this._editors.original, w, b, !f));
            }
            {
              const C = xe(this, (v) => (
                /** @description hiddenModifiedRangeStart */
                b.getHiddenModifiedRange(v).startLineNumber - 1
              )), w = new fu(C, 12);
              u.push(w), c.add(new yP(this._editors.modified, w, b));
            }
          } else {
            {
              const C = xe(this, (v) => (
                /** @description hiddenOriginalRangeStart */
                b.getHiddenOriginalRange(v).startLineNumber - 1
              )), w = new fu(C, 24);
              d.push(w), c.add(new SP(this._editors.original, w, b, b.originalUnchangedRange, !f, h, (v) => this._diffModel.get().ensureModifiedLineIsVisible(v, 2, void 0), this._options));
            }
            {
              const C = xe(this, (v) => (
                /** @description hiddenModifiedRangeStart */
                b.getHiddenModifiedRange(v).startLineNumber - 1
              )), w = new fu(C, 24);
              u.push(w), c.add(new SP(this._editors.modified, w, b, b.modifiedUnchangedRange, !1, h, (v) => this._diffModel.get().ensureModifiedLineIsVisible(v, 2, void 0), this._options));
            }
          }
      }
      return { origViewZones: d, modViewZones: u };
    });
    const r = {
      description: "unchanged lines",
      className: "diff-unchanged-lines",
      isWholeLine: !0
    }, a = {
      description: "Fold Unchanged",
      glyphMarginHoverMessage: new Oo(void 0, { isTrusted: !0, supportThemeIcons: !0 }).appendMarkdown(m("foldUnchanged", "Fold Unchanged Region")),
      glyphMarginClassName: "fold-unchanged " + Te.asClassName(ie.fold),
      zIndex: 10001
    };
    this._register(RC(this._editors.original, xe(this, (l) => {
      const c = o.read(l), h = c.map((d) => ({
        range: d.originalUnchangedRange.toInclusiveRange(),
        options: r
      }));
      for (const d of c)
        d.shouldHideControls(l) && h.push({
          range: T.fromPositions(new F(d.originalLineNumber, 1)),
          options: a
        });
      return h;
    }))), this._register(RC(this._editors.modified, xe(this, (l) => {
      const c = o.read(l), h = c.map((d) => ({
        range: d.modifiedUnchangedRange.toInclusiveRange(),
        options: r
      }));
      for (const d of c)
        d.shouldHideControls(l) && h.push({
          range: pe.ofLength(d.modifiedLineNumber, 1).toInclusiveRange(),
          options: a
        });
      return h;
    }))), this._register(Qe((l) => {
      const c = o.read(l);
      this._isUpdatingHiddenAreas = !0;
      try {
        this._editors.original.setHiddenAreas(c.map((h) => h.getHiddenOriginalRange(l).toInclusiveRange()).filter(nf)), this._editors.modified.setHiddenAreas(c.map((h) => h.getHiddenModifiedRange(l).toInclusiveRange()).filter(nf));
      } finally {
        this._isUpdatingHiddenAreas = !1;
      }
    })), this._register(this._editors.modified.onMouseUp((l) => {
      var c;
      if (!l.event.rightButton && l.target.position && ((c = l.target.element) != null && c.className.includes("fold-unchanged"))) {
        const h = l.target.position.lineNumber, d = this._diffModel.get();
        if (!d)
          return;
        const u = d.unchangedRegions.get().find((f) => f.modifiedUnchangedRange.includes(h));
        if (!u)
          return;
        u.collapseAll(void 0), l.event.stopPropagation(), l.event.preventDefault();
      }
    })), this._register(this._editors.original.onMouseUp((l) => {
      var c;
      if (!l.event.rightButton && l.target.position && ((c = l.target.element) != null && c.className.includes("fold-unchanged"))) {
        const h = l.target.position.lineNumber, d = this._diffModel.get();
        if (!d)
          return;
        const u = d.unchangedRegions.get().find((f) => f.originalUnchangedRange.includes(h));
        if (!u)
          return;
        u.collapseAll(void 0), l.event.stopPropagation(), l.event.preventDefault();
      }
    }));
  }
}, Ib = Oh, Oh._breadcrumbsSourceFactory = it(Ib, () => ({
  dispose() {
  },
  getBreadcrumbItems(e, t) {
    return [];
  }
})), Oh);
UD = Ib = dre([
  ure(3, Pe)
], UD);
class yP extends VN {
  constructor(e, t, i, n = !1) {
    const o = Xe("div.diff-hidden-lines-widget");
    super(e, t, o.root), this._unchangedRegion = i, this._hide = n, this._nodes = Xe("div.diff-hidden-lines-compact", [
      Xe("div.line-left", []),
      Xe("div.text@text", []),
      Xe("div.line-right", [])
    ]), o.root.appendChild(this._nodes.root), this._hide && this._nodes.root.replaceChildren(), this._register(Qe((r) => {
      if (!this._hide) {
        const a = this._unchangedRegion.getHiddenModifiedRange(r).length, l = m("hiddenLines", "{0} hidden lines", a);
        this._nodes.text.innerText = l;
      }
    }));
  }
}
class SP extends VN {
  constructor(e, t, i, n, o, r, a, l) {
    const c = Xe("div.diff-hidden-lines-widget");
    super(e, t, c.root), this._editor = e, this._unchangedRegion = i, this._unchangedRegionRange = n, this._hide = o, this._modifiedOutlineSource = r, this._revealModifiedHiddenLine = a, this._options = l, this._nodes = Xe("div.diff-hidden-lines", [
      Xe("div.top@top", { title: m("diff.hiddenLines.top", "Click or drag to show more above") }),
      Xe("div.center@content", { style: { display: "flex" } }, [
        Xe("div@first", { style: { display: "flex", justifyContent: "center", alignItems: "center", flexShrink: "0" } }, [he("a", { title: m("showUnchangedRegion", "Show Unchanged Region"), role: "button", onclick: () => {
          this._unchangedRegion.showAll(void 0);
        } }, ...lh("$(unfold)"))]),
        Xe("div@others", { style: { display: "flex", justifyContent: "center", alignItems: "center" } })
      ]),
      Xe("div.bottom@bottom", { title: m("diff.bottom", "Click or drag to show more below"), role: "button" })
    ]), c.root.appendChild(this._nodes.root), this._hide ? _n(this._nodes.first) : this._register(ic(this._nodes.first, { width: Sp(this._editor).layoutInfoContentLeft })), this._register(Qe((d) => {
      const u = this._unchangedRegion.visibleLineCountTop.read(d) + this._unchangedRegion.visibleLineCountBottom.read(d) === this._unchangedRegion.lineCount;
      this._nodes.bottom.classList.toggle("canMoveTop", !u), this._nodes.bottom.classList.toggle("canMoveBottom", this._unchangedRegion.visibleLineCountBottom.read(d) > 0), this._nodes.top.classList.toggle("canMoveTop", this._unchangedRegion.visibleLineCountTop.read(d) > 0), this._nodes.top.classList.toggle("canMoveBottom", !u);
      const f = this._unchangedRegion.isDragged.read(d), g = this._editor.getDomNode();
      g && (g.classList.toggle("draggingUnchangedRegion", !!f), f === "top" ? (g.classList.toggle("canMoveTop", this._unchangedRegion.visibleLineCountTop.read(d) > 0), g.classList.toggle("canMoveBottom", !u)) : f === "bottom" ? (g.classList.toggle("canMoveTop", !u), g.classList.toggle("canMoveBottom", this._unchangedRegion.visibleLineCountBottom.read(d) > 0)) : (g.classList.toggle("canMoveTop", !1), g.classList.toggle("canMoveBottom", !1)));
    }));
    const h = this._editor;
    this._register(z(this._nodes.top, "mousedown", (d) => {
      if (d.button !== 0)
        return;
      this._nodes.top.classList.toggle("dragging", !0), this._nodes.root.classList.toggle("dragging", !0), d.preventDefault();
      const u = d.clientY;
      let f = !1;
      const g = this._unchangedRegion.visibleLineCountTop.get();
      this._unchangedRegion.isDragged.set("top", void 0);
      const p = fe(this._nodes.top), _ = z(p, "mousemove", (C) => {
        const v = C.clientY - u;
        f = f || Math.abs(v) > 2;
        const S = Math.round(v / h.getOption(
          67
          /* EditorOption.lineHeight */
        )), L = Math.max(0, Math.min(g + S, this._unchangedRegion.getMaxVisibleLineCountTop()));
        this._unchangedRegion.visibleLineCountTop.set(L, void 0);
      }), b = z(p, "mouseup", (C) => {
        f || this._unchangedRegion.showMoreAbove(this._options.hideUnchangedRegionsRevealLineCount.get(), void 0), this._nodes.top.classList.toggle("dragging", !1), this._nodes.root.classList.toggle("dragging", !1), this._unchangedRegion.isDragged.set(void 0, void 0), _.dispose(), b.dispose();
      });
    })), this._register(z(this._nodes.bottom, "mousedown", (d) => {
      if (d.button !== 0)
        return;
      this._nodes.bottom.classList.toggle("dragging", !0), this._nodes.root.classList.toggle("dragging", !0), d.preventDefault();
      const u = d.clientY;
      let f = !1;
      const g = this._unchangedRegion.visibleLineCountBottom.get();
      this._unchangedRegion.isDragged.set("bottom", void 0);
      const p = fe(this._nodes.bottom), _ = z(p, "mousemove", (C) => {
        const v = C.clientY - u;
        f = f || Math.abs(v) > 2;
        const S = Math.round(v / h.getOption(
          67
          /* EditorOption.lineHeight */
        )), L = Math.max(0, Math.min(g - S, this._unchangedRegion.getMaxVisibleLineCountBottom())), k = this._unchangedRegionRange.endLineNumberExclusive > h.getModel().getLineCount() ? h.getContentHeight() : h.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
        this._unchangedRegion.visibleLineCountBottom.set(L, void 0);
        const x = this._unchangedRegionRange.endLineNumberExclusive > h.getModel().getLineCount() ? h.getContentHeight() : h.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
        h.setScrollTop(h.getScrollTop() + (x - k));
      }), b = z(p, "mouseup", (C) => {
        if (this._unchangedRegion.isDragged.set(void 0, void 0), !f) {
          const w = h.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
          this._unchangedRegion.showMoreBelow(this._options.hideUnchangedRegionsRevealLineCount.get(), void 0);
          const v = h.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
          h.setScrollTop(h.getScrollTop() + (v - w));
        }
        this._nodes.bottom.classList.toggle("dragging", !1), this._nodes.root.classList.toggle("dragging", !1), _.dispose(), b.dispose();
      });
    })), this._register(Qe((d) => {
      const u = [];
      if (!this._hide) {
        const f = i.getHiddenModifiedRange(d).length, g = m("hiddenLines", "{0} hidden lines", f), p = he("span", { title: m("diff.hiddenLines.expandAll", "Double click to unfold") }, g);
        p.addEventListener("dblclick", (C) => {
          C.button === 0 && (C.preventDefault(), this._unchangedRegion.showAll(void 0));
        }), u.push(p);
        const _ = this._unchangedRegion.getHiddenModifiedRange(d), b = this._modifiedOutlineSource.getBreadcrumbItems(_, d);
        if (b.length > 0) {
          u.push(he("span", void 0, "  |  "));
          for (let C = 0; C < b.length; C++) {
            const w = b[C], v = zS.toIcon(w.kind), S = Xe("div.breadcrumb-item", {
              style: { display: "flex", alignItems: "center" }
            }, [
              Qb(v),
              " ",
              w.name,
              ...C === b.length - 1 ? [] : [Qb(ie.chevronRight)]
            ]).root;
            u.push(S), S.onclick = () => {
              this._revealModifiedHiddenLine(w.startLineNumber);
            };
          }
        }
      }
      _n(this._nodes.others, ...u);
    }));
  }
}
var fre = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, gre = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Io, Pa;
let Lp = (Pa = class extends U {
  constructor(e, t, i, n, o, r, a) {
    super(), this._editors = e, this._rootElement = t, this._diffModel = i, this._rootWidth = n, this._rootHeight = o, this._modifiedEditorLayoutInfo = r, this._themeService = a, this.width = Io.ENTIRE_DIFF_OVERVIEW_WIDTH;
    const l = zt(this._themeService.onDidColorThemeChange, () => this._themeService.getColorTheme()), c = xe((u) => {
      const f = l.read(u), g = f.getColor(Vz) || (f.getColor(Wz) || ES).transparent(2), p = f.getColor(zz) || (f.getColor(Hz) || IS).transparent(2);
      return { insertColor: g, removeColor: p };
    }), h = st(document.createElement("div"));
    h.setClassName("diffViewport"), h.setPosition("absolute");
    const d = Xe("div.diffOverview", {
      style: { position: "absolute", top: "0px", width: Io.ENTIRE_DIFF_OVERVIEW_WIDTH + "px" }
    }).root;
    this._register(Ig(d, h.domNode)), this._register(Zt(d, X.POINTER_DOWN, (u) => {
      this._editors.modified.delegateVerticalScrollbarPointerDown(u);
    })), this._register(z(d, X.MOUSE_WHEEL, (u) => {
      this._editors.modified.delegateScrollFromMouseWheelEvent(u);
    }, { passive: !1 })), this._register(Ig(this._rootElement, d)), this._register(ho((u, f) => {
      const g = this._diffModel.read(u), p = this._editors.original.createOverviewRuler("original diffOverviewRuler");
      p && (f.add(p), f.add(Ig(d, p.getDomNode())));
      const _ = this._editors.modified.createOverviewRuler("modified diffOverviewRuler");
      if (_ && (f.add(_), f.add(Ig(d, _.getDomNode()))), !p || !_)
        return;
      const b = Ms("viewZoneChanged", this._editors.original.onDidChangeViewZones), C = Ms("viewZoneChanged", this._editors.modified.onDidChangeViewZones), w = Ms("hiddenRangesChanged", this._editors.original.onDidChangeHiddenAreas), v = Ms("hiddenRangesChanged", this._editors.modified.onDidChangeHiddenAreas);
      f.add(Qe((S) => {
        var B;
        b.read(S), C.read(S), w.read(S), v.read(S);
        const L = c.read(S), k = (B = g == null ? void 0 : g.diff.read(S)) == null ? void 0 : B.mappings;
        function x(W, H, P) {
          const q = P._getViewModel();
          return q ? W.filter((J) => J.length > 0).map((J) => {
            const oe = q.coordinatesConverter.convertModelPositionToViewPosition(new F(J.startLineNumber, 1)), ae = q.coordinatesConverter.convertModelPositionToViewPosition(new F(J.endLineNumberExclusive, 1)), re = ae.lineNumber - oe.lineNumber;
            return new tF(oe.lineNumber, ae.lineNumber, re, H.toString());
          }) : [];
        }
        const I = x((k || []).map((W) => W.lineRangeMapping.original), L.removeColor, this._editors.original), K = x((k || []).map((W) => W.lineRangeMapping.modified), L.insertColor, this._editors.modified);
        p == null || p.setZones(I), _ == null || _.setZones(K);
      })), f.add(Qe((S) => {
        const L = this._rootHeight.read(S), k = this._rootWidth.read(S), x = this._modifiedEditorLayoutInfo.read(S);
        if (x) {
          const I = Io.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * Io.ONE_OVERVIEW_WIDTH;
          p.setLayout({
            top: 0,
            height: L,
            right: I + Io.ONE_OVERVIEW_WIDTH,
            width: Io.ONE_OVERVIEW_WIDTH
          }), _.setLayout({
            top: 0,
            height: L,
            right: 0,
            width: Io.ONE_OVERVIEW_WIDTH
          });
          const K = this._editors.modifiedScrollTop.read(S), B = this._editors.modifiedScrollHeight.read(S), W = this._editors.modified.getOption(
            104
            /* EditorOption.scrollbar */
          ), H = new lf(W.verticalHasArrows ? W.arrowSize : 0, W.verticalScrollbarSize, 0, x.height, B, K);
          h.setTop(H.getSliderPosition()), h.setHeight(H.getSliderSize());
        } else
          h.setTop(0), h.setHeight(0);
        d.style.height = L + "px", d.style.left = k - Io.ENTIRE_DIFF_OVERVIEW_WIDTH + "px", h.setWidth(Io.ENTIRE_DIFF_OVERVIEW_WIDTH);
      }));
    }));
  }
}, Io = Pa, Pa.ONE_OVERVIEW_WIDTH = 15, Pa.ENTIRE_DIFF_OVERVIEW_WIDTH = Pa.ONE_OVERVIEW_WIDTH * 2, Pa);
Lp = Io = fre([
  gre(6, wn)
], Lp);
const Ey = [];
class mre extends U {
  constructor(e, t, i, n) {
    super(), this._editors = e, this._diffModel = t, this._options = i, this._widget = n, this._selectedDiffs = xe(this, (o) => {
      const r = this._diffModel.read(o), a = r == null ? void 0 : r.diff.read(o);
      if (!a)
        return Ey;
      const l = this._editors.modifiedSelections.read(o);
      if (l.every((u) => u.isEmpty()))
        return Ey;
      const c = new Rs(l.map((u) => pe.fromRangeInclusive(u))), d = a.mappings.filter((u) => u.lineRangeMapping.innerChanges && c.intersects(u.lineRangeMapping.modified)).map((u) => ({
        mapping: u,
        rangeMappings: u.lineRangeMapping.innerChanges.filter((f) => l.some((g) => T.areIntersecting(f.modifiedRange, g)))
      }));
      return d.length === 0 || d.every((u) => u.rangeMappings.length === 0) ? Ey : d;
    }), this._register(ho((o, r) => {
      if (!this._options.shouldRenderOldRevertArrows.read(o))
        return;
      const a = this._diffModel.read(o), l = a == null ? void 0 : a.diff.read(o);
      if (!a || !l || a.movedTextToCompare.read(o))
        return;
      const c = [], h = this._selectedDiffs.read(o), d = new Set(h.map((u) => u.mapping));
      if (h.length > 0) {
        const u = this._editors.modifiedSelections.read(o), f = r.add(new OC(u[u.length - 1].positionLineNumber, this._widget, h.flatMap((g) => g.rangeMappings), !0));
        this._editors.modified.addGlyphMarginWidget(f), c.push(f);
      }
      for (const u of l.mappings)
        if (!d.has(u) && !u.lineRangeMapping.modified.isEmpty && u.lineRangeMapping.innerChanges) {
          const f = r.add(new OC(u.lineRangeMapping.modified.startLineNumber, this._widget, u.lineRangeMapping, !1));
          this._editors.modified.addGlyphMarginWidget(f), c.push(f);
        }
      r.add(_e(() => {
        for (const u of c)
          this._editors.modified.removeGlyphMarginWidget(u);
      }));
    }));
  }
}
const Pv = class Pv extends U {
  getId() {
    return this._id;
  }
  constructor(e, t, i, n) {
    super(), this._lineNumber = e, this._widget = t, this._diffs = i, this._revertSelection = n, this._id = `revertButton${Pv.counter++}`, this._domNode = Xe("div.revertButton", {
      title: this._revertSelection ? m("revertSelectedChanges", "Revert Selected Changes") : m("revertChange", "Revert Change")
    }, [Qb(ie.arrowRight)]).root, this._register(z(this._domNode, X.MOUSE_DOWN, (o) => {
      o.button !== 2 && (o.stopPropagation(), o.preventDefault());
    })), this._register(z(this._domNode, X.MOUSE_UP, (o) => {
      o.stopPropagation(), o.preventDefault();
    })), this._register(z(this._domNode, X.CLICK, (o) => {
      this._diffs instanceof an ? this._widget.revert(this._diffs) : this._widget.revertRangeMappings(this._diffs), o.stopPropagation(), o.preventDefault();
    }));
  }
  /**
   * Get the dom node of the glyph widget.
   */
  getDomNode() {
    return this._domNode;
  }
  /**
   * Get the placement of the glyph widget.
   */
  getPosition() {
    return {
      lane: _o.Right,
      range: {
        startColumn: 1,
        startLineNumber: this._lineNumber,
        endColumn: 1,
        endLineNumber: this._lineNumber
      },
      zIndex: 10001
    };
  }
};
Pv.counter = 0;
let OC = Pv;
function oa(s, e, t) {
  const i = s.bindTo(e);
  return lw({ debugName: () => `Set Context Key "${s.key}"` }, (n) => {
    i.set(t(n));
  });
}
var pre = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, LP = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let $D = class extends U {
  get onDidContentSizeChange() {
    return this._onDidContentSizeChange.event;
  }
  constructor(e, t, i, n, o, r, a) {
    super(), this.originalEditorElement = e, this.modifiedEditorElement = t, this._options = i, this._argCodeEditorWidgetOptions = n, this._createInnerEditor = o, this._instantiationService = r, this._keybindingService = a, this.original = this._register(this._createLeftHandSideEditor(this._options.editorOptions.get(), this._argCodeEditorWidgetOptions.originalEditor || {})), this.modified = this._register(this._createRightHandSideEditor(this._options.editorOptions.get(), this._argCodeEditorWidgetOptions.modifiedEditor || {})), this._onDidContentSizeChange = this._register(new A()), this.modifiedScrollTop = zt(this, this.modified.onDidScrollChange, () => (
      /** @description modified.getScrollTop */
      this.modified.getScrollTop()
    )), this.modifiedScrollHeight = zt(this, this.modified.onDidScrollChange, () => (
      /** @description modified.getScrollHeight */
      this.modified.getScrollHeight()
    )), this.modifiedObs = Sp(this.modified), this.originalObs = Sp(this.original), this.modifiedModel = this.modifiedObs.model, this.modifiedSelections = zt(this, this.modified.onDidChangeCursorSelection, () => this.modified.getSelections() ?? []), this.modifiedCursor = aw({ owner: this, equalsFn: F.equals }, (l) => {
      var c;
      return ((c = this.modifiedSelections.read(l)[0]) == null ? void 0 : c.getPosition()) ?? new F(1, 1);
    }), this.originalCursor = zt(this, this.original.onDidChangeCursorPosition, () => this.original.getPosition() ?? new F(1, 1)), this._argCodeEditorWidgetOptions = null, this._register(cw({
      createEmptyChangeSummary: () => ({}),
      handleChange: (l, c) => (l.didChange(i.editorOptions) && Object.assign(c, l.change.changedOptions), !0)
    }, (l, c) => {
      i.editorOptions.read(l), this._options.renderSideBySide.read(l), this.modified.updateOptions(this._adjustOptionsForRightHandSide(l, c)), this.original.updateOptions(this._adjustOptionsForLeftHandSide(l, c));
    }));
  }
  _createLeftHandSideEditor(e, t) {
    const i = this._adjustOptionsForLeftHandSide(void 0, e), n = this._constructInnerEditor(this._instantiationService, this.originalEditorElement, i, t);
    return n.setContextValue("isInDiffLeftEditor", !0), n;
  }
  _createRightHandSideEditor(e, t) {
    const i = this._adjustOptionsForRightHandSide(void 0, e), n = this._constructInnerEditor(this._instantiationService, this.modifiedEditorElement, i, t);
    return n.setContextValue("isInDiffRightEditor", !0), n;
  }
  _constructInnerEditor(e, t, i, n) {
    const o = this._createInnerEditor(e, t, i, n);
    return this._register(o.onDidContentSizeChange((r) => {
      const a = this.original.getContentWidth() + this.modified.getContentWidth() + Lp.ENTIRE_DIFF_OVERVIEW_WIDTH, l = Math.max(this.modified.getContentHeight(), this.original.getContentHeight());
      this._onDidContentSizeChange.fire({
        contentHeight: l,
        contentWidth: a,
        contentHeightChanged: r.contentHeightChanged,
        contentWidthChanged: r.contentWidthChanged
      });
    })), o;
  }
  _adjustOptionsForLeftHandSide(e, t) {
    const i = this._adjustOptionsForSubEditor(t);
    return this._options.renderSideBySide.get() ? (i.unicodeHighlight = this._options.editorOptions.get().unicodeHighlight || {}, i.wordWrapOverride1 = this._options.diffWordWrap.get()) : (i.wordWrapOverride1 = "off", i.wordWrapOverride2 = "off", i.stickyScroll = { enabled: !1 }, i.unicodeHighlight = { nonBasicASCII: !1, ambiguousCharacters: !1, invisibleCharacters: !1 }), i.glyphMargin = this._options.renderSideBySide.get(), t.originalAriaLabel && (i.ariaLabel = t.originalAriaLabel), i.ariaLabel = this._updateAriaLabel(i.ariaLabel), i.readOnly = !this._options.originalEditable.get(), i.dropIntoEditor = { enabled: !i.readOnly }, i.extraEditorClassName = "original-in-monaco-diff-editor", i;
  }
  _adjustOptionsForRightHandSide(e, t) {
    const i = this._adjustOptionsForSubEditor(t);
    return t.modifiedAriaLabel && (i.ariaLabel = t.modifiedAriaLabel), i.ariaLabel = this._updateAriaLabel(i.ariaLabel), i.wordWrapOverride1 = this._options.diffWordWrap.get(), i.revealHorizontalRightPadding = ad.revealHorizontalRightPadding.defaultValue + Lp.ENTIRE_DIFF_OVERVIEW_WIDTH, i.scrollbar.verticalHasArrows = !1, i.extraEditorClassName = "modified-in-monaco-diff-editor", i;
  }
  _adjustOptionsForSubEditor(e) {
    const t = {
      ...e,
      dimension: {
        height: 0,
        width: 0
      }
    };
    return t.inDiffEditor = !0, t.automaticLayout = !1, t.scrollbar = { ...t.scrollbar || {} }, t.folding = !1, t.codeLens = this._options.diffCodeLens.get(), t.fixedOverflowWidgets = !0, t.minimap = { ...t.minimap || {} }, t.minimap.enabled = !1, this._options.hideUnchangedRegions.get() ? t.stickyScroll = { enabled: !1 } : t.stickyScroll = this._options.editorOptions.get().stickyScroll, t;
  }
  _updateAriaLabel(e) {
    var i;
    e || (e = "");
    const t = m("diff-aria-navigation-tip", " use {0} to open the accessibility help.", (i = this._keybindingService.lookupKeybinding("editor.action.accessibilityHelp")) == null ? void 0 : i.getAriaLabel());
    return this._options.accessibilityVerbose.get() ? e + t : e ? e.replaceAll(t, "") : "";
  }
};
$D = pre([
  LP(5, Pe),
  LP(6, Lt)
], $D);
const Ov = class Ov extends U {
  constructor() {
    super(...arguments), this._id = ++Ov.idCounter, this._onDidDispose = this._register(new A()), this.onDidDispose = this._onDidDispose.event;
  }
  getId() {
    return this.getEditorType() + ":v2:" + this._id;
  }
  // #region editorBrowser.IDiffEditor: Delegating to modified Editor
  getVisibleColumnFromPosition(e) {
    return this._targetEditor.getVisibleColumnFromPosition(e);
  }
  getPosition() {
    return this._targetEditor.getPosition();
  }
  setPosition(e, t = "api") {
    this._targetEditor.setPosition(e, t);
  }
  revealLine(e, t = 0) {
    this._targetEditor.revealLine(e, t);
  }
  revealLineInCenter(e, t = 0) {
    this._targetEditor.revealLineInCenter(e, t);
  }
  revealLineInCenterIfOutsideViewport(e, t = 0) {
    this._targetEditor.revealLineInCenterIfOutsideViewport(e, t);
  }
  revealLineNearTop(e, t = 0) {
    this._targetEditor.revealLineNearTop(e, t);
  }
  revealPosition(e, t = 0) {
    this._targetEditor.revealPosition(e, t);
  }
  revealPositionInCenter(e, t = 0) {
    this._targetEditor.revealPositionInCenter(e, t);
  }
  revealPositionInCenterIfOutsideViewport(e, t = 0) {
    this._targetEditor.revealPositionInCenterIfOutsideViewport(e, t);
  }
  revealPositionNearTop(e, t = 0) {
    this._targetEditor.revealPositionNearTop(e, t);
  }
  getSelection() {
    return this._targetEditor.getSelection();
  }
  getSelections() {
    return this._targetEditor.getSelections();
  }
  setSelection(e, t = "api") {
    this._targetEditor.setSelection(e, t);
  }
  setSelections(e, t = "api") {
    this._targetEditor.setSelections(e, t);
  }
  revealLines(e, t, i = 0) {
    this._targetEditor.revealLines(e, t, i);
  }
  revealLinesInCenter(e, t, i = 0) {
    this._targetEditor.revealLinesInCenter(e, t, i);
  }
  revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
    this._targetEditor.revealLinesInCenterIfOutsideViewport(e, t, i);
  }
  revealLinesNearTop(e, t, i = 0) {
    this._targetEditor.revealLinesNearTop(e, t, i);
  }
  revealRange(e, t = 0, i = !1, n = !0) {
    this._targetEditor.revealRange(e, t, i, n);
  }
  revealRangeInCenter(e, t = 0) {
    this._targetEditor.revealRangeInCenter(e, t);
  }
  revealRangeInCenterIfOutsideViewport(e, t = 0) {
    this._targetEditor.revealRangeInCenterIfOutsideViewport(e, t);
  }
  revealRangeNearTop(e, t = 0) {
    this._targetEditor.revealRangeNearTop(e, t);
  }
  revealRangeNearTopIfOutsideViewport(e, t = 0) {
    this._targetEditor.revealRangeNearTopIfOutsideViewport(e, t);
  }
  revealRangeAtTop(e, t = 0) {
    this._targetEditor.revealRangeAtTop(e, t);
  }
  getSupportedActions() {
    return this._targetEditor.getSupportedActions();
  }
  focus() {
    this._targetEditor.focus();
  }
  trigger(e, t, i) {
    this._targetEditor.trigger(e, t, i);
  }
  createDecorationsCollection(e) {
    return this._targetEditor.createDecorationsCollection(e);
  }
  changeDecorations(e) {
    return this._targetEditor.changeDecorations(e);
  }
};
Ov.idCounter = 0;
let KD = Ov;
var _re = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, bre = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let jD = class {
  get editorOptions() {
    return this._options;
  }
  constructor(e, t) {
    this._accessibilityService = t, this._diffEditorWidth = it(this, 0), this._screenReaderMode = zt(this, this._accessibilityService.onDidChangeScreenReaderOptimized, () => this._accessibilityService.isScreenReaderOptimized()), this.couldShowInlineViewBecauseOfSize = xe(this, (n) => this._options.read(n).renderSideBySide && this._diffEditorWidth.read(n) <= this._options.read(n).renderSideBySideInlineBreakpoint), this.renderOverviewRuler = xe(this, (n) => this._options.read(n).renderOverviewRuler), this.renderSideBySide = xe(this, (n) => this.compactMode.read(n) && this.shouldRenderInlineViewInSmartMode.read(n) ? !1 : this._options.read(n).renderSideBySide && !(this._options.read(n).useInlineViewWhenSpaceIsLimited && this.couldShowInlineViewBecauseOfSize.read(n) && !this._screenReaderMode.read(n))), this.readOnly = xe(this, (n) => this._options.read(n).readOnly), this.shouldRenderOldRevertArrows = xe(this, (n) => !(!this._options.read(n).renderMarginRevertIcon || !this.renderSideBySide.read(n) || this.readOnly.read(n) || this.shouldRenderGutterMenu.read(n))), this.shouldRenderGutterMenu = xe(this, (n) => this._options.read(n).renderGutterMenu), this.renderIndicators = xe(this, (n) => this._options.read(n).renderIndicators), this.enableSplitViewResizing = xe(this, (n) => this._options.read(n).enableSplitViewResizing), this.splitViewDefaultRatio = xe(this, (n) => this._options.read(n).splitViewDefaultRatio), this.ignoreTrimWhitespace = xe(this, (n) => this._options.read(n).ignoreTrimWhitespace), this.maxComputationTimeMs = xe(this, (n) => this._options.read(n).maxComputationTime), this.showMoves = xe(this, (n) => this._options.read(n).experimental.showMoves && this.renderSideBySide.read(n)), this.isInEmbeddedEditor = xe(this, (n) => this._options.read(n).isInEmbeddedEditor), this.diffWordWrap = xe(this, (n) => this._options.read(n).diffWordWrap), this.originalEditable = xe(this, (n) => this._options.read(n).originalEditable), this.diffCodeLens = xe(this, (n) => this._options.read(n).diffCodeLens), this.accessibilityVerbose = xe(this, (n) => this._options.read(n).accessibilityVerbose), this.diffAlgorithm = xe(this, (n) => this._options.read(n).diffAlgorithm), this.showEmptyDecorations = xe(this, (n) => this._options.read(n).experimental.showEmptyDecorations), this.onlyShowAccessibleDiffViewer = xe(this, (n) => this._options.read(n).onlyShowAccessibleDiffViewer), this.compactMode = xe(this, (n) => this._options.read(n).compactMode), this.trueInlineDiffRenderingEnabled = xe(this, (n) => this._options.read(n).experimental.useTrueInlineView), this.useTrueInlineDiffRendering = xe(this, (n) => !this.renderSideBySide.read(n) && this.trueInlineDiffRenderingEnabled.read(n)), this.hideUnchangedRegions = xe(this, (n) => this._options.read(n).hideUnchangedRegions.enabled), this.hideUnchangedRegionsRevealLineCount = xe(this, (n) => this._options.read(n).hideUnchangedRegions.revealLineCount), this.hideUnchangedRegionsContextLineCount = xe(this, (n) => this._options.read(n).hideUnchangedRegions.contextLineCount), this.hideUnchangedRegionsMinimumLineCount = xe(this, (n) => this._options.read(n).hideUnchangedRegions.minimumLineCount), this._model = it(this, void 0), this.shouldRenderInlineViewInSmartMode = this._model.map(this, (n) => PH(this, (o) => {
      const r = n == null ? void 0 : n.diff.read(o);
      return r ? Cre(r, this.trueInlineDiffRenderingEnabled.read(o)) : void 0;
    })).flatten().map(this, (n) => !!n), this.inlineViewHideOriginalLineNumbers = this.compactMode;
    const i = { ...e, ...kP(e, Ai) };
    this._options = it(this, i);
  }
  updateOptions(e) {
    const t = kP(e, this._options.get()), i = { ...this._options.get(), ...e, ...t };
    this._options.set(i, void 0, { changedOptions: e });
  }
  setWidth(e) {
    this._diffEditorWidth.set(e, void 0);
  }
  setModel(e) {
    this._model.set(e, void 0);
  }
};
jD = _re([
  bre(1, Ks)
], jD);
function Cre(s, e) {
  return s.mappings.every((t) => vre(t.lineRangeMapping) || wre(t.lineRangeMapping) || e && qN(t.lineRangeMapping));
}
function vre(s) {
  return s.original.length === 0;
}
function wre(s) {
  return s.modified.length === 0;
}
function kP(s, e) {
  var t, i, n, o, r, a, l, c;
  return {
    enableSplitViewResizing: le(s.enableSplitViewResizing, e.enableSplitViewResizing),
    splitViewDefaultRatio: uV(s.splitViewDefaultRatio, 0.5, 0.1, 0.9),
    renderSideBySide: le(s.renderSideBySide, e.renderSideBySide),
    renderMarginRevertIcon: le(s.renderMarginRevertIcon, e.renderMarginRevertIcon),
    maxComputationTime: wc(
      s.maxComputationTime,
      e.maxComputationTime,
      0,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ),
    maxFileSize: wc(
      s.maxFileSize,
      e.maxFileSize,
      0,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ),
    ignoreTrimWhitespace: le(s.ignoreTrimWhitespace, e.ignoreTrimWhitespace),
    renderIndicators: le(s.renderIndicators, e.renderIndicators),
    originalEditable: le(s.originalEditable, e.originalEditable),
    diffCodeLens: le(s.diffCodeLens, e.diffCodeLens),
    renderOverviewRuler: le(s.renderOverviewRuler, e.renderOverviewRuler),
    diffWordWrap: Ot(s.diffWordWrap, e.diffWordWrap, ["off", "on", "inherit"]),
    diffAlgorithm: Ot(s.diffAlgorithm, e.diffAlgorithm, ["legacy", "advanced"], { smart: "legacy", experimental: "advanced" }),
    accessibilityVerbose: le(s.accessibilityVerbose, e.accessibilityVerbose),
    experimental: {
      showMoves: le((t = s.experimental) == null ? void 0 : t.showMoves, e.experimental.showMoves),
      showEmptyDecorations: le((i = s.experimental) == null ? void 0 : i.showEmptyDecorations, e.experimental.showEmptyDecorations),
      useTrueInlineView: le((n = s.experimental) == null ? void 0 : n.useTrueInlineView, e.experimental.useTrueInlineView)
    },
    hideUnchangedRegions: {
      enabled: le(((o = s.hideUnchangedRegions) == null ? void 0 : o.enabled) ?? ((r = s.experimental) == null ? void 0 : r.collapseUnchangedRegions), e.hideUnchangedRegions.enabled),
      contextLineCount: wc(
        (a = s.hideUnchangedRegions) == null ? void 0 : a.contextLineCount,
        e.hideUnchangedRegions.contextLineCount,
        0,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      ),
      minimumLineCount: wc(
        (l = s.hideUnchangedRegions) == null ? void 0 : l.minimumLineCount,
        e.hideUnchangedRegions.minimumLineCount,
        0,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      ),
      revealLineCount: wc(
        (c = s.hideUnchangedRegions) == null ? void 0 : c.revealLineCount,
        e.hideUnchangedRegions.revealLineCount,
        0,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      )
    },
    isInEmbeddedEditor: le(s.isInEmbeddedEditor, e.isInEmbeddedEditor),
    onlyShowAccessibleDiffViewer: le(s.onlyShowAccessibleDiffViewer, e.onlyShowAccessibleDiffViewer),
    renderSideBySideInlineBreakpoint: wc(
      s.renderSideBySideInlineBreakpoint,
      e.renderSideBySideInlineBreakpoint,
      0,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ),
    useInlineViewWhenSpaceIsLimited: le(s.useInlineViewWhenSpaceIsLimited, e.useInlineViewWhenSpaceIsLimited),
    renderGutterMenu: le(s.renderGutterMenu, e.renderGutterMenu),
    compactMode: le(s.compactMode, e.compactMode)
  };
}
var yre = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, gg = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let FC = class extends KD {
  get onDidContentSizeChange() {
    return this._editors.onDidContentSizeChange;
  }
  constructor(e, t, i, n, o, r, a, l) {
    super(), this._domElement = e, this._parentContextKeyService = n, this._parentInstantiationService = o, this._accessibilitySignalService = a, this._editorProgressService = l, this.elements = Xe("div.monaco-diff-editor.side-by-side", { style: { position: "relative", height: "100%" } }, [
      Xe("div.editor.original@original", { style: { position: "absolute", height: "100%" } }),
      Xe("div.editor.modified@modified", { style: { position: "absolute", height: "100%" } }),
      Xe("div.accessibleDiffViewer@accessibleDiffViewer", { style: { position: "absolute", height: "100%" } })
    ]), this._diffModelSrc = this._register(IO(this, void 0)), this._diffModel = xe(this, (v) => {
      var S;
      return (S = this._diffModelSrc.read(v)) == null ? void 0 : S.object;
    }), this.onDidChangeModel = ee.fromObservableLight(this._diffModel), this._contextKeyService = this._register(this._parentContextKeyService.createScoped(this._domElement)), this._instantiationService = this._register(this._parentInstantiationService.createChild(new Hf([Fe, this._contextKeyService]))), this._boundarySashes = it(this, void 0), this._accessibleDiffViewerShouldBeVisible = it(this, !1), this._accessibleDiffViewerVisible = xe(this, (v) => this._options.onlyShowAccessibleDiffViewer.read(v) ? !0 : this._accessibleDiffViewerShouldBeVisible.read(v)), this._movedBlocksLinesPart = it(this, void 0), this._layoutInfo = xe(this, (v) => {
      var oe, ae;
      const S = this._rootSizeObserver.width.read(v), L = this._rootSizeObserver.height.read(v);
      this._rootSizeObserver.automaticLayout ? this.elements.root.style.height = "100%" : this.elements.root.style.height = L + "px";
      const k = this._sash.read(v), x = this._gutter.read(v), I = (x == null ? void 0 : x.width.read(v)) ?? 0, K = ((oe = this._overviewRulerPart.read(v)) == null ? void 0 : oe.width) ?? 0;
      let B, W, H, P, q;
      if (!!k) {
        const re = k.sashLeft.read(v), be = ((ae = this._movedBlocksLinesPart.read(v)) == null ? void 0 : ae.width.read(v)) ?? 0;
        B = 0, W = re - I - be, q = re - I, H = re, P = S - H - K;
      } else {
        q = 0;
        const re = this._options.inlineViewHideOriginalLineNumbers.read(v);
        B = I, re ? W = 0 : W = Math.max(5, this._editors.originalObs.layoutInfoDecorationsLeft.read(v)), H = I + W, P = S - H - K;
      }
      return this.elements.original.style.left = B + "px", this.elements.original.style.width = W + "px", this._editors.original.layout({ width: W, height: L }, !0), x == null || x.layout(q), this.elements.modified.style.left = H + "px", this.elements.modified.style.width = P + "px", this._editors.modified.layout({ width: P, height: L }, !0), {
        modifiedEditor: this._editors.modified.getLayoutInfo(),
        originalEditor: this._editors.original.getLayoutInfo()
      };
    }), this._diffValue = this._diffModel.map((v, S) => v == null ? void 0 : v.diff.read(S)), this.onDidUpdateDiff = ee.fromObservableLight(this._diffValue), r.willCreateDiffEditor(), this._contextKeyService.createKey("isInDiffEditor", !0), this._domElement.appendChild(this.elements.root), this._register(_e(() => this.elements.root.remove())), this._rootSizeObserver = this._register(new P3(this.elements.root, t.dimension)), this._rootSizeObserver.setAutomaticLayout(t.automaticLayout ?? !1), this._options = this._instantiationService.createInstance(jD, t), this._register(Qe((v) => {
      this._options.setWidth(this._rootSizeObserver.width.read(v));
    })), this._contextKeyService.createKey(Z.isEmbeddedDiffEditor.key, !1), this._register(oa(Z.isEmbeddedDiffEditor, this._contextKeyService, (v) => this._options.isInEmbeddedEditor.read(v))), this._register(oa(Z.comparingMovedCode, this._contextKeyService, (v) => {
      var S;
      return !!((S = this._diffModel.read(v)) != null && S.movedTextToCompare.read(v));
    })), this._register(oa(Z.diffEditorRenderSideBySideInlineBreakpointReached, this._contextKeyService, (v) => this._options.couldShowInlineViewBecauseOfSize.read(v))), this._register(oa(Z.diffEditorInlineMode, this._contextKeyService, (v) => !this._options.renderSideBySide.read(v))), this._register(oa(Z.hasChanges, this._contextKeyService, (v) => {
      var S, L;
      return (((L = (S = this._diffModel.read(v)) == null ? void 0 : S.diff.read(v)) == null ? void 0 : L.mappings.length) ?? 0) > 0;
    })), this._editors = this._register(this._instantiationService.createInstance($D, this.elements.original, this.elements.modified, this._options, i, (v, S, L, k) => this._createInnerEditor(v, S, L, k))), this._register(oa(Z.diffEditorOriginalWritable, this._contextKeyService, (v) => this._options.originalEditable.read(v))), this._register(oa(Z.diffEditorModifiedWritable, this._contextKeyService, (v) => !this._options.readOnly.read(v))), this._register(oa(Z.diffEditorOriginalUri, this._contextKeyService, (v) => {
      var S;
      return ((S = this._diffModel.read(v)) == null ? void 0 : S.model.original.uri.toString()) ?? "";
    })), this._register(oa(Z.diffEditorModifiedUri, this._contextKeyService, (v) => {
      var S;
      return ((S = this._diffModel.read(v)) == null ? void 0 : S.model.modified.uri.toString()) ?? "";
    })), this._overviewRulerPart = mr(this, (v) => this._options.renderOverviewRuler.read(v) ? this._instantiationService.createInstance(Js(Lp, v), this._editors, this.elements.root, this._diffModel, this._rootSizeObserver.width, this._rootSizeObserver.height, this._layoutInfo.map((S) => S.modifiedEditor)) : void 0).recomputeInitiallyAndOnChange(this._store);
    const c = {
      height: this._rootSizeObserver.height,
      width: this._rootSizeObserver.width.map((v, S) => {
        var L;
        return v - (((L = this._overviewRulerPart.read(S)) == null ? void 0 : L.width) ?? 0);
      })
    };
    this._sashLayout = new lre(this._options, c), this._sash = mr(this, (v) => {
      const S = this._options.renderSideBySide.read(v);
      return this.elements.root.classList.toggle("side-by-side", S), S ? new V3(this.elements.root, c, this._options.enableSplitViewResizing, this._boundarySashes, this._sashLayout.sashLeft, () => this._sashLayout.resetSash()) : void 0;
    }).recomputeInitiallyAndOnChange(this._store);
    const h = mr(this, (v) => (
      /** @description UnchangedRangesFeature */
      this._instantiationService.createInstance(Js(UD, v), this._editors, this._diffModel, this._options)
    )).recomputeInitiallyAndOnChange(this._store);
    mr(this, (v) => (
      /** @description DiffEditorDecorations */
      this._instantiationService.createInstance(Js(are, v), this._editors, this._diffModel, this._options, this)
    )).recomputeInitiallyAndOnChange(this._store);
    const d = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set();
    let f = !1;
    const g = mr(this, (v) => (
      /** @description ViewZoneManager */
      this._instantiationService.createInstance(Js(WD, v), fe(this._domElement), this._editors, this._diffModel, this._options, this, () => f || h.get().isUpdatingHiddenAreas, d, u)
    )).recomputeInitiallyAndOnChange(this._store), p = xe(this, (v) => {
      const S = g.read(v).viewZones.read(v).orig, L = h.read(v).viewZones.read(v).origViewZones;
      return S.concat(L);
    }), _ = xe(this, (v) => {
      const S = g.read(v).viewZones.read(v).mod, L = h.read(v).viewZones.read(v).modViewZones;
      return S.concat(L);
    });
    this._register(AC(this._editors.original, p, (v) => {
      f = v;
    }, d));
    let b;
    this._register(AC(this._editors.modified, _, (v) => {
      f = v, f ? b = mp.capture(this._editors.modified) : (b == null || b.restore(this._editors.modified), b = void 0);
    }, u)), this._accessibleDiffViewer = mr(this, (v) => this._instantiationService.createInstance(Js(sh, v), this.elements.accessibleDiffViewer, this._accessibleDiffViewerVisible, (S, L) => this._accessibleDiffViewerShouldBeVisible.set(S, L), this._options.onlyShowAccessibleDiffViewer.map((S) => !S), this._rootSizeObserver.width, this._rootSizeObserver.height, this._diffModel.map((S, L) => {
      var k;
      return (k = S == null ? void 0 : S.diff.read(L)) == null ? void 0 : k.mappings.map((x) => x.lineRangeMapping);
    }), new Koe(this._editors))).recomputeInitiallyAndOnChange(this._store);
    const C = this._accessibleDiffViewerVisible.map((v) => v ? "hidden" : "visible");
    this._register(ic(this.elements.modified, { visibility: C })), this._register(ic(this.elements.original, { visibility: C })), this._createDiffEditorContributions(), r.addDiffEditor(this), this._gutter = mr(this, (v) => this._options.shouldRenderGutterMenu.read(v) ? this._instantiationService.createInstance(Js(HD, v), this.elements.root, this._diffModel, this._editors, this._options, this._sashLayout, this._boundarySashes) : void 0), this._register(dw(this._layoutInfo)), mr(this, (v) => (
      /** @description MovedBlocksLinesPart */
      new (Js(Zu, v))(this.elements.root, this._diffModel, this._layoutInfo.map((S) => S.originalEditor), this._layoutInfo.map((S) => S.modifiedEditor), this._editors)
    )).recomputeInitiallyAndOnChange(this._store, (v) => {
      this._movedBlocksLinesPart.set(v, void 0);
    }), this._register(ee.runAndSubscribe(this._editors.modified.onDidChangeCursorPosition, (v) => this._handleCursorPositionChange(v, !0))), this._register(ee.runAndSubscribe(this._editors.original.onDidChangeCursorPosition, (v) => this._handleCursorPositionChange(v, !1)));
    const w = this._diffModel.map(this, (v, S) => {
      if (v)
        return v.diff.read(S) === void 0 && !v.isDiffUpToDate.read(S);
    });
    this._register(ho((v, S) => {
      if (w.read(v) === !0) {
        const L = this._editorProgressService.show(!0, 1e3);
        S.add(_e(() => L.done()));
      }
    })), this._register(ho((v, S) => {
      S.add(new (Js(mre, v))(this._editors, this._diffModel, this._options, this));
    })), this._register(ho((v, S) => {
      const L = this._diffModel.read(v);
      if (L)
        for (const k of [L.model.original, L.model.modified])
          S.add(k.onWillDispose((x) => {
            Je(new at("TextModel got disposed before DiffEditorWidget model got reset")), this.setModel(null);
          }));
    })), this._register(Qe((v) => {
      this._options.setModel(this._diffModel.read(v));
    }));
  }
  _createInnerEditor(e, t, i, n) {
    return e.createInstance(sp, t, i, n);
  }
  _createDiffEditorContributions() {
    const e = Tu.getDiffEditorContributions();
    for (const t of e)
      try {
        this._register(this._instantiationService.createInstance(t.ctor, this));
      } catch (i) {
        Je(i);
      }
  }
  get _targetEditor() {
    return this._editors.modified;
  }
  getEditorType() {
    return Iw.IDiffEditor;
  }
  layout(e) {
    this._rootSizeObserver.observe(e);
  }
  hasTextFocus() {
    return this._editors.original.hasTextFocus() || this._editors.modified.hasTextFocus();
  }
  saveViewState() {
    var i;
    const e = this._editors.original.saveViewState(), t = this._editors.modified.saveViewState();
    return {
      original: e,
      modified: t,
      modelState: (i = this._diffModel.get()) == null ? void 0 : i.serializeState()
    };
  }
  restoreViewState(e) {
    var t;
    if (e && e.original && e.modified) {
      const i = e;
      this._editors.original.restoreViewState(i.original), this._editors.modified.restoreViewState(i.modified), i.modelState && ((t = this._diffModel.get()) == null || t.restoreSerializedState(i.modelState));
    }
  }
  handleInitialized() {
    this._editors.original.handleInitialized(), this._editors.modified.handleInitialized();
  }
  createViewModel(e) {
    return this._instantiationService.createInstance(BD, e, this._options);
  }
  getModel() {
    var e;
    return ((e = this._diffModel.get()) == null ? void 0 : e.model) ?? null;
  }
  setModel(e) {
    const t = e ? "model" in e ? PC.create(e).createNewRef(this) : PC.create(this.createViewModel(e), this) : null;
    this.setDiffModel(t);
  }
  setDiffModel(e, t) {
    const i = this._diffModel.get();
    !e && i && this._accessibleDiffViewer.get().close(), this._diffModel.get() !== (e == null ? void 0 : e.object) && ZE(t, (n) => {
      var a;
      const o = e == null ? void 0 : e.object;
      zt.batchEventsGlobally(n, () => {
        this._editors.original.setModel(o ? o.model.original : null), this._editors.modified.setModel(o ? o.model.modified : null);
      });
      const r = (a = this._diffModelSrc.get()) == null ? void 0 : a.createNewRef(this);
      this._diffModelSrc.set(e == null ? void 0 : e.createNewRef(this), n), setTimeout(() => {
        r == null || r.dispose();
      }, 0);
    });
  }
  /**
   * @param changedOptions Only has values for top-level options that have actually changed.
   */
  updateOptions(e) {
    this._options.updateOptions(e);
  }
  getContainerDomNode() {
    return this._domElement;
  }
  getOriginalEditor() {
    return this._editors.original;
  }
  getModifiedEditor() {
    return this._editors.modified;
  }
  /**
   * @deprecated Use `this.getDiffComputationResult().changes2` instead.
   */
  getLineChanges() {
    var t;
    const e = (t = this._diffModel.get()) == null ? void 0 : t.diff.get();
    return e ? Sre(e) : null;
  }
  revert(e) {
    const t = this._diffModel.get();
    !t || !t.isDiffUpToDate.get() || this._editors.modified.executeEdits("diffEditor", [
      {
        range: e.modified.toExclusiveRange(),
        text: t.model.original.getValueInRange(e.original.toExclusiveRange())
      }
    ]);
  }
  revertRangeMappings(e) {
    const t = this._diffModel.get();
    if (!t || !t.isDiffUpToDate.get())
      return;
    const i = e.map((n) => ({
      range: n.modifiedRange,
      text: t.model.original.getValueInRange(n.originalRange)
    }));
    this._editors.modified.executeEdits("diffEditor", i);
  }
  _goTo(e) {
    this._editors.modified.setPosition(new F(e.lineRangeMapping.modified.startLineNumber, 1)), this._editors.modified.revealRangeInCenter(e.lineRangeMapping.modified.toExclusiveRange());
  }
  goToDiff(e) {
    var o, r;
    const t = (r = (o = this._diffModel.get()) == null ? void 0 : o.diff.get()) == null ? void 0 : r.mappings;
    if (!t || t.length === 0)
      return;
    const i = this._editors.modified.getPosition().lineNumber;
    let n;
    e === "next" ? n = t.find((a) => a.lineRangeMapping.modified.startLineNumber > i) ?? t[0] : n = L1(t, (a) => a.lineRangeMapping.modified.startLineNumber < i) ?? t[t.length - 1], this._goTo(n), n.lineRangeMapping.modified.isEmpty ? this._accessibilitySignalService.playSignal(xr.diffLineDeleted, { source: "diffEditor.goToDiff" }) : n.lineRangeMapping.original.isEmpty ? this._accessibilitySignalService.playSignal(xr.diffLineInserted, { source: "diffEditor.goToDiff" }) : n && this._accessibilitySignalService.playSignal(xr.diffLineModified, { source: "diffEditor.goToDiff" });
  }
  revealFirstDiff() {
    const e = this._diffModel.get();
    e && this.waitForDiff().then(() => {
      var i;
      const t = (i = e.diff.get()) == null ? void 0 : i.mappings;
      !t || t.length === 0 || this._goTo(t[0]);
    });
  }
  accessibleDiffViewerNext() {
    this._accessibleDiffViewer.get().next();
  }
  accessibleDiffViewerPrev() {
    this._accessibleDiffViewer.get().prev();
  }
  async waitForDiff() {
    const e = this._diffModel.get();
    e && await e.waitForDiff();
  }
  mapToOtherSide() {
    var r, a;
    const e = this._editors.modified.hasWidgetFocus(), t = e ? this._editors.modified : this._editors.original, i = e ? this._editors.original : this._editors.modified;
    let n;
    const o = t.getSelection();
    if (o) {
      const l = (a = (r = this._diffModel.get()) == null ? void 0 : r.diff.get()) == null ? void 0 : a.mappings.map((c) => e ? c.lineRangeMapping.flip() : c.lineRangeMapping);
      if (l) {
        const c = rP(o.getStartPosition(), l), h = rP(o.getEndPosition(), l);
        n = T.plusRange(c, h);
      }
    }
    return { destination: i, destinationSelection: n };
  }
  switchSide() {
    const { destination: e, destinationSelection: t } = this.mapToOtherSide();
    e.focus(), t && e.setSelection(t);
  }
  exitCompareMove() {
    const e = this._diffModel.get();
    e && e.movedTextToCompare.set(void 0, void 0);
  }
  collapseAllUnchangedRegions() {
    var t;
    const e = (t = this._diffModel.get()) == null ? void 0 : t.unchangedRegions.get();
    e && bi((i) => {
      for (const n of e)
        n.collapseAll(i);
    });
  }
  showAllUnchangedRegions() {
    var t;
    const e = (t = this._diffModel.get()) == null ? void 0 : t.unchangedRegions.get();
    e && bi((i) => {
      for (const n of e)
        n.showAll(i);
    });
  }
  _handleCursorPositionChange(e, t) {
    var i, n;
    if ((e == null ? void 0 : e.reason) === 3) {
      const o = (n = (i = this._diffModel.get()) == null ? void 0 : i.diff.get()) == null ? void 0 : n.mappings.find((r) => t ? r.lineRangeMapping.modified.contains(e.position.lineNumber) : r.lineRangeMapping.original.contains(e.position.lineNumber));
      o != null && o.lineRangeMapping.modified.isEmpty ? this._accessibilitySignalService.playSignal(xr.diffLineDeleted, { source: "diffEditor.cursorPositionChanged" }) : o != null && o.lineRangeMapping.original.isEmpty ? this._accessibilitySignalService.playSignal(xr.diffLineInserted, { source: "diffEditor.cursorPositionChanged" }) : o && this._accessibilitySignalService.playSignal(xr.diffLineModified, { source: "diffEditor.cursorPositionChanged" });
    }
  }
};
FC = yre([
  gg(3, Fe),
  gg(4, Pe),
  gg(5, Tt),
  gg(6, Yw),
  gg(7, Kp)
], FC);
function Sre(s) {
  return s.mappings.map((e) => {
    const t = e.lineRangeMapping;
    let i, n, o, r, a = t.innerChanges;
    return t.original.isEmpty ? (i = t.original.startLineNumber - 1, n = 0, a = void 0) : (i = t.original.startLineNumber, n = t.original.endLineNumberExclusive - 1), t.modified.isEmpty ? (o = t.modified.startLineNumber - 1, r = 0, a = void 0) : (o = t.modified.startLineNumber, r = t.modified.endLineNumberExclusive - 1), {
      originalStartLineNumber: i,
      originalEndLineNumber: n,
      modifiedStartLineNumber: o,
      modifiedEndLineNumber: r,
      charChanges: a == null ? void 0 : a.map((l) => ({
        originalStartLineNumber: l.originalRange.startLineNumber,
        originalStartColumn: l.originalRange.startColumn,
        originalEndLineNumber: l.originalRange.endLineNumber,
        originalEndColumn: l.originalRange.endColumn,
        modifiedStartLineNumber: l.modifiedRange.startLineNumber,
        modifiedStartColumn: l.modifiedRange.startColumn,
        modifiedEndLineNumber: l.modifiedRange.endLineNumber,
        modifiedEndColumn: l.modifiedRange.endColumn
      }))
    };
  });
}
var ZN = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, bt = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Lre = 0, xP = !1;
function kre(s) {
  if (!s) {
    if (xP)
      return;
    xP = !0;
  }
  XW(s || pt.document.body);
}
let BC = class extends sp {
  constructor(e, t, i, n, o, r, a, l, c, h, d, u, f) {
    const g = { ...t };
    g.ariaLabel = g.ariaLabel || Bx.editorViewAccessibleLabel, super(e, g, {}, i, n, o, r, c, h, d, u, f), l instanceof xf ? this._standaloneKeybindingService = l : this._standaloneKeybindingService = null, kre(g.ariaContainerElement), dW((p, _) => i.createInstance(wf, p, _, {})), YW(a);
  }
  addCommand(e, t, i) {
    if (!this._standaloneKeybindingService)
      return console.warn("Cannot add command because the editor is configured with an unrecognized KeybindingService"), null;
    const n = "DYNAMIC_" + ++Lre, o = ve.deserialize(i);
    return this._standaloneKeybindingService.addDynamicKeybinding(n, e, t, o), n;
  }
  createContextKey(e, t) {
    return this._contextKeyService.createKey(e, t);
  }
  addAction(e) {
    if (typeof e.id != "string" || typeof e.label != "string" || typeof e.run != "function")
      throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
    if (!this._standaloneKeybindingService)
      return console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService"), U.None;
    const t = e.id, i = e.label, n = ve.and(ve.equals("editorId", this.getId()), ve.deserialize(e.precondition)), o = e.keybindings, r = ve.and(n, ve.deserialize(e.keybindingContext)), a = e.contextMenuGroupId || null, l = e.contextMenuOrder || 0, c = (f, ...g) => Promise.resolve(e.run(this, ...g)), h = new ne(), d = this.getId() + ":" + t;
    if (h.add(St.registerCommand(d, c)), a) {
      const f = {
        command: {
          id: d,
          title: i
        },
        when: n,
        group: a,
        order: l
      };
      h.add(so.appendMenuItem(et.EditorContext, f));
    }
    if (Array.isArray(o))
      for (const f of o)
        h.add(this._standaloneKeybindingService.addDynamicKeybinding(d, f, c, r));
    const u = new nF(d, i, i, void 0, n, (...f) => Promise.resolve(e.run(this, ...f)), this._contextKeyService);
    return this._actions.set(t, u), h.add(_e(() => {
      this._actions.delete(t);
    })), h;
  }
  _triggerCommand(e, t) {
    if (this._codeEditorService instanceof mC)
      try {
        this._codeEditorService.setActiveCodeEditor(this), super._triggerCommand(e, t);
      } finally {
        this._codeEditorService.setActiveCodeEditor(null);
      }
    else
      super._triggerCommand(e, t);
  }
};
BC = ZN([
  bt(2, Pe),
  bt(3, Tt),
  bt(4, fi),
  bt(5, Fe),
  bt(6, Cd),
  bt(7, Lt),
  bt(8, wn),
  bt(9, cn),
  bt(10, Ks),
  bt(11, ir),
  bt(12, De)
], BC);
let qD = class extends BC {
  constructor(e, t, i, n, o, r, a, l, c, h, d, u, f, g, p, _) {
    const b = { ...t };
    TC(d, b, !1);
    const C = c.registerEditorContainer(e);
    typeof b.theme == "string" && c.setTheme(b.theme), typeof b.autoDetectHighContrast < "u" && c.setAutoDetectHighContrast(!!b.autoDetectHighContrast);
    const w = b.model;
    delete b.model, super(e, b, i, n, o, r, a, l, c, h, u, p, _), this._configurationService = d, this._standaloneThemeService = c, this._register(C);
    let v;
    if (typeof w > "u") {
      const S = g.getLanguageIdByMimeType(b.language) || b.language || Fs;
      v = $3(f, g, b.value || "", S, void 0), this._ownsModel = !0;
    } else
      v = w, this._ownsModel = !1;
    if (this._attachModel(v), v) {
      const S = {
        oldModelUrl: null,
        newModelUrl: v.uri
      };
      this._onDidChangeModel.fire(S);
    }
  }
  dispose() {
    super.dispose();
  }
  updateOptions(e) {
    TC(this._configurationService, e, !1), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(!!e.autoDetectHighContrast), super.updateOptions(e);
  }
  _postDetachModelCleanup(e) {
    super._postDetachModelCleanup(e), e && this._ownsModel && (e.dispose(), this._ownsModel = !1);
  }
};
qD = ZN([
  bt(2, Pe),
  bt(3, Tt),
  bt(4, fi),
  bt(5, Fe),
  bt(6, Cd),
  bt(7, Lt),
  bt(8, yo),
  bt(9, cn),
  bt(10, gt),
  bt(11, Ks),
  bt(12, Ui),
  bt(13, ci),
  bt(14, ir),
  bt(15, De)
], qD);
let GD = class extends FC {
  constructor(e, t, i, n, o, r, a, l, c, h, d, u) {
    const f = { ...t };
    TC(l, f, !0);
    const g = r.registerEditorContainer(e);
    typeof f.theme == "string" && r.setTheme(f.theme), typeof f.autoDetectHighContrast < "u" && r.setAutoDetectHighContrast(!!f.autoDetectHighContrast), super(e, f, {}, n, i, o, u, h), this._configurationService = l, this._standaloneThemeService = r, this._register(g);
  }
  dispose() {
    super.dispose();
  }
  updateOptions(e) {
    TC(this._configurationService, e, !0), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(!!e.autoDetectHighContrast), super.updateOptions(e);
  }
  _createInnerEditor(e, t, i) {
    return e.createInstance(BC, t, i);
  }
  getOriginalEditor() {
    return super.getOriginalEditor();
  }
  getModifiedEditor() {
    return super.getModifiedEditor();
  }
  addCommand(e, t, i) {
    return this.getModifiedEditor().addCommand(e, t, i);
  }
  createContextKey(e, t) {
    return this.getModifiedEditor().createContextKey(e, t);
  }
  addAction(e) {
    return this.getModifiedEditor().addAction(e);
  }
};
GD = ZN([
  bt(2, Pe),
  bt(3, Fe),
  bt(4, Tt),
  bt(5, yo),
  bt(6, cn),
  bt(7, gt),
  bt(8, nr),
  bt(9, Kp),
  bt(10, BN),
  bt(11, Yw)
], GD);
function $3(s, e, t, i, n) {
  if (t = t || "", !i) {
    const o = t.indexOf(`
`);
    let r = t;
    return o !== -1 && (r = t.substring(0, o)), DP(s, t, e.createByFilepathOrFirstLine(n || null, r), n);
  }
  return DP(s, t, e.createById(i), n);
}
function DP(s, e, t, i) {
  return s.createModel(e, t, i);
}
var xre = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, EP = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class Dre {
  constructor(e, t) {
    this.viewModel = e, this.deltaScrollVertical = t;
  }
  getId() {
    return this.viewModel;
  }
}
let WC = class extends U {
  constructor(e, t, i, n, o) {
    super(), this._container = e, this._overflowWidgetsDomNode = t, this._workbenchUIElementFactory = i, this._instantiationService = n, this._viewModel = it(this, void 0), this._collapsed = xe(this, (l) => {
      var c;
      return (c = this._viewModel.read(l)) == null ? void 0 : c.collapsed.read(l);
    }), this._editorContentHeight = it(this, 500), this.contentHeight = xe(this, (l) => (this._collapsed.read(l) ? 0 : this._editorContentHeight.read(l)) + this._outerEditorHeight), this._modifiedContentWidth = it(this, 0), this._modifiedWidth = it(this, 0), this._originalContentWidth = it(this, 0), this._originalWidth = it(this, 0), this.maxScroll = xe(this, (l) => {
      const c = this._modifiedContentWidth.read(l) - this._modifiedWidth.read(l), h = this._originalContentWidth.read(l) - this._originalWidth.read(l);
      return c > h ? { maxScroll: c, width: this._modifiedWidth.read(l) } : { maxScroll: h, width: this._originalWidth.read(l) };
    }), this._elements = Xe("div.multiDiffEntry", [
      Xe("div.header@header", [
        Xe("div.header-content", [
          Xe("div.collapse-button@collapseButton"),
          Xe("div.file-path", [
            Xe("div.title.modified.show-file-icons@primaryPath", []),
            Xe("div.status.deleted@status", ["R"]),
            Xe("div.title.original.show-file-icons@secondaryPath", [])
          ]),
          Xe("div.actions@actions")
        ])
      ]),
      Xe("div.editorParent", [
        Xe("div.editorContainer@editor")
      ])
    ]), this.editor = this._register(this._instantiationService.createInstance(FC, this._elements.editor, {
      overflowWidgetsDomNode: this._overflowWidgetsDomNode
    }, {})), this.isModifedFocused = Sp(this.editor.getModifiedEditor()).isFocused, this.isOriginalFocused = Sp(this.editor.getOriginalEditor()).isFocused, this.isFocused = xe(this, (l) => this.isModifedFocused.read(l) || this.isOriginalFocused.read(l)), this._resourceLabel = this._workbenchUIElementFactory.createResourceLabel ? this._register(this._workbenchUIElementFactory.createResourceLabel(this._elements.primaryPath)) : void 0, this._resourceLabel2 = this._workbenchUIElementFactory.createResourceLabel ? this._register(this._workbenchUIElementFactory.createResourceLabel(this._elements.secondaryPath)) : void 0, this._dataStore = this._register(new ne()), this._headerHeight = 40, this._lastScrollTop = -1, this._isSettingScrollTop = !1;
    const r = new iD(this._elements.collapseButton, {});
    this._register(Qe((l) => {
      r.element.className = "", r.icon = this._collapsed.read(l) ? ie.chevronRight : ie.chevronDown;
    })), this._register(r.onDidClick(() => {
      var l;
      (l = this._viewModel.get()) == null || l.collapsed.set(!this._collapsed.get(), void 0);
    })), this._register(Qe((l) => {
      this._elements.editor.style.display = this._collapsed.read(l) ? "none" : "block";
    })), this._register(this.editor.getModifiedEditor().onDidLayoutChange((l) => {
      const c = this.editor.getModifiedEditor().getLayoutInfo().contentWidth;
      this._modifiedWidth.set(c, void 0);
    })), this._register(this.editor.getOriginalEditor().onDidLayoutChange((l) => {
      const c = this.editor.getOriginalEditor().getLayoutInfo().contentWidth;
      this._originalWidth.set(c, void 0);
    })), this._register(this.editor.onDidContentSizeChange((l) => {
      _g((c) => {
        this._editorContentHeight.set(l.contentHeight, c), this._modifiedContentWidth.set(this.editor.getModifiedEditor().getContentWidth(), c), this._originalContentWidth.set(this.editor.getOriginalEditor().getContentWidth(), c);
      });
    })), this._register(this.editor.getOriginalEditor().onDidScrollChange((l) => {
      if (this._isSettingScrollTop || !l.scrollTopChanged || !this._data)
        return;
      const c = l.scrollTop - this._lastScrollTop;
      this._data.deltaScrollVertical(c);
    })), this._register(Qe((l) => {
      var h;
      const c = (h = this._viewModel.read(l)) == null ? void 0 : h.isActive.read(l);
      this._elements.root.classList.toggle("active", c);
    })), this._container.appendChild(this._elements.root), this._outerEditorHeight = this._headerHeight, this._contextKeyService = this._register(o.createScoped(this._elements.actions));
    const a = this._register(this._instantiationService.createChild(new Hf([Fe, this._contextKeyService])));
    this._register(a.createInstance(Q1, this._elements.actions, et.MultiDiffEditorFileToolbar, {
      actionRunner: this._register(new z3(() => {
        var l;
        return (l = this._viewModel.get()) == null ? void 0 : l.modifiedUri;
      })),
      menuOptions: {
        shouldForwardArgs: !0
      },
      toolbarOptions: { primaryGroup: (l) => l.startsWith("navigation") },
      actionViewItemProvider: (l, c) => NF(a, l, c)
    }));
  }
  setScrollLeft(e) {
    this._modifiedContentWidth.get() - this._modifiedWidth.get() > this._originalContentWidth.get() - this._originalWidth.get() ? this.editor.getModifiedEditor().setScrollLeft(e) : this.editor.getOriginalEditor().setScrollLeft(e);
  }
  setData(e) {
    this._data = e;
    function t(n) {
      return {
        ...n,
        scrollBeyondLastLine: !1,
        hideUnchangedRegions: {
          enabled: !0
        },
        scrollbar: {
          vertical: "hidden",
          horizontal: "hidden",
          handleMouseWheel: !1,
          useShadows: !1
        },
        renderOverviewRuler: !1,
        fixedOverflowWidgets: !0,
        overviewRulerBorder: !1
      };
    }
    if (!e) {
      _g((n) => {
        this._viewModel.set(void 0, n), this.editor.setDiffModel(null, n), this._dataStore.clear();
      });
      return;
    }
    const i = e.viewModel.documentDiffItem;
    if (_g((n) => {
      var c, h;
      (c = this._resourceLabel) == null || c.setUri(e.viewModel.modifiedUri ?? e.viewModel.originalUri, { strikethrough: e.viewModel.modifiedUri === void 0 });
      let o = !1, r = !1, a = !1, l = "";
      e.viewModel.modifiedUri && e.viewModel.originalUri && e.viewModel.modifiedUri.path !== e.viewModel.originalUri.path ? (l = "R", o = !0) : e.viewModel.modifiedUri ? e.viewModel.originalUri || (l = "A", a = !0) : (l = "D", r = !0), this._elements.status.classList.toggle("renamed", o), this._elements.status.classList.toggle("deleted", r), this._elements.status.classList.toggle("added", a), this._elements.status.innerText = l, (h = this._resourceLabel2) == null || h.setUri(o ? e.viewModel.originalUri : void 0, { strikethrough: !0 }), this._dataStore.clear(), this._viewModel.set(e.viewModel, n), this.editor.setDiffModel(e.viewModel.diffEditorViewModelRef, n), this.editor.updateOptions(t(i.options ?? {}));
    }), i.onOptionsDidChange && this._dataStore.add(i.onOptionsDidChange(() => {
      this.editor.updateOptions(t(i.options ?? {}));
    })), e.viewModel.isAlive.recomputeInitiallyAndOnChange(this._dataStore, (n) => {
      n || this.setData(void 0);
    }), e.viewModel.documentDiffItem.contextKeys)
      for (const [n, o] of Object.entries(e.viewModel.documentDiffItem.contextKeys))
        this._contextKeyService.createKey(n, o);
  }
  render(e, t, i, n) {
    this._elements.root.style.visibility = "visible", this._elements.root.style.top = `${e.start}px`, this._elements.root.style.height = `${e.length}px`, this._elements.root.style.width = `${t}px`, this._elements.root.style.position = "absolute";
    const o = e.length - this._headerHeight, r = Math.max(0, Math.min(n.start - e.start, o));
    this._elements.header.style.transform = `translateY(${r}px)`, _g((a) => {
      this.editor.layout({
        width: t - 2 * 8 - 2 * 1,
        height: e.length - this._outerEditorHeight
      });
    });
    try {
      this._isSettingScrollTop = !0, this._lastScrollTop = i, this.editor.getOriginalEditor().setScrollTop(i);
    } finally {
      this._isSettingScrollTop = !1;
    }
    this._elements.header.classList.toggle("shadow", r > 0 || i > 0), this._elements.header.classList.toggle("collapsed", r === o);
  }
  hide() {
    this._elements.root.style.top = "-100000px", this._elements.root.style.visibility = "hidden";
  }
};
WC = xre([
  EP(3, Pe),
  EP(4, Fe)
], WC);
class Ere {
  constructor(e) {
    this._create = e, this._unused = /* @__PURE__ */ new Set(), this._used = /* @__PURE__ */ new Set(), this._itemData = /* @__PURE__ */ new Map();
  }
  getUnusedObj(e) {
    let t;
    if (this._unused.size === 0)
      t = this._create(e), this._itemData.set(t, e);
    else {
      const i = [...this._unused.values()];
      t = i.find((n) => this._itemData.get(n).getId() === e.getId()) ?? i[0], this._unused.delete(t), this._itemData.set(t, e), t.setData(e);
    }
    return this._used.add(t), {
      object: t,
      dispose: () => {
        this._used.delete(t), this._unused.size > 5 ? t.dispose() : this._unused.add(t);
      }
    };
  }
  dispose() {
    for (const e of this._used)
      e.dispose();
    for (const e of this._unused)
      e.dispose();
    this._used.clear(), this._unused.clear();
  }
}
var Ire = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, IP = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let ZD = class extends U {
  constructor(e, t, i, n, o, r) {
    super(), this._element = e, this._dimension = t, this._viewModel = i, this._workbenchUIElementFactory = n, this._parentContextKeyService = o, this._parentInstantiationService = r, this._scrollableElements = Xe("div.scrollContent", [
      Xe("div@content", {
        style: {
          overflow: "hidden"
        }
      }),
      Xe("div.monaco-editor@overflowWidgetsDomNode", {})
    ]), this._scrollable = this._register(new Pf({
      forceIntegerValues: !1,
      scheduleAtNextAnimationFrame: (l) => ns(fe(this._element), l),
      smoothScrollDuration: 100
    })), this._scrollableElement = this._register(new rw(this._scrollableElements.root, {
      vertical: 1,
      horizontal: 1,
      useShadows: !1
    }, this._scrollable)), this._elements = Xe("div.monaco-component.multiDiffEditor", {}, [
      Xe("div", {}, [this._scrollableElement.getDomNode()]),
      Xe("div.placeholder@placeholder", {}, [Xe("div", [m("noChangedFiles", "No Changed Files")])])
    ]), this._sizeObserver = this._register(new P3(this._element, void 0)), this._objectPool = this._register(new Ere((l) => {
      const c = this._instantiationService.createInstance(WC, this._scrollableElements.content, this._scrollableElements.overflowWidgetsDomNode, this._workbenchUIElementFactory);
      return c.setData(l), c;
    })), this.scrollTop = zt(this, this._scrollableElement.onScroll, () => (
      /** @description scrollTop */
      this._scrollableElement.getScrollPosition().scrollTop
    )), this.scrollLeft = zt(this, this._scrollableElement.onScroll, () => (
      /** @description scrollLeft */
      this._scrollableElement.getScrollPosition().scrollLeft
    )), this._viewItemsInfo = rd(this, (l, c) => {
      const h = this._viewModel.read(l);
      if (!h)
        return { items: [], getItem: (g) => {
          throw new at();
        } };
      const d = h.items.read(l), u = /* @__PURE__ */ new Map();
      return { items: d.map((g) => {
        var b;
        const p = c.add(new Nre(g, this._objectPool, this.scrollLeft, (C) => {
          this._scrollableElement.setScrollPosition({ scrollTop: this._scrollableElement.getScrollPosition().scrollTop + C });
        })), _ = (b = this._lastDocStates) == null ? void 0 : b[p.getKey()];
        return _ && bi((C) => {
          p.setViewState(_, C);
        }), u.set(g, p), p;
      }), getItem: (g) => u.get(g) };
    }), this._viewItems = this._viewItemsInfo.map(this, (l) => l.items), this._spaceBetweenPx = 0, this._totalHeight = this._viewItems.map(this, (l, c) => l.reduce((h, d) => h + d.contentHeight.read(c) + this._spaceBetweenPx, 0)), this._contextKeyService = this._register(this._parentContextKeyService.createScoped(this._element)), this._instantiationService = this._register(this._parentInstantiationService.createChild(new Hf([Fe, this._contextKeyService]))), this._lastDocStates = {}, this._contextKeyService.createKey(Z.inMultiDiffEditor.key, !0), this._register(ho((l, c) => {
      const h = this._viewModel.read(l);
      if (h && h.contextKeys)
        for (const [d, u] of Object.entries(h.contextKeys)) {
          const f = this._contextKeyService.createKey(d, void 0);
          f.set(u), c.add(_e(() => f.reset()));
        }
    }));
    const a = this._parentContextKeyService.createKey(Z.multiDiffEditorAllCollapsed.key, !1);
    this._register(Qe((l) => {
      const c = this._viewModel.read(l);
      if (c) {
        const h = c.items.read(l).every((d) => d.collapsed.read(l));
        a.set(h);
      }
    })), this._register(Qe((l) => {
      const c = this._dimension.read(l);
      this._sizeObserver.observe(c);
    })), this._register(Qe((l) => {
      const c = this._viewItems.read(l);
      this._elements.placeholder.classList.toggle("visible", c.length === 0);
    })), this._scrollableElements.content.style.position = "relative", this._register(Qe((l) => {
      const c = this._sizeObserver.height.read(l);
      this._scrollableElements.root.style.height = `${c}px`;
      const h = this._totalHeight.read(l);
      this._scrollableElements.content.style.height = `${h}px`;
      const d = this._sizeObserver.width.read(l);
      let u = d;
      const f = this._viewItems.read(l), g = Y5(f, Os((p) => p.maxScroll.read(l).maxScroll, Ba));
      if (g) {
        const p = g.maxScroll.read(l);
        u = d + p.maxScroll;
      }
      this._scrollableElement.setScrollDimensions({
        width: d,
        height: c,
        scrollHeight: h,
        scrollWidth: u
      });
    })), e.replaceChildren(this._elements.root), this._register(_e(() => {
      e.replaceChildren();
    })), this._register(this._register(Qe((l) => {
      _g((c) => {
        this.render(l);
      });
    })));
  }
  render(e) {
    const t = this.scrollTop.read(e);
    let i = 0, n = 0, o = 0;
    const r = this._sizeObserver.height.read(e), a = Ne.ofStartAndLength(t, r), l = this._sizeObserver.width.read(e);
    for (const c of this._viewItems.read(e)) {
      const h = c.contentHeight.read(e), d = Math.min(h, r), u = Ne.ofStartAndLength(n, d), f = Ne.ofStartAndLength(o, h);
      if (f.isBefore(a))
        i -= h - d, c.hide();
      else if (f.isAfter(a))
        c.hide();
      else {
        const g = Math.max(0, Math.min(a.start - f.start, h - d));
        i -= g;
        const p = Ne.ofStartAndLength(t + i, r);
        c.render(u, g, l, p);
      }
      n += d + this._spaceBetweenPx, o += h + this._spaceBetweenPx;
    }
    this._scrollableElements.content.style.transform = `translateY(${-(t + i)}px)`;
  }
};
ZD = Ire([
  IP(4, Fe),
  IP(5, Pe)
], ZD);
class Nre extends U {
  constructor(e, t, i, n) {
    super(), this.viewModel = e, this._objectPool = t, this._scrollLeft = i, this._deltaScrollVertical = n, this._templateRef = this._register(IO(this, void 0)), this.contentHeight = xe(this, (o) => {
      var r, a;
      return ((a = (r = this._templateRef.read(o)) == null ? void 0 : r.object.contentHeight) == null ? void 0 : a.read(o)) ?? this.viewModel.lastTemplateData.read(o).contentHeight;
    }), this.maxScroll = xe(this, (o) => {
      var r;
      return ((r = this._templateRef.read(o)) == null ? void 0 : r.object.maxScroll.read(o)) ?? { maxScroll: 0, scrollWidth: 0 };
    }), this.template = xe(this, (o) => {
      var r;
      return (r = this._templateRef.read(o)) == null ? void 0 : r.object;
    }), this._isHidden = it(this, !1), this._isFocused = xe(this, (o) => {
      var r;
      return ((r = this.template.read(o)) == null ? void 0 : r.isFocused.read(o)) ?? !1;
    }), this.viewModel.setIsFocused(this._isFocused, void 0), this._register(Qe((o) => {
      var a;
      const r = this._scrollLeft.read(o);
      (a = this._templateRef.read(o)) == null || a.object.setScrollLeft(r);
    })), this._register(Qe((o) => {
      const r = this._templateRef.read(o);
      !r || !this._isHidden.read(o) || r.object.isFocused.read(o) || this._clear();
    }));
  }
  dispose() {
    this._clear(), super.dispose();
  }
  toString() {
    var e;
    return `VirtualViewItem(${(e = this.viewModel.documentDiffItem.modified) == null ? void 0 : e.uri.toString()})`;
  }
  getKey() {
    return this.viewModel.getKey();
  }
  setViewState(e, t) {
    var r;
    this.viewModel.collapsed.set(e.collapsed, t), this._updateTemplateData(t);
    const i = this.viewModel.lastTemplateData.get(), n = (r = e.selections) == null ? void 0 : r.map(Ue.liftSelection);
    this.viewModel.lastTemplateData.set({
      ...i,
      selections: n
    }, t);
    const o = this._templateRef.get();
    o && n && o.object.editor.setSelections(n);
  }
  _updateTemplateData(e) {
    const t = this._templateRef.get();
    t && this.viewModel.lastTemplateData.set({
      contentHeight: t.object.contentHeight.get(),
      selections: t.object.editor.getSelections() ?? void 0
    }, e);
  }
  _clear() {
    const e = this._templateRef.get();
    e && bi((t) => {
      this._updateTemplateData(t), e.object.hide(), this._templateRef.set(void 0, t);
    });
  }
  hide() {
    this._isHidden.set(!0, void 0);
  }
  render(e, t, i, n) {
    this._isHidden.set(!1, void 0);
    let o = this._templateRef.get();
    if (!o) {
      o = this._objectPool.getUnusedObj(new Dre(this.viewModel, this._deltaScrollVertical)), this._templateRef.set(o, void 0);
      const r = this.viewModel.lastTemplateData.get().selections;
      r && o.object.editor.setSelections(r);
    }
    o.object.render(e, i, t, n);
  }
}
E("multiDiffEditor.headerBackground", { dark: "#262626", light: "tab.inactiveBackground", hcDark: "tab.inactiveBackground", hcLight: "tab.inactiveBackground" }, m("multiDiffEditor.headerBackground", "The background color of the diff editor's header"));
E("multiDiffEditor.background", po, m("multiDiffEditor.background", "The background color of the multi file diff editor"));
E("multiDiffEditor.border", { dark: "sideBarSectionHeader.border", light: "#cccccc", hcDark: "sideBarSectionHeader.border", hcLight: "#cccccc" }, m("multiDiffEditor.border", "The border color of the multi file diff editor"));
var Tre = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Mre = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let YD = class extends U {
  constructor(e, t, i) {
    super(), this._element = e, this._workbenchUIElementFactory = t, this._instantiationService = i, this._dimension = it(this, void 0), this._viewModel = it(this, void 0), this._widgetImpl = rd(this, (n, o) => (Js(WC, n), o.add(this._instantiationService.createInstance(Js(ZD, n), this._element, this._dimension, this._viewModel, this._workbenchUIElementFactory)))), this._register(dw(this._widgetImpl));
  }
};
YD = Tre([
  Mre(2, Pe)
], YD);
function Rre(s, e, t) {
  return ge.initialize(t || {}).createInstance(qD, s, e);
}
function Are(s) {
  return ge.get(Tt).onCodeEditorAdd((t) => {
    s(t);
  });
}
function Pre(s) {
  return ge.get(Tt).onDiffEditorAdd((t) => {
    s(t);
  });
}
function Ore() {
  return ge.get(Tt).listCodeEditors();
}
function Fre() {
  return ge.get(Tt).listDiffEditors();
}
function Bre(s, e, t) {
  return ge.initialize(t || {}).createInstance(GD, s, e);
}
function Wre(s, e) {
  const t = ge.initialize(e || {});
  return new YD(s, {}, t);
}
function Hre(s) {
  if (typeof s.id != "string" || typeof s.run != "function")
    throw new Error("Invalid command descriptor, `id` and `run` are required properties!");
  return St.registerCommand(s.id, s.run);
}
function Vre(s) {
  if (typeof s.id != "string" || typeof s.label != "string" || typeof s.run != "function")
    throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
  const e = ve.deserialize(s.precondition), t = (n, ...o) => jo.runEditorCommand(n, o, e, (r, a, l) => Promise.resolve(s.run(a, ...l))), i = new ne();
  if (i.add(St.registerCommand(s.id, t)), s.contextMenuGroupId) {
    const n = {
      command: {
        id: s.id,
        title: s.label
      },
      when: e,
      group: s.contextMenuGroupId,
      order: s.contextMenuOrder || 0
    };
    i.add(so.appendMenuItem(et.EditorContext, n));
  }
  if (Array.isArray(s.keybindings)) {
    const n = ge.get(Lt);
    if (!(n instanceof xf))
      console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService");
    else {
      const o = ve.and(e, ve.deserialize(s.keybindingContext));
      i.add(n.addDynamicKeybindings(s.keybindings.map((r) => ({
        keybinding: r,
        command: s.id,
        when: o
      }))));
    }
  }
  return i;
}
function zre(s) {
  return K3([s]);
}
function K3(s) {
  const e = ge.get(Lt);
  return e instanceof xf ? e.addDynamicKeybindings(s.map((t) => ({
    keybinding: t.keybinding,
    command: t.command,
    commandArgs: t.commandArgs,
    when: ve.deserialize(t.when)
  }))) : (console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService"), U.None);
}
function Ure(s, e, t) {
  const i = ge.get(ci), n = i.getLanguageIdByMimeType(e) || e;
  return $3(ge.get(Ui), i, s, n, t);
}
function $re(s, e) {
  const t = ge.get(ci), i = t.getLanguageIdByMimeType(e) || e || Fs;
  s.setLanguage(t.createById(i));
}
function Kre(s, e, t) {
  s && ge.get(Zr).changeOne(e, s.uri, t);
}
function jre(s) {
  ge.get(Zr).changeAll(s, []);
}
function qre(s) {
  return ge.get(Zr).read(s);
}
function Gre(s) {
  return ge.get(Zr).onMarkerChanged(s);
}
function Zre(s) {
  return ge.get(Ui).getModel(s);
}
function Yre() {
  return ge.get(Ui).getModels();
}
function Xre(s) {
  return ge.get(Ui).onModelAdded(s);
}
function Qre(s) {
  return ge.get(Ui).onModelRemoved(s);
}
function Jre(s) {
  return ge.get(Ui).onModelLanguageChanged((t) => {
    s({
      model: t.model,
      oldLanguage: t.oldLanguageId
    });
  });
}
function eae(s) {
  return _oe(ge.get(Ui), s);
}
function tae(s, e) {
  const t = ge.get(ci), i = ge.get(yo);
  return HN.colorizeElement(i, t, s, e).then(() => {
    i.registerEditorContainer(s);
  });
}
function iae(s, e, t) {
  const i = ge.get(ci);
  return ge.get(yo).registerEditorContainer(pt.document.body), HN.colorize(i, s, e, t);
}
function nae(s, e, t = 4) {
  return ge.get(yo).registerEditorContainer(pt.document.body), HN.colorizeModelLine(s, e, t);
}
function sae(s) {
  const e = ii.get(s);
  return e || {
    getInitialState: () => ep,
    tokenize: (t, i, n) => _F(s, n)
  };
}
function oae(s, e) {
  ii.getOrCreate(e);
  const t = sae(e), i = td(s), n = [];
  let o = t.getInitialState();
  for (let r = 0, a = i.length; r < a; r++) {
    const l = i[r], c = t.tokenize(l, !0, o);
    n[r] = c.tokens, o = c.endState;
  }
  return n;
}
function rae(s, e) {
  ge.get(yo).defineTheme(s, e);
}
function aae(s) {
  ge.get(yo).setTheme(s);
}
function lae() {
  kS.clearAllFontInfos();
}
function cae(s, e) {
  return St.registerCommand({ id: s, handler: e });
}
function hae(s) {
  return ge.get(sr).registerOpener({
    async open(t) {
      return typeof t == "string" && (t = we.parse(t)), s.open(t);
    }
  });
}
function dae(s) {
  return ge.get(Tt).registerCodeEditorOpenHandler(async (t, i, n) => {
    var a;
    if (!i)
      return null;
    const o = (a = t.options) == null ? void 0 : a.selection;
    let r;
    return o && typeof o.endLineNumber == "number" && typeof o.endColumn == "number" ? r = o : o && (r = { lineNumber: o.startLineNumber, column: o.startColumn }), await s.openCodeEditor(i, t.resource, r) ? i : null;
  });
}
function uae() {
  return {
    // methods
    create: Rre,
    getEditors: Ore,
    getDiffEditors: Fre,
    onDidCreateEditor: Are,
    onDidCreateDiffEditor: Pre,
    createDiffEditor: Bre,
    addCommand: Hre,
    addEditorAction: Vre,
    addKeybindingRule: zre,
    addKeybindingRules: K3,
    createModel: Ure,
    setModelLanguage: $re,
    setModelMarkers: Kre,
    getModelMarkers: qre,
    removeAllMarkers: jre,
    onDidChangeMarkers: Gre,
    getModels: Yre,
    getModel: Zre,
    onDidCreateModel: Xre,
    onWillDisposeModel: Qre,
    onDidChangeModelLanguage: Jre,
    createWebWorker: eae,
    colorizeElement: tae,
    colorize: iae,
    colorizeModelLine: nae,
    tokenize: oae,
    defineTheme: rae,
    setTheme: aae,
    remeasureFonts: lae,
    registerCommand: cae,
    registerLinkOpener: hae,
    registerEditorOpener: dae,
    // enums
    AccessibilitySupport: Lk,
    ContentWidgetPositionPreference: Nk,
    CursorChangeReason: Tk,
    DefaultEndOfLine: Mk,
    EditorAutoIndentStrategy: Ak,
    EditorOption: Pk,
    EndOfLinePreference: Ok,
    EndOfLineSequence: Fk,
    MinimapPosition: Gk,
    MinimapSectionHeaderStyle: Zk,
    MouseTargetType: Yk,
    OverlayWidgetPositionPreference: Jk,
    OverviewRulerLane: ex,
    GlyphMarginLane: Bk,
    RenderLineNumbersType: nx,
    RenderMinimap: sx,
    ScrollbarVisibility: rx,
    ScrollType: ox,
    TextEditorCursorBlinkingStyle: ux,
    TextEditorCursorStyle: fx,
    TrackedRangeStickiness: gx,
    WrappingIndent: mx,
    InjectedTextCursorStops: Vk,
    PositionAffinity: ix,
    ShowLightbulbIconMode: lx,
    // classes
    ConfigurationChangedEvent: zO,
    BareFontInfo: ch,
    FontInfo: LS,
    TextModelResolvedOptions: hb,
    FindMatch: jm,
    ApplyUpdateResult: Og,
    EditorZoom: pl,
    createMultiFileDiffEditor: Wre,
    // vars
    EditorType: Iw,
    EditorOptions: ad
  };
}
function fae(s, e) {
  if (!e || !Array.isArray(e))
    return !1;
  for (const t of e)
    if (!s(t))
      return !1;
  return !0;
}
function Y_(s, e) {
  return typeof s == "boolean" ? s : e;
}
function NP(s, e) {
  return typeof s == "string" ? s : e;
}
function gae(s) {
  const e = {};
  for (const t of s)
    e[t] = !0;
  return e;
}
function TP(s, e = !1) {
  e && (s = s.map(function(i) {
    return i.toLowerCase();
  }));
  const t = gae(s);
  return e ? function(i) {
    return t[i.toLowerCase()] !== void 0 && t.hasOwnProperty(i.toLowerCase());
  } : function(i) {
    return t[i] !== void 0 && t.hasOwnProperty(i);
  };
}
function XD(s, e, t) {
  e = e.replace(/@@/g, "");
  let i = 0, n;
  do
    n = !1, e = e.replace(/@(\w+)/g, function(r, a) {
      n = !0;
      let l = "";
      if (typeof s[a] == "string")
        l = s[a];
      else if (s[a] && s[a] instanceof RegExp)
        l = s[a].source;
      else
        throw s[a] === void 0 ? xt(s, "language definition does not contain attribute '" + a + "', used at: " + e) : xt(s, "attribute reference '" + a + "' must be a string, used at: " + e);
      return zc(l) ? "" : "(?:" + l + ")";
    }), i++;
  while (n && i < 5);
  e = e.replace(/\x01/g, "@");
  const o = (s.ignoreCase ? "i" : "") + (s.unicode ? "u" : "");
  if (t && e.match(/\$[sS](\d\d?)/g)) {
    let a = null, l = null;
    return (c) => (l && a === c || (a = c, l = new RegExp(yoe(s, e, c), o)), l);
  }
  return new RegExp(e, o);
}
function mae(s, e, t, i) {
  if (i < 0)
    return s;
  if (i < e.length)
    return e[i];
  if (i >= 100) {
    i = i - 100;
    const n = t.split(".");
    if (n.unshift(t), i < n.length)
      return n[i];
  }
  return null;
}
function pae(s, e, t, i) {
  let n = -1, o = t, r = t.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
  r && (r[3] && (n = parseInt(r[3]), r[2] && (n = n + 100)), o = r[4]);
  let a = "~", l = o;
  !o || o.length === 0 ? (a = "!=", l = "") : /^\w*$/.test(l) ? a = "==" : (r = o.match(/^(@|!@|~|!~|==|!=)(.*)$/), r && (a = r[1], l = r[2]));
  let c;
  if ((a === "~" || a === "!~") && /^(\w|\|)*$/.test(l)) {
    const h = TP(l.split("|"), s.ignoreCase);
    c = function(d) {
      return a === "~" ? h(d) : !h(d);
    };
  } else if (a === "@" || a === "!@") {
    const h = s[l];
    if (!h)
      throw xt(s, "the @ match target '" + l + "' is not defined, in rule: " + e);
    if (!fae(function(u) {
      return typeof u == "string";
    }, h))
      throw xt(s, "the @ match target '" + l + "' must be an array of strings, in rule: " + e);
    const d = TP(h, s.ignoreCase);
    c = function(u) {
      return a === "@" ? d(u) : !d(u);
    };
  } else if (a === "~" || a === "!~")
    if (l.indexOf("$") < 0) {
      const h = XD(s, "^" + l + "$", !1);
      c = function(d) {
        return a === "~" ? h.test(d) : !h.test(d);
      };
    } else
      c = function(h, d, u, f) {
        return XD(s, "^" + vl(s, l, d, u, f) + "$", !1).test(h);
      };
  else if (l.indexOf("$") < 0) {
    const h = Va(s, l);
    c = function(d) {
      return a === "==" ? d === h : d !== h;
    };
  } else {
    const h = Va(s, l);
    c = function(d, u, f, g, p) {
      const _ = vl(s, h, u, f, g);
      return a === "==" ? d === _ : d !== _;
    };
  }
  return n === -1 ? {
    name: t,
    value: i,
    test: function(h, d, u, f) {
      return c(h, h, d, u, f);
    }
  } : {
    name: t,
    value: i,
    test: function(h, d, u, f) {
      const g = mae(h, d, u, n);
      return c(g || "", h, d, u, f);
    }
  };
}
function QD(s, e, t) {
  if (t) {
    if (typeof t == "string")
      return t;
    if (t.token || t.token === "") {
      if (typeof t.token != "string")
        throw xt(s, "a 'token' attribute must be of type string, in rule: " + e);
      {
        const i = { token: t.token };
        if (t.token.indexOf("$") >= 0 && (i.tokenSubst = !0), typeof t.bracket == "string")
          if (t.bracket === "@open")
            i.bracket = 1;
          else if (t.bracket === "@close")
            i.bracket = -1;
          else
            throw xt(s, "a 'bracket' attribute must be either '@open' or '@close', in rule: " + e);
        if (t.next) {
          if (typeof t.next != "string")
            throw xt(s, "the next state must be a string value in rule: " + e);
          {
            let n = t.next;
            if (!/^(@pop|@push|@popall)$/.test(n) && (n[0] === "@" && (n = n.substr(1)), n.indexOf("$") < 0 && !Soe(s, vl(s, n, "", [], ""))))
              throw xt(s, "the next state '" + t.next + "' is not defined in rule: " + e);
            i.next = n;
          }
        }
        return typeof t.goBack == "number" && (i.goBack = t.goBack), typeof t.switchTo == "string" && (i.switchTo = t.switchTo), typeof t.log == "string" && (i.log = t.log), typeof t.nextEmbedded == "string" && (i.nextEmbedded = t.nextEmbedded, s.usesEmbedded = !0), i;
      }
    } else if (Array.isArray(t)) {
      const i = [];
      for (let n = 0, o = t.length; n < o; n++)
        i[n] = QD(s, e, t[n]);
      return { group: i };
    } else if (t.cases) {
      const i = [];
      for (const o in t.cases)
        if (t.cases.hasOwnProperty(o)) {
          const r = QD(s, e, t.cases[o]);
          o === "@default" || o === "@" || o === "" ? i.push({ test: void 0, value: r, name: o }) : o === "@eos" ? i.push({ test: function(a, l, c, h) {
            return h;
          }, value: r, name: o }) : i.push(pae(s, e, o, r));
        }
      const n = s.defaultToken;
      return {
        test: function(o, r, a, l) {
          for (const c of i)
            if (!c.test || c.test(o, r, a, l))
              return c.value;
          return n;
        }
      };
    } else
      throw xt(s, "an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: " + e);
  } else return { token: "" };
}
class _ae {
  constructor(e) {
    this.regex = new RegExp(""), this.action = { token: "" }, this.matchOnlyAtLineStart = !1, this.name = "", this.name = e;
  }
  setRegex(e, t) {
    let i;
    if (typeof t == "string")
      i = t;
    else if (t instanceof RegExp)
      i = t.source;
    else
      throw xt(e, "rules must start with a match string or regular expression: " + this.name);
    this.matchOnlyAtLineStart = i.length > 0 && i[0] === "^", this.name = this.name + ": " + i, this.regex = XD(e, "^(?:" + (this.matchOnlyAtLineStart ? i.substr(1) : i) + ")", !0);
  }
  setAction(e, t) {
    this.action = QD(e, this.name, t);
  }
  resolveRegex(e) {
    return this.regex instanceof RegExp ? this.regex : this.regex(e);
  }
}
function j3(s, e) {
  if (!e || typeof e != "object")
    throw new Error("Monarch: expecting a language definition object");
  const t = {
    languageId: s,
    includeLF: Y_(e.includeLF, !1),
    noThrow: !1,
    // raise exceptions during compilation
    maxStack: 100,
    start: typeof e.start == "string" ? e.start : null,
    ignoreCase: Y_(e.ignoreCase, !1),
    unicode: Y_(e.unicode, !1),
    tokenPostfix: NP(e.tokenPostfix, "." + s),
    defaultToken: NP(e.defaultToken, "source"),
    usesEmbedded: !1,
    // becomes true if we find a nextEmbedded action
    stateNames: {},
    tokenizer: {},
    brackets: []
  }, i = e;
  i.languageId = s, i.includeLF = t.includeLF, i.ignoreCase = t.ignoreCase, i.unicode = t.unicode, i.noThrow = t.noThrow, i.usesEmbedded = t.usesEmbedded, i.stateNames = e.tokenizer, i.defaultToken = t.defaultToken;
  function n(r, a, l) {
    for (const c of l) {
      let h = c.include;
      if (h) {
        if (typeof h != "string")
          throw xt(t, "an 'include' attribute must be a string at: " + r);
        if (h[0] === "@" && (h = h.substr(1)), !e.tokenizer[h])
          throw xt(t, "include target '" + h + "' is not defined at: " + r);
        n(r + "." + h, a, e.tokenizer[h]);
      } else {
        const d = new _ae(r);
        if (Array.isArray(c) && c.length >= 1 && c.length <= 3)
          if (d.setRegex(i, c[0]), c.length >= 3)
            if (typeof c[1] == "string")
              d.setAction(i, { token: c[1], next: c[2] });
            else if (typeof c[1] == "object") {
              const u = c[1];
              u.next = c[2], d.setAction(i, u);
            } else
              throw xt(t, "a next state as the last element of a rule can only be given if the action is either an object or a string, at: " + r);
          else
            d.setAction(i, c[1]);
        else {
          if (!c.regex)
            throw xt(t, "a rule must either be an array, or an object with a 'regex' or 'include' field at: " + r);
          c.name && typeof c.name == "string" && (d.name = c.name), c.matchOnlyAtStart && (d.matchOnlyAtLineStart = Y_(c.matchOnlyAtLineStart, !1)), d.setRegex(i, c.regex), d.setAction(i, c.action);
        }
        a.push(d);
      }
    }
  }
  if (!e.tokenizer || typeof e.tokenizer != "object")
    throw xt(t, "a language definition must define the 'tokenizer' attribute as an object");
  t.tokenizer = [];
  for (const r in e.tokenizer)
    if (e.tokenizer.hasOwnProperty(r)) {
      t.start || (t.start = r);
      const a = e.tokenizer[r];
      t.tokenizer[r] = new Array(), n("tokenizer." + r, t.tokenizer[r], a);
    }
  if (t.usesEmbedded = i.usesEmbedded, e.brackets) {
    if (!Array.isArray(e.brackets))
      throw xt(t, "the 'brackets' attribute must be defined as an array");
  } else
    e.brackets = [
      { open: "{", close: "}", token: "delimiter.curly" },
      { open: "[", close: "]", token: "delimiter.square" },
      { open: "(", close: ")", token: "delimiter.parenthesis" },
      { open: "<", close: ">", token: "delimiter.angle" }
    ];
  const o = [];
  for (const r of e.brackets) {
    let a = r;
    if (a && Array.isArray(a) && a.length === 3 && (a = { token: a[2], open: a[0], close: a[1] }), a.open === a.close)
      throw xt(t, "open and close brackets in a 'brackets' attribute must be different: " + a.open + `
 hint: use the 'bracket' attribute if matching on equal brackets is required.`);
    if (typeof a.open == "string" && typeof a.token == "string" && typeof a.close == "string")
      o.push({
        token: a.token + t.tokenPostfix,
        open: Va(t, a.open),
        close: Va(t, a.close)
      });
    else
      throw xt(t, "every element in the 'brackets' array must be a '{open,close,token}' object or array");
  }
  return t.brackets = o, t.noThrow = !0, t;
}
function bae(s) {
  gf.registerLanguage(s);
}
function Cae() {
  let s = [];
  return s = s.concat(gf.getLanguages()), s;
}
function vae(s) {
  return ge.get(ci).languageIdCodec.encodeLanguageId(s);
}
function wae(s, e) {
  return ge.withServices(() => {
    const i = ge.get(ci).onDidRequestRichLanguageFeatures((n) => {
      n === s && (i.dispose(), e());
    });
    return i;
  });
}
function yae(s, e) {
  return ge.withServices(() => {
    const i = ge.get(ci).onDidRequestBasicLanguageFeatures((n) => {
      n === s && (i.dispose(), e());
    });
    return i;
  });
}
function Sae(s, e) {
  if (!ge.get(ci).isRegisteredLanguageId(s))
    throw new Error(`Cannot set configuration for unknown language ${s}`);
  return ge.get(ir).register(s, e, 100);
}
class Lae {
  constructor(e, t) {
    this._languageId = e, this._actual = t;
  }
  dispose() {
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  tokenize(e, t, i) {
    if (typeof this._actual.tokenize == "function")
      return kp.adaptTokenize(this._languageId, this._actual, e, i);
    throw new Error("Not supported!");
  }
  tokenizeEncoded(e, t, i) {
    const n = this._actual.tokenizeEncoded(e, i);
    return new kw(n.tokens, n.endState);
  }
}
class kp {
  constructor(e, t, i, n) {
    this._languageId = e, this._actual = t, this._languageService = i, this._standaloneThemeService = n;
  }
  dispose() {
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  static _toClassicTokens(e, t) {
    const i = [];
    let n = 0;
    for (let o = 0, r = e.length; o < r; o++) {
      const a = e[o];
      let l = a.startIndex;
      o === 0 ? l = 0 : l < n && (l = n), i[o] = new Km(l, a.scopes, t), n = l;
    }
    return i;
  }
  static adaptTokenize(e, t, i, n) {
    const o = t.tokenize(i, n), r = kp._toClassicTokens(o.tokens, e);
    let a;
    return o.endState.equals(n) ? a = n : a = o.endState, new _I(r, a);
  }
  tokenize(e, t, i) {
    return kp.adaptTokenize(this._languageId, this._actual, e, i);
  }
  _toBinaryTokens(e, t) {
    const i = e.encodeLanguageId(this._languageId), n = this._standaloneThemeService.getColorTheme().tokenTheme, o = [];
    let r = 0, a = 0;
    for (let c = 0, h = t.length; c < h; c++) {
      const d = t[c], u = n.match(i, d.scopes) | 1024;
      if (r > 0 && o[r - 1] === u)
        continue;
      let f = d.startIndex;
      c === 0 ? f = 0 : f < a && (f = a), o[r++] = f, o[r++] = u, a = f;
    }
    const l = new Uint32Array(r);
    for (let c = 0; c < r; c++)
      l[c] = o[c];
    return l;
  }
  tokenizeEncoded(e, t, i) {
    const n = this._actual.tokenize(e, i), o = this._toBinaryTokens(this._languageService.languageIdCodec, n.tokens);
    let r;
    return n.endState.equals(i) ? r = i : r = n.endState, new kw(o, r);
  }
}
function kae(s) {
  return typeof s.getInitialState == "function";
}
function xae(s) {
  return "tokenizeEncoded" in s;
}
function q3(s) {
  return s && typeof s.then == "function";
}
function Dae(s) {
  const e = ge.get(yo);
  if (s) {
    const t = [null];
    for (let i = 1, n = s.length; i < n; i++)
      t[i] = j.fromHex(s[i]);
    e.setColorMapOverride(t);
  } else
    e.setColorMapOverride(null);
}
function G3(s, e) {
  return xae(e) ? new Lae(s, e) : new kp(s, e, ge.get(ci), ge.get(yo));
}
function YN(s, e) {
  const t = new HK(async () => {
    const i = await Promise.resolve(e.create());
    return i ? kae(i) ? G3(s, i) : new yp(ge.get(ci), ge.get(yo), s, j3(s, i), ge.get(gt)) : null;
  });
  return ii.registerFactory(s, t);
}
function Eae(s, e) {
  if (!ge.get(ci).isRegisteredLanguageId(s))
    throw new Error(`Cannot set tokens provider for unknown language ${s}`);
  return q3(e) ? YN(s, { create: () => e }) : ii.register(s, G3(s, e));
}
function Iae(s, e) {
  const t = (i) => new yp(ge.get(ci), ge.get(yo), s, j3(s, i), ge.get(gt));
  return q3(e) ? YN(s, { create: () => e }) : ii.register(s, t(e));
}
function Nae(s, e) {
  return ge.get(De).referenceProvider.register(s, e);
}
function Tae(s, e) {
  return ge.get(De).renameProvider.register(s, e);
}
function Mae(s, e) {
  return ge.get(De).newSymbolNamesProvider.register(s, e);
}
function Rae(s, e) {
  return ge.get(De).signatureHelpProvider.register(s, e);
}
function Aae(s, e) {
  return ge.get(De).hoverProvider.register(s, {
    provideHover: async (i, n, o, r) => {
      const a = i.getWordAtPosition(n);
      return Promise.resolve(e.provideHover(i, n, o, r)).then((l) => {
        if (l)
          return !l.range && a && (l.range = new T(n.lineNumber, a.startColumn, n.lineNumber, a.endColumn)), l.range || (l.range = new T(n.lineNumber, n.column, n.lineNumber, n.column)), l;
      });
    }
  });
}
function Pae(s, e) {
  return ge.get(De).documentSymbolProvider.register(s, e);
}
function Oae(s, e) {
  return ge.get(De).documentHighlightProvider.register(s, e);
}
function Fae(s, e) {
  return ge.get(De).linkedEditingRangeProvider.register(s, e);
}
function Bae(s, e) {
  return ge.get(De).definitionProvider.register(s, e);
}
function Wae(s, e) {
  return ge.get(De).implementationProvider.register(s, e);
}
function Hae(s, e) {
  return ge.get(De).typeDefinitionProvider.register(s, e);
}
function Vae(s, e) {
  return ge.get(De).codeLensProvider.register(s, e);
}
function zae(s, e, t) {
  return ge.get(De).codeActionProvider.register(s, {
    providedCodeActionKinds: t == null ? void 0 : t.providedCodeActionKinds,
    documentation: t == null ? void 0 : t.documentation,
    provideCodeActions: (n, o, r, a) => {
      const c = ge.get(Zr).read({ resource: n.uri }).filter((h) => T.areIntersectingOrTouching(h, o));
      return e.provideCodeActions(n, o, { markers: c, only: r.only, trigger: r.trigger }, a);
    },
    resolveCodeAction: e.resolveCodeAction
  });
}
function Uae(s, e) {
  return ge.get(De).documentFormattingEditProvider.register(s, e);
}
function $ae(s, e) {
  return ge.get(De).documentRangeFormattingEditProvider.register(s, e);
}
function Kae(s, e) {
  return ge.get(De).onTypeFormattingEditProvider.register(s, e);
}
function jae(s, e) {
  return ge.get(De).linkProvider.register(s, e);
}
function qae(s, e) {
  return ge.get(De).completionProvider.register(s, e);
}
function Gae(s, e) {
  return ge.get(De).colorProvider.register(s, e);
}
function Zae(s, e) {
  return ge.get(De).foldingRangeProvider.register(s, e);
}
function Yae(s, e) {
  return ge.get(De).declarationProvider.register(s, e);
}
function Xae(s, e) {
  return ge.get(De).selectionRangeProvider.register(s, e);
}
function Qae(s, e) {
  return ge.get(De).documentSemanticTokensProvider.register(s, e);
}
function Jae(s, e) {
  return ge.get(De).documentRangeSemanticTokensProvider.register(s, e);
}
function ele(s, e) {
  return ge.get(De).inlineCompletionsProvider.register(s, e);
}
function tle(s, e) {
  return ge.get(De).inlineEditProvider.register(s, e);
}
function ile(s, e) {
  return ge.get(De).inlayHintsProvider.register(s, e);
}
function nle() {
  return {
    register: bae,
    getLanguages: Cae,
    onLanguage: wae,
    onLanguageEncountered: yae,
    getEncodedLanguageId: vae,
    // provider methods
    setLanguageConfiguration: Sae,
    setColorMap: Dae,
    registerTokensProviderFactory: YN,
    setTokensProvider: Eae,
    setMonarchTokensProvider: Iae,
    registerReferenceProvider: Nae,
    registerRenameProvider: Tae,
    registerNewSymbolNameProvider: Mae,
    registerCompletionItemProvider: qae,
    registerSignatureHelpProvider: Rae,
    registerHoverProvider: Aae,
    registerDocumentSymbolProvider: Pae,
    registerDocumentHighlightProvider: Oae,
    registerLinkedEditingRangeProvider: Fae,
    registerDefinitionProvider: Bae,
    registerImplementationProvider: Wae,
    registerTypeDefinitionProvider: Hae,
    registerCodeLensProvider: Vae,
    registerCodeActionProvider: zae,
    registerDocumentFormattingEditProvider: Uae,
    registerDocumentRangeFormattingEditProvider: $ae,
    registerOnTypeFormattingEditProvider: Kae,
    registerLinkProvider: jae,
    registerColorProvider: Gae,
    registerFoldingRangeProvider: Zae,
    registerDeclarationProvider: Yae,
    registerSelectionRangeProvider: Xae,
    registerDocumentSemanticTokensProvider: Qae,
    registerDocumentRangeSemanticTokensProvider: Jae,
    registerInlineCompletionsProvider: ele,
    registerInlineEditProvider: tle,
    registerInlayHintsProvider: ile,
    // enums
    DocumentHighlightKind: Rk,
    CompletionItemKind: Dk,
    CompletionItemTag: Ek,
    CompletionItemInsertTextRule: xk,
    SymbolKind: hx,
    SymbolTag: dx,
    IndentAction: Hk,
    CompletionTriggerKind: Ik,
    SignatureHelpTriggerKind: cx,
    InlayHintKind: zk,
    InlineCompletionTriggerKind: Uk,
    InlineEditTriggerKind: $k,
    CodeActionTriggerType: kk,
    NewSymbolNameTag: Xk,
    NewSymbolNameTriggerKind: Qk,
    PartialAcceptTriggerKind: tx,
    HoverVerbosityAction: Wk,
    // classes
    FoldingRangeKind: US,
    SelectedSuggestionInfo: BK
  };
}
class MP {
  constructor(e) {
    this.value = e, this._lower = e.toLowerCase();
  }
  /**
   * Gives the value by which to index (for equality).
   */
  static toKey(e) {
    return typeof e == "string" ? e.toLowerCase() : e._lower;
  }
}
class sle {
  constructor(e) {
    if (this._set = /* @__PURE__ */ new Set(), e)
      for (const t of e)
        this.add(t);
  }
  add(e) {
    this._set.add(MP.toKey(e));
  }
  has(e) {
    return this._set.has(MP.toKey(e));
  }
}
function ole(s, e, t) {
  const i = [], n = new sle(), o = s.ordered(t);
  for (const a of o)
    i.push(a), a.extensionId && n.add(a.extensionId);
  const r = e.ordered(t);
  for (const a of r) {
    if (a.extensionId) {
      if (n.has(a.extensionId))
        continue;
      n.add(a.extensionId);
    }
    i.push({
      displayName: a.displayName,
      extensionId: a.extensionId,
      provideDocumentFormattingEdits(l, c, h) {
        return a.provideDocumentRangeFormattingEdits(l, l.getFullModelRange(), c, h);
      }
    });
  }
  return i;
}
const wm = class wm {
  static setFormatterSelector(e) {
    return { dispose: wm._selectors.unshift(e) };
  }
  static async select(e, t, i, n) {
    if (e.length === 0)
      return;
    const o = nt.first(wm._selectors);
    if (o)
      return await o(e, t, i, n);
  }
};
wm._selectors = new Tn();
let JD = wm;
async function rle(s, e, t, i, n, o) {
  const r = e.documentRangeFormattingEditProvider.ordered(t);
  for (const a of r) {
    const l = await Promise.resolve(a.provideDocumentRangeFormattingEdits(t, i, n, o)).catch(Qo);
    if (co(l))
      return await s.computeMoreMinimalEdits(t.uri, l);
  }
}
async function ale(s, e, t, i, n) {
  const o = ole(e.documentFormattingEditProvider, e.documentRangeFormattingEditProvider, t);
  for (const r of o) {
    const a = await Promise.resolve(r.provideDocumentFormattingEdits(t, i, n)).catch(Qo);
    if (co(a))
      return await s.computeMoreMinimalEdits(t.uri, a);
  }
}
function lle(s, e, t, i, n, o, r) {
  const a = e.onTypeFormattingEditProvider.ordered(t);
  return a.length === 0 || a[0].autoFormatTriggerCharacters.indexOf(n) < 0 ? Promise.resolve(void 0) : Promise.resolve(a[0].provideOnTypeFormattingEdits(t, i, n, o, r)).catch(Qo).then((l) => s.computeMoreMinimalEdits(t.uri, l));
}
St.registerCommand("_executeFormatRangeProvider", async function(s, ...e) {
  const [t, i, n] = e;
  qi(we.isUri(t)), qi(T.isIRange(i));
  const o = s.get(bo), r = s.get(vd), a = s.get(De), l = await o.createModelReference(t);
  try {
    return rle(r, a, l.object.textEditorModel, T.lift(i), n, _t.None);
  } finally {
    l.dispose();
  }
});
St.registerCommand("_executeFormatDocumentProvider", async function(s, ...e) {
  const [t, i] = e;
  qi(we.isUri(t));
  const n = s.get(bo), o = s.get(vd), r = s.get(De), a = await n.createModelReference(t);
  try {
    return ale(o, r, a.object.textEditorModel, i, _t.None);
  } finally {
    a.dispose();
  }
});
St.registerCommand("_executeFormatOnTypeProvider", async function(s, ...e) {
  const [t, i, n, o] = e;
  qi(we.isUri(t)), qi(F.isIPosition(i)), qi(typeof n == "string");
  const r = s.get(bo), a = s.get(vd), l = s.get(De), c = await r.createModelReference(t);
  try {
    return lle(a, l, c.object.textEditorModel, F.lift(i), n, o, _t.None);
  } finally {
    c.dispose();
  }
});
ad.wrappingIndent.defaultValue = 0;
ad.glyphMargin.defaultValue = !1;
ad.autoIndent.defaultValue = 3;
ad.overviewRulerLanes.defaultValue = 2;
JD.setFormatterSelector((s, e, t) => Promise.resolve(s[0]));
const yn = G7();
yn.editor = uae();
yn.languages = nle();
yn.CancellationTokenSource;
yn.Emitter;
yn.KeyCode;
yn.KeyMod;
yn.Position;
const cle = yn.Range;
yn.Selection;
yn.SelectionDirection;
const hle = yn.MarkerSeverity;
yn.MarkerTag;
yn.Uri;
yn.Token;
const XN = yn.editor, Iy = yn.languages, Ny = globalThis.MonacoEnvironment;
(Ny != null && Ny.globalAPI || typeof define == "function" && define.amd) && (globalThis.monaco = yn);
typeof globalThis.require < "u" && typeof globalThis.require.config == "function" && globalThis.require.config({
  ignoreDuplicateModules: [
    "vscode-languageserver-types",
    "vscode-languageserver-types/main",
    "vscode-languageserver-textdocument",
    "vscode-languageserver-textdocument/main",
    "vscode-nls",
    "vscode-nls/vscode-nls",
    "jsonc-parser",
    "jsonc-parser/main",
    "vscode-uri",
    "vscode-uri/index",
    "vs/basic-languages/typescript/typescript"
  ]
});
const dle = "{{", RP = ":", ule = "}}", fle = "(embed)", gle = "(content_block_pension|content_block_email)", mle = "([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})", ple = "\\/?([a-z0-9_\\-\\/]+)?", QN = new RegExp(
  `${dle}${fle}${RP}${gle}${RP}${mle}${ple}${ule}`,
  "g"
), _le = {
  tokenizer: {
    root: [[QN, "embedded"]]
  }
}, ble = {
  embedHighlightColour: "ffa500"
}, Cle = {
  base: "vs",
  inherit: !0,
  rules: [
    {
      token: "embedded",
      foreground: ble.embedHighlightColour
    }
  ],
  colors: {
    "editor.foreground": "#000000",
    "editor.lineHighlightBorder": "#fff"
  }
};
class Df {
  constructor(e, t, i, n) {
    rt(this, "embedCode", (e = "") => `{{embed:${this.schemaName}:${this.contentId}${e}}}`);
    rt(this, "digDetails", (e) => {
      let t = this.details;
      return e.forEach(function(i) {
        try {
          t = t[i];
        } catch {
          return;
        }
      }), t;
    });
    this.title = e, this.contentId = t, this.details = i, this.schemaName = n;
  }
  get blockType() {
    return this.schemaName.replace("content_block_", "").replace("_", " ").split(" ").map((e) => e[0].toUpperCase() + e.substring(1).toLowerCase()).join(" ");
  }
  static all() {
    var e;
    if (!window.contentBlocks) {
      const t = JSON.parse(
        ((e = window.document.querySelector("#content-blocks")) == null ? void 0 : e.textContent) || "[]"
      );
      window.contentBlocks = t.map(
        (i) => new Df(
          i.title,
          i.content_id,
          i.details,
          i.schema_name
        )
      );
    }
    return window.contentBlocks || [];
  }
  static findByContentId(e) {
    return Df.all().find((t) => t.contentId == e);
  }
}
const vle = (s, e) => {
  const t = s.getLineContent(e.lineNumber);
  let i;
  for (; (i = QN.exec(t)) !== null; ) {
    const n = i.index + 1, o = n + i[0].length - 1;
    if (e.column >= n && e.column <= o) {
      const r = Df.findByContentId(i[3]);
      if (r) {
        const a = i[4] ? r.digDetails(i[4].split("/")) : r.title;
        return {
          range: new cle(
            e.lineNumber,
            n,
            e.lineNumber,
            o + 1
          ),
          contents: [
            { value: `**Content block:** ${r.blockType}

${a}` }
          ]
        };
      }
    }
  }
  return null;
}, wle = '"GDS Transport", arial, sans-serif', yle = {
  fontFamily: wle
}, AP = (s) => {
  const e = [], t = s.getLineCount() + 1;
  for (let i = 1; i < t; i++) {
    const n = {
      startLineNumber: i,
      startColumn: 1,
      endLineNumber: i,
      endColumn: s.getLineLength(i) + 1
    }, o = s.getValueInRange(n).trim();
    let r;
    for (; (r = QN.exec(o)) !== null; ) {
      const a = r.index + 1, l = a + r[0].length - 1;
      Df.findByContentId(r[3]) || e.push({
        message: "Invalid embed code",
        severity: hle.Error,
        startLineNumber: n.startLineNumber,
        startColumn: a,
        endLineNumber: n.endLineNumber,
        endColumn: l
      });
    }
  }
  XN.setModelMarkers(s, "owner", e);
}, Z3 = "content-block-editor", Nb = "govspeak", Sle = () => {
  Iy.register({ id: Nb }), Iy.setMonarchTokensProvider(Nb, _le), Iy.registerHoverProvider(Nb, {
    provideHover: vle
  }), XN.defineTheme(Z3, Cle);
}, Lle = (s, e) => {
  Sle();
  const t = XN.create(s, {
    value: e.value,
    language: Nb,
    minimap: { enabled: !1 },
    lineNumbers: "off",
    fontFamily: yle.fontFamily,
    fontSize: 19,
    glyphMargin: !1,
    folding: !1,
    lineDecorationsWidth: 5,
    lineNumbersMinChars: 0,
    theme: Z3,
    scrollBeyondLastLine: !1,
    overviewRulerLanes: 0,
    scrollbar: {
      verticalScrollbarSize: 8
    },
    padding: {
      top: 5,
      bottom: 5
    },
    wordWrap: "on"
  });
  return AP(t.getModel()), t.onDidChangeModelContent(() => {
    AP(t.getModel()), e.value = t == null ? void 0 : t.getValue();
  }), t.onDidFocusEditorText(() => {
    s.classList.add("content-block-editor__wrapper--focussed");
  }), t.onDidBlurEditorText(() => {
    s.classList.remove("content-block-editor__wrapper--focussed");
  }), t;
}, kle = (s, e, t) => `
    <div class="govuk-summary-list__row">
      <dt class="govuk-summary-list__key">
        ${t.title}
      </dt>
      <dd class="govuk-summary-list__value">
        ${t.amount}
      </dd>
      <dd class="govuk-summary-list__actions">
        <a class="govuk-link" href="#" data-embed-code="${s.embedCode(`/rates/${e}/amount`)}">Insert<span class="govuk-visually-hidden">${t.title}</span></a>
      </dd>
    </div>`, xle = (s) => {
  if (s.schemaName == "content_block_pension") {
    const t = s.details.rates;
    return t ? `
            <div class="govuk-summary-card">
              <div class="govuk-summary-card__title-wrapper">
                <h2 class="govuk-summary-card__title">${s.title}</h2>
              </div>
              <div class="govuk-summary-card__content">
                <dl class="govuk-summary-list">
                  ${Object.keys(t).map((i) => kle(s, i, t[i]))}
                </dl>
              </div>
            </div>
        ` : void 0;
  }
}, Dle = () => `
  <div
    id="modal-default"
    data-module="modal-dialogue"
    class="gem-c-modal-dialogue"
  >
    <div class="gem-c-modal-dialogue__overlay"></div>
    <dialog
      class="gem-c-modal-dialogue__box"
      aria-modal="true"
      role="dialog"
      tabindex="0"
    >
      <div class="gem-c-modal-dialogue__header">
        <svg
          focusable="false"
          class="gem-c-modal-dialogue__logotype-crown"
          xmlns="http://www.w3.org/2000/svg"
          aria-hidden="true"
          height="30"
          width="32"
          viewBox="0 0 32 30"
        >
          <path
            d="M22.6 10.4c-1 .4-2-.1-2.4-1-.4-.9.1-2 1-2.4.9-.4 2 .1 2.4 1s-.1 2-1 2.4m-5.9 6.7c-.9.4-2-.1-2.4-1-.4-.9.1-2 1-2.4.9-.4 2 .1 2.4 1s-.1 2-1 2.4m10.8-3.7c-1 .4-2-.1-2.4-1-.4-.9.1-2 1-2.4.9-.4 2 .1 2.4 1s0 2-1 2.4m3.3 4.8c-1 .4-2-.1-2.4-1-.4-.9.1-2 1-2.4.9-.4 2 .1 2.4 1s-.1 2-1 2.4M17 4.7l2.3 1.2V2.5l-2.3.7-.2-.2.9-3h-3.4l.9 3-.2.2c-.1.1-2.3-.7-2.3-.7v3.4L15 4.7c.1.1.1.2.2.2l-1.3 4c-.1.2-.1.4-.1.6 0 1.1.8 2 1.9 2.2h.7c1-.2 1.9-1.1 1.9-2.1 0-.2 0-.4-.1-.6l-1.3-4c-.1-.2 0-.2.1-.3m-7.6 5.7c.9.4 2-.1 2.4-1 .4-.9-.1-2-1-2.4-.9-.4-2 .1-2.4 1s0 2 1 2.4m-5 3c.9.4 2-.1 2.4-1 .4-.9-.1-2-1-2.4-.9-.4-2 .1-2.4 1s.1 2 1 2.4m-3.2 4.8c.9.4 2-.1 2.4-1 .4-.9-.1-2-1-2.4-.9-.4-2 .1-2.4 1s0 2 1 2.4m14.8 11c4.4 0 8.6.3 12.3.8 1.1-4.5 2.4-7 3.7-8.8l-2.5-.9c.2 1.3.3 1.9 0 2.7-.4-.4-.8-1.1-1.1-2.3l-1.2 4c.7-.5 1.3-.8 2-.9-1.1 2.5-2.6 3.1-3.5 3-1.1-.2-1.7-1.2-1.5-2.1.3-1.2 1.5-1.5 2.1-.1 1.1-2.3-.8-3-2-2.3 1.9-1.9 2.1-3.5.6-5.6-2.1 1.6-2.1 3.2-1.2 5.5-1.2-1.4-3.2-.6-2.5 1.6.9-1.4 2.1-.5 1.9.8-.2 1.1-1.7 2.1-3.5 1.9-2.7-.2-2.9-2.1-2.9-3.6.7-.1 1.9.5 2.9 1.9l.4-4.3c-1.1 1.1-2.1 1.4-3.2 1.4.4-1.2 2.1-3 2.1-3h-5.4s1.7 1.9 2.1 3c-1.1 0-2.1-.2-3.2-1.4l.4 4.3c1-1.4 2.2-2 2.9-1.9-.1 1.5-.2 3.4-2.9 3.6-1.9.2-3.4-.8-3.5-1.9-.2-1.3 1-2.2 1.9-.8.7-2.3-1.2-3-2.5-1.6.9-2.2.9-3.9-1.2-5.5-1.5 2-1.3 3.7.6 5.6-1.2-.7-3.1 0-2 2.3.6-1.4 1.8-1.1 2.1.1.2.9-.3 1.9-1.5 2.1-.9.2-2.4-.5-3.5-3 .6 0 1.2.3 2 .9l-1.2-4c-.3 1.1-.7 1.9-1.1 2.3-.3-.8-.2-1.4 0-2.7l-2.9.9C1.3 23 2.6 25.5 3.7 30c3.7-.5 7.9-.8 12.3-.8"
          ></path>
        </svg>
      </div>
      <div class="gem-c-modal-dialogue__content">
        <h2 class="govuk-heading-l">Insert content block</h2>
        ${Df.all().map((s) => xle(s))}
      </div>
      <button
        class="gem-c-modal-dialogue__close-button"
        aria-label="Close modal dialogue"
      >
        ×
      </button>
    </dialog>
  </div>
`;
class Ele {
  constructor(e) {
    rt(this, "module");
    rt(this, "dialogBox");
    rt(this, "closeButton");
    rt(this, "html");
    rt(this, "body");
    rt(this, "focusedElementBeforeOpen", null);
    if (this.module = e, this.dialogBox = this.module.querySelector(".gem-c-modal-dialogue__box"), this.closeButton = this.module.querySelector(
      ".gem-c-modal-dialogue__close-button"
    ), this.html = document.querySelector("html"), this.body = document.querySelector("body"), !this.dialogBox || !this.closeButton) return;
    this.module.open = this.handleOpen.bind(this), this.module.close = this.handleClose.bind(this), this.module.focusDialog = this.handleFocusDialog.bind(this), this.module.boundKeyDown = this.handleKeyDown.bind(this);
    const t = document.querySelector(
      '[data-toggle="modal"][data-target="' + this.module.id + '"]'
    );
    t && t.addEventListener(
      "click",
      this.module.open
    ), this.closeButton && this.closeButton.addEventListener("click", this.module.close);
  }
  handleOpen(e) {
    e && e.preventDefault(), this.html.classList.add("gem-o-template--modal"), this.body.classList.add("gem-o-template__body--modal"), this.focusedElementBeforeOpen = document.activeElement, this.module.style.display = "block", this.dialogBox.focus(), document.addEventListener("keydown", this.module.boundKeyDown, !0);
  }
  handleClose(e) {
    var t;
    e && e.preventDefault(), this.html.classList.remove("gem-o-template--modal"), this.body.classList.remove("gem-o-template__body--modal"), this.body.classList.remove("gem-o-template__body--blur"), this.module.style.display = "none", (t = this.focusedElementBeforeOpen) == null || t.focus(), document.removeEventListener("keydown", this.module.boundKeyDown, !0);
  }
  handleFocusDialog() {
    this.dialogBox.focus();
  }
  handleKeyDown(e) {
    switch (e.keyCode) {
      case 9:
        e.shiftKey ? document.activeElement === this.dialogBox && (e.preventDefault(), this.closeButton.focus()) : document.activeElement === this.closeButton && (e.preventDefault(), this.dialogBox.focus());
        break;
      case 27:
        this.module.close();
        break;
    }
  }
}
class Ile {
  constructor() {
    rt(this, "wrapper");
    rt(this, "modal");
    this.wrapper = document.createElement("div"), this.wrapper.classList.add("content-block-browser"), this.wrapper.innerHTML = Dle(), window.document.body.append(this.wrapper), this.modal = this.activateModal(), this.activateInserts();
  }
  activateModal() {
    const e = this.wrapper.querySelector(
      '[data-module="modal-dialogue"]'
    );
    return new Ele(e);
  }
  activateInserts() {
    this.wrapper.querySelectorAll(
      "a[data-embed-code]"
    ).forEach((t) => {
      t.addEventListener("click", this.insertEmbed.bind(this));
    });
  }
  insertEmbed(e) {
    e.preventDefault();
    const i = e.target.dataset.embedCode, n = this.modal.module.dataset.editorId;
    if (!n)
      throw new Error("Cannot find editor!");
    const o = self.editors[n], r = o.getSelection(), l = {
      identifier: { major: 1, minor: 1 },
      range: {
        startLineNumber: (r == null ? void 0 : r.selectionStartLineNumber) || 1,
        startColumn: (r == null ? void 0 : r.selectionStartColumn) || 1,
        endLineNumber: (r == null ? void 0 : r.endLineNumber) || 1,
        endColumn: (r == null ? void 0 : r.endColumn) || 1
      },
      text: i,
      forceMoveMarkers: !0
    };
    o.executeEdits("content-block-browser", [l]), this.modal.module.close();
  }
}
self.editors = {};
self.MonacoEnvironment = {
  getWorker() {
    return new Q3();
  }
};
self.contentBlockBrowser = new Ile();
class Nle {
  constructor(e) {
    rt(this, "module");
    rt(this, "container");
    rt(this, "editor");
    rt(this, "themeName", "content-block-editor");
    rt(this, "languageId", "govspeak");
    rt(this, "initializeModule", (e) => {
      if ("value" in e)
        return e;
      throw new Error(`The module ${e.outerHTML} is not a textarea`);
    });
    this.module = this.initializeModule(e), this.container = this.createContainer(), this.editor = Lle(this.container, this.module), this.createToolbar(), e.classList.add("govuk-visually-hidden"), self.editors[this.editor.getId()] = this.editor;
  }
  createToolbar() {
    const e = document.createElement("button");
    e.classList.add(
      "gem-c-button",
      "govuk-button",
      "content-block-editor__toggle-button"
    ), e.innerText = "Insert Content Block", e.addEventListener("click", () => {
      const t = self.contentBlockBrowser.modal.module;
      t.open(), t.dataset.editorId = this.editor.getId();
    }), this.container.before(e);
  }
  createContainer() {
    const e = window.getComputedStyle(this.module), t = this.module.dataset.editorHeight || e.height, i = document.createElement("div");
    return i.classList.add("content-block-editor__wrapper"), i.setAttribute("style", `height: ${t}`), this.module.after(i), i;
  }
}
window.ContentBlockEditor = Nle;
export {
  Nle as ContentBlockEditor
};
